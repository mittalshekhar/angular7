{"version":3,"file":"icu-message.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/icu-message.ts"],"names":[],"mappings":"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","sourcesContent":["import {IICUMessage, IICUMessageCategory, IICUMessageTranslation, INormalizedMessage} from '../api/index';\r\nimport {format, isNullOrUndefined, isString} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\nclass MessageCategory implements IICUMessageCategory {\r\n\r\n    constructor(private _category: string, private _message: INormalizedMessage) {}\r\n\r\n    public getCategory(): string {\r\n        return this._category;\r\n    }\r\n\r\n    public getMessageNormalized(): INormalizedMessage {\r\n        return this._message;\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nexport class ICUMessage implements IICUMessage {\r\n\r\n    private _isPluralMessage: boolean;\r\n\r\n    private _categories: IICUMessageCategory[];\r\n\r\n    constructor(private _parser: IMessageParser, isPluralMessage: boolean) {\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n\r\n    addCategory(category: string, message: INormalizedMessage) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    public asNativeString(): string {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category: IICUMessageCategory) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage(): boolean {\r\n        return this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage(): boolean {\r\n        return !this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories(): IICUMessageCategory[] {\r\n        return this._categories;\r\n    }\r\n\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation: IICUMessageTranslation): IICUMessage {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories: Set<string> = new Set<string>();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage: INormalizedMessage;\r\n            const translationForCategory: string|IICUMessageTranslation = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            } else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(<string> translationForCategory, null);\r\n            } else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)',\r\n                        categoryName));\r\n                } else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    let translatedMessage = this._parser.parseNormalizedString(<string> translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    private checkValidPluralCategory(categoryName: string) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\r\n"]}