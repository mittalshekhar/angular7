{"version":3,"file":"xtb-trans-unit.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/xtb-trans-unit.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNullOrUndefined} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\n\r\nexport class XtbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceTransUnitFromMaster: AbstractTransUnit;\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile,\r\n                _sourceTransUnitFromMaster: AbstractTransUnit) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    public sourceContent(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    public nativeTargetState(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            } else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public description(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public meaning(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n\r\n}\r\n"]}