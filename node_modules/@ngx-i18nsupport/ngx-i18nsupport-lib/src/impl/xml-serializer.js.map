{"version":3,"file":"xml-serializer.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/xml-serializer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\n\r\ninterface Namespace {\r\n    prefix: string;\r\n    namespace: string;\r\n}\r\n\r\n/**\r\n * Options used to control the formatting\r\n */\r\nexport interface XmlSerializerOptions {\r\n    beautify?: boolean; // set to activate beautify\r\n    indentString?: string; // Sequence uses for indentation, must only contain white space chars, e.g. \"  \" or \"    \" or \"\\t\"\r\n    mixedContentElements?: string[]; // Names of elements containing mixed content (these are not beautified)\r\n}\r\n\r\nconst DEFAULT_INDENT_STRING = '  ';\r\n\r\nexport class XmlSerializer {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document: Document, options?: XmlSerializerOptions): string {\r\n        const buf = [];\r\n        let visibleNamespaces: Namespace[] = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    {namespace: uri, prefix: null}\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    private doSerializeToString(node: Node, options: XmlSerializerOptions, buf: string[],\r\n                                indentLevel: number, partOfMixedContent: boolean, visibleNamespaces: Namespace[]) {\r\n        let child: Node;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode: Element = <Element> node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<' , nodeName);\r\n                } else {\r\n                    this.outputIndented(options, buf, indentLevel, '<' , nodeName);\r\n                }\r\n\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: attr.localName, namespace: attr.value});\r\n                    } else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: '', namespace: attr.value});\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = node.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                }\r\n\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1,\r\n                            partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    } else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                } else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = <Attr> node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = <Text> node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = <CDATASection> node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = <Comment> node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = <DocumentType> node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                } else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                } else {\r\n                    const sub = documenttypeNode.internalSubset;\r\n                    if (sub) {\r\n                        buf.push(' [', sub, ']');\r\n                    }\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = <ProcessingInstruction> node;\r\n                return buf.push( '<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n\r\n    private needNamespaceDefine(node: Element | Attr, visibleNamespaces: Namespace[]): boolean {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _xmlEncoder(c: string): string {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n\r\n    private outputIndented(options: XmlSerializerOptions, buf: string[], indentLevel: number, ...outputParts: string[]) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n\r\n    private indentationString(options: XmlSerializerOptions, indentLevel: number): string {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    private isMixedContentElement(tagName: string, options: XmlSerializerOptions): boolean {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private containsOnlyWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"]}