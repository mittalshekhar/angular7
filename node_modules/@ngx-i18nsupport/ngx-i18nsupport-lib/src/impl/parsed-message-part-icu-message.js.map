{"version":3,"file":"parsed-message-part-icu-message.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-icu-message.ts"],"names":[],"mappings":"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","sourcesContent":["import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {IICUMessage, INormalizedMessage} from '../api/index';\r\nimport {\r\n    COMMA, CURLY_BRACE_CLOSE, CURLY_BRACE_OPEN, ICUMessageTokenizer, ICUToken, PLURAL, SELECT,\r\n    TEXT\r\n} from './icu-message-tokenizer';\r\nimport {ICUMessage} from './icu-message';\r\nimport {format} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\n\r\nexport class ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n\r\n    private _message: ICUMessage;\r\n    private _messageText: string;\r\n    private _tokenizer: ICUMessageTokenizer;\r\n\r\n    constructor(icuMessageText: string, private _parser: IMessageParser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText: string): boolean {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n\r\n    public asDisplayString(displayFormat?: string) {\r\n        return '<ICU-Message/>';\r\n    }\r\n\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        return this._message;\r\n    }\r\n\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    private parseICUMessage(text: string) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token: ICUToken = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        } else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    private looksLikeICUMessage(text: string): boolean {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token: ICUToken = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    private expectNext(tokentype: string): ICUToken {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)',\r\n                tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    private parseNativeSubMessage(message: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\r\n"]}