{"version":3,"file":"xliff2-message-parser.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-message-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nexport class Xliff2MessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            } else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            } else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            } else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        } else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    private tagNameFromPCElement(pcNode: Element): string {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        const stack = [{element: rootElem, tagName: 'root'}];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfPlaceholderPart(<ParsedMessagePartPlaceholder> part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfICUMessageRefPart(<ParsedMessagePartICUMessageRef> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(<ParsedMessagePartStartTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({element: <Element> newTagElem, tagName: (<ParsedMessagePartStartTag> part).tagName()});\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(<ParsedMessagePartEmptyTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        // not used\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n\r\n    private getTypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id: number): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n}\r\n"]}