{"version":3,"file":"xmb-message-parser.spec.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/xmb-message-parser.spec.ts"],"names":[],"mappings":";;AAAA,6DAAsD;AAEtD;;;GAGG;AAEH,QAAQ,CAAC,6BAA6B,EAAE,GAAG,EAAE;IAEzC;;;;;OAKG;IACH,0BAA0B,gBAAwB,EAAE,aAA6B;QAC7E,MAAM,MAAM,GAAG,IAAI,qCAAgB,EAAE,CAAC;QACtC,OAAO,MAAM,CAAC,qBAAqB,CAAC,gBAAgB,EAAE,aAAa,CAAC,CAAC;IACzE,CAAC;IAED;;;;;OAKG;IACH,8BAA8B,UAAkB,EAAE,aAA6B;QAC3E,MAAM,MAAM,GAAG,IAAI,qCAAgB,EAAE,CAAC;QACtC,OAAO,MAAM,CAAC,oCAAoC,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC;IAClF,CAAC;IAED;;;;OAIG;IACH,2BAA2B,iBAAyB;QAChD,MAAM,GAAG,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC,cAAc,EAAE,CAAC;QACjE,MAAM,CAAC,oBAAoB,CAAC,OAAO,GAAG,GAAG,GAAG,QAAQ,CAAC,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;IACrG,CAAC;IAED,QAAQ,CAAC,2BAA2B,EAAE,GAAG,EAAE;QAEvC,EAAE,CAAC,yBAAyB,EAAE,GAAG,EAAE;YAC/B,MAAM,iBAAiB,GAAG,iCAAiC,CAAC;YAC5D,MAAM,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;YAC1D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QACnE,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,oCAAoC,EAAE,GAAG,EAAE;YAC1C,MAAM,iBAAiB,GAAG,sBAAsB,CAAC;YACjD,MAAM,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;YAC1D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC,CAAC,IAAI,CAAC,qEAAqE,CAAC,CAAC;YACnH,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,uCAAuC,EAAE,GAAG,EAAE;YAC7C,MAAM,iBAAiB,GAAG,6BAA6B,CAAC;YACxD,MAAM,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;YAC1D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;iBACjC,IAAI,CAAC,0DAA0D;gBAC5D,uEAAuE,CAAC,CAAC;YACjF,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,8BAA8B,EAAE,GAAG,EAAE;YACpC,MAAM,iBAAiB,GAAG,gCAAgC,CAAC;YAC3D,MAAM,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;YAC1D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;iBACjC,IAAI,CAAC,wDAAwD;gBAC1D,kEAAkE,CAAC,CAAC;YAC5E,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,gCAAgC,EAAE,GAAG,EAAE;YACtC,MAAM,iBAAiB,GAAG,6BAA6B,CAAC;YACxD,MAAM,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;YAC1D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;iBACjC,IAAI,CAAC,0DAA0D;gBAC5D,iEAAiE,CAAC,CAAC;YAC3E,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,0BAA0B,EAAE,GAAG,EAAE;YAChC,MAAM,iBAAiB,GAAG,iDAAiD,CAAC;YAC5E,MAAM,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;YAC1D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;iBACjC,IAAI,CAAC,qEAAqE;gBACvE,0EAA0E,CAAC,CAAC;YACpF,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,oDAAoD,EAAE,GAAG,EAAE;YAC1D,MAAM,iBAAiB,GAAG,oDAAoD,CAAC;YAC/E,MAAM,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;YAC1D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;iBACjC,IAAI,CAAC,kGAAkG;gBACpG,8FAA8F;gBAC9F,kHAAkH;gBAClH,uEAAuE,CAAC,CAAC;YACjF,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,uBAAuB,EAAE,GAAG,EAAE;YAC7B,MAAM,iBAAiB,GAAG,kCAAkC,CAAC;YAC7D,MAAM,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;YAC1D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC,CAAC,IAAI,CAAC,8CAA8C,CAAC,CAAC;YAC5F,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;IAEP,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,2BAA2B,EAAE,GAAG,EAAE;QAEvC,EAAE,CAAC,kCAAkC,EAAE,GAAG,EAAE;YACzC,MAAM,aAAa,GAAG,oBAAoB,CAAC,kBAAkB,CAAC,CAAC;YAC/D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;QACpE,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,mDAAmD,EAAE,GAAG,EAAE;YACzD,MAAM,aAAa,GAAG,oBAAoB,CAAC,mDAAmD;gBAC1F,6GAA6G;gBAC7G,6BAA6B,CAAC,CAAC;YACnC,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,8CAA8C,CAAC,CAAC;QACjG,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,4BAA4B,EAAE,GAAG,EAAE;YAClC,MAAM,aAAa,GAAG,oBAAoB,CAAC,iDAAiD;gBACxF,sHAAsH;gBACtH,6EAA6E,CAAC,CAAC;YACnF,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,4DAA4D,CAAC,CAAC;QAC/G,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,wDAAwD,EAAE,GAAG,EAAE;YAC9D,MAAM,aAAa,GAAG,oBAAoB,CAAC,kCAAkC;gBACzE,kFAAkF;gBAClF,kDAAkD,CAAC,CAAC;YACxD,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,qCAAqC,CAAC,CAAC;QACxF,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,wEAAwE,EAAE,GAAG,EAAE;YAC9E,IAAI;gBACA,MAAM,aAAa,GAAG,oBAAoB,CAAC,sEAAsE;oBAC7G,6EAA6E;oBAC7E,kGAAkG,CAAC,CAAC;gBACxG,MAAM,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;aACzD;YAAC,OAAO,CAAC,EAAE;gBACR,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,SAAS,CAAC,wBAAwB,CAAC,CAAC;aACzD;QACL,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,0DAA0D,EAAE,GAAG,EAAE;YAChE,MAAM,aAAa,GAAG,oBAAoB,CAAC,yCAAyC,CAAC,CAAC;YACtF,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,6BAA6B,CAAC,CAAC;QAChF,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,4DAA4D,EAAE,GAAG,EAAE;YAClE,MAAM,aAAa,GAAG,oBAAoB,CAAC,yCAAyC;gBAChF,6CAA6C,CAAC,CAAC;YACnD,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,0DAA0D,CAAC,CAAC;QAC7G,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,kCAAkC,EAAE,GAAG,EAAE;YACxC,MAAM,iBAAiB,GAAG,yBAAyB,CAAC;YACpD,MAAM,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;YAC1D,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC,CAAC,IAAI,CAAC,gEAAgE,CAAC,CAAC;YAC9G,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;IAEP,CAAC,CAAC,CAAC;AAEP,CAAC,CAAC,CAAC","sourcesContent":["import {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\n/**\r\n * Created by martin on 17.05.2017.\r\n * Testcases for parsing normalized messages to XMB format and vive versa.\r\n */\r\n\r\ndescribe('message parse XMB test spec', () => {\r\n\r\n    /**\r\n     * Helperfunction to create a parsed message from normalized string.\r\n     * @param normalizedString normalizedString\r\n     * @param sourceMessage sourceMessage\r\n     * @return ParsedMessage\r\n     */\r\n    function parsedMessageFor(normalizedString: string, sourceMessage?: ParsedMessage): ParsedMessage {\r\n        const parser = new XmbMessageParser();\r\n        return parser.parseNormalizedString(normalizedString, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * Helperfunction to create a parsed message from native xml.\r\n     * @param xmlContent xmlContent\r\n     * @param sourceMessage sourceMessage\r\n     * @return ParsedMessage\r\n     */\r\n    function parsedMessageFromXML(xmlContent: string, sourceMessage?: ParsedMessage): ParsedMessage {\r\n        const parser = new XmbMessageParser();\r\n        return parser.createNormalizedMessageFromXMLString(xmlContent, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * create normalized message from string, then create one from generated xml.\r\n     * Check that it is the same.\r\n     * @param normalizedMessage normalizedMessage\r\n     */\r\n    function checkToXmlAndBack(normalizedMessage: string) {\r\n        const xml = parsedMessageFor(normalizedMessage).asNativeString();\r\n        expect(parsedMessageFromXML('<msg>' + xml + '</msg>').asDisplayString()).toBe(normalizedMessage);\r\n    }\r\n\r\n    describe('normalized message to xml', () => {\r\n\r\n        it('should parse plain text', () => {\r\n            const normalizedMessage = 'a text without anything special';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString()).toBe(normalizedMessage);\r\n        });\r\n\r\n        it('should parse text with placeholder', () => {\r\n            const normalizedMessage = 'a placeholder: {{0}}';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString()).toBe('a placeholder: <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse text with 2 placeholders', () => {\r\n            const normalizedMessage = '{{1}}: a placeholder: {{0}}';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('<ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>' +\r\n                    ': a placeholder: <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse simple bold tag', () => {\r\n            const normalizedMessage = 'a text <b>with</b> a bold text';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('a text <ph name=\"START_BOLD_TEXT\"><ex>&lt;b></ex></ph>' +\r\n                    'with<ph name=\"CLOSE_BOLD_TEXT\"><ex>&lt;/b></ex></ph> a bold text');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse simple italic tag', () => {\r\n            const normalizedMessage = 'a text <i>with</i> emphasis';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('a text <ph name=\"START_ITALIC_TEXT\"><ex>&lt;i></ex></ph>' +\r\n                    'with<ph name=\"CLOSE_ITALIC_TEXT\"><ex>&lt;/i></ex></ph> emphasis');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse unknown tag', () => {\r\n            const normalizedMessage = 'a text with <strange>strange emphasis</strange>';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('a text with <ph name=\"START_TAG_STRANGE\"><ex>&lt;strange></ex></ph>' +\r\n                    'strange emphasis<ph name=\"CLOSE_TAG_STRANGE\"><ex>&lt;/strange></ex></ph>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse embedded tags with placeholder inside', () => {\r\n            const normalizedMessage = '<b><i><strange>Placeholder {{0}}</strange></i></b>';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('<ph name=\"START_BOLD_TEXT\"><ex>&lt;b></ex></ph><ph name=\"START_ITALIC_TEXT\"><ex>&lt;i></ex></ph>' +\r\n                    '<ph name=\"START_TAG_STRANGE\"><ex>&lt;strange></ex></ph>Placeholder <ph name=\"INTERPOLATION\">' +\r\n                    '<ex>INTERPOLATION</ex></ph><ph name=\"CLOSE_TAG_STRANGE\"><ex>&lt;/strange></ex></ph><ph name=\"CLOSE_ITALIC_TEXT\">' +\r\n                    '<ex>&lt;/i></ex></ph><ph name=\"CLOSE_BOLD_TEXT\"><ex>&lt;/b></ex></ph>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse ICU Refs', () => {\r\n            const normalizedMessage = 'a text with <ICU-Message-Ref_0/>';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString()).toBe('a text with <ph name=\"ICU\"><ex>ICU</ex></ph>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n    });\r\n\r\n    describe('xml to normalized message', () => {\r\n\r\n        it('should parse simple text content', () => {\r\n           const parsedMessage = parsedMessageFromXML('a simple content');\r\n           expect(parsedMessage.asDisplayString()).toBe('a simple content');\r\n        });\r\n\r\n        it('should parse strange tag with placeholder content', () => {\r\n            const parsedMessage = parsedMessageFromXML('Diese Nachricht ist <ph name=\"START_TAG_STRANGE\">' +\r\n                '<ex>&lt;strange></ex></ph><ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph><ph name=\"CLOSE_TAG_STRANGE\">' +\r\n                '<ex>&lt;/strange></ex></ph>');\r\n            expect(parsedMessage.asDisplayString()).toBe('Diese Nachricht ist <strange>{{0}}</strange>');\r\n        });\r\n\r\n        it('should parse embedded tags', () => {\r\n            const parsedMessage = parsedMessageFromXML('Diese Nachricht ist <ph name=\"START_BOLD_TEXT\">' +\r\n                '<ex>&lt;b></ex></ph><ph name=\"START_TAG_STRANGE\"><ex>&lt;strange></ex></ph>SEHR WICHTIG<ph name=\"CLOSE_TAG_STRANGE\">' +\r\n                '<ex>&lt;/strange></ex></ph><ph name=\"CLOSE_BOLD_TEXT\"><ex>&lt;/b></ex></ph>');\r\n            expect(parsedMessage.asDisplayString()).toBe('Diese Nachricht ist <b><strange>SEHR WICHTIG</strange></b>');\r\n        });\r\n\r\n        it('should parse complex message with embedded placeholder', () => {\r\n            const parsedMessage = parsedMessageFromXML('<ph name=\"START_LINK\"><ex>&lt;a>' +\r\n                '</ex></ph>link1 with placeholder <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex>' +\r\n                '</ph><ph name=\"CLOSE_LINK\"><ex>&lt;/a></ex></ph>');\r\n            expect(parsedMessage.asDisplayString()).toBe('<a>link1 with placeholder {{0}}</a>');\r\n        });\r\n\r\n        it('should throw an error due to not well formed elements <b><strange></b>', () => {\r\n            try {\r\n                const parsedMessage = parsedMessageFromXML('Diese Nachricht ist falsch geschachtelt: <ph name=\"START_BOLD_TEXT\">' +\r\n                    '<ex>&lt;b></ex></ph><ph name=\"START_TAG_STRANGE\"><ex>&lt;strange></ex></ph>' +\r\n                    'FALSCH<x id=\"CLOSE_BOLD_TEXT\" ctype=\"x-b\"/></ph><ph name=\"CLOSE_BOLD_TEXT\"><ex>&lt;/b></ex></ph>');\r\n                expect('parsedMessage').toBe('should throw an error');\r\n            } catch (e) {\r\n                expect(e.message).toContain('unexpected close tag b');\r\n            }\r\n        });\r\n\r\n        it('should parse message with embedded ICU message reference', () => {\r\n            const parsedMessage = parsedMessageFromXML('first: <ph name=\"ICU\"><ex>ICU</ex></ph>');\r\n            expect(parsedMessage.asDisplayString()).toBe('first: <ICU-Message-Ref_0/>');\r\n        });\r\n\r\n        it('should parse message with 2 embedded ICU message reference', () => {\r\n            const parsedMessage = parsedMessageFromXML('first: <ph name=\"ICU\"><ex>ICU</ex></ph>' +\r\n                ', second <ph name=\"ICU_1\"><ex>ICU</ex></ph>');\r\n            expect(parsedMessage.asDisplayString()).toBe('first: <ICU-Message-Ref_0/>, second <ICU-Message-Ref_1/>');\r\n        });\r\n\r\n        it('should parse empty tag like <br>', () => {\r\n            const normalizedMessage = 'one line<br>second line';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString()).toBe('one line<ph name=\"LINE_BREAK\"><ex>&lt;br></ex></ph>second line');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n    });\r\n\r\n});\r\n"]}