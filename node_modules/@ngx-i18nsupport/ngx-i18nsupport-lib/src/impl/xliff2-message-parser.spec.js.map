{"version":3,"file":"xliff2-message-parser.spec.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-message-parser.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import {Xliff2MessageParser} from './xliff2-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\n/**\r\n * Created by martin on 14.05.2017.\r\n * Testcases for parsing normalized messages to XLIFF 2.0 and vive versa.\r\n */\r\n\r\ndescribe('message parse XLIFF 2.0 test spec', () => {\r\n\r\n    /**\r\n     * Helperfunction to create a parsed message from normalized string.\r\n     * @param normalizedString normalizedString\r\n     * @param sourceMessage sourceMessage\r\n     * @return ParsedMessage\r\n     */\r\n    function parsedMessageFor(normalizedString: string, sourceMessage?: ParsedMessage): ParsedMessage {\r\n        const parser = new Xliff2MessageParser();\r\n        return parser.parseNormalizedString(normalizedString, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * Helperfunction to create a parsed message from native xml.\r\n     * @param xmlContent xmlContent\r\n     * @param sourceMessage sourceMessage\r\n     * @return ParsedMessage\r\n     */\r\n    function parsedMessageFromXML(xmlContent: string, sourceMessage?: ParsedMessage): ParsedMessage {\r\n        const parser = new Xliff2MessageParser();\r\n        return parser.createNormalizedMessageFromXMLString(xmlContent, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * create normalized message from string, then create one from generated xml.\r\n     * Check that it is the same.\r\n     * @param normalizedMessage normalizedMessage\r\n     */\r\n    function checkToXmlAndBack(normalizedMessage: string) {\r\n        const xml = parsedMessageFor(normalizedMessage).asNativeString();\r\n        expect(parsedMessageFromXML('<source>' + xml + '</source>').asDisplayString()).toBe(normalizedMessage);\r\n    }\r\n\r\n    describe('normalized message to xml', () => {\r\n\r\n        it('should parse plain text', () => {\r\n            const normalizedMessage = 'a text without anything special';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString()).toBe(normalizedMessage);\r\n        });\r\n\r\n        it('should parse text with placeholder', () => {\r\n            const normalizedMessage = 'a placeholder: {{0}}';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString()).toBe('a placeholder: <ph id=\"0\" equiv=\"INTERPOLATION\"/>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse text with 2 placeholders', () => {\r\n            const normalizedMessage = '{{1}}: a placeholder: {{0}}';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('<ph id=\"0\" equiv=\"INTERPOLATION_1\"/>: a placeholder: <ph id=\"1\" equiv=\"INTERPOLATION\"/>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse simple bold tag', () => {\r\n            const normalizedMessage = 'a text <b>with</b> a bold text';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('a text <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b>\"' +\r\n                    ' dispEnd=\"&lt;/b>\">with</pc> a bold text');\r\n        });\r\n\r\n        it('should parse simple italic tag', () => {\r\n            const normalizedMessage = 'a text <i>with</i> emphasis';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('a text <pc id=\"0\" equivStart=\"START_ITALIC_TEXT\" equivEnd=\"CLOSE_ITALIC_TEXT\" type=\"fmt\" dispStart=\"&lt;i>\"' +\r\n                    ' dispEnd=\"&lt;/i>\">with</pc> emphasis');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse unknown tag', () => {\r\n            const normalizedMessage = 'a text with <strange>strange emphasis</strange>';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('a text with <pc id=\"0\" equivStart=\"START_TAG_STRANGE\" equivEnd=\"CLOSE_TAG_STRANGE\" type=\"other\"' +\r\n                    ' dispStart=\"&lt;strange>\" dispEnd=\"&lt;/strange>\">strange emphasis</pc>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse embedded tags with placeholder inside', () => {\r\n            const normalizedMessage = '<b><i><strange>Placeholder {{0}}</strange></i></b>';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString())\r\n                .toBe('<pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b>\"' +\r\n                    ' dispEnd=\"&lt;/b>\"><pc id=\"1\" equivStart=\"START_ITALIC_TEXT\" equivEnd=\"CLOSE_ITALIC_TEXT\" type=\"fmt\"' +\r\n                    ' dispStart=\"&lt;i>\" dispEnd=\"&lt;/i>\"><pc id=\"2\" equivStart=\"START_TAG_STRANGE\"' +\r\n                    ' equivEnd=\"CLOSE_TAG_STRANGE\" type=\"other\" dispStart=\"&lt;strange>\" dispEnd=\"&lt;/strange>\">' +\r\n                    'Placeholder <ph id=\"3\" equiv=\"INTERPOLATION\"/></pc></pc></pc>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n        it('should parse ICU Refs', () => {\r\n            const normalizedMessage = 'a text with <ICU-Message-Ref_0/>';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            // old syntax before angular #17344\r\n            // expect(parsedMessage.asNativeString()).toBe('a text with <ph id=\"0\"/>');\r\n            // new syntax after angular #17344\r\n            expect(parsedMessage.asNativeString()).toBe('a text with <ph id=\"0\" equiv=\"ICU\"/>');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n     });\r\n\r\n    describe('xml to normalized message', () => {\r\n\r\n        it('should parse simple text content', () => {\r\n           const parsedMessage = parsedMessageFromXML('a simple content');\r\n           expect(parsedMessage.asDisplayString()).toBe('a simple content');\r\n        });\r\n\r\n        it('should parse strange tag with placeholder content', () => {\r\n            const parsedMessage = parsedMessageFromXML('Diese Nachricht ist <pc id=\"0\" equivStart=\"START_TAG_STRANGE\"' +\r\n                ' equivEnd=\"CLOSE_TAG_STRANGE\" type=\"other\" dispStart=\"&lt;strange&gt;\" dispEnd=\"&lt;/strange&gt;\">' +\r\n                '<ph id=\"1\" equiv=\"INTERPOLATION\" disp=\"{{strangeness}}\"/></pc>');\r\n            expect(parsedMessage.asDisplayString()).toBe('Diese Nachricht ist <strange>{{0}}</strange>');\r\n        });\r\n\r\n        it('should parse embedded tags', () => {\r\n            const parsedMessage = parsedMessageFromXML('Diese Nachricht ist <pc id=\"0\" equivStart=\"START_BOLD_TEXT\"' +\r\n                ' equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\"><pc id=\"1\"' +\r\n                ' equivStart=\"START_TAG_STRONG\" equivEnd=\"CLOSE_TAG_STRONG\" type=\"other\" dispStart=\"&lt;strong&gt;\"' +\r\n                ' dispEnd=\"&lt;/strong&gt;\">SEHR WICHTIG</pc></pc>');\r\n            expect(parsedMessage.asDisplayString()).toBe('Diese Nachricht ist <b><strong>SEHR WICHTIG</strong></b>');\r\n        });\r\n\r\n        it('should parse complex message with embedded placeholder', () => {\r\n            const parsedMessage = parsedMessageFromXML('<pc id=\"0\" equivStart=\"START_LINK\" equivEnd=\"CLOSE_LINK\" type=\"link\"' +\r\n                ' dispStart=\"&lt;a>\" dispEnd=\"&lt;/a>\">link1 with placeholder <ph id=\"1\" equiv=\"INTERPOLATION\"' +\r\n                ' disp=\"{{placeholder}}\"/></pc>');\r\n            expect(parsedMessage.asDisplayString()).toBe('<a>link1 with placeholder {{0}}</a>');\r\n        });\r\n\r\n        it('should report an error when xml string is not correct (TODO, does not work)', () => {\r\n            const parsedMessage = parsedMessageFromXML('</dummy></dummy>');\r\n            expect(parsedMessage.asDisplayString()).toBe(''); // TODO xmldoc does not report any error\r\n        });\r\n\r\n        it('should parse message with embedded ICU message reference', () => {\r\n            const parsedMessage = parsedMessageFromXML('first: <ph id=\"0\"/>');\r\n            expect(parsedMessage.asDisplayString()).toBe('first: <ICU-Message-Ref_0/>');\r\n        });\r\n\r\n        it('should parse message with embedded ICU message reference (new syntax after angular #17344)', () => {\r\n            const parsedMessage = parsedMessageFromXML('first: <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...}' +\r\n                ' other {...}}\"/>');\r\n            expect(parsedMessage.asDisplayString()).toBe('first: <ICU-Message-Ref_0/>');\r\n        });\r\n\r\n        it('should parse message with 2 embedded ICU message reference', () => {\r\n            const parsedMessage = parsedMessageFromXML('first: <ph id=\"0\"/>, second <ph id=\"1\"/>');\r\n            expect(parsedMessage.asDisplayString()).toBe('first: <ICU-Message-Ref_0/>, second <ICU-Message-Ref_1/>');\r\n        });\r\n\r\n        it('should parse message with 2 embedded ICU message reference (new syntax after angular #17344)', () => {\r\n            const parsedMessage = parsedMessageFromXML('first: <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...}' +\r\n                ' other {...}}\"/>, second <ph id=\"1\" equiv=\"ICU_1\" disp=\"{gender, select, m {...} f {...}}\"/>');\r\n            expect(parsedMessage.asDisplayString()).toBe('first: <ICU-Message-Ref_0/>, second <ICU-Message-Ref_1/>');\r\n        });\r\n\r\n        it('should parse empty tag like <br>', () => {\r\n            const normalizedMessage = 'one line<br>second line';\r\n            const parsedMessage = parsedMessageFor(normalizedMessage);\r\n            expect(parsedMessage.asDisplayString()).toBe(normalizedMessage);\r\n            expect(parsedMessage.asNativeString()).toBe('one line<ph id=\"0\" equiv=\"LINE_BREAK\" type=\"fmt\" disp=\"&lt;br/>\"/>second line');\r\n            checkToXmlAndBack(normalizedMessage);\r\n        });\r\n\r\n    });\r\n\r\n});\r\n"]}