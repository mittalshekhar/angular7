{"version":3,"file":"xml-serializer.spec.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/xml-serializer.spec.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Created by martin on 04.08.2018.\r\n * Testcases for the XmlSerializer.\r\n */\r\n\r\nimport {DOMParser} from 'xmldom';\r\nimport {XmlSerializer, XmlSerializerOptions} from './xml-serializer';\r\nimport {fail} from 'assert';\r\n\r\ndescribe('XmlSerializer test spec', () => {\r\n\r\n    let serializer: XmlSerializer;\r\n\r\n    /**\r\n     * Helper. Parse an XML string.\r\n     * @param xmlstring xmlstring\r\n     */\r\n    function parseXmlString(xmlstring: string): Document {\r\n        return new DOMParser().parseFromString(xmlstring);\r\n    }\r\n\r\n    beforeEach(() => {\r\n        serializer = new XmlSerializer();\r\n    });\r\n\r\n    it('should serialize a simple document without any changes in output', () => {\r\n        const doc1string = `<test><elem>a test</elem></test>`;\r\n        const doc1: Document = parseXmlString(doc1string);\r\n        const serializedDoc = serializer.serializeToString(doc1);\r\n        expect(serializedDoc).toEqual(doc1string);\r\n    });\r\n\r\n    it('should serialize a complex document with attributes etc. without any changes in output', () => {\r\n        const doc1string = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">\r\n  <file source-language=\"en\" datatype=\"plaintext\" original=\"ng2.template\">\r\n  </file>\r\n</xliff>`;\r\n        const doc1: Document = parseXmlString(doc1string);\r\n        const serializedDoc = serializer.serializeToString(doc1);\r\n        expect(serializedDoc).toEqual(doc1string);\r\n    });\r\n\r\n    it('should beautify output using 2 spaces for indentation', () => {\r\n        const doc1string = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<x a=\"1\" b=\"&amp;\"><y>a simple pcdata element</y></x>`;\r\n        const doc1: Document = parseXmlString(doc1string);\r\n        const beautifyOptions: XmlSerializerOptions = {\r\n          beautify: true\r\n        };\r\n        const serializedDoc = serializer.serializeToString(doc1, beautifyOptions);\r\n        const expectedResult = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<x a=\"1\" b=\"&amp;\">\r\n  <y>a simple pcdata element</y>\r\n</x>`;\r\n        expect(serializedDoc).toEqual(expectedResult);\r\n    });\r\n\r\n    it('should beautify output using e.g. tab for indentation', () => {\r\n        const doc1string = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<x a=\"1\" b=\"&amp;\"><y>a simple pcdata element</y></x>`;\r\n        const doc1: Document = parseXmlString(doc1string);\r\n        const beautifyOptions: XmlSerializerOptions = {\r\n            beautify: true,\r\n            indentString: '\\t'\r\n        };\r\n        const serializedDoc = serializer.serializeToString(doc1, beautifyOptions);\r\n        const expectedResult = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<x a=\"1\" b=\"&amp;\">\r\n\\t<y>a simple pcdata element</y>\r\n</x>`;\r\n        expect(serializedDoc).toEqual(expectedResult);\r\n    });\r\n\r\n    it('should throw an error if a non whitespace char is used for indentation', () => {\r\n        const doc1string = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<x a=\"1\" b=\"&amp;\"><y>a simple pcdata element</y></x>`;\r\n        const doc1: Document = parseXmlString(doc1string);\r\n        const beautifyOptions: XmlSerializerOptions = {\r\n            beautify: true,\r\n            indentString: '\\tx'\r\n        };\r\n        try {\r\n            serializer.serializeToString(doc1, beautifyOptions);\r\n            fail('oops, error expected here');\r\n        } catch (err) {\r\n            expect(err.message).toBe('indentString must not contain non white characters');\r\n        }\r\n    });\r\n\r\n    it('should beautify output with mixed content', () => {\r\n        const doc1string = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<x a=\"1\" b=\"&amp;\"><y>a <b><it>mixed</it> content</b> element</y></x>`;\r\n        const doc1: Document = parseXmlString(doc1string);\r\n        const beautifyOptions: XmlSerializerOptions = {\r\n            beautify: true,\r\n            mixedContentElements: ['y']\r\n        };\r\n        const serializedDoc = serializer.serializeToString(doc1, beautifyOptions);\r\n        const expectedResult = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<x a=\"1\" b=\"&amp;\">\r\n  <y>a <b><it>mixed</it> content</b> element</y>\r\n</x>`;\r\n        expect(serializedDoc).toEqual(expectedResult);\r\n    });\r\n\r\n});\r\n"]}