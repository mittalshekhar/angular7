{"version":3,"file":"xliff2-trans-unit.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-trans-unit.ts"],"names":[],"mappings":"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","sourcesContent":["import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {Xliff2MessageParser} from './xliff2-message-parser';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\n\r\nexport class Xliff2TransUnit extends AbstractTransUnit  implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new Xliff2MessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos: string = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    private parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithCategoryAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithCategoryAttribute(attrValue: string, content: string): Element {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    private removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithCategoryAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            } else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"]}