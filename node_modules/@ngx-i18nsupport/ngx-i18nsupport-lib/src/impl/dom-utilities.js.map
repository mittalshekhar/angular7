{"version":3,"file":"dom-utilities.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/impl/dom-utilities.ts"],"names":[],"mappings":"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","sourcesContent":["import {DOMParser, XMLSerializer} from 'xmldom';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\n\r\nexport class DOMUtilities {\r\n\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getFirstElementByTagName(element: Element | Document, tagName: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getElementByTagNameAndId(element: Element | Document, tagName: string, id: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node: Element = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementFollowingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementPrecedingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    public static getXMLContent(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg: RegExp = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg: RegExp = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    public static getPCDATA(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    public static replaceContentWithXMLContent(element: Element, pcdata: string) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment: Document = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    public static getPreviousElementSibling(element: Node): Element {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return <Element> node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    public static createFollowingSibling(elementNameToCreate: string, previousSibling: Node): Element {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return <Element> DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    public static insertAfter(newElement: Node, previousSibling: Node): Node {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        } else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    public static insertBefore(newElement: Node, nextSibling: Node): Node {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\r\n"]}