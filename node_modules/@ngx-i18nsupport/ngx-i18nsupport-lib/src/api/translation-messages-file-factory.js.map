{"version":3,"file":"translation-messages-file-factory.js","sourceRoot":"","sources":["../../../../projects/ngx-i18nsupport-lib/src/api/translation-messages-file-factory.ts"],"names":[],"mappings":";;AAIA,mDAA6C;AAC7C,+CAAyC;AACzC,+BAA4B;AAC5B,qDAA+C;AAC/C,2CAAmF;AACnF,+CAAyC;AAGzC;;;GAGG;AACH;IAEI;;;;;;;;;;;OAWG;IACI,MAAM,CAAC,eAAe,CAAC,UAAkB,EAClB,UAAkB,EAClB,IAAY,EACZ,QAAgB,EAChB,cAAqE;QAC/F,OAAO,IAAI,8BAA8B,EAAE,CAAC,yBAAyB,CAAC,UAAU,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;IAClI,CAAC;IAED;;;;;;;;;;;;OAYG;IACI,MAAM,CAAC,4BAA4B,CAAC,UAAkB,EAC/B,IAAY,EACZ,QAAgB,EAChB,cAAqE;QAC/F,OAAO,IAAI,8BAA8B,EAAE,CAAC,sCAAsC,CAAC,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;IACnI,CAAC;IAED;;;;;;;;;;;OAWG;IACH,yBAAyB,CAAC,UAAkB,EAClB,UAAkB,EAClB,IAAY,EACZ,QAAgB,EAChB,cAAuE;QAC7F,IAAI,UAAU,KAAK,0BAAc,EAAE;YAC/B,OAAO,IAAI,sBAAS,CAAC,UAAU,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;SACpD;QACD,IAAI,UAAU,KAAK,0BAAc,EAAE;YAC/B,OAAO,IAAI,wBAAU,CAAC,UAAU,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;SACrD;QACD,IAAI,UAAU,KAAK,sBAAU,EAAE;YAC3B,OAAO,IAAI,kBAAO,CAAC,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;SACxD;QACD,IAAI,UAAU,KAAK,sBAAU,EAAE;YAC3B,OAAO,IAAI,kBAAO,CAAC,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;SACxE;QACD,MAAM,IAAI,KAAK,CAAC,aAAM,CAAC,+BAA+B,EAAE,UAAU,CAAC,CAAC,CAAC;IAEzE,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,sCAAsC,CAAC,UAAkB,EAClB,IAAY,EACZ,QAAgB,EAChB,cAAuE;QAE1G,IAAI,gBAAgB,GAAG,CAAC,0BAAc,EAAE,0BAAc,EAAE,sBAAU,EAAE,sBAAU,CAAC,CAAC;QAChF,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YAC9B,gBAAgB,GAAG,CAAC,sBAAU,EAAE,sBAAU,EAAE,0BAAc,EAAE,0BAAc,CAAC,CAAC;SAC/E;QACD,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YAC9B,gBAAgB,GAAG,CAAC,sBAAU,EAAE,sBAAU,EAAE,0BAAc,EAAE,0BAAc,CAAC,CAAC;SAC/E;QACD,iDAAiD;QACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC9C,MAAM,eAAe,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;YAC5C,IAAI;gBACA,MAAM,eAAe,GAAG,8BAA8B,CAAC,eAAe,CAClE,eAAe,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;gBACjE,IAAI,eAAe,EAAE;oBACjB,OAAO,eAAe,CAAC;iBAC1B;aACJ;YAAC,OAAO,CAAC,EAAE;gBACR,+BAA+B;aAClC;SACJ;QACD,MAAM,IAAI,KAAK,CAAC,aAAM,CAAC,6EAA6E,CAAC,CAAC,CAAC;IAC3G,CAAC;CAEJ;AApHD,wEAoHC","sourcesContent":["/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile} from './i-translation-messages-file';\r\nimport {XliffFile} from '../impl/xliff-file';\r\nimport {XmbFile} from '../impl/xmb-file';\r\nimport {format} from 'util';\r\nimport {Xliff2File} from '../impl/xliff2-file';\r\nimport {FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB} from './constants';\r\nimport {XtbFile} from '../impl/xtb-file';\r\nimport {ITranslationMessagesFileFactory} from './i-translation-messages-file-factory';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nexport class TranslationMessagesFileFactory implements ITranslationMessagesFileFactory {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromFileContent(i18nFormat: string,\r\n                                  xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromUnknownFormatFileContent(xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat: string,\r\n                              xmlContent: string,\r\n                              path: string,\r\n                              encoding: string,\r\n                              optionalMaster?: { xmlContent: string, path: string, encoding: string }): ITranslationMessagesFile {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent: string,\r\n                                           path: string,\r\n                                           encoding: string,\r\n                                           optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : ITranslationMessagesFile {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(\r\n                    formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            } catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n\r\n}\r\n\r\n"]}