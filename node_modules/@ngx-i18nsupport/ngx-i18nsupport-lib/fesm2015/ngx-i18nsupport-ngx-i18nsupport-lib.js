import { NgModule } from '@angular/core';
import { DOMParser, XMLSerializer } from 'xmldom';
import { isNullOrUndefined, isString, format } from 'util';
import * as Tokenizr from 'tokenizr';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgxI18nsupportLibModule {
}
NgxI18nsupportLibModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [],
                exports: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * supported file formats
  @type {?} */
const FORMAT_XLIFF12 = 'xlf';
/** @type {?} */
const FORMAT_XLIFF20 = 'xlf2';
/** @type {?} */
const FORMAT_XMB = 'xmb';
/** @type {?} */
const FORMAT_XTB = 'xtb';
/** *
 * File types
 * (returned by fileType() method)
  @type {?} */
const FILETYPE_XLIFF12 = 'XLIFF 1.2';
/** @type {?} */
const FILETYPE_XLIFF20 = 'XLIFF 2.0';
/** @type {?} */
const FILETYPE_XMB = 'XMB';
/** @type {?} */
const FILETYPE_XTB = 'XTB';
/** *
 * State NEW.
 * Signals an untranslated unit.
  @type {?} */
const STATE_NEW = 'new';
/** *
 * State TRANSLATED.
 * Signals a translated unit, that is not reviewed until now.
  @type {?} */
const STATE_TRANSLATED = 'translated';
/** *
 * State FINAL.
 * Signals a translated unit, that is reviewed and ready for use.
  @type {?} */
const STATE_FINAL = 'final';
/** *
 * Default format, contains placeholders, html markup.
  @type {?} */
const NORMALIZATION_FORMAT_DEFAULT = 'default';
/** *
 * Format for usage in ngxtranslate messages.
 * Placeholder are in the form {{n}}, no html markup.
  @type {?} */
const NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 01.05.2017.
 * Some Tool functions for XML Handling.
 */
class DOMUtilities {
    /**
     * return the first subelement with the given tag.
     * @param {?} element element
     * @param {?} tagName tagName
     * @return {?} subelement or null, if not existing.
     */
    static getFirstElementByTagName(element, tagName) {
        /** @type {?} */
        const matchingElements = element.getElementsByTagName(tagName);
        if (matchingElements && matchingElements.length > 0) {
            return matchingElements.item(0);
        }
        else {
            return null;
        }
    }
    /**
     * return an element with the given tag and id attribute.
     * @param {?} element element
     * @param {?} tagName tagName
     * @param {?} id id
     * @return {?} subelement or null, if not existing.
     */
    static getElementByTagNameAndId(element, tagName, id) {
        /** @type {?} */
        const matchingElements = element.getElementsByTagName(tagName);
        if (matchingElements && matchingElements.length > 0) {
            for (let i = 0; i < matchingElements.length; i++) {
                /** @type {?} */
                const node = matchingElements.item(i);
                if (node.getAttribute('id') === id) {
                    return node;
                }
            }
        }
        return null;
    }
    /**
     * Get next sibling, that is an element.
     * @param {?} element element
     * @return {?}
     */
    static getElementFollowingSibling(element) {
        if (!element) {
            return null;
        }
        /** @type {?} */
        let e = element.nextSibling;
        while (e) {
            if (e.nodeType === e.ELEMENT_NODE) {
                return /** @type {?} */ (e);
            }
            e = e.nextSibling;
        }
        return null;
    }
    /**
     * Get previous sibling, that is an element.
     * @param {?} element element
     * @return {?}
     */
    static getElementPrecedingSibling(element) {
        if (!element) {
            return null;
        }
        /** @type {?} */
        let e = element.previousSibling;
        while (e) {
            if (e.nodeType === e.ELEMENT_NODE) {
                return /** @type {?} */ (e);
            }
            e = e.previousSibling;
        }
        return null;
    }
    /**
     * return content of element as string, including all markup.
     * @param {?} element element
     * @return {?} content of element as string, including all markup.
     */
    static getXMLContent(element) {
        if (!element) {
            return null;
        }
        /** @type {?} */
        let result = new XMLSerializer().serializeToString(element);
        /** @type {?} */
        const tagName = element.nodeName;
        /** @type {?} */
        const reStartMsg = new RegExp('<' + tagName + '[^>]*>', 'g');
        result = result.replace(reStartMsg, '');
        /** @type {?} */
        const reEndMsg = new RegExp('</' + tagName + '>', 'g');
        result = result.replace(reEndMsg, '');
        return result;
    }
    /**
     * return PCDATA content of element.
     * @param {?} element element
     * @return {?} PCDATA content of element.
     */
    static getPCDATA(element) {
        if (!element) {
            return null;
        }
        /** @type {?} */
        let result = '';
        /** @type {?} */
        const childNodes = element.childNodes;
        for (let i = 0; i < childNodes.length; i++) {
            /** @type {?} */
            const child = childNodes.item(i);
            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {
                result = result + child.nodeValue;
            }
        }
        return result.length === 0 ? null : result;
    }
    /**
     * replace PCDATA content with a new one.
     * @param {?} element element
     * @param {?} pcdata pcdata
     * @return {?}
     */
    static replaceContentWithXMLContent(element, pcdata) {
        // remove all children
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
        /** @type {?} */
        const pcdataFragment = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');
        /** @type {?} */
        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;
        for (let j = 0; j < newChildren.length; j++) {
            /** @type {?} */
            const newChild = newChildren.item(j);
            element.appendChild(element.ownerDocument.importNode(newChild, true));
        }
    }
    /**
     * find the previous sibling that is an element.
     * @param {?} element element
     * @return {?} the previous sibling that is an element or null.
     */
    static getPreviousElementSibling(element) {
        /** @type {?} */
        let node = element.previousSibling;
        while (node !== null) {
            if (node.nodeType === node.ELEMENT_NODE) {
                return /** @type {?} */ (node);
            }
            node = node.previousSibling;
        }
        return null;
    }
    /**
     * Create an Element Node that is the next sibling of a given node.
     * @param {?} elementNameToCreate elementNameToCreate
     * @param {?} previousSibling previousSibling
     * @return {?} new element
     */
    static createFollowingSibling(elementNameToCreate, previousSibling) {
        /** @type {?} */
        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);
        return /** @type {?} */ (DOMUtilities.insertAfter(newElement, previousSibling));
    }
    /**
     * Insert newElement directly after previousSibling.
     * @param {?} newElement newElement
     * @param {?} previousSibling previousSibling
     * @return {?}
     */
    static insertAfter(newElement, previousSibling) {
        if (previousSibling.nextSibling !== null) {
            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);
        }
        else {
            previousSibling.parentNode.appendChild(newElement);
        }
        return newElement;
    }
    /**
     * Insert newElement directly before nextSibling.
     * @param {?} newElement newElement
     * @param {?} nextSibling nextSibling
     * @return {?}
     */
    static insertBefore(newElement, nextSibling) {
        nextSibling.parentNode.insertBefore(newElement, nextSibling);
        return newElement;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_INDENT_STRING = '  ';
class XmlSerializer {
    constructor() {
    }
    /**
     * Serialze xml document to string.
     * @param {?} document the document
     * @param {?=} options can be used to activate beautifying.
     * @return {?}
     */
    serializeToString(document, options) {
        /** @type {?} */
        const buf = [];
        /** @type {?} */
        let visibleNamespaces = [];
        /** @type {?} */
        const refNode = document.documentElement;
        /** @type {?} */
        let prefix = refNode.prefix;
        /** @type {?} */
        const uri = refNode.namespaceURI;
        if (uri && prefix == null) {
            prefix = refNode.lookupPrefix(uri);
            if (prefix == null) {
                visibleNamespaces = [
                    { namespace: uri, prefix: null }
                ];
            }
        }
        if (!options) {
            options = {};
        }
        if (options.indentString) {
            if (!this.containsOnlyWhiteSpace(options.indentString)) {
                throw new Error('indentString must not contain non white characters');
            }
        }
        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);
        return buf.join('');
    }
    /**
     * Main format method that does all the work.
     * Outputs a node to the outputbuffer.
     * @param {?} node the node to be formatted.
     * @param {?} options options
     * @param {?} buf outputbuffer, new output will be appended to this array.
     * @param {?} indentLevel Lever of indentation for formatted output.
     * @param {?} partOfMixedContent true, if node is a subelement of an element containind mixed content.
     * @param {?} visibleNamespaces visibleNamespaces
     * @return {?}
     */
    doSerializeToString(node, options, buf, indentLevel, partOfMixedContent, visibleNamespaces) {
        /** @type {?} */
        let child;
        switch (node.nodeType) {
            case node.ELEMENT_NODE:
                /** @type {?} */
                const elementNode = /** @type {?} */ (node);
                /** @type {?} */
                const attrs = elementNode.attributes;
                /** @type {?} */
                const len = attrs.length;
                child = elementNode.firstChild;
                /** @type {?} */
                const nodeName = elementNode.tagName;
                /** @type {?} */
                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);
                if (partOfMixedContent) {
                    buf.push('<', nodeName);
                }
                else {
                    this.outputIndented(options, buf, indentLevel, '<', nodeName);
                }
                for (let i = 0; i < len; i++) {
                    /** @type {?} */
                    const attr = attrs.item(i);
                    if (attr.prefix === 'xmlns') {
                        visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
                    }
                    else if (attr.nodeName === 'xmlns') {
                        visibleNamespaces.push({ prefix: '', namespace: attr.value });
                    }
                }
                for (let i = 0; i < len; i++) {
                    /** @type {?} */
                    const attr = attrs.item(i);
                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {
                        /** @type {?} */
                        const prefix = attr.prefix || '';
                        /** @type {?} */
                        const uri = attr.namespaceURI;
                        /** @type {?} */
                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';
                        buf.push(ns, '="', uri, '"');
                        visibleNamespaces.push({ prefix: prefix, namespace: uri });
                    }
                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);
                }
                // add namespace for current node
                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {
                    /** @type {?} */
                    const prefix = elementNode.prefix || '';
                    /** @type {?} */
                    const uri = node.namespaceURI;
                    /** @type {?} */
                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';
                    buf.push(ns, '="', uri, '"');
                    visibleNamespaces.push({ prefix: prefix, namespace: uri });
                }
                if (child) {
                    buf.push('>');
                    /** @type {?} */
                    let hasComplexContent = false;
                    while (child) {
                        if (child.nodeType === child.ELEMENT_NODE) {
                            hasComplexContent = true;
                        }
                        this.doSerializeToString(child, options, buf, indentLevel + 1, partOfMixedContent || elementHasMixedContent, visibleNamespaces);
                        child = child.nextSibling;
                    }
                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {
                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');
                    }
                    else {
                        buf.push('</', nodeName, '>');
                    }
                }
                else {
                    buf.push('/>');
                }
                return;
            case node.DOCUMENT_NODE:
            case node.DOCUMENT_FRAGMENT_NODE:
                child = node.firstChild;
                while (child) {
                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);
                    child = child.nextSibling;
                }
                return;
            case node.ATTRIBUTE_NODE:
                /** @type {?} */
                const attrNode = /** @type {?} */ (node);
                return buf.push(' ', attrNode.name, '="', attrNode.value.replace(/[<&"]/g, this._xmlEncoder), '"');
            case node.TEXT_NODE:
                /** @type {?} */
                const textNode = /** @type {?} */ (node);
                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {
                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));
                }
                return;
            case node.CDATA_SECTION_NODE:
                /** @type {?} */
                const cdatasectionNode = /** @type {?} */ (node);
                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');
            case node.COMMENT_NODE:
                /** @type {?} */
                const commentNode = /** @type {?} */ (node);
                return buf.push('<!--', commentNode.data, '-->');
            case node.DOCUMENT_TYPE_NODE:
                /** @type {?} */
                const documenttypeNode = /** @type {?} */ (node);
                /** @type {?} */
                const pubid = documenttypeNode.publicId;
                /** @type {?} */
                const sysid = documenttypeNode.systemId;
                buf.push('<!DOCTYPE ', documenttypeNode.name);
                if (pubid) {
                    buf.push(' PUBLIC "', pubid);
                    if (sysid && sysid !== '.') {
                        buf.push('" "', sysid);
                    }
                    buf.push('">');
                }
                else if (sysid && sysid !== '.') {
                    buf.push(' SYSTEM "', sysid, '">');
                }
                else {
                    /** @type {?} */
                    const sub = documenttypeNode.internalSubset;
                    if (sub) {
                        buf.push(' [', sub, ']');
                    }
                    buf.push('>');
                }
                return;
            case node.PROCESSING_INSTRUCTION_NODE:
                /** @type {?} */
                const piNode = /** @type {?} */ (node);
                return buf.push('<?', piNode.target, ' ', piNode.data, '?>');
            case node.ENTITY_REFERENCE_NODE:
                return buf.push('&', node.nodeName, ';');
            // case ENTITY_NODE:
            // case NOTATION_NODE:
            default:
                buf.push('??', node.nodeName);
        }
    }
    /**
     * @param {?} node
     * @param {?} visibleNamespaces
     * @return {?}
     */
    needNamespaceDefine(node, visibleNamespaces) {
        /** @type {?} */
        const prefix = node.prefix || '';
        /** @type {?} */
        const uri = node.namespaceURI;
        if (!prefix && !uri) {
            return false;
        }
        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'
            || uri === 'http://www.w3.org/2000/xmlns/') {
            return false;
        }
        /** @type {?} */
        let i = visibleNamespaces.length;
        while (i--) {
            /** @type {?} */
            const ns = visibleNamespaces[i];
            // get namespace prefix
            if (ns.prefix === prefix) {
                return ns.namespace !== uri;
            }
        }
        return true;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    _xmlEncoder(c) {
        return c === '<' && '&lt;' ||
            c === '>' && '&gt;' ||
            c === '&' && '&amp;' ||
            c === '"' && '&quot;' ||
            '&#' + c.charCodeAt(0) + ';';
    }
    /**
     * @param {?} options
     * @param {?} buf
     * @param {?} indentLevel
     * @param {...?} outputParts
     * @return {?}
     */
    outputIndented(options, buf, indentLevel, ...outputParts) {
        if (options.beautify) {
            buf.push('\n');
            if (indentLevel > 0) {
                buf.push(this.indentationString(options, indentLevel));
            }
        }
        buf.push(...outputParts);
    }
    /**
     * @param {?} options
     * @param {?} indentLevel
     * @return {?}
     */
    indentationString(options, indentLevel) {
        /** @type {?} */
        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;
        /** @type {?} */
        let result = '';
        for (let i = 0; i < indentLevel; i++) {
            result = result + indent;
        }
        return result;
    }
    /**
     * Test, wether tagName is an element containing mixed content.
     * @param {?} tagName tagName
     * @param {?} options options
     * @return {?}
     */
    isMixedContentElement(tagName, options) {
        if (options && options.mixedContentElements) {
            return !!options.mixedContentElements.find((tag) => tag === tagName);
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} text
     * @return {?}
     */
    containsOnlyWhiteSpace(text) {
        for (let i = 0; i < text.length; i++) {
            /** @type {?} */
            const c = text.charAt(i);
            if (!(c === ' ' || c === '\t' || c === '\r' || c === '\n')) {
                return false;
            }
        }
        return true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by roobm on 09.05.2017.
 * Abstract superclass for all implementations of ITranslationMessagesFile.
 * @abstract
 */
class AbstractTranslationMessagesFile {
    constructor() {
        this.transUnits = null;
        this._warnings = [];
    }
    /**
     * Parse file content.
     * Sets _parsedDocument, line ending, encoding, etc.
     * @param {?} xmlString xmlString
     * @param {?} path path
     * @param {?} encoding encoding
     * @param {?=} optionalMaster optionalMaster
     * @return {?}
     */
    parseContent(xmlString, path, encoding, optionalMaster) {
        this._filename = path;
        this._encoding = encoding;
        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');
        this._fileEndsWithEOL = xmlString.endsWith('\n');
    }
    /**
     * @return {?}
     */
    lazyInitializeTransUnits() {
        if (isNullOrUndefined(this.transUnits)) {
            this.initializeTransUnits();
            this.countNumbers();
        }
    }
    /**
     * count units after changes of trans units
     * @return {?}
     */
    countNumbers() {
        this._numberOfTransUnitsWithMissingId = 0;
        this._numberOfUntranslatedTransUnits = 0;
        this._numberOfReviewedTransUnits = 0;
        this.forEachTransUnit((tu) => {
            if (isNullOrUndefined(tu.id) || tu.id === '') {
                this._numberOfTransUnitsWithMissingId++;
            }
            /** @type {?} */
            const state = tu.targetState();
            if (isNullOrUndefined(state) || state === STATE_NEW) {
                this._numberOfUntranslatedTransUnits++;
            }
            if (state === STATE_TRANSLATED) {
                this._numberOfReviewedTransUnits++;
            }
        });
    }
    /**
     * @return {?}
     */
    warnings() {
        this.lazyInitializeTransUnits();
        return this._warnings;
    }
    /**
     * Total number of translation units found in the file.
     * @return {?}
     */
    numberOfTransUnits() {
        this.lazyInitializeTransUnits();
        return this.transUnits.length;
    }
    /**
     * Number of translation units without translation found in the file.
     * These units have state 'translated'.
     * @return {?}
     */
    numberOfUntranslatedTransUnits() {
        this.lazyInitializeTransUnits();
        return this._numberOfUntranslatedTransUnits;
    }
    /**
     * Number of translation units with state 'final'.
     * @return {?}
     */
    numberOfReviewedTransUnits() {
        this.lazyInitializeTransUnits();
        return this._numberOfReviewedTransUnits;
    }
    /**
     * Number of translation units without translation found in the file.
     * These units have state 'translated'.
     * @return {?}
     */
    numberOfTransUnitsWithMissingId() {
        this.lazyInitializeTransUnits();
        return this._numberOfTransUnitsWithMissingId;
    }
    /**
     * Loop over all Translation Units.
     * @param {?} callback callback
     * @return {?}
     */
    forEachTransUnit(callback) {
        this.lazyInitializeTransUnits();
        this.transUnits.forEach((tu) => callback(tu));
    }
    /**
     * Get trans-unit with given id.
     * @param {?} id id
     * @return {?} trans-unit with given id.
     */
    transUnitWithId(id) {
        this.lazyInitializeTransUnits();
        return this.transUnits.find((tu) => tu.id === id);
    }
    /**
     * Set the praefix used when copying source to target.
     * This is used by importNewTransUnit and createTranslationFileForLang methods.
     * (since 1.8.0)
     * @param {?} targetPraefix targetPraefix
     * @return {?}
     */
    setNewTransUnitTargetPraefix(targetPraefix) {
        this.targetPraefix = targetPraefix;
    }
    /**
     * Get the praefix used when copying source to target.
     * (since 1.8.0)
     * @return {?} the praefix used when copying source to target.
     */
    getNewTransUnitTargetPraefix() {
        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;
    }
    /**
     * Set the suffix used when copying source to target.
     * This is used by importNewTransUnit and createTranslationFileForLang methods.
     * (since 1.8.0)
     * @param {?} targetSuffix targetSuffix
     * @return {?}
     */
    setNewTransUnitTargetSuffix(targetSuffix) {
        this.targetSuffix = targetSuffix;
    }
    /**
     * Get the suffix used when copying source to target.
     * (since 1.8.0)
     * @return {?} the suffix used when copying source to target.
     */
    getNewTransUnitTargetSuffix() {
        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;
    }
    /**
     * Remove the trans-unit with the given id.
     * @param {?} id id
     * @return {?}
     */
    removeTransUnitWithId(id) {
        /** @type {?} */
        const tuNode = this._parsedDocument.getElementById(id);
        if (tuNode) {
            tuNode.parentNode.removeChild(tuNode);
            this.lazyInitializeTransUnits();
            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);
            this.countNumbers();
        }
    }
    /**
     * The filename where the data is read from.
     * @return {?}
     */
    filename() {
        return this._filename;
    }
    /**
     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)
     * @return {?}
     */
    encoding() {
        return this._encoding;
    }
    /**
     * The xml content to be saved after changes are made.
     * @param {?=} beautifyOutput Flag whether to use pretty-data to format the output.
     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
     * See issue #64 for details.
     * Default is false.
     * @return {?}
     */
    editedContent(beautifyOutput) {
        /** @type {?} */
        const options = {};
        if (beautifyOutput === true) {
            options.beautify = true;
            options.indentString = '  ';
            options.mixedContentElements = this.elementsWithMixedContent();
        }
        /** @type {?} */
        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);
        if (this._fileEndsWithEOL) {
            // add eol if there was eol in original source
            return result + '\n';
        }
        else {
            return result;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by roobm on 10.05.2017.
 * Abstract superclass for all implementations of ITransUnit.
 * @abstract
 */
class AbstractTransUnit {
    /**
     * @param {?} _element
     * @param {?} _id
     * @param {?} _translationMessagesFile
     */
    constructor(_element, _id, _translationMessagesFile) {
        this._element = _element;
        this._id = _id;
        this._translationMessagesFile = _translationMessagesFile;
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * The file the unit belongs to.,
     * @return {?}
     */
    translationMessagesFile() {
        return this._translationMessagesFile;
    }
    /**
     * Test, wether setting of source content is supported.
     * If not, setSourceContent in trans-unit will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetSourceContent() {
        return true;
    }
    /**
     * The original text value, that is to be translated, as normalized message.
     * @return {?}
     */
    sourceContentNormalized() {
        if (isNullOrUndefined(this._sourceContentNormalized)) {
            this._sourceContentNormalized = this.createSourceContentNormalized();
        }
        return this._sourceContentNormalized;
    }
    /**
     * State of the translation.
     * (on of new, translated, final)
     * Return values are defined as Constants STATE_...
     * @return {?}
     */
    targetState() {
        /** @type {?} */
        const nativeState = this.nativeTargetState();
        return this.mapNativeStateToState(nativeState);
    }
    /**
     * Modify the target state.
     * @param {?} newState one of the 3 allowed target states new, translated, final.
     * Constants STATE_...
     * Invalid states throw an error.
     * @return {?}
     */
    setTargetState(newState) {
        this.setNativeTargetState(this.mapStateToNativeState(newState));
        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {
            (/** @type {?} */ (this.translationMessagesFile())).countNumbers();
        }
    }
    /**
     * Test, wether setting of source refs is supported.
     * If not, setSourceReferences will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetSourceReferences() {
        return true;
    }
    /**
     * Test, wether setting of description and meaning is supported.
     * If not, setDescription and setMeaning will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetDescriptionAndMeaning() {
        return true;
    }
    /**
     * Check notes
     * @throws an Error if any note contains description or meaning as from attribute.
     * @param {?} newNotes the notes to add.
     * @return {?}
     */
    checkNotes(newNotes) {
        /** @type {?} */
        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');
        if (!isNullOrUndefined(errorInFromNote)) {
            throw new Error('description or meaning are not allowed as from atttribute');
        }
    }
    /**
     * The real xml element used for the trans unit.
     * (internal usage only, a client should never need this)
     * @return {?} real xml element used for the trans unit.
     */
    asXmlElement() {
        return this._element;
    }
    /**
     * Translate the trans unit.
     * @param {?} translation the translated string or (preferred) a normalized message.
     * The pure string can contain any markup and will not be checked.
     * So it can damage the document.
     * A normalized message prevents this.
     * @return {?}
     */
    translate(translation) {
        /** @type {?} */
        let translationNative;
        if (isString(translation)) {
            translationNative = /** @type {?} */ (translation);
        }
        else {
            translationNative = (/** @type {?} */ (translation)).asNativeString();
        }
        this.translateNative(translationNative);
        this.setTargetState(STATE_TRANSLATED);
    }
    /**
     * Test, wether message looks like ICU message.
     * @param {?} message message
     * @return {?} wether message looks like ICU message.
     */
    isICUMessage(message) {
        return this.messageParser().isICUMessageStart(message);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 05.05.2017.
 * A part of a parsed message.
 * Can be a text, a placeholder, a tag
 */
/** @enum {number} */
const ParsedMessagePartType = {
    TEXT: 0,
    PLACEHOLDER: 1,
    START_TAG: 2,
    END_TAG: 3,
    EMPTY_TAG: 4,
    ICU_MESSAGE: 5,
    ICU_MESSAGE_REF: 6,
};
ParsedMessagePartType[ParsedMessagePartType.TEXT] = 'TEXT';
ParsedMessagePartType[ParsedMessagePartType.PLACEHOLDER] = 'PLACEHOLDER';
ParsedMessagePartType[ParsedMessagePartType.START_TAG] = 'START_TAG';
ParsedMessagePartType[ParsedMessagePartType.END_TAG] = 'END_TAG';
ParsedMessagePartType[ParsedMessagePartType.EMPTY_TAG] = 'EMPTY_TAG';
ParsedMessagePartType[ParsedMessagePartType.ICU_MESSAGE] = 'ICU_MESSAGE';
ParsedMessagePartType[ParsedMessagePartType.ICU_MESSAGE_REF] = 'ICU_MESSAGE_REF';
/**
 * @abstract
 */
class ParsedMessagePart {
    /**
     * @param {?} type
     */
    constructor(type) {
        this.type = type;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 05.05.2017.
 * A message part consisting of just simple text.
 */
class ParsedMessagePartText extends ParsedMessagePart {
    /**
     * @param {?} text
     */
    constructor(text) {
        super(ParsedMessagePartType.TEXT);
        this.text = text;
    }
    /**
     * @param {?=} format
     * @return {?}
     */
    asDisplayString(format$$1) {
        return this.text;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 05.05.2017.
 * A message part consisting of a placeholder.
 * Placeholders are numbered from 0 to n.
 */
class ParsedMessagePartPlaceholder extends ParsedMessagePart {
    /**
     * @param {?} index
     * @param {?} disp
     */
    constructor(index, disp) {
        super(ParsedMessagePartType.PLACEHOLDER);
        this._index = index;
        this._disp = disp;
    }
    /**
     * @param {?=} format
     * @return {?}
     */
    asDisplayString(format$$1) {
        if (format$$1 === NORMALIZATION_FORMAT_NGXTRANSLATE) {
            return '{{' + this._index + '}}';
        }
        return '{{' + this._index + '}}';
    }
    /**
     * @return {?}
     */
    index() {
        return this._index;
    }
    /**
     * @return {?}
     */
    disp() {
        return this._disp;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 05.05.2017.
 * A message part consisting of an opening tag like <b> or <strange>.
 */
class ParsedMessagePartStartTag extends ParsedMessagePart {
    /**
     * @param {?} tagname
     * @param {?} idcounter
     */
    constructor(tagname, idcounter) {
        super(ParsedMessagePartType.START_TAG);
        this._tagname = tagname;
        this._idcounter = idcounter;
    }
    /**
     * @param {?=} format
     * @return {?}
     */
    asDisplayString(format$$1) {
        if (this._idcounter === 0) {
            return '<' + this._tagname + '>';
        }
        else {
            return '<' + this._tagname + ' id="' + this._idcounter.toString() + '">';
        }
    }
    /**
     * @return {?}
     */
    tagName() {
        return this._tagname;
    }
    /**
     * @return {?}
     */
    idCounter() {
        return this._idcounter;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 05.05.2017.
 * A message part consisting of a closing tag like </b> or </strange>.
 */
class ParsedMessagePartEndTag extends ParsedMessagePart {
    /**
     * @param {?} tagname
     */
    constructor(tagname) {
        super(ParsedMessagePartType.END_TAG);
        this._tagname = tagname;
    }
    /**
     * @param {?=} format
     * @return {?}
     */
    asDisplayString(format$$1) {
        return '</' + this._tagname + '>';
    }
    /**
     * @return {?}
     */
    tagName() {
        return this._tagname;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Created by martin on 04.06.2017.
 * A tokenizer for ICU messages.
  @type {?} */
const TEXT = 'TEXT';
/** @type {?} */
const CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';
/** @type {?} */
const CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';
/** @type {?} */
const COMMA = 'COMMA';
/** @type {?} */
const PLURAL = 'PLURAL';
/** @type {?} */
const SELECT = 'SELECT';
/** @type {?} */
const STATE_DEFAULT = 'default';
/** @type {?} */
const STATE_NORMAL = 'normal';
/** @type {?} */
const STATE_IN_MESSAGE = 'in_message';
class ICUMessageTokenizer {
    /**
     * @return {?}
     */
    getLexer() {
        /** @type {?} */
        const lexer = new Tokenizr();
        /** @type {?} */
        let plaintext = '';
        /** @type {?} */
        let openedCurlyBracesInTextCounter = 0;
        lexer.before((ctx, match, rule) => {
            if (rule.name !== TEXT) {
                if (this.containsNonWhiteSpace(plaintext)) {
                    ctx.accept(TEXT, plaintext);
                    plaintext = '';
                }
                else {
                    ctx.ignore();
                }
            }
        });
        lexer.finish((ctx) => {
            if (this.containsNonWhiteSpace(plaintext)) {
                ctx.accept(TEXT, plaintext);
            }
        });
        // curly brace
        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {
            ctx.accept(CURLY_BRACE_OPEN, match[0]);
            ctx.push(STATE_NORMAL);
        }, CURLY_BRACE_OPEN);
        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {
            ctx.accept(CURLY_BRACE_OPEN, match[0]);
            ctx.push(STATE_IN_MESSAGE);
        }, CURLY_BRACE_OPEN);
        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {
            ctx.pop();
            ctx.accept(CURLY_BRACE_CLOSE, match[0]);
        }, CURLY_BRACE_CLOSE);
        // masked ' { and }
        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {
            if (match[0] === '\'\'') {
                plaintext += '\'';
            }
            else if (match[0] === '\'{\'') {
                plaintext += '{';
            }
            else if (match[0] === '\'}\'') {
                plaintext += '}';
            }
            ctx.ignore();
        }, TEXT);
        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {
            /** @type {?} */
            const char = match[0];
            if (char === '{') {
                openedCurlyBracesInTextCounter++;
                plaintext += match[0];
                ctx.ignore();
            }
            else if (char === '}') {
                if (openedCurlyBracesInTextCounter > 0) {
                    openedCurlyBracesInTextCounter--;
                    plaintext += match[0];
                    ctx.ignore();
                }
                else {
                    ctx.pop();
                    ctx.accept(TEXT, plaintext);
                    plaintext = '';
                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);
                }
            }
            else {
                plaintext += match[0];
                ctx.ignore();
            }
        }, TEXT);
        // comma
        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {
            ctx.accept(COMMA, match[0]);
        }, COMMA);
        // keywords plural and select
        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {
            ctx.accept(PLURAL, match[0]);
        }, PLURAL);
        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {
            ctx.accept(SELECT, match[0]);
        }, SELECT);
        // text
        lexer.rule(/./, (ctx, match) => {
            plaintext += match[0];
            ctx.ignore();
        }, TEXT);
        lexer.rule(/[\s]+/, (ctx, match) => {
            plaintext += match[0];
            ctx.ignore();
        }, TEXT);
        return lexer;
    }
    /**
     * @param {?} text
     * @return {?}
     */
    containsNonWhiteSpace(text) {
        for (let i = 0; i < text.length; i++) {
            if (!/\s/.test(text.charAt(i))) {
                return true;
            }
        }
        return false;
    }
    /**
     * @param {?} normalizedMessage
     * @return {?}
     */
    tokenize(normalizedMessage) {
        /** @type {?} */
        const lexer = this.getLexer();
        lexer.input(normalizedMessage);
        return lexer.tokens();
    }
    /**
     * @param {?} normalizedMessage
     * @return {?}
     */
    input(normalizedMessage) {
        this.lexer = this.getLexer();
        this.lexer.input(normalizedMessage);
    }
    /**
     * @return {?}
     */
    next() {
        return this.lexer.token();
    }
    /**
     * @return {?}
     */
    peek() {
        return this.lexer.peek();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class MessageCategory {
    /**
     * @param {?} _category
     * @param {?} _message
     */
    constructor(_category, _message) {
        this._category = _category;
        this._message = _message;
    }
    /**
     * @return {?}
     */
    getCategory() {
        return this._category;
    }
    /**
     * @return {?}
     */
    getMessageNormalized() {
        return this._message;
    }
}
/**
 * Implementation of an ICU Message.
 * Created by martin on 05.06.2017.
 */
class ICUMessage {
    /**
     * @param {?} _parser
     * @param {?} isPluralMessage
     */
    constructor(_parser, isPluralMessage) {
        this._parser = _parser;
        this._isPluralMessage = isPluralMessage;
        this._categories = [];
    }
    /**
     * @param {?} category
     * @param {?} message
     * @return {?}
     */
    addCategory(category, message) {
        this._categories.push(new MessageCategory(category, message));
    }
    /**
     * ICU message as native string.
     * This is, how it is stored, something like '{x, plural, =0 {..}'
     * @return {?} ICU message as native string.
     */
    asNativeString() {
        /** @type {?} */
        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';
        /** @type {?} */
        const type = (this.isPluralMessage()) ? 'plural' : 'select';
        /** @type {?} */
        let choiceString = '';
        this._categories.forEach((category) => {
            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());
        });
        return format('{%s, %s,%s}', varname, type, choiceString);
    }
    /**
     * Is it a plural message?
     * @return {?}
     */
    isPluralMessage() {
        return this._isPluralMessage;
    }
    /**
     * Is it a select message?
     * @return {?}
     */
    isSelectMessage() {
        return !this._isPluralMessage;
    }
    /**
     * All the parts of the message.
     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}
     * has 4 category objects with the categories =0, =1, =2, other.
     * @return {?}
     */
    getCategories() {
        return this._categories;
    }
    /**
     * Translate message and return a new, translated message
     * @throws an error if translation does not match the message.
     * This is the case, if there are categories not contained in the original message.
     * @param {?} translation the translation (hashmap of categories and translations).
     * @return {?} new message wit translated content.
     */
    translate(translation) {
        /** @type {?} */
        const message = new ICUMessage(this._parser, this.isPluralMessage());
        /** @type {?} */
        const translatedCategories = new Set();
        this._categories.forEach((category) => {
            /** @type {?} */
            let translatedMessage;
            /** @type {?} */
            const translationForCategory = translation[category.getCategory()];
            if (isNullOrUndefined(translationForCategory)) {
                translatedMessage = category.getMessageNormalized();
            }
            else if (isString(translationForCategory)) {
                translatedCategories.add(category.getCategory());
                translatedMessage = this._parser.parseNormalizedString(/** @type {?} */ (translationForCategory), null);
            }
            else {
                // TODO embedded ICU Message
                translatedMessage = null;
            }
            message.addCategory(category.getCategory(), translatedMessage);
        });
        // new categories, which are not part of the original message
        Object.keys(translation).forEach((categoryName) => {
            if (!translatedCategories.has(categoryName)) {
                if (this.isSelectMessage()) {
                    throw new Error(format('adding a new category not allowed for select messages ("%s" is not part of message)', categoryName));
                }
                else {
                    this.checkValidPluralCategory(categoryName);
                    /** @type {?} */
                    let translatedMessage = this._parser.parseNormalizedString(/** @type {?} */ (translation[categoryName]), null);
                    message.addCategory(categoryName, translatedMessage);
                }
            }
        });
        return message;
    }
    /**
     * Check, wether category is valid plural category.
     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'
     * @throws an error, if it is not a valid category name
     * @param {?} categoryName category
     * @return {?}
     */
    checkValidPluralCategory(categoryName) {
        /** @type {?} */
        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];
        if (categoryName.match(/=\d+/)) {
            return;
        }
        if (allowedKeywords.find((key) => key === categoryName)) {
            return;
        }
        throw new Error(format('invalid plural category "%s", allowed are =<n> and %s', categoryName, allowedKeywords));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 02.06.2017.
 * A message part consisting of an icu message.
 * There can only be one icu message in a parsed message.
 * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'
 */
class ParsedMessagePartICUMessage extends ParsedMessagePart {
    /**
     * @param {?} icuMessageText
     * @param {?} _parser
     */
    constructor(icuMessageText, _parser) {
        super(ParsedMessagePartType.ICU_MESSAGE);
        this._parser = _parser;
        if (icuMessageText) {
            this.parseICUMessage(icuMessageText);
        }
    }
    /**
     * Test wether text might be an ICU message.
     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'
     * @param {?} icuMessageText icuMessageText
     * @return {?} wether text might be an ICU message.
     */
    static looksLikeICUMessage(icuMessageText) {
        /** @type {?} */
        const part = new ParsedMessagePartICUMessage(null, null);
        return part.looksLikeICUMessage(icuMessageText);
    }
    /**
     * @param {?=} displayFormat
     * @return {?}
     */
    asDisplayString(displayFormat) {
        return '<ICU-Message/>';
    }
    /**
     * return the parsed message.
     * @return {?} parsed message
     */
    getICUMessage() {
        return this._message;
    }
    /**
     * Parse the message.
     * @throws an error if the syntax is not ok in any way.
     * @param {?} text message text to parse
     * @return {?}
     */
    parseICUMessage(text) {
        // console.log('message ', text);
        // const tokens = new ICUMessageTokenizer().tokenize(text);
        // tokens.forEach((tok) => {
        //     console.log('Token', tok.type, tok.value);
        // });
        this._messageText = text;
        this._tokenizer = new ICUMessageTokenizer();
        this._tokenizer.input(text);
        this.expectNext(CURLY_BRACE_OPEN);
        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT
        this.expectNext(COMMA);
        /** @type {?} */
        let token = this._tokenizer.next();
        if (token.type === PLURAL) {
            this._message = new ICUMessage(this._parser, true);
        }
        else if (token.type === SELECT) {
            this._message = new ICUMessage(this._parser, false);
        }
        this.expectNext(COMMA);
        token = this._tokenizer.peek();
        while (token.type !== CURLY_BRACE_CLOSE) {
            /** @type {?} */
            const category = this.expectNext(TEXT).value.trim();
            this.expectNext(CURLY_BRACE_OPEN);
            /** @type {?} */
            const message = this.expectNext(TEXT).value;
            this._message.addCategory(category, this.parseNativeSubMessage(message));
            this.expectNext(CURLY_BRACE_CLOSE);
            token = this._tokenizer.peek();
        }
        this.expectNext(CURLY_BRACE_CLOSE);
        this.expectNext('EOF');
    }
    /**
     * Parse the message to check, wether it might be an ICU message.
     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'
     * @param {?} text message text to parse
     * @return {?}
     */
    looksLikeICUMessage(text) {
        // console.log('message ', text);
        // const tokens = new ICUMessageTokenizer().tokenize(text);
        // tokens.forEach((tok) => {
        //     console.log('Token', tok.type, tok.value);
        // });
        this._tokenizer = new ICUMessageTokenizer();
        this._tokenizer.input(text);
        try {
            this.expectNext(CURLY_BRACE_OPEN);
            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT
            this.expectNext(COMMA);
            /** @type {?} */
            const token = this._tokenizer.next();
            if (token.type !== PLURAL && token.type !== SELECT) {
                return false;
            }
            this.expectNext(COMMA);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Read next token and expect, that it is of the given type.
     * @throws error, if next token has wrong type.
     * @param {?} tokentype expected type.
     * @return {?} Token
     */
    expectNext(tokentype) {
        /** @type {?} */
        const token = this._tokenizer.next();
        if (token.type !== tokentype) {
            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)', tokentype, token.type, token.value, this._messageText));
        }
        return token;
    }
    /**
     * Parse XML text to normalized message.
     * @param {?} message message in format dependent xml syntax.
     * @return {?} normalized message
     */
    parseNativeSubMessage(message) {
        return this._parser.createNormalizedMessageFromXMLString(message, null);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 05.05.2017.
 * A reference to an ICU message
 * icu references are numbered from 0 to n.
 */
class ParsedMessagePartICUMessageRef extends ParsedMessagePart {
    /**
     * @param {?} index
     * @param {?} disp
     */
    constructor(index, disp) {
        super(ParsedMessagePartType.ICU_MESSAGE_REF);
        this._index = index;
        this._disp = disp;
    }
    /**
     * @param {?=} format
     * @return {?}
     */
    asDisplayString(format$$1) {
        return '<ICU-Message-Ref_' + this._index + '/>';
    }
    /**
     * @return {?}
     */
    index() {
        return this._index;
    }
    /**
     * @return {?}
     */
    disp() {
        return this._disp;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 14.06.2017.
 * A message part consisting of an empty tag like <br/>.
 */
class ParsedMessagePartEmptyTag extends ParsedMessagePart {
    /**
     * @param {?} tagname
     * @param {?} idcounter
     */
    constructor(tagname, idcounter) {
        super(ParsedMessagePartType.EMPTY_TAG);
        this._tagname = tagname;
        this._idcounter = idcounter;
    }
    /**
     * @param {?=} format
     * @return {?}
     */
    asDisplayString(format$$1) {
        if (this._idcounter === 0) {
            return '<' + this._tagname + '>';
        }
        else {
            return '<' + this._tagname + ' id="' + this._idcounter.toString() + '">';
        }
    }
    /**
     * @return {?}
     */
    tagName() {
        return this._tagname;
    }
    /**
     * @return {?}
     */
    idCounter() {
        return this._idcounter;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 05.05.2017.
 * A message text read from a translation file.
 * Can contain placeholders, tags, text.
 * This class is a representation independent of the concrete format.
 */
class ParsedMessage {
    /**
     * @param {?} parser
     * @param {?} sourceMessage
     */
    constructor(parser, sourceMessage) {
        this._parser = parser;
        this.sourceMessage = sourceMessage;
        this._parts = [];
    }
    /**
     * Get the parser (for tests only, not part of API)
     * @return {?} parser
     */
    getParser() {
        return this._parser;
    }
    /**
     * Create a new normalized message as a translation of this one.
     * @throws an error if normalized string is not well formed.
     * Throws an error too, if this is an ICU message.
     * @param {?} normalizedString the translation in normalized form.
     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.
     * @return {?}
     */
    translate(normalizedString) {
        if (isNullOrUndefined(this.getICUMessage())) {
            return this._parser.parseNormalizedString(/** @type {?} */ (normalizedString), this);
        }
        else {
            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead ("%s", "%s")', normalizedString, this.asNativeString()));
        }
    }
    /**
     * Create a new normalized icu message as a translation of this one.
     * @throws an error if normalized string is not well formed.
     * Throws an error too, if this is not an ICU message.
     * @param {?} icuTranslation the translation, this is the translation of the ICU message,
     * which is not a string, but a collections of the translations of the different categories.
     * The message must be an ICUMessage (getICUMessage returns a value)
     * @return {?}
     */
    translateICUMessage(icuTranslation) {
        /** @type {?} */
        const icuMessage = this.getICUMessage();
        if (isNullOrUndefined(icuMessage)) {
            throw new Error(format('this is not an ICU message, use translate() instead ("%s", "%s")', icuTranslation, this.asNativeString()));
        }
        else {
            /** @type {?} */
            const translatedICUMessage = icuMessage.translate(icuTranslation);
            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);
        }
    }
    /**
     * Create a new normalized message from a native xml string as a translation of this one.
     * @param {?} nativeString xml string in the format of the underlying file format.
     * Throws an error if native string is not acceptable.
     * @return {?}
     */
    translateNativeString(nativeString) {
        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);
    }
    /**
     * normalized message as string.
     * @param {?=} displayFormat optional way to determine the exact syntax.
     * Allowed formats are defined as constants NORMALIZATION_FORMAT...
     * @return {?}
     */
    asDisplayString(displayFormat) {
        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');
    }
    /**
     * Returns the message content as format dependent native string.
     * Includes all format specific markup like <ph id="INTERPOLATION" ../> ..
     * @return {?}
     */
    asNativeString() {
        if (isNullOrUndefined(this.getICUMessage())) {
            return DOMUtilities.getXMLContent(this._xmlRepresentation);
        }
        else {
            return this.getICUMessage().asNativeString();
        }
    }
    /**
     * Validate the message.
     * @return {?} null, if ok, error object otherwise.
     */
    validate() {
        /** @type {?} */
        let hasErrors = false;
        /** @type {?} */
        const errors = {};
        /** @type {?} */
        let e;
        e = this.checkPlaceholderAdded();
        if (!isNullOrUndefined(e)) {
            errors.placeholderAdded = e;
            hasErrors = true;
        }
        e = this.checkICUMessageRefRemoved();
        if (!isNullOrUndefined(e)) {
            errors["icuMessageRefRemoved"] = e;
            hasErrors = true;
        }
        e = this.checkICUMessageRefAdded();
        if (!isNullOrUndefined(e)) {
            errors["icuMessageRefAdded"] = e;
            hasErrors = true;
        }
        return hasErrors ? errors : null;
    }
    /**
     * Validate the message, check for warnings only.
     * A warning shows, that the message is acceptable, but misses something.
     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.
     * @return {?} null, if no warning, warnings as error object otherwise.
     */
    validateWarnings() {
        /** @type {?} */
        let hasWarnings = false;
        /** @type {?} */
        const warnings = {};
        /** @type {?} */
        let w;
        w = this.checkPlaceholderRemoved();
        if (!isNullOrUndefined(w)) {
            warnings.placeholderRemoved = w;
            hasWarnings = true;
        }
        w = this.checkTagRemoved();
        if (!isNullOrUndefined(w)) {
            warnings.tagRemoved = w;
            hasWarnings = true;
        }
        w = this.checkTagAdded();
        if (!isNullOrUndefined(w)) {
            warnings.tagAdded = w;
            hasWarnings = true;
        }
        return hasWarnings ? warnings : null;
    }
    /**
     * If this message is an ICU message, returns its structure.
     * Otherwise this method returns null.
     * @return {?} ICUMessage or null.
     */
    getICUMessage() {
        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {
            /** @type {?} */
            const icuPart = /** @type {?} */ (this._parts[0]);
            return icuPart.getICUMessage();
        }
        else {
            return null;
        }
    }
    /**
     * Check for added placeholder.
     * @return {?} null or message, if fulfilled.
     */
    checkPlaceholderAdded() {
        /** @type {?} */
        let e = null;
        /** @type {?} */
        const suspiciousIndexes = [];
        if (this.sourceMessage) {
            /** @type {?} */
            const sourcePlaceholders = this.sourceMessage.allPlaceholders();
            /** @type {?} */
            const myPlaceholders = this.allPlaceholders();
            myPlaceholders.forEach((index) => {
                if (!sourcePlaceholders.has(index)) {
                    suspiciousIndexes.push(index);
                }
            });
        }
        if (suspiciousIndexes.length === 1) {
            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';
        }
        else if (suspiciousIndexes.length > 1) {
            /** @type {?} */
            let allSuspiciousIndexes = '';
            /** @type {?} */
            let first = true;
            suspiciousIndexes.forEach((index) => {
                if (!first) {
                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';
                }
                allSuspiciousIndexes = allSuspiciousIndexes + index;
                first = false;
            });
            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';
        }
        return e;
    }
    /**
     * Check for removed placeholder.
     * @return {?} null or message, if fulfilled.
     */
    checkPlaceholderRemoved() {
        /** @type {?} */
        let w = null;
        /** @type {?} */
        const suspiciousIndexes = [];
        if (this.sourceMessage) {
            /** @type {?} */
            const sourcePlaceholders = this.sourceMessage.allPlaceholders();
            /** @type {?} */
            const myPlaceholders = this.allPlaceholders();
            sourcePlaceholders.forEach((index) => {
                if (!myPlaceholders.has(index)) {
                    suspiciousIndexes.push(index);
                }
            });
        }
        if (suspiciousIndexes.length === 1) {
            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';
        }
        else if (suspiciousIndexes.length > 1) {
            /** @type {?} */
            let allSuspiciousIndexes = '';
            /** @type {?} */
            let first = true;
            suspiciousIndexes.forEach((index) => {
                if (!first) {
                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';
                }
                allSuspiciousIndexes = allSuspiciousIndexes + index;
                first = false;
            });
            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';
        }
        return w;
    }
    /**
     * Check for added ICU Message Refs.
     * @return {?} null or message, if fulfilled.
     */
    checkICUMessageRefAdded() {
        /** @type {?} */
        let e = null;
        /** @type {?} */
        const suspiciousIndexes = [];
        if (this.sourceMessage) {
            /** @type {?} */
            const sourceICURefs = this.sourceMessage.allICUMessageRefs();
            /** @type {?} */
            const myICURefs = this.allICUMessageRefs();
            myICURefs.forEach((index) => {
                if (!sourceICURefs.has(index)) {
                    suspiciousIndexes.push(index);
                }
            });
        }
        if (suspiciousIndexes.length === 1) {
            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';
        }
        else if (suspiciousIndexes.length > 1) {
            /** @type {?} */
            let allSuspiciousIndexes = '';
            /** @type {?} */
            let first = true;
            suspiciousIndexes.forEach((index) => {
                if (!first) {
                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';
                }
                allSuspiciousIndexes = allSuspiciousIndexes + index;
                first = false;
            });
            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';
        }
        return e;
    }
    /**
     * Check for removed ICU Message Refs.
     * @return {?} null or message, if fulfilled.
     */
    checkICUMessageRefRemoved() {
        /** @type {?} */
        let e = null;
        /** @type {?} */
        const suspiciousIndexes = [];
        if (this.sourceMessage) {
            /** @type {?} */
            const sourceICURefs = this.sourceMessage.allICUMessageRefs();
            /** @type {?} */
            const myICURefs = this.allICUMessageRefs();
            sourceICURefs.forEach((index) => {
                if (!myICURefs.has(index)) {
                    suspiciousIndexes.push(index);
                }
            });
        }
        if (suspiciousIndexes.length === 1) {
            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';
        }
        else if (suspiciousIndexes.length > 1) {
            /** @type {?} */
            let allSuspiciousIndexes = '';
            /** @type {?} */
            let first = true;
            suspiciousIndexes.forEach((index) => {
                if (!first) {
                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';
                }
                allSuspiciousIndexes = allSuspiciousIndexes + index;
                first = false;
            });
            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';
        }
        return e;
    }
    /**
     * Get all indexes of placeholders used in the message.
     * @return {?}
     */
    allPlaceholders() {
        /** @type {?} */
        const result = new Set();
        this.parts().forEach((part) => {
            if (part.type === ParsedMessagePartType.PLACEHOLDER) {
                /** @type {?} */
                const index = (/** @type {?} */ (part)).index();
                result.add(index);
            }
        });
        return result;
    }
    /**
     * Return the disp-Attribute of placeholder
     * @param {?} index index of placeholder
     * @return {?} disp or null
     */
    getPlaceholderDisp(index) {
        /** @type {?} */
        let placeHolder = null;
        this.parts().forEach((part) => {
            if (part.type === ParsedMessagePartType.PLACEHOLDER) {
                /** @type {?} */
                const phPart = /** @type {?} */ (part);
                if (phPart.index() === index) {
                    placeHolder = phPart;
                }
            }
        });
        return placeHolder ? placeHolder.disp() : null;
    }
    /**
     * Get all indexes of ICU message refs used in the message.
     * @return {?}
     */
    allICUMessageRefs() {
        /** @type {?} */
        const result = new Set();
        this.parts().forEach((part) => {
            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {
                /** @type {?} */
                const index = (/** @type {?} */ (part)).index();
                result.add(index);
            }
        });
        return result;
    }
    /**
     * Return the disp-Attribute of icu message ref
     * @param {?} index of ref
     * @return {?} disp or null
     */
    getICUMessageRefDisp(index) {
        /** @type {?} */
        let icuMessageRefPart = null;
        this.parts().forEach((part) => {
            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {
                /** @type {?} */
                const refPart = /** @type {?} */ (part);
                if (refPart.index() === index) {
                    icuMessageRefPart = refPart;
                }
            }
        });
        return icuMessageRefPart ? icuMessageRefPart.disp() : null;
    }
    /**
     * Check for added tags.
     * @return {?} null or message, if fulfilled.
     */
    checkTagAdded() {
        /** @type {?} */
        let e = null;
        /** @type {?} */
        const suspiciousTags = [];
        if (this.sourceMessage) {
            /** @type {?} */
            const sourceTags = this.sourceMessage.allTags();
            /** @type {?} */
            const myTags = this.allTags();
            myTags.forEach((tagName) => {
                if (!sourceTags.has(tagName)) {
                    suspiciousTags.push(tagName);
                }
            });
        }
        if (suspiciousTags.length === 1) {
            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';
        }
        else if (suspiciousTags.length > 1) {
            /** @type {?} */
            let allSuspiciousTags = '';
            /** @type {?} */
            let first = true;
            suspiciousTags.forEach((tag) => {
                if (!first) {
                    allSuspiciousTags = allSuspiciousTags + ', ';
                }
                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';
                first = false;
            });
            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';
        }
        return e;
    }
    /**
     * Check for removed tags.
     * @return {?} null or message, if fulfilled.
     */
    checkTagRemoved() {
        /** @type {?} */
        let w = null;
        /** @type {?} */
        const suspiciousTags = [];
        if (this.sourceMessage) {
            /** @type {?} */
            const sourceTags = this.sourceMessage.allTags();
            /** @type {?} */
            const myTags = this.allTags();
            sourceTags.forEach((tagName) => {
                if (!myTags.has(tagName)) {
                    suspiciousTags.push(tagName);
                }
            });
        }
        if (suspiciousTags.length === 1) {
            w = 'removed tag <' + suspiciousTags[0] + '> from original message';
        }
        else if (suspiciousTags.length > 1) {
            /** @type {?} */
            let allSuspiciousTags = '';
            /** @type {?} */
            let first = true;
            suspiciousTags.forEach((tag) => {
                if (!first) {
                    allSuspiciousTags = allSuspiciousTags + ', ';
                }
                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';
                first = false;
            });
            w = 'removed tags ' + allSuspiciousTags + ' from original message';
        }
        return w;
    }
    /**
     * Get all tag names used in the message.
     * @return {?}
     */
    allTags() {
        /** @type {?} */
        const result = new Set();
        this.parts().forEach((part) => {
            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {
                /** @type {?} */
                const tagName = (/** @type {?} */ (part)).tagName();
                result.add(tagName);
            }
        });
        return result;
    }
    /**
     * @return {?}
     */
    parts() {
        return this._parts;
    }
    /**
     * @param {?} xmlRepresentation
     * @return {?}
     */
    setXmlRepresentation(xmlRepresentation) {
        this._xmlRepresentation = xmlRepresentation;
    }
    /**
     * @param {?} text
     * @return {?}
     */
    addText(text) {
        this._parts.push(new ParsedMessagePartText(text));
    }
    /**
     * @param {?} index
     * @param {?} disp
     * @return {?}
     */
    addPlaceholder(index, disp) {
        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));
    }
    /**
     * @param {?} tagname
     * @param {?} idcounter
     * @return {?}
     */
    addStartTag(tagname, idcounter) {
        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));
    }
    /**
     * @param {?} tagname
     * @return {?}
     */
    addEndTag(tagname) {
        /** @type {?} */
        const openTag = this.calculateOpenTagName();
        if (!openTag || openTag !== tagname) {
            // oops, not well formed
            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is "%s")', tagname, openTag, this.asNativeString()));
        }
        this._parts.push(new ParsedMessagePartEndTag(tagname));
    }
    /**
     * @param {?} tagname
     * @param {?} idcounter
     * @return {?}
     */
    addEmptyTag(tagname, idcounter) {
        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));
    }
    /**
     * @param {?} index
     * @param {?} disp
     * @return {?}
     */
    addICUMessageRef(index, disp) {
        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));
    }
    /**
     * @param {?} text
     * @return {?}
     */
    addICUMessage(text) {
        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));
    }
    /**
     * Determine, wether there is an open tag, that is not closed.
     * Returns the latest one or null, if there is no open tag.
     * @return {?}
     */
    calculateOpenTagName() {
        /** @type {?} */
        const openTags = [];
        this._parts.forEach((part) => {
            switch (part.type) {
                case ParsedMessagePartType.START_TAG:
                    openTags.push((/** @type {?} */ (part)).tagName());
                    break;
                case ParsedMessagePartType.END_TAG:
                    /** @type {?} */
                    const tagName = (/** @type {?} */ (part)).tagName();
                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {
                        /** @type {?} */
                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];
                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is "%s")', tagName, openTag, this.asNativeString()));
                    }
                    openTags.pop();
            }
        });
        return openTags.length === 0 ? null : openTags[openTags.length - 1];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Created by martin on 14.05.2017.
 * A tokenizer for normalized messages.
  @type {?} */
const TEXT$1 = 'TEXT';
/** @type {?} */
const START_TAG = 'START_TAG';
/** @type {?} */
const END_TAG = 'END_TAG';
/** @type {?} */
const EMPTY_TAG = 'EMPTY_TAG';
/** @type {?} */
const PLACEHOLDER = 'PLACEHOLDER';
/** @type {?} */
const ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';
/** @type {?} */
const ICU_MESSAGE = 'ICU_MESSAGE';
class ParsedMesageTokenizer {
    /**
     * @return {?}
     */
    getLexer() {
        /** @type {?} */
        const lexer = new Tokenizr();
        /** @type {?} */
        let plaintext = '';
        lexer.before((ctx, match, rule) => {
            if (rule.name !== TEXT$1 && plaintext !== '') {
                ctx.accept(TEXT$1, { text: plaintext });
                plaintext = '';
            }
        });
        lexer.finish((ctx) => {
            if (plaintext !== '') {
                ctx.accept(TEXT$1, { text: plaintext });
            }
        });
        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']
        // format is <name id="nr">, nr ist optional, z.B. <img> oder <img id="2">
        lexer.rule(/<(br|hr|img|area|link|wbr)( id="([0-9])*")?\>/, (ctx, match) => {
            /** @type {?} */
            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);
            ctx.accept(EMPTY_TAG, { name: match[1], idcounter: idcount });
        }, EMPTY_TAG);
        // start tag, Format <name id="nr">, nr ist optional, z.B. <mytag> oder <mytag id="2">
        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id="([0-9]*)")?>/, (ctx, match) => {
            /** @type {?} */
            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);
            ctx.accept(START_TAG, { name: match[1], idcounter: idcount });
        }, START_TAG);
        // end tag
        lexer.rule(/<\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {
            ctx.accept(END_TAG, { name: match[1] });
        }, END_TAG);
        // placeholder
        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {
            ctx.accept(PLACEHOLDER, { idcounter: parseInt(match[1], 10) });
        }, PLACEHOLDER);
        // icu message ref
        lexer.rule(/<ICU-Message-Ref_([0-9]+)\/>/, (ctx, match) => {
            ctx.accept(ICU_MESSAGE_REF, { idcounter: parseInt(match[1], 10) });
        }, ICU_MESSAGE_REF);
        // icu message
        lexer.rule(/<ICU-Message\/>/, (ctx, match) => {
            ctx.accept(ICU_MESSAGE, { message: match[0] });
        }, ICU_MESSAGE);
        // text
        lexer.rule(/./, (ctx, match) => {
            plaintext += match[0];
            ctx.ignore();
        }, TEXT$1);
        lexer.rule(/[\t\r\n]+/, (ctx, match) => {
            plaintext += match[0];
            ctx.ignore();
        }, TEXT$1);
        return lexer;
    }
    /**
     * @param {?} normalizedMessage
     * @return {?}
     */
    tokenize(normalizedMessage) {
        /** @type {?} */
        const lexer = this.getLexer();
        lexer.reset();
        lexer.input(normalizedMessage);
        return lexer.tokens();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by roobm on 10.05.2017.
 * A message parser can parse the xml content of a translatable message.
 * It generates a ParsedMessage from it.
 * @abstract
 */
class AbstractMessageParser {
    /**
     * Parse XML to ParsedMessage.
     * @param {?} xmlElement the xml representation
     * @param {?} sourceMessage optional original message that will be translated by normalized new one
     * Throws an error if normalized xml is not well formed.
     * @return {?}
     */
    createNormalizedMessageFromXML(xmlElement, sourceMessage) {
        /** @type {?} */
        const message = new ParsedMessage(this, sourceMessage);
        if (xmlElement) {
            message.setXmlRepresentation(xmlElement);
            this.addPartsOfNodeToMessage(xmlElement, message, false);
        }
        return message;
    }
    /**
     * Parse XML string to ParsedMessage.
     * @param {?} xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.
     * @param {?} sourceMessage optional original message that will be translated by normalized new one
     * Throws an error if normalized xml is not well formed.
     * @return {?}
     */
    createNormalizedMessageFromXMLString(xmlString, sourceMessage) {
        /** @type {?} */
        const doc = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');
        /** @type {?} */
        const xmlElement = /** @type {?} */ (doc.childNodes.item(0));
        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);
    }
    /**
     * recursively run through a node and add all identified parts to the message.
     * @param {?} node node
     * @param {?} message message to be generated.
     * @param {?} includeSelf if true, add node by itself, otherwise only children.
     * @return {?}
     */
    addPartsOfNodeToMessage(node, message, includeSelf) {
        /** @type {?} */
        let processChildren = true;
        if (includeSelf) {
            if (node.nodeType === node.TEXT_NODE) {
                message.addText(node.textContent);
                return;
            }
            if (node.nodeType === node.ELEMENT_NODE) {
                processChildren = this.processStartElement(/** @type {?} */ (node), message);
            }
        }
        if (processChildren) {
            /** @type {?} */
            const icuMessageText = this.getICUMessageText(node);
            /** @type {?} */
            let isICU = !isNullOrUndefined(icuMessageText);
            if (isICU) {
                try {
                    message.addICUMessage(icuMessageText);
                }
                catch (error) {
                    // if it is not parsable, handle it as non ICU
                    console.log('non ICU message: ', icuMessageText, error);
                    isICU = false;
                }
            }
            if (!isICU) {
                /** @type {?} */
                const children = node.childNodes;
                for (let i = 0; i < children.length; i++) {
                    this.addPartsOfNodeToMessage(children.item(i), message, true);
                }
            }
        }
        if (node.nodeType === node.ELEMENT_NODE) {
            this.processEndElement(/** @type {?} */ (node), message);
        }
    }
    /**
     * Return the ICU message content of the node, if it is an ICU Message.
     * @param {?} node node
     * @return {?} message or null, if it is no ICU Message.
     */
    getICUMessageText(node) {
        /** @type {?} */
        const children = node.childNodes;
        if (children.length === 0) {
            return null;
        }
        /** @type {?} */
        const firstChild = children.item(0);
        if (firstChild.nodeType === firstChild.TEXT_NODE) {
            if (this.isICUMessageStart(firstChild.textContent)) {
                return DOMUtilities.getXMLContent(/** @type {?} */ (node));
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    }
    /**
     * Test, wether text is beginning of ICU Message.
     * @param {?} text text
     * @return {?}
     */
    isICUMessageStart(text) {
        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);
        //        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');
    }
    /**
     * Parse normalized string to ParsedMessage.
     * @param {?} normalizedString normalized string
     * @param {?} sourceMessage optional original message that will be translated by normalized new one
     * @return {?} a new parsed message.
     * Throws an error if normalized string is not well formed.
     */
    parseNormalizedString(normalizedString, sourceMessage) {
        /** @type {?} */
        const message = new ParsedMessage(this, sourceMessage);
        /** @type {?} */
        const openTags = [];
        /** @type {?} */
        let tokens;
        try {
            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);
        }
        catch (error) {
            throw new Error(format('unexpected error while parsing message: "%s" (parsed "%")', error.message, normalizedString));
        }
        tokens.forEach((token) => {
            /** @type {?} */
            let disp = null;
            switch (token.type) {
                case TEXT$1:
                    message.addText(token.value.text);
                    break;
                case START_TAG:
                    message.addStartTag(token.value.name, token.value.idcounter);
                    openTags.push(token.value.name);
                    break;
                case END_TAG:
                    message.addEndTag(token.value.name);
                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {
                        // oops, not well formed
                        throw new Error(format('unexpected close tag "%s" (parsed "%s")', token.value.name, normalizedString));
                    }
                    openTags.pop();
                    break;
                case EMPTY_TAG:
                    message.addEmptyTag(token.value.name, token.value.idcounter);
                    break;
                case PLACEHOLDER:
                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;
                    message.addPlaceholder(token.value.idcounter, disp);
                    break;
                case ICU_MESSAGE_REF:
                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;
                    message.addICUMessageRef(token.value.idcounter, disp);
                    break;
                case ICU_MESSAGE:
                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed "%")', normalizedString));
                default:
                    break;
            }
        });
        if (openTags.length > 0) {
            // oops, not well closed tags
            throw new Error(format('missing close tag "%s" (parsed "%s")', openTags[openTags.length - 1], normalizedString));
        }
        message.setXmlRepresentation(this.createXmlRepresentation(message));
        return message;
    }
    /**
     * Parse a string, that is an ICU message, to ParsedMessage.
     * @param {?} icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.
     * @param {?} sourceMessage optional original message that will be translated by normalized new one
     * @return {?} a new parsed message.
     * Throws an error if icuMessageString has not the correct syntax.
     */
    parseICUMessage(icuMessageString, sourceMessage) {
        /** @type {?} */
        const message = new ParsedMessage(this, sourceMessage);
        message.addICUMessage(icuMessageString);
        return message;
    }
    /**
     * Helper function: Parse ID from a name.
     * name optionally ends with _<number>. This is the idcount.
     * E.g. name="TAG_IMG" returns 0
     * name = "TAG_IMG_1" returns 1
     * @param {?} name name
     * @return {?} id count
     */
    parseIdCountFromName(name) {
        /** @type {?} */
        const regex = /.*_([0-9]*)/;
        /** @type {?} */
        const match = regex.exec(name);
        if (isNullOrUndefined(match) || match[1] === '') {
            return 0;
        }
        else {
            /** @type {?} */
            const num = match[1];
            return parseInt(num, 10);
        }
    }
    /**
     * Create the native xml for a message.
     * Parts are already set here.
     * @param {?} message message
     * @return {?}
     */
    createXmlRepresentation(message) {
        /** @type {?} */
        const root = new DOMParser().parseFromString('<dummy/>', 'text/xml');
        /** @type {?} */
        const rootElem = root.getElementsByTagName('dummy').item(0);
        this.addXmlRepresentationToRoot(message, rootElem);
        return rootElem;
    }
    /**
     * @param {?} part
     * @param {?} rootElem
     * @return {?}
     */
    createXmlRepresentationOfTextPart(part, rootElem) {
        return rootElem.ownerDocument.createTextNode(part.asDisplayString());
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Created by roobm on 16.05.2017.
 * Mapping from normalized tag names to placeholder names.
  @type {?} */
const TAG_TO_PLACEHOLDER_NAMES = {
    'A': 'LINK',
    'B': 'BOLD_TEXT',
    'BR': 'LINE_BREAK',
    'EM': 'EMPHASISED_TEXT',
    'H1': 'HEADING_LEVEL1',
    'H2': 'HEADING_LEVEL2',
    'H3': 'HEADING_LEVEL3',
    'H4': 'HEADING_LEVEL4',
    'H5': 'HEADING_LEVEL5',
    'H6': 'HEADING_LEVEL6',
    'HR': 'HORIZONTAL_RULE',
    'I': 'ITALIC_TEXT',
    'LI': 'LIST_ITEM',
    'LINK': 'MEDIA_LINK',
    'OL': 'ORDERED_LIST',
    'P': 'PARAGRAPH',
    'Q': 'QUOTATION',
    'S': 'STRIKETHROUGH_TEXT',
    'SMALL': 'SMALL_TEXT',
    'SUB': 'SUBSTRIPT',
    'SUP': 'SUPERSCRIPT',
    'TBODY': 'TABLE_BODY',
    'TD': 'TABLE_CELL',
    'TFOOT': 'TABLE_FOOTER',
    'TH': 'TABLE_HEADER_CELL',
    'THEAD': 'TABLE_HEADER',
    'TR': 'TABLE_ROW',
    'TT': 'MONOSPACED_TEXT',
    'U': 'UNDERLINED_TEXT',
    'UL': 'UNORDERED_LIST',
};
/** *
 * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.
  @type {?} */
const VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];
class TagMapping {
    /**
     * @param {?} tag
     * @param {?} id
     * @return {?}
     */
    getStartTagPlaceholderName(tag, id) {
        /** @type {?} */
        const upperTag = tag.toUpperCase();
        /** @type {?} */
        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
        return `START_${baseName}` + this.counterString(id);
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    getCloseTagPlaceholderName(tag) {
        /** @type {?} */
        const upperTag = tag.toUpperCase();
        /** @type {?} */
        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
        return `CLOSE_${baseName}`;
    }
    /**
     * @param {?} tag
     * @param {?} id
     * @return {?}
     */
    getEmptyTagPlaceholderName(tag, id) {
        /** @type {?} */
        const upperTag = tag.toUpperCase();
        /** @type {?} */
        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
        return baseName + this.counterString(id);
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    getCtypeForTag(tag) {
        switch (tag.toLowerCase()) {
            case 'br':
                return 'lb';
            case 'img':
                return 'image';
            default:
                return `x-${tag}`;
        }
    }
    /**
     * @param {?} placeholderName
     * @return {?}
     */
    getTagnameFromStartTagPlaceholderName(placeholderName) {
        if (placeholderName.startsWith('START_TAG_')) {
            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();
        }
        else if (placeholderName.startsWith('START_')) {
            /** @type {?} */
            const ph = this.stripCounter(placeholderName.substring('START_'.length));
            /** @type {?} */
            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);
            return matchKey ? matchKey.toLowerCase() : null;
        }
        return null;
    }
    /**
     * @param {?} placeholderName
     * @return {?}
     */
    getTagnameFromCloseTagPlaceholderName(placeholderName) {
        if (placeholderName.startsWith('CLOSE_TAG_')) {
            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();
        }
        else if (placeholderName.startsWith('CLOSE_')) {
            /** @type {?} */
            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));
            /** @type {?} */
            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);
            return matchKey ? matchKey.toLowerCase() : null;
        }
        return null;
    }
    /**
     * Test, wether placeholder name stands for empty html tag.
     * @param {?} placeholderName can be TAG_<name> or just <name>
     * @return {?}
     */
    isEmptyTagPlaceholderName(placeholderName) {
        /** @type {?} */
        const ph = this.stripCounter(placeholderName);
        /** @type {?} */
        let matchKey;
        if (ph.startsWith('TAG_')) {
            matchKey = ph.substring(4).toUpperCase();
        }
        else {
            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);
        }
        if (matchKey) {
            if (VOID_TAGS.indexOf(matchKey) >= 0) {
                return true;
            }
        }
        return false;
    }
    /**
     * tagname of empty tag placeholder.
     * @param {?} placeholderName can be TAG_<name> or just <name>
     * @return {?}
     */
    getTagnameFromEmptyTagPlaceholderName(placeholderName) {
        /** @type {?} */
        const ph = this.stripCounter(placeholderName);
        /** @type {?} */
        let matchKey;
        if (ph.startsWith('TAG_')) {
            matchKey = ph.substring(4).toUpperCase();
        }
        else {
            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);
        }
        if (matchKey) {
            if (VOID_TAGS.indexOf(matchKey) >= 0) {
                return matchKey.toLowerCase();
            }
            else {
                return null;
            }
        }
        return null;
    }
    /**
     * If placeholder ends with _[0-9]+, strip that number.
     * @param {?} placeholderName placeholderName
     * @return {?} placeholderName without counter at end.
     */
    stripCounter(placeholderName) {
        if (placeholderName) {
            /** @type {?} */
            const re = /(.*)_[0-9]+$/;
            if (placeholderName.match(re)) {
                return placeholderName.replace(re, '$1');
            }
        }
        return placeholderName;
    }
    /**
     * String suffix for counter.
     * If counter is 0, it is empty, otherwise _<id>.
     * @param {?} id id
     * @return {?} suffix for counter.
     */
    counterString(id) {
        if (id === 0) {
            return '';
        }
        else {
            return '_' + id.toString(10);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by roobm on 10.05.2017.
 * A message parser for XLIFF 1.2
 */
class XliffMessageParser extends AbstractMessageParser {
    /**
     * Handle this element node.
     * This is called before the children are done.
     * @param {?} elementNode elementNode
     * @param {?} message message to be altered
     * @return {?} true, if children should be processed too, false otherwise (children ignored then)
     */
    processStartElement(elementNode, message) {
        /** @type {?} */
        const tagName = elementNode.tagName;
        /** @type {?} */
        const tagMapping = new TagMapping();
        if (tagName === 'x') {
            /** @type {?} */
            const id = elementNode.getAttribute('id');
            if (!id) {
                return; // should not happen
            }
            if (id.startsWith('INTERPOLATION')) {
                /** @type {?} */
                const index = this.parsePlaceholderIndexFromId(id);
                message.addPlaceholder(index, null);
            }
            else if (id.startsWith('ICU')) {
                /** @type {?} */
                const index = this.parseICUMessageRefIndexFromId(id);
                message.addICUMessageRef(index, null);
            }
            else if (id.startsWith('START_')) {
                /** @type {?} */
                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);
                if (normalizedTagName) {
                    /** @type {?} */
                    const idcount = this.parseIdCountFromName(id);
                    message.addStartTag(normalizedTagName, idcount);
                }
            }
            else if (id.startsWith('CLOSE_')) {
                /** @type {?} */
                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);
                if (normalizedTagName) {
                    message.addEndTag(normalizedTagName);
                }
            }
            else if (tagMapping.isEmptyTagPlaceholderName(id)) {
                /** @type {?} */
                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);
                if (normalizedTagName) {
                    /** @type {?} */
                    const idcount = this.parseIdCountFromName(id);
                    message.addEmptyTag(normalizedTagName, idcount);
                }
            }
        }
        return true;
    }
    /**
     * Handle end of this element node.
     * This is called after all children are processed.
     * @param {?} elementNode elementNode
     * @param {?} message message to be altered
     * @return {?}
     */
    processEndElement(elementNode, message) {
    }
    /**
     * Parse id attribute of x element as placeholder index.
     * id can be "INTERPOLATION" or "INTERPOLATION_n"
     * @param {?} id id
     * @return {?} index
     */
    parsePlaceholderIndexFromId(id) {
        /** @type {?} */
        let indexString = '';
        if (id === 'INTERPOLATION') {
            indexString = '0';
        }
        else {
            indexString = id.substring('INTERPOLATION_'.length);
        }
        return Number.parseInt(indexString, 10);
    }
    /**
     * Parse id attribute of x element as placeholder index.
     * id can be "INTERPOLATION" or "INTERPOLATION_n"
     * @param {?} id id
     * @return {?} id as number
     */
    parseICUMessageRefIndexFromId(id) {
        /** @type {?} */
        let indexString = '';
        if (id === 'ICU') {
            indexString = '0';
        }
        else {
            indexString = id.substring('ICU_'.length);
        }
        return Number.parseInt(indexString, 10);
    }
    /**
     * @param {?} message
     * @param {?} rootElem
     * @return {?}
     */
    addXmlRepresentationToRoot(message, rootElem) {
        message.parts().forEach((part) => {
            /** @type {?} */
            let child;
            switch (part.type) {
                case ParsedMessagePartType.TEXT:
                    child = this.createXmlRepresentationOfTextPart(/** @type {?} */ (part), rootElem);
                    break;
                case ParsedMessagePartType.START_TAG:
                    child = this.createXmlRepresentationOfStartTagPart((/** @type {?} */ (part)), rootElem);
                    break;
                case ParsedMessagePartType.END_TAG:
                    child = this.createXmlRepresentationOfEndTagPart((/** @type {?} */ (part)), rootElem);
                    break;
                case ParsedMessagePartType.EMPTY_TAG:
                    child = this.createXmlRepresentationOfEmptyTagPart((/** @type {?} */ (part)), rootElem);
                    break;
                case ParsedMessagePartType.PLACEHOLDER:
                    child = this.createXmlRepresentationOfPlaceholderPart((/** @type {?} */ (part)), rootElem);
                    break;
                case ParsedMessagePartType.ICU_MESSAGE_REF:
                    child = this.createXmlRepresentationOfICUMessageRefPart((/** @type {?} */ (part)), rootElem);
                    break;
            }
            if (child) {
                rootElem.appendChild(child);
            }
        });
    }
    /**
     * the xml used for start tag in the message.
     * Returns an empty <x/>-Element with attributes id and ctype
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfStartTagPart(part, rootElem) {
        /** @type {?} */
        const xElem = rootElem.ownerDocument.createElement('x');
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());
        /** @type {?} */
        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());
        /** @type {?} */
        const equivTextAttr = '<' + part.tagName() + '>';
        xElem.setAttribute('id', idAttrib);
        xElem.setAttribute('ctype', ctypeAttrib);
        xElem.setAttribute('equiv-text', equivTextAttr);
        return xElem;
    }
    /**
     * the xml used for end tag in the message.
     * Returns an empty <x/>-Element with attributes id and ctype
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfEndTagPart(part, rootElem) {
        /** @type {?} */
        const xElem = rootElem.ownerDocument.createElement('x');
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());
        /** @type {?} */
        const ctypeAttrib = 'x-' + part.tagName();
        xElem.setAttribute('id', idAttrib);
        xElem.setAttribute('ctype', ctypeAttrib);
        return xElem;
    }
    /**
     * the xml used for empty tag in the message.
     * Returns an empty <x/>-Element with attributes id and ctype
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfEmptyTagPart(part, rootElem) {
        /** @type {?} */
        const xElem = rootElem.ownerDocument.createElement('x');
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());
        /** @type {?} */
        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());
        /** @type {?} */
        const equivTextAttr = '<' + part.tagName() + '/>';
        xElem.setAttribute('id', idAttrib);
        xElem.setAttribute('ctype', ctypeAttrib);
        xElem.setAttribute('equiv-text', equivTextAttr);
        return xElem;
    }
    /**
     * the xml used for placeholder in the message.
     * Returns an empty <x/>-Element with attribute id="INTERPOLATION" or id="INTERPOLATION_n"
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfPlaceholderPart(part, rootElem) {
        /** @type {?} */
        const xElem = rootElem.ownerDocument.createElement('x');
        /** @type {?} */
        let idAttrib = 'INTERPOLATION';
        if (part.index() > 0) {
            idAttrib = 'INTERPOLATION_' + part.index().toString(10);
        }
        /** @type {?} */
        const equivTextAttr = part.disp();
        xElem.setAttribute('id', idAttrib);
        if (equivTextAttr) {
            xElem.setAttribute('equiv-text', equivTextAttr);
        }
        return xElem;
    }
    /**
     * the xml used for icu message refs in the message.
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {
        /** @type {?} */
        const xElem = rootElem.ownerDocument.createElement('x');
        /** @type {?} */
        let idAttrib = 'ICU';
        if (part.index() > 0) {
            idAttrib = 'ICU_' + part.index().toString(10);
        }
        xElem.setAttribute('id', idAttrib);
        return xElem;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 01.05.2017.
 * A Translation Unit in an XLIFF 1.2 file.
 */
class XliffTransUnit extends AbstractTransUnit {
    /**
     * @param {?} _element
     * @param {?} _id
     * @param {?} _translationMessagesFile
     */
    constructor(_element, _id, _translationMessagesFile) {
        super(_element, _id, _translationMessagesFile);
    }
    /**
     * @return {?}
     */
    sourceContent() {
        /** @type {?} */
        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        return DOMUtilities.getXMLContent(sourceElement);
    }
    /**
     * Set new source content in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing changed source content.
     * @param {?} newContent the new content.
     * @return {?}
     */
    setSourceContent(newContent) {
        /** @type {?} */
        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        if (!source) {
            // should not happen, there always has to be a source, but who knows..
            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));
        }
        DOMUtilities.replaceContentWithXMLContent(source, newContent);
    }
    /**
     * Return a parser used for normalized messages.
     * @return {?}
     */
    messageParser() {
        return new XliffMessageParser();
    }
    /**
     * The original text value, that is to be translated, as normalized message.
     * @return {?}
     */
    createSourceContentNormalized() {
        /** @type {?} */
        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        if (sourceElement) {
            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);
        }
        else {
            return null;
        }
    }
    /**
     * the translated value (containing all markup, depends on the concrete format used).
     * @return {?}
     */
    targetContent() {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        return DOMUtilities.getXMLContent(targetElement);
    }
    /**
     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
     * and all embedded html is replaced by direct html markup.
     * @return {?}
     */
    targetContentNormalized() {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());
    }
    /**
     * State of the translation as stored in the xml.
     * @return {?}
     */
    nativeTargetState() {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (targetElement) {
            return targetElement.getAttribute('state');
        }
        else {
            return null;
        }
    }
    /**
     * set state in xml.
     * @param {?} nativeState nativeState
     * @return {?}
     */
    setNativeTargetState(nativeState) {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (targetElement) {
            targetElement.setAttribute('state', nativeState);
        }
    }
    /**
     * Map an abstract state (new, translated, final) to a concrete state used in the xml.
     * Returns the state to be used in the xml.
     * @throws error, if state is invalid.
     * @param {?} state one of Constants.STATE...
     * @return {?} a native state (depends on concrete format)
     */
    mapStateToNativeState(state) {
        switch (state) {
            case STATE_NEW:
                return 'new';
            case STATE_TRANSLATED:
                return 'translated';
            case STATE_FINAL:
                return 'final';
            default:
                throw new Error('unknown state ' + state);
        }
    }
    /**
     * Map a native state (found in the document) to an abstract state (new, translated, final).
     * Returns the abstract state.
     * @param {?} nativeState nativeState
     * @return {?}
     */
    mapNativeStateToState(nativeState) {
        switch (nativeState) {
            case 'new':
                return STATE_NEW;
            case 'needs-translation':
                return STATE_NEW;
            case 'translated':
                return STATE_TRANSLATED;
            case 'needs-adaptation':
                return STATE_TRANSLATED;
            case 'needs-l10n':
                return STATE_TRANSLATED;
            case 'needs-review-adaptation':
                return STATE_TRANSLATED;
            case 'needs-review-l10n':
                return STATE_TRANSLATED;
            case 'needs-review-translation':
                return STATE_TRANSLATED;
            case 'final':
                return STATE_FINAL;
            case 'signed-off':
                return STATE_FINAL;
            default:
                return STATE_NEW;
        }
    }
    /**
     * All the source elements in the trans unit.
     * The source element is a reference to the original template.
     * It contains the name of the template file and a line number with the position inside the template.
     * It is just a help for translators to find the context for the translation.
     * This is set when using Angular 4.0 or greater.
     * Otherwise it just returns an empty array.
     * @return {?}
     */
    sourceReferences() {
        /** @type {?} */
        const sourceElements = this._element.getElementsByTagName('context-group');
        /** @type {?} */
        const sourceRefs = [];
        for (let i = 0; i < sourceElements.length; i++) {
            /** @type {?} */
            const elem = sourceElements.item(i);
            if (elem.getAttribute('purpose') === 'location') {
                /** @type {?} */
                const contextElements = elem.getElementsByTagName('context');
                /** @type {?} */
                let sourcefile = null;
                /** @type {?} */
                let linenumber = 0;
                for (let j = 0; j < contextElements.length; j++) {
                    /** @type {?} */
                    const contextElem = contextElements.item(j);
                    if (contextElem.getAttribute('context-type') === 'sourcefile') {
                        sourcefile = DOMUtilities.getPCDATA(contextElem);
                    }
                    if (contextElem.getAttribute('context-type') === 'linenumber') {
                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);
                    }
                }
                sourceRefs.push({ sourcefile: sourcefile, linenumber: linenumber });
            }
        }
        return sourceRefs;
    }
    /**
     * Set source ref elements in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing source refs.
     * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
     * @return {?}
     */
    setSourceReferences(sourceRefs) {
        this.removeAllSourceReferences();
        sourceRefs.forEach((ref) => {
            /** @type {?} */
            const contextGroup = this._element.ownerDocument.createElement('context-group');
            contextGroup.setAttribute('purpose', 'location');
            /** @type {?} */
            const contextSource = this._element.ownerDocument.createElement('context');
            contextSource.setAttribute('context-type', 'sourcefile');
            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));
            /** @type {?} */
            const contextLine = this._element.ownerDocument.createElement('context');
            contextLine.setAttribute('context-type', 'linenumber');
            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));
            contextGroup.appendChild(contextSource);
            contextGroup.appendChild(contextLine);
            this._element.appendChild(contextGroup);
        });
    }
    /**
     * @return {?}
     */
    removeAllSourceReferences() {
        /** @type {?} */
        const sourceElements = this._element.getElementsByTagName('context-group');
        /** @type {?} */
        const toBeRemoved = [];
        for (let i = 0; i < sourceElements.length; i++) {
            /** @type {?} */
            const elem = sourceElements.item(i);
            if (elem.getAttribute('purpose') === 'location') {
                toBeRemoved.push(elem);
            }
        }
        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });
    }
    /**
     * The description set in the template as value of the i18n-attribute.
     * e.g. i18n="mydescription".
     * In xliff this is stored as a note element with attribute from="description".
     * @return {?}
     */
    description() {
        /** @type {?} */
        const noteElem = this.findNoteElementWithFromAttribute('description');
        if (noteElem) {
            return DOMUtilities.getPCDATA(noteElem);
        }
        else {
            return null;
        }
    }
    /**
     * Change description property of trans-unit.
     * @param {?} description description
     * @return {?}
     */
    setDescription(description) {
        /** @type {?} */
        let noteElem = this.findNoteElementWithFromAttribute('description');
        if (description) {
            if (isNullOrUndefined(noteElem)) {
                // create it
                noteElem = this.createNoteElementWithFromAttribute('description', description);
            }
            else {
                DOMUtilities.replaceContentWithXMLContent(noteElem, description);
            }
        }
        else {
            if (!isNullOrUndefined(noteElem)) {
                // remove node
                this.removeNoteElementWithFromAttribute('description');
            }
        }
    }
    /**
     * Find a note element with attribute from='<attrValue>'
     * @param {?} attrValue attrValue
     * @return {?} element or null is absent
     */
    findNoteElementWithFromAttribute(attrValue) {
        /** @type {?} */
        const noteElements = this._element.getElementsByTagName('note');
        for (let i = 0; i < noteElements.length; i++) {
            /** @type {?} */
            const noteElem = noteElements.item(i);
            if (noteElem.getAttribute('from') === attrValue) {
                return noteElem;
            }
        }
        return null;
    }
    /**
     * Get all note elements where from attribute is not description or meaning
     * @return {?} elements
     */
    findAllAdditionalNoteElements() {
        /** @type {?} */
        const noteElements = this._element.getElementsByTagName('note');
        /** @type {?} */
        const result = [];
        for (let i = 0; i < noteElements.length; i++) {
            /** @type {?} */
            const noteElem = noteElements.item(i);
            /** @type {?} */
            const fromAttribute = noteElem.getAttribute('from');
            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {
                result.push(noteElem);
            }
        }
        return result;
    }
    /**
     * Create a new note element with attribute from='<attrValue>'
     * @param {?} fromAttrValue value of "from" attribute
     * @param {?} content text value of note element
     * @return {?} the new created element
     */
    createNoteElementWithFromAttribute(fromAttrValue, content) {
        /** @type {?} */
        const noteElement = this._element.ownerDocument.createElement('note');
        if (fromAttrValue) {
            noteElement.setAttribute('from', fromAttrValue);
        }
        noteElement.setAttribute('priority', '1');
        if (content) {
            DOMUtilities.replaceContentWithXMLContent(noteElement, content);
        }
        this._element.appendChild(noteElement);
        return noteElement;
    }
    /**
     * Remove note element with attribute from='<attrValue>'
     * @param {?} attrValue attrValue
     * @return {?}
     */
    removeNoteElementWithFromAttribute(attrValue) {
        /** @type {?} */
        const noteElement = this.findNoteElementWithFromAttribute(attrValue);
        if (noteElement) {
            this._element.removeChild(noteElement);
        }
    }
    /**
     * Remove all note elements where attribute "from" is not description or meaning.
     * @return {?}
     */
    removeAllAdditionalNoteElements() {
        /** @type {?} */
        const noteElements = this.findAllAdditionalNoteElements();
        noteElements.forEach((noteElement) => {
            this._element.removeChild(noteElement);
        });
    }
    /**
     * The meaning (intent) set in the template as value of the i18n-attribute.
     * This is the part in front of the | symbol.
     * e.g. i18n="meaning|mydescription".
     * In xliff this is stored as a note element with attribute from="meaning".
     * @return {?}
     */
    meaning() {
        /** @type {?} */
        const noteElem = this.findNoteElementWithFromAttribute('meaning');
        if (noteElem) {
            return DOMUtilities.getPCDATA(noteElem);
        }
        else {
            return null;
        }
    }
    /**
     * Change meaning property of trans-unit.
     * @param {?} meaning meaning
     * @return {?}
     */
    setMeaning(meaning) {
        /** @type {?} */
        let noteElem = this.findNoteElementWithFromAttribute('meaning');
        if (meaning) {
            if (isNullOrUndefined(noteElem)) {
                // create it
                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);
            }
            else {
                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);
            }
        }
        else {
            if (!isNullOrUndefined(noteElem)) {
                // remove node
                this.removeNoteElementWithFromAttribute('meaning');
            }
        }
    }
    /**
     * Get all notes of the trans-unit.
     * Notes are remarks made by a translator.
     * (description and meaning are not included here!)
     * @return {?}
     */
    notes() {
        /** @type {?} */
        const noteElememts = this.findAllAdditionalNoteElements();
        return noteElememts.map(elem => {
            return {
                from: elem.getAttribute('from'),
                text: DOMUtilities.getPCDATA(elem)
            };
        });
    }
    /**
     * Test, wether setting of notes is supported.
     * If not, setNotes will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetNotes() {
        return true;
    }
    /**
     * Add notes to trans unit.
     * @throws an Error if any note contains description or meaning as from attribute.
     * @param {?} newNotes the notes to add.
     * @return {?}
     */
    setNotes(newNotes) {
        if (!isNullOrUndefined(newNotes)) {
            this.checkNotes(newNotes);
        }
        this.removeAllAdditionalNoteElements();
        if (!isNullOrUndefined(newNotes)) {
            newNotes.forEach((note) => {
                /** @type {?} */
                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);
            });
        }
    }
    /**
     * Set the translation to a given string (including markup).
     * @param {?} translation translation
     * @return {?}
     */
    translateNative(translation) {
        /** @type {?} */
        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (!target) {
            /** @type {?} */
            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
            target = DOMUtilities.createFollowingSibling('target', source);
        }
        DOMUtilities.replaceContentWithXMLContent(target, /** @type {?} */ (translation));
        this.setTargetState(STATE_TRANSLATED);
    }
    /**
     * Copy source to target to use it as dummy translation.
     * Returns a changed copy of this trans unit.
     * receiver is not changed.
     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @param {?} targetFile
     * @return {?}
     */
    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {
        /** @type {?} */
        const element = /** @type {?} */ (this._element.cloneNode(true));
        /** @type {?} */
        const clone = new XliffTransUnit(element, this._id, targetFile);
        clone.useSourceAsTarget(isDefaultLang, copyContent);
        return clone;
    }
    /**
     * Copy source to target to use it as dummy translation.
     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @return {?}
     */
    useSourceAsTarget(isDefaultLang, copyContent) {
        /** @type {?} */
        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        /** @type {?} */
        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (!target) {
            target = DOMUtilities.createFollowingSibling('target', source);
        }
        if (isDefaultLang || copyContent) {
            /** @type {?} */
            const sourceString = DOMUtilities.getXMLContent(source);
            /** @type {?} */
            let newTargetString = sourceString;
            if (!this.isICUMessage(sourceString)) {
                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()
                    + sourceString
                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();
            }
            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);
        }
        else {
            DOMUtilities.replaceContentWithXMLContent(target, '');
        }
        if (isDefaultLang) {
            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));
        }
        else {
            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 23.02.2017.
 * Ab xliff file read from a source file.
 * Defines some relevant get and set method for reading and modifying such a file.
 */
class XliffFile extends AbstractTranslationMessagesFile {
    /**
     * Create an xlf-File from source.
     * @param {?} xmlString source read from file.
     * @param {?} path Path to file
     * @param {?} encoding optional encoding of the xml.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     */
    constructor(xmlString, path, encoding) {
        super();
        this._warnings = [];
        this._numberOfTransUnitsWithMissingId = 0;
        this.initializeFromContent(xmlString, path, encoding);
    }
    /**
     * @param {?} xmlString
     * @param {?} path
     * @param {?} encoding
     * @return {?}
     */
    initializeFromContent(xmlString, path, encoding) {
        this.parseContent(xmlString, path, encoding);
        /** @type {?} */
        const xliffList = this._parsedDocument.getElementsByTagName('xliff');
        if (xliffList.length !== 1) {
            throw new Error(format('File "%s" seems to be no xliff file (should contain an xliff element)', path));
        }
        else {
            /** @type {?} */
            const version = xliffList.item(0).getAttribute('version');
            /** @type {?} */
            const expectedVersion = '1.2';
            if (version !== expectedVersion) {
                throw new Error(format('File "%s" seems to be no xliff 1.2 file, version should be %s, found %s', path, expectedVersion, version));
            }
        }
        return this;
    }
    /**
     * File format as it is used in config files.
     * Currently 'xlf', 'xmb', 'xmb2'
     * Returns one of the constants FORMAT_..
     * @return {?}
     */
    i18nFormat() {
        return FORMAT_XLIFF12;
    }
    /**
     * File type.
     * Here 'XLIFF 1.2'
     * @return {?}
     */
    fileType() {
        return FILETYPE_XLIFF12;
    }
    /**
     * return tag names of all elements that have mixed content.
     * These elements will not be beautified.
     * Typical candidates are source and target.
     * @return {?}
     */
    elementsWithMixedContent() {
        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];
    }
    /**
     * @return {?}
     */
    initializeTransUnits() {
        this.transUnits = [];
        /** @type {?} */
        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');
        for (let i = 0; i < transUnitsInFile.length; i++) {
            /** @type {?} */
            const transunit = transUnitsInFile.item(i);
            /** @type {?} */
            const id = transunit.getAttribute('id');
            if (!id) {
                this._warnings.push(format('oops, trans-unit without "id" found in master, please check file %s', this._filename));
            }
            this.transUnits.push(new XliffTransUnit(transunit, id, this));
        }
    }
    /**
     * Get source language.
     * @return {?} source language.
     */
    sourceLanguage() {
        /** @type {?} */
        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
        if (fileElem) {
            return fileElem.getAttribute('source-language');
        }
        else {
            return null;
        }
    }
    /**
     * Edit the source language.
     * @param {?} language language
     * @return {?}
     */
    setSourceLanguage(language) {
        /** @type {?} */
        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
        if (fileElem) {
            fileElem.setAttribute('source-language', language);
        }
    }
    /**
     * Get target language.
     * @return {?} target language.
     */
    targetLanguage() {
        /** @type {?} */
        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
        if (fileElem) {
            return fileElem.getAttribute('target-language');
        }
        else {
            return null;
        }
    }
    /**
     * Edit the target language.
     * @param {?} language language
     * @return {?}
     */
    setTargetLanguage(language) {
        /** @type {?} */
        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
        if (fileElem) {
            fileElem.setAttribute('target-language', language);
        }
    }
    /**
     * Add a new trans-unit to this file.
     * The trans unit stems from another file.
     * It copies the source content of the tu to the target content too,
     * depending on the values of isDefaultLang and copyContent.
     * So the source can be used as a dummy translation.
     * (used by xliffmerge)
     * @throws an error if trans-unit with same id already is in the file.
     * @param {?} foreignTransUnit the trans unit to be imported.
     * @param {?} isDefaultLang Flag, wether file contains the default language.
     * Then source and target are just equal.
     * The content will be copied.
     * State will be final.
     * @param {?} copyContent Flag, wether to copy content or leave it empty.
     * Wben true, content will be copied from source.
     * When false, content will be left empty (if it is not the default language).
     * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
     * Newly imported trans unit is then inserted directly after this element.
     * If not set or not part of this file, new unit will be imported at the end.
     * If explicity set to null, new unit will be imported at the start.
     * @return {?} the newly imported trans unit (since version 1.7.0)
     */
    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {
        if (this.transUnitWithId(foreignTransUnit.id)) {
            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));
        }
        /** @type {?} */
        const newTu = (/** @type {?} */ (foreignTransUnit)).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);
        /** @type {?} */
        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');
        if (!bodyElement) {
            throw new Error(format('File "%s" seems to be no xliff 1.2 file (should contain a body element)', this._filename));
        }
        /** @type {?} */
        let inserted = false;
        /** @type {?} */
        let isAfterElementPartOfFile = false;
        if (!!importAfterElement) {
            /** @type {?} */
            const insertionPoint = this.transUnitWithId(importAfterElement.id);
            if (!!insertionPoint) {
                isAfterElementPartOfFile = true;
            }
        }
        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {
            bodyElement.appendChild(newTu.asXmlElement());
            inserted = true;
        }
        else if (importAfterElement === null) {
            /** @type {?} */
            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');
            if (firstUnitElement) {
                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);
                inserted = true;
            }
            else {
                // no trans-unit, empty file, so add to body
                bodyElement.appendChild(newTu.asXmlElement());
                inserted = true;
            }
        }
        else {
            /** @type {?} */
            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);
            if (refUnitElement) {
                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);
                inserted = true;
            }
        }
        if (inserted) {
            this.lazyInitializeTransUnits();
            this.transUnits.push(newTu);
            this.countNumbers();
            return newTu;
        }
        else {
            return null;
        }
    }
    /**
     * Create a new translation file for this file for a given language.
     * Normally, this is just a copy of the original one.
     * But for XMB the translation file has format 'XTB'.
     * @param {?} lang Language code
     * @param {?} filename expected filename to store file
     * @param {?} isDefaultLang Flag, wether file contains the default language.
     * Then source and target are just equal.
     * The content will be copied.
     * State will be final.
     * @param {?} copyContent Flag, wether to copy content or leave it empty.
     * Wben true, content will be copied from source.
     * When false, content will be left empty (if it is not the default language).
     * @return {?}
     */
    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {
        /** @type {?} */
        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding());
        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);
        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);
        translationFile.setTargetLanguage(lang);
        translationFile.forEachTransUnit((transUnit) => {
            (/** @type {?} */ (transUnit)).useSourceAsTarget(isDefaultLang, copyContent);
        });
        return translationFile;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by roobm on 10.05.2017.
 * A message parser for XMB
 */
class XmbMessageParser extends AbstractMessageParser {
    /**
     * Handle this element node.
     * This is called before the children are done.
     * @param {?} elementNode elementNode
     * @param {?} message message to be altered
     * @return {?} true, if children should be processed too, false otherwise (children ignored then)
     */
    processStartElement(elementNode, message) {
        /** @type {?} */
        const tagName = elementNode.tagName;
        if (tagName === 'ph') {
            /** @type {?} */
            const name = elementNode.getAttribute('name');
            if (!name) {
                return true; // should not happen
            }
            if (name.startsWith('INTERPOLATION')) {
                /** @type {?} */
                const index = this.parsePlaceholderIndexFromName(name);
                message.addPlaceholder(index, null);
                return false; // ignore children
            }
            else if (name.startsWith('START_')) {
                /** @type {?} */
                const tag = this.parseTagnameFromPhElement(elementNode);
                /** @type {?} */
                const idcounter = this.parseIdCountFromName(name);
                if (tag) {
                    message.addStartTag(tag, idcounter);
                }
                return false; // ignore children
            }
            else if (name.startsWith('CLOSE_')) {
                /** @type {?} */
                const tag = this.parseTagnameFromPhElement(elementNode);
                if (tag) {
                    message.addEndTag(tag);
                }
                return false; // ignore children
            }
            else if (new TagMapping().isEmptyTagPlaceholderName(name)) {
                /** @type {?} */
                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);
                /** @type {?} */
                const idcounter = this.parseIdCountFromName(name);
                message.addEmptyTag(emptyTagName, idcounter);
                return false; // ignore children
            }
            else if (name.startsWith('ICU')) {
                /** @type {?} */
                const index = this.parseICUMessageIndexFromName(name);
                message.addICUMessageRef(index, null);
                return false; // ignore children
            }
        }
        else if (tagName === 'source') {
            // ignore source
            return false;
        }
        return true;
    }
    /**
     * Return the ICU message content of the node, if it is an ICU Message.
     * @param {?} node node
     * @return {?} message or null, if it is no ICU Message.
     */
    getICUMessageText(node) {
        /** @type {?} */
        const children = node.childNodes;
        if (children.length === 0) {
            return null;
        }
        /** @type {?} */
        let firstChild = null;
        /** @type {?} */
        let i;
        for (i = 0; i < children.length; i++) {
            /** @type {?} */
            const child = children.item(i);
            if (child.nodeType !== child.ELEMENT_NODE || (/** @type {?} */ (child)).tagName !== 'source') {
                firstChild = child;
                break;
            }
        }
        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {
            if (this.isICUMessageStart(firstChild.textContent)) {
                /** @type {?} */
                const messageText = DOMUtilities.getXMLContent(/** @type {?} */ (node));
                if (i > 0) {
                    /** @type {?} */
                    const reSource = new RegExp('<source[^>]*>.*</source>', 'g');
                    return messageText.replace(reSource, '');
                }
                else {
                    return messageText;
                }
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    }
    /**
     * Handle end of this element node.
     * This is called after all children are processed.
     * @param {?} elementNode elementNode
     * @param {?} message message to be altered
     * @return {?}
     */
    processEndElement(elementNode, message) {
    }
    /**
     * Parse id attribute of x element as placeholder index.
     * id can be "INTERPOLATION" or "INTERPOLATION_n"
     * @param {?} name name
     * @return {?} id as number
     */
    parsePlaceholderIndexFromName(name) {
        /** @type {?} */
        let indexString = '';
        if (name === 'INTERPOLATION') {
            indexString = '0';
        }
        else {
            indexString = name.substring('INTERPOLATION_'.length);
        }
        return Number.parseInt(indexString, 10);
    }
    /**
     * Parse id attribute of x element as ICU message ref index.
     * id can be "ICU" or "ICU_n"
     * @param {?} name name
     * @return {?} id as number
     */
    parseICUMessageIndexFromName(name) {
        /** @type {?} */
        let indexString = '';
        if (name === 'ICU') {
            indexString = '0';
        }
        else {
            indexString = name.substring('ICU_'.length);
        }
        return Number.parseInt(indexString, 10);
    }
    /**
     * Parse the tag name from a ph element.
     * It contained in the <ex> subelements value and enclosed in <>.
     * Example: <ph name="START_BOLD_TEXT"><ex>&lt;b&gt;</ex></ph>
     * @param {?} phElement phElement
     * @return {?}
     */
    parseTagnameFromPhElement(phElement) {
        /** @type {?} */
        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');
        if (exElement) {
            /** @type {?} */
            const value = DOMUtilities.getPCDATA(exElement);
            if (!value || !value.startsWith('<') || !value.endsWith('>')) {
                // oops
                return null;
            }
            if (value.charAt(1) === '/') {
                return value.substring(2, value.length - 1);
            }
            else {
                return value.substring(1, value.length - 1);
            }
        }
        else {
            return null;
        }
    }
    /**
     * @param {?} message
     * @param {?} rootElem
     * @return {?}
     */
    addXmlRepresentationToRoot(message, rootElem) {
        message.parts().forEach((part) => {
            /** @type {?} */
            const child = this.createXmlRepresentationOfPart(part, rootElem);
            if (child) {
                rootElem.appendChild(child);
            }
        });
    }
    /**
     * @param {?} part
     * @param {?} rootElem
     * @return {?}
     */
    createXmlRepresentationOfPart(part, rootElem) {
        switch (part.type) {
            case ParsedMessagePartType.TEXT:
                return this.createXmlRepresentationOfTextPart(/** @type {?} */ (part), rootElem);
            case ParsedMessagePartType.START_TAG:
                return this.createXmlRepresentationOfStartTagPart((/** @type {?} */ (part)), rootElem);
            case ParsedMessagePartType.END_TAG:
                return this.createXmlRepresentationOfEndTagPart((/** @type {?} */ (part)), rootElem);
            case ParsedMessagePartType.EMPTY_TAG:
                return this.createXmlRepresentationOfEmptyTagPart((/** @type {?} */ (part)), rootElem);
            case ParsedMessagePartType.PLACEHOLDER:
                return this.createXmlRepresentationOfPlaceholderPart((/** @type {?} */ (part)), rootElem);
            case ParsedMessagePartType.ICU_MESSAGE_REF:
                return this.createXmlRepresentationOfICUMessageRefPart((/** @type {?} */ (part)), rootElem);
        }
    }
    /**
     * the xml used for start tag in the message.
     * Returns an <ph>-Element with attribute name and subelement ex
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfStartTagPart(part, rootElem) {
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());
        phElem.setAttribute('name', nameAttrib);
        /** @type {?} */
        const exElem = rootElem.ownerDocument.createElement('ex');
        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));
        phElem.appendChild(exElem);
        return phElem;
    }
    /**
     * the xml used for end tag in the message.
     * Returns an <ph>-Element with attribute name and subelement ex
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfEndTagPart(part, rootElem) {
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());
        phElem.setAttribute('name', nameAttrib);
        /** @type {?} */
        const exElem = rootElem.ownerDocument.createElement('ex');
        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));
        phElem.appendChild(exElem);
        return phElem;
    }
    /**
     * the xml used for empty tag in the message.
     * Returns an <ph>-Element with attribute name and subelement ex
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfEmptyTagPart(part, rootElem) {
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());
        phElem.setAttribute('name', nameAttrib);
        /** @type {?} */
        const exElem = rootElem.ownerDocument.createElement('ex');
        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));
        phElem.appendChild(exElem);
        return phElem;
    }
    /**
     * the xml used for placeholder in the message.
     * Returns an <ph>-Element with attribute name and subelement ex
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfPlaceholderPart(part, rootElem) {
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        let nameAttrib = 'INTERPOLATION';
        if (part.index() > 0) {
            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);
        }
        phElem.setAttribute('name', nameAttrib);
        /** @type {?} */
        const exElem = rootElem.ownerDocument.createElement('ex');
        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));
        phElem.appendChild(exElem);
        return phElem;
    }
    /**
     * the xml used for icu message refs in the message.
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        let nameAttrib = 'ICU';
        if (part.index() > 0) {
            nameAttrib = 'ICU_' + part.index().toString(10);
        }
        phElem.setAttribute('name', nameAttrib);
        /** @type {?} */
        const exElem = rootElem.ownerDocument.createElement('ex');
        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));
        phElem.appendChild(exElem);
        return phElem;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 01.05.2017.
 * A Translation Unit in an XMB file.
 */
class XmbTransUnit extends AbstractTransUnit {
    /**
     * @param {?} _element
     * @param {?} _id
     * @param {?} _translationMessagesFile
     */
    constructor(_element, _id, _translationMessagesFile) {
        super(_element, _id, _translationMessagesFile);
    }
    /**
     * Parses something like 'c:\xxx:7' and returns source and linenumber.
     * @param {?} sourceAndPos something like 'c:\xxx:7', last colon is the separator
     * @return {?} source and linenumber
     */
    static parseSourceAndPos(sourceAndPos) {
        /** @type {?} */
        const index = sourceAndPos.lastIndexOf(':');
        if (index < 0) {
            return {
                sourcefile: sourceAndPos,
                linenumber: 0
            };
        }
        else {
            return {
                sourcefile: sourceAndPos.substring(0, index),
                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))
            };
        }
    }
    /**
     * @param {?} lineNumberString
     * @return {?}
     */
    static parseLineNumber(lineNumberString) {
        return Number.parseInt(lineNumberString, 10);
    }
    /**
     * Get content to translate.
     * Source parts are excluded here.
     * @return {?} source content
     */
    sourceContent() {
        /** @type {?} */
        let msgContent = DOMUtilities.getXMLContent(this._element);
        /** @type {?} */
        const reSourceElem = /<source>.*<\/source>/g;
        msgContent = msgContent.replace(reSourceElem, '');
        return msgContent;
    }
    /**
     * Test, wether setting of source content is supported.
     * If not, setSourceContent in trans-unit will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetSourceContent() {
        return false;
    }
    /**
     * Set new source content in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing changed source content.
     * @param {?} newContent the new content.
     * @return {?}
     */
    setSourceContent(newContent) {
        // not supported
    }
    /**
     * Return a parser used for normalized messages.
     * @return {?}
     */
    messageParser() {
        return new XmbMessageParser();
    }
    /**
     * The original text value, that is to be translated, as normalized message.
     * @return {?}
     */
    createSourceContentNormalized() {
        return this.messageParser().createNormalizedMessageFromXML(this._element, null);
    }
    /**
     * the translated value (containing all markup, depends on the concrete format used).
     * @return {?}
     */
    targetContent() {
        // in fact, target and source are just the same in xmb
        return this.sourceContent();
    }
    /**
     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
     * and all embedded html is replaced by direct html markup.
     * @return {?}
     */
    targetContentNormalized() {
        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());
    }
    /**
     * State of the translation.
     * (not supported in xmb)
     * @return {?}
     */
    nativeTargetState() {
        return null; // not supported in xmb
    }
    /**
     * Map an abstract state (new, translated, final) to a concrete state used in the xml.
     * Returns the state to be used in the xml.
     * @throws error, if state is invalid.
     * @param {?} state one of Constants.STATE...
     * @return {?} a native state (depends on concrete format)
     */
    mapStateToNativeState(state) {
        return state;
    }
    /**
     * Map a native state (found in the document) to an abstract state (new, translated, final).
     * Returns the abstract state.
     * @param {?} nativeState nativeState
     * @return {?}
     */
    mapNativeStateToState(nativeState) {
        return nativeState;
    }
    /**
     * set state in xml.
     * (not supported in xmb)
     * @param {?} nativeState nativeState
     * @return {?}
     */
    setNativeTargetState(nativeState) {
        // not supported for xmb
    }
    /**
     * All the source elements in the trans unit.
     * The source element is a reference to the original template.
     * It contains the name of the template file and a line number with the position inside the template.
     * It is just a help for translators to find the context for the translation.
     * This is set when using Angular 4.0 or greater.
     * Otherwise it just returns an empty array.
     * @return {?}
     */
    sourceReferences() {
        /** @type {?} */
        const sourceElements = this._element.getElementsByTagName('source');
        /** @type {?} */
        const sourceRefs = [];
        for (let i = 0; i < sourceElements.length; i++) {
            /** @type {?} */
            const elem = sourceElements.item(i);
            /** @type {?} */
            const sourceAndPos = DOMUtilities.getPCDATA(elem);
            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));
        }
        return sourceRefs;
    }
    /**
     * Set source ref elements in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing source refs.
     * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
     * @return {?}
     */
    setSourceReferences(sourceRefs) {
        this.removeAllSourceReferences();
        /** @type {?} */
        let insertPosition = this._element.childNodes.item(0);
        for (let i = sourceRefs.length - 1; i >= 0; i--) {
            /** @type {?} */
            const ref = sourceRefs[i];
            /** @type {?} */
            const source = this._element.ownerDocument.createElement('source');
            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));
            this._element.insertBefore(source, insertPosition);
            insertPosition = source;
        }
    }
    /**
     * @return {?}
     */
    removeAllSourceReferences() {
        /** @type {?} */
        const sourceElements = this._element.getElementsByTagName('source');
        /** @type {?} */
        const toBeRemoved = [];
        for (let i = 0; i < sourceElements.length; i++) {
            /** @type {?} */
            const elem = sourceElements.item(i);
            toBeRemoved.push(elem);
        }
        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });
    }
    /**
     * The description set in the template as value of the i18n-attribute.
     * e.g. i18n="mydescription".
     * In xmb this is stored in the attribute "desc".
     * @return {?}
     */
    description() {
        return this._element.getAttribute('desc');
    }
    /**
     * The meaning (intent) set in the template as value of the i18n-attribute.
     * This is the part in front of the | symbol.
     * e.g. i18n="meaning|mydescription".
     * In xmb this is stored in the attribute "meaning".
     * @return {?}
     */
    meaning() {
        return this._element.getAttribute('meaning');
    }
    /**
     * Test, wether setting of description and meaning is supported.
     * If not, setDescription and setMeaning will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetDescriptionAndMeaning() {
        return false;
    }
    /**
     * Change description property of trans-unit.
     * @param {?} description description
     * @return {?}
     */
    setDescription(description) {
        // not supported, do nothing
    }
    /**
     * Change meaning property of trans-unit.
     * @param {?} meaning meaning
     * @return {?}
     */
    setMeaning(meaning) {
        // not supported, do nothing
    }
    /**
     * Get all notes of the trans-unit.
     * There are NO notes in xmb/xtb
     * @return {?}
     */
    notes() {
        return [];
    }
    /**
     * Test, wether setting of notes is supported.
     * If not, setNotes will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetNotes() {
        return false;
    }
    /**
     * Add notes to trans unit.
     * @param {?} newNotes the notes to add.
     * NOT Supported in xmb/xtb
     * @return {?}
     */
    setNotes(newNotes) {
        // not supported, do nothing
    }
    /**
     * Copy source to target to use it as dummy translation.
     * Returns a changed copy of this trans unit.
     * receiver is not changed.
     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
     * In xmb there is nothing to do, because there is only a target, no source.
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @param {?} targetFile
     * @return {?}
     */
    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {
        return this;
    }
    /**
     * Copy source to target to use it as dummy translation.
     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @return {?}
     */
    useSourceAsTarget(isDefaultLang, copyContent) {
        // do nothing
    }
    /**
     * Set the translation to a given string (including markup).
     * In fact, xmb cannot be translated.
     * So this throws an error.
     * @param {?} translation translation
     * @return {?}
     */
    translateNative(translation) {
        throw new Error('You cannot translate xmb files, use xtb instead.');
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Doctype of xtb translation file corresponding with thos xmb file.
  @type {?} */
const XTB_DOCTYPE = `<!DOCTYPE translationbundle [
  <!ELEMENT translationbundle (translation)*>
  <!ATTLIST translationbundle lang CDATA #REQUIRED>
  <!ELEMENT translation (#PCDATA|ph)*>
  <!ATTLIST translation id CDATA #REQUIRED>
  <!ELEMENT ph EMPTY>
  <!ATTLIST ph name CDATA #REQUIRED>
]>`;
class XmbFile extends AbstractTranslationMessagesFile {
    /**
     * Create an xmb-File from source.
     * @param {?} _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file
     * @param {?} xmlString file content
     * @param {?} path Path to file
     * @param {?} encoding optional encoding of the xml.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     */
    constructor(_translationMessageFileFactory, xmlString, path, encoding) {
        super();
        this._translationMessageFileFactory = _translationMessageFileFactory;
        this._warnings = [];
        this._numberOfTransUnitsWithMissingId = 0;
        this.initializeFromContent(xmlString, path, encoding);
    }
    /**
     * @param {?} xmlString
     * @param {?} path
     * @param {?} encoding
     * @return {?}
     */
    initializeFromContent(xmlString, path, encoding) {
        this.parseContent(xmlString, path, encoding);
        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {
            throw new Error(format('File "%s" seems to be no xmb file (should contain a messagebundle element)', path));
        }
        return this;
    }
    /**
     * @return {?}
     */
    initializeTransUnits() {
        this.transUnits = [];
        /** @type {?} */
        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');
        for (let i = 0; i < transUnitsInFile.length; i++) {
            /** @type {?} */
            const msg = transUnitsInFile.item(i);
            /** @type {?} */
            const id = msg.getAttribute('id');
            if (!id) {
                this._warnings.push(format('oops, msg without "id" found in master, please check file %s', this._filename));
            }
            this.transUnits.push(new XmbTransUnit(msg, id, this));
        }
    }
    /**
     * File format as it is used in config files.
     * Currently 'xlf', 'xmb', 'xmb2'
     * Returns one of the constants FORMAT_..
     * @return {?}
     */
    i18nFormat() {
        return FORMAT_XMB;
    }
    /**
     * File type.
     * Here 'XMB'
     * @return {?}
     */
    fileType() {
        return FILETYPE_XMB;
    }
    /**
     * return tag names of all elements that have mixed content.
     * These elements will not be beautified.
     * Typical candidates are source and target.
     * @return {?}
     */
    elementsWithMixedContent() {
        return ['message'];
    }
    /**
     * Guess language from filename.
     * If filename is foo.xy.xmb, than language is assumed to be xy.
     * @return {?} Language or null
     */
    guessLanguageFromFilename() {
        if (this._filename) {
            /** @type {?} */
            const parts = this._filename.split('.');
            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {
                return parts[parts.length - 2];
            }
        }
        return null;
    }
    /**
     * Get source language.
     * Unsupported in xmb.
     * Try to guess it from filename if any..
     * @return {?} source language.
     */
    sourceLanguage() {
        return this.guessLanguageFromFilename();
    }
    /**
     * Edit the source language.
     * Unsupported in xmb.
     * @param {?} language language
     * @return {?}
     */
    setSourceLanguage(language) {
        // do nothing, xmb has no notation for this.
    }
    /**
     * Get target language.
     * Unsupported in xmb.
     * Try to guess it from filename if any..
     * @return {?} target language.
     */
    targetLanguage() {
        return this.guessLanguageFromFilename();
    }
    /**
     * Edit the target language.
     * Unsupported in xmb.
     * @param {?} language language
     * @return {?}
     */
    setTargetLanguage(language) {
        // do nothing, xmb has no notation for this.
    }
    /**
     * Add a new trans-unit to this file.
     * The trans unit stems from another file.
     * It copies the source content of the tu to the target content too,
     * depending on the values of isDefaultLang and copyContent.
     * So the source can be used as a dummy translation.
     * (used by xliffmerge)
     * @throws an error if trans-unit with same id already is in the file.
     * @param {?} foreignTransUnit the trans unit to be imported.
     * @param {?} isDefaultLang Flag, wether file contains the default language.
     * Then source and target are just equal.
     * The content will be copied.
     * State will be final.
     * @param {?} copyContent Flag, wether to copy content or leave it empty.
     * Wben true, content will be copied from source.
     * When false, content will be left empty (if it is not the default language).
     * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
     * Newly imported trans unit is then inserted directly after this element.
     * If not set or not part of this file, new unit will be imported at the end.
     * If explicity set to null, new unit will be imported at the start.
     * @return {?} the newly imported trans unit (since version 1.7.0)
     */
    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {
        throw Error('xmb file cannot be used to store translations, use xtb file');
    }
    /**
     * Create a new translation file for this file for a given language.
     * Normally, this is just a copy of the original one.
     * But for XMB the translation file has format 'XTB'.
     * @param {?} lang Language code
     * @param {?} filename expected filename to store file
     * @param {?} isDefaultLang Flag, wether file contains the default language.
     * Then source and target are just equal.
     * The content will be copied.
     * State will be final.
     * @param {?} copyContent Flag, wether to copy content or leave it empty.
     * Wben true, content will be copied from source.
     * When false, content will be left empty (if it is not the default language).
     * @return {?}
     */
    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {
        /** @type {?} */
        const translationbundleXMLSource = '<?xml version="1.0" encoding="UTF-8"?>\n' + XTB_DOCTYPE + '\n<translationbundle>\n</translationbundle>\n';
        /** @type {?} */
        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(FORMAT_XTB, translationbundleXMLSource, filename, this.encoding(), { xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding() });
        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);
        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);
        translationFile.setTargetLanguage(lang);
        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());
        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());
        this.forEachTransUnit((tu) => {
            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);
        });
        return translationFile;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by roobm on 10.05.2017.
 * A message parser for XLIFF 2.0
 */
class Xliff2MessageParser extends AbstractMessageParser {
    /**
     * Handle this element node.
     * This is called before the children are done.
     * @param {?} elementNode elementNode
     * @param {?} message message to be altered
     * @return {?} true, if children should be processed too, false otherwise (children ignored then)
     */
    processStartElement(elementNode, message) {
        /** @type {?} */
        const tagName = elementNode.tagName;
        if (tagName === 'ph') {
            /** @type {?} */
            let isInterpolation = false;
            /** @type {?} */
            let isICU = false;
            /** @type {?} */
            let isEmptyTag = false;
            /** @type {?} */
            const equiv = elementNode.getAttribute('equiv');
            /** @type {?} */
            const disp = elementNode.getAttribute('disp');
            /** @type {?} */
            let indexString = null;
            /** @type {?} */
            let index = 0;
            /** @type {?} */
            let emptyTagName = null;
            if (!equiv) {
                // old ICU syntax, fixed with #17344
                isICU = true;
                indexString = elementNode.getAttribute('id');
                index = Number.parseInt(indexString, 10);
            }
            else if (equiv.startsWith('ICU')) {
                // new ICU syntax, fixed with #17344
                isICU = true;
                if (equiv === 'ICU') {
                    indexString = '0';
                }
                else {
                    indexString = equiv.substring('ICU_'.length);
                }
                index = Number.parseInt(indexString, 10);
            }
            else if (equiv.startsWith('INTERPOLATION')) {
                isInterpolation = true;
                if (equiv === 'INTERPOLATION') {
                    indexString = '0';
                }
                else {
                    indexString = equiv.substring('INTERPOLATION_'.length);
                }
                index = Number.parseInt(indexString, 10);
            }
            else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {
                isEmptyTag = true;
                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);
            }
            else {
                return true;
            }
            if (isInterpolation) {
                message.addPlaceholder(index, disp);
            }
            else if (isICU) {
                message.addICUMessageRef(index, disp);
            }
            else if (isEmptyTag) {
                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));
            }
        }
        else if (tagName === 'pc') {
            /** @type {?} */
            const embeddedTagName = this.tagNameFromPCElement(elementNode);
            if (embeddedTagName) {
                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));
            }
        }
        return true;
    }
    /**
     * Handle end of this element node.
     * This is called after all children are processed.
     * @param {?} elementNode elementNode
     * @param {?} message message to be altered
     * @return {?}
     */
    processEndElement(elementNode, message) {
        /** @type {?} */
        const tagName = elementNode.tagName;
        if (tagName === 'pc') {
            /** @type {?} */
            const embeddedTagName = this.tagNameFromPCElement(elementNode);
            if (embeddedTagName) {
                message.addEndTag(embeddedTagName);
            }
            return;
        }
    }
    /**
     * @param {?} pcNode
     * @return {?}
     */
    tagNameFromPCElement(pcNode) {
        /** @type {?} */
        let dispStart = pcNode.getAttribute('dispStart');
        if (dispStart.startsWith('<')) {
            dispStart = dispStart.substring(1);
        }
        if (dispStart.endsWith('>')) {
            dispStart = dispStart.substring(0, dispStart.length - 1);
        }
        return dispStart;
    }
    /**
     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.
     * So we cannot simply replace the message parts by xml parts.
     * @param {?} message message
     * @param {?} rootElem rootElem
     * @return {?}
     */
    addXmlRepresentationToRoot(message, rootElem) {
        /** @type {?} */
        const stack = [{ element: rootElem, tagName: 'root' }];
        /** @type {?} */
        let id = 0;
        message.parts().forEach((part) => {
            switch (part.type) {
                case ParsedMessagePartType.TEXT:
                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfTextPart(/** @type {?} */ (part), rootElem));
                    break;
                case ParsedMessagePartType.PLACEHOLDER:
                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfPlaceholderPart(/** @type {?} */ (part), rootElem, id++));
                    break;
                case ParsedMessagePartType.ICU_MESSAGE_REF:
                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfICUMessageRefPart(/** @type {?} */ (part), rootElem));
                    break;
                case ParsedMessagePartType.START_TAG:
                    /** @type {?} */
                    const newTagElem = this.createXmlRepresentationOfStartTagPart(/** @type {?} */ (part), rootElem, id++);
                    stack[stack.length - 1].element.appendChild(newTagElem);
                    stack.push({ element: /** @type {?} */ (newTagElem), tagName: (/** @type {?} */ (part)).tagName() });
                    break;
                case ParsedMessagePartType.END_TAG:
                    /** @type {?} */
                    const closeTagName = (/** @type {?} */ (part)).tagName();
                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {
                        // oops, not well formed
                        throw new Error('unexpected close tag ' + closeTagName);
                    }
                    stack.pop();
                    break;
                case ParsedMessagePartType.EMPTY_TAG:
                    /** @type {?} */
                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(/** @type {?} */ (part), rootElem, id++);
                    stack[stack.length - 1].element.appendChild(emptyTagElem);
                    break;
            }
        });
        if (stack.length !== 1) {
            // oops, not well closed tags
            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);
        }
    }
    /**
     * the xml used for start tag in the message.
     * Returns an empty pc-Element.
     * e.g. <pc id="0" equivStart="START_BOLD_TEXT" equivEnd="CLOSE_BOLD_TEXT" type="fmt" dispStart="&lt;b&gt;" dispEnd="&lt;/b&gt;">
     * Text content will be added later.
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @param {?} id id number in xliff2
     * @return {?}
     */
    createXmlRepresentationOfStartTagPart(part, rootElem, id) {
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const pcElem = rootElem.ownerDocument.createElement('pc');
        /** @type {?} */
        const tagName = part.tagName();
        /** @type {?} */
        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());
        /** @type {?} */
        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);
        /** @type {?} */
        const dispStart = '<' + tagName + '>';
        /** @type {?} */
        const dispEnd = '</' + tagName + '>';
        pcElem.setAttribute('id', id.toString(10));
        pcElem.setAttribute('equivStart', equivStart);
        pcElem.setAttribute('equivEnd', equivEnd);
        pcElem.setAttribute('type', this.getTypeForTag(tagName));
        pcElem.setAttribute('dispStart', dispStart);
        pcElem.setAttribute('dispEnd', dispEnd);
        return pcElem;
    }
    /**
     * the xml used for end tag in the message.
     * Not used here, because content is child of start tag.
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfEndTagPart(part, rootElem) {
        // not used
        return null;
    }
    /**
     * the xml used for empty tag in the message.
     * Returns an empty ph-Element.
     * e.g. <ph id="3" equiv="TAG_IMG" type="image" disp="&lt;img/>"/>
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @param {?} id id number in xliff2
     * @return {?}
     */
    createXmlRepresentationOfEmptyTagPart(part, rootElem, id) {
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        const tagName = part.tagName();
        /** @type {?} */
        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());
        /** @type {?} */
        const disp = '<' + tagName + '/>';
        phElem.setAttribute('id', id.toString(10));
        phElem.setAttribute('equiv', equiv);
        phElem.setAttribute('type', this.getTypeForTag(tagName));
        phElem.setAttribute('disp', disp);
        return phElem;
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    getTypeForTag(tag) {
        switch (tag.toLowerCase()) {
            case 'br':
            case 'b':
            case 'i':
            case 'u':
                return 'fmt';
            case 'img':
                return 'image';
            case 'a':
                return 'link';
            default:
                return 'other';
        }
    }
    /**
     * the xml used for placeholder in the message.
     * Returns e.g. <ph id="1" equiv="INTERPOLATION_1" disp="{{total()}}"/>
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @param {?} id id number in xliff2
     * @return {?}
     */
    createXmlRepresentationOfPlaceholderPart(part, rootElem, id) {
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        let equivAttrib = 'INTERPOLATION';
        if (part.index() > 0) {
            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);
        }
        phElem.setAttribute('id', id.toString(10));
        phElem.setAttribute('equiv', equivAttrib);
        /** @type {?} */
        const disp = part.disp();
        if (disp) {
            phElem.setAttribute('disp', disp);
        }
        return phElem;
    }
    /**
     * the xml used for icu message refs in the message.
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        let equivAttrib = 'ICU';
        if (part.index() > 0) {
            equivAttrib = 'ICU_' + part.index().toString(10);
        }
        phElem.setAttribute('id', part.index().toString(10));
        phElem.setAttribute('equiv', equivAttrib);
        /** @type {?} */
        const disp = part.disp();
        if (disp) {
            phElem.setAttribute('disp', disp);
        }
        return phElem;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 04.05.2017.
 * A Translation Unit in an XLIFF 2.0 file.
 */
class Xliff2TransUnit extends AbstractTransUnit {
    /**
     * @param {?} _element
     * @param {?} _id
     * @param {?} _translationMessagesFile
     */
    constructor(_element, _id, _translationMessagesFile) {
        super(_element, _id, _translationMessagesFile);
    }
    /**
     * @return {?}
     */
    sourceContent() {
        /** @type {?} */
        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        return DOMUtilities.getXMLContent(sourceElement);
    }
    /**
     * Set new source content in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing changed source content.
     * @param {?} newContent the new content.
     * @return {?}
     */
    setSourceContent(newContent) {
        /** @type {?} */
        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        if (!source) {
            /** @type {?} */
            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');
            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));
        }
        DOMUtilities.replaceContentWithXMLContent(source, newContent);
    }
    /**
     * Return a parser used for normalized messages.
     * @return {?}
     */
    messageParser() {
        return new Xliff2MessageParser();
    }
    /**
     * The original text value, that is to be translated, as normalized message.
     * @return {?}
     */
    createSourceContentNormalized() {
        /** @type {?} */
        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        if (sourceElement) {
            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);
        }
        else {
            return null;
        }
    }
    /**
     * the translated value (containing all markup, depends on the concrete format used).
     * @return {?}
     */
    targetContent() {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        return DOMUtilities.getXMLContent(targetElement);
    }
    /**
     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
     * and all embedded html is replaced by direct html markup.
     * @return {?}
     */
    targetContentNormalized() {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());
    }
    /**
     * State of the translation as stored in the xml.
     * @return {?}
     */
    nativeTargetState() {
        /** @type {?} */
        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');
        if (segmentElement) {
            return segmentElement.getAttribute('state');
        }
        else {
            return null;
        }
    }
    /**
     * set state in xml.
     * @param {?} nativeState nativeState
     * @return {?}
     */
    setNativeTargetState(nativeState) {
        /** @type {?} */
        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');
        if (segmentElement) {
            segmentElement.setAttribute('state', nativeState);
        }
    }
    /**
     * Map an abstract state (new, translated, final) to a concrete state used in the xml.
     * Returns the state to be used in the xml.
     * @throws error, if state is invalid.
     * @param {?} state one of Constants.STATE...
     * @return {?} a native state (depends on concrete format)
     */
    mapStateToNativeState(state) {
        switch (state) {
            case STATE_NEW:
                return 'initial';
            case STATE_TRANSLATED:
                return 'translated';
            case STATE_FINAL:
                return 'final';
            default:
                throw new Error('unknown state ' + state);
        }
    }
    /**
     * Map a native state (found in the document) to an abstract state (new, translated, final).
     * Returns the abstract state.
     * @param {?} nativeState nativeState
     * @return {?}
     */
    mapNativeStateToState(nativeState) {
        switch (nativeState) {
            case 'initial':
                return STATE_NEW;
            case 'translated':
                return STATE_TRANSLATED;
            case 'reviewed': // same as translated
                // same as translated
                return STATE_TRANSLATED;
            case 'final':
                return STATE_FINAL;
            default:
                return STATE_NEW;
        }
    }
    /**
     * All the source elements in the trans unit.
     * The source element is a reference to the original template.
     * It contains the name of the template file and a line number with the position inside the template.
     * It is just a help for translators to find the context for the translation.
     * This is set when using Angular 4.0 or greater.
     * Otherwise it just returns an empty array.
     * @return {?}
     */
    sourceReferences() {
        /** @type {?} */
        const noteElements = this._element.getElementsByTagName('note');
        /** @type {?} */
        const sourceRefs = [];
        for (let i = 0; i < noteElements.length; i++) {
            /** @type {?} */
            const noteElem = noteElements.item(i);
            if (noteElem.getAttribute('category') === 'location') {
                /** @type {?} */
                const sourceAndPos = DOMUtilities.getPCDATA(noteElem);
                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));
            }
        }
        return sourceRefs;
    }
    /**
     * Parses something like 'c:\xxx:7' and returns source and linenumber.
     * @param {?} sourceAndPos something like 'c:\xxx:7', last colon is the separator
     * @return {?} source and line number
     */
    parseSourceAndPos(sourceAndPos) {
        /** @type {?} */
        const index = sourceAndPos.lastIndexOf(':');
        if (index < 0) {
            return {
                sourcefile: sourceAndPos,
                linenumber: 0
            };
        }
        else {
            return {
                sourcefile: sourceAndPos.substring(0, index),
                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))
            };
        }
    }
    /**
     * @param {?} lineNumberString
     * @return {?}
     */
    parseLineNumber(lineNumberString) {
        return Number.parseInt(lineNumberString, 10);
    }
    /**
     * Set source ref elements in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing source refs.
     * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
     * @return {?}
     */
    setSourceReferences(sourceRefs) {
        this.removeAllSourceReferences();
        /** @type {?} */
        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');
        if (sourceRefs.length === 0 && !isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {
            // remove empty notes element
            notesElement.parentNode.removeChild(notesElement);
            return;
        }
        if (isNullOrUndefined(notesElement)) {
            notesElement = this._element.ownerDocument.createElement('notes');
            this._element.insertBefore(notesElement, this._element.childNodes.item(0));
        }
        sourceRefs.forEach((ref) => {
            /** @type {?} */
            const note = this._element.ownerDocument.createElement('note');
            note.setAttribute('category', 'location');
            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));
            notesElement.appendChild(note);
        });
    }
    /**
     * @return {?}
     */
    removeAllSourceReferences() {
        /** @type {?} */
        const noteElements = this._element.getElementsByTagName('note');
        /** @type {?} */
        const toBeRemoved = [];
        for (let i = 0; i < noteElements.length; i++) {
            /** @type {?} */
            const elem = noteElements.item(i);
            if (elem.getAttribute('category') === 'location') {
                toBeRemoved.push(elem);
            }
        }
        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });
    }
    /**
     * The description set in the template as value of the i18n-attribute.
     * e.g. i18n="mydescription".
     * In xliff 2.0 this is stored as a note element with attribute category="description".
     * @return {?}
     */
    description() {
        /** @type {?} */
        const noteElem = this.findNoteElementWithCategoryAttribute('description');
        if (noteElem) {
            return DOMUtilities.getPCDATA(noteElem);
        }
        else {
            return null;
        }
    }
    /**
     * Change description property of trans-unit.
     * @param {?} description description
     * @return {?}
     */
    setDescription(description) {
        /** @type {?} */
        const noteElem = this.findNoteElementWithCategoryAttribute('description');
        if (description) {
            if (isNullOrUndefined(noteElem)) {
                // create it
                this.createNoteElementWithCategoryAttribute('description', description);
            }
            else {
                DOMUtilities.replaceContentWithXMLContent(noteElem, description);
            }
        }
        else {
            if (!isNullOrUndefined(noteElem)) {
                // remove node
                this.removeNoteElementWithCategoryAttribute('description');
            }
        }
    }
    /**
     * Find a note element with attribute category='<attrValue>'
     * @param {?} attrValue value of category attribute
     * @return {?} element or null is absent
     */
    findNoteElementWithCategoryAttribute(attrValue) {
        /** @type {?} */
        const noteElements = this._element.getElementsByTagName('note');
        for (let i = 0; i < noteElements.length; i++) {
            /** @type {?} */
            const noteElem = noteElements.item(i);
            if (noteElem.getAttribute('category') === attrValue) {
                return noteElem;
            }
        }
        return null;
    }
    /**
     * Get all note elements where from attribute is not description or meaning
     * @return {?} elements
     */
    findAllAdditionalNoteElements() {
        /** @type {?} */
        const noteElements = this._element.getElementsByTagName('note');
        /** @type {?} */
        const result = [];
        for (let i = 0; i < noteElements.length; i++) {
            /** @type {?} */
            const noteElem = noteElements.item(i);
            /** @type {?} */
            const fromAttribute = noteElem.getAttribute('category');
            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {
                result.push(noteElem);
            }
        }
        return result;
    }
    /**
     * Create a new note element with attribute from='<attrValue>'
     * @param {?} attrValue category attribute value
     * @param {?} content content of note element
     * @return {?} the new created element
     */
    createNoteElementWithCategoryAttribute(attrValue, content) {
        /** @type {?} */
        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');
        if (isNullOrUndefined(notesElement)) {
            // create it
            notesElement = this._element.ownerDocument.createElement('notes');
            this._element.appendChild(notesElement);
        }
        /** @type {?} */
        const noteElement = this._element.ownerDocument.createElement('note');
        if (attrValue) {
            noteElement.setAttribute('category', attrValue);
        }
        if (content) {
            DOMUtilities.replaceContentWithXMLContent(noteElement, content);
        }
        notesElement.appendChild(noteElement);
        return noteElement;
    }
    /**
     * @return {?}
     */
    removeNotesElementIfEmpty() {
        /** @type {?} */
        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');
        if (notesElement) {
            /** @type {?} */
            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');
            if (!childNote) {
                // remove notes element
                notesElement.parentNode.removeChild(notesElement);
            }
        }
    }
    /**
     * Remove note element with attribute from='<attrValue>'
     * @param {?} attrValue attrValue
     * @return {?}
     */
    removeNoteElementWithCategoryAttribute(attrValue) {
        /** @type {?} */
        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);
        if (noteElement) {
            noteElement.parentNode.removeChild(noteElement);
        }
        this.removeNotesElementIfEmpty();
    }
    /**
     * Remove all note elements where attribute "from" is not description or meaning.
     * @return {?}
     */
    removeAllAdditionalNoteElements() {
        /** @type {?} */
        const noteElements = this.findAllAdditionalNoteElements();
        noteElements.forEach((noteElement) => {
            noteElement.parentNode.removeChild(noteElement);
        });
        this.removeNotesElementIfEmpty();
    }
    /**
     * The meaning (intent) set in the template as value of the i18n-attribute.
     * This is the part in front of the | symbol.
     * e.g. i18n="meaning|mydescription".
     * In xliff 2.0 this is stored as a note element with attribute category="meaning".
     * @return {?}
     */
    meaning() {
        /** @type {?} */
        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');
        if (noteElem) {
            return DOMUtilities.getPCDATA(noteElem);
        }
        else {
            return null;
        }
    }
    /**
     * Change meaning property of trans-unit.
     * @param {?} meaning meaning
     * @return {?}
     */
    setMeaning(meaning) {
        /** @type {?} */
        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');
        if (meaning) {
            if (isNullOrUndefined(noteElem)) {
                // create it
                this.createNoteElementWithCategoryAttribute('meaning', meaning);
            }
            else {
                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);
            }
        }
        else {
            if (!isNullOrUndefined(noteElem)) {
                // remove node
                this.removeNoteElementWithCategoryAttribute('meaning');
            }
        }
    }
    /**
     * Get all notes of the trans-unit.
     * Notes are remarks made by a translator.
     * (description and meaning are not included here!)
     * @return {?}
     */
    notes() {
        /** @type {?} */
        const noteElememts = this.findAllAdditionalNoteElements();
        return noteElememts.map(elem => {
            return {
                from: elem.getAttribute('category'),
                text: DOMUtilities.getPCDATA(elem)
            };
        });
    }
    /**
     * Test, wether setting of notes is supported.
     * If not, setNotes will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetNotes() {
        return true;
    }
    /**
     * Add notes to trans unit.
     * @param {?} newNotes the notes to add.
     * @return {?}
     */
    setNotes(newNotes) {
        if (!isNullOrUndefined(newNotes)) {
            this.checkNotes(newNotes);
        }
        this.removeAllAdditionalNoteElements();
        if (!isNullOrUndefined(newNotes)) {
            newNotes.forEach((note) => {
                this.createNoteElementWithCategoryAttribute(note.from, note.text);
            });
        }
    }
    /**
     * Set the translation to a given string (including markup).
     * @param {?} translation translation
     * @return {?}
     */
    translateNative(translation) {
        /** @type {?} */
        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (!target) {
            /** @type {?} */
            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));
        }
        DOMUtilities.replaceContentWithXMLContent(target, /** @type {?} */ (translation));
        this.setTargetState(STATE_TRANSLATED);
    }
    /**
     * Copy source to target to use it as dummy translation.
     * Returns a changed copy of this trans unit.
     * receiver is not changed.
     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @param {?} targetFile
     * @return {?}
     */
    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {
        /** @type {?} */
        const element = /** @type {?} */ (this._element.cloneNode(true));
        /** @type {?} */
        const clone = new Xliff2TransUnit(element, this._id, targetFile);
        clone.useSourceAsTarget(isDefaultLang, copyContent);
        return clone;
    }
    /**
     * Copy source to target to use it as dummy translation.
     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @return {?}
     */
    useSourceAsTarget(isDefaultLang, copyContent) {
        /** @type {?} */
        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        /** @type {?} */
        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (!target) {
            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));
        }
        if (isDefaultLang || copyContent) {
            /** @type {?} */
            const sourceString = DOMUtilities.getXMLContent(source);
            /** @type {?} */
            let newTargetString = sourceString;
            if (!this.isICUMessage(sourceString)) {
                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()
                    + sourceString
                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();
            }
            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);
        }
        else {
            DOMUtilities.replaceContentWithXMLContent(target, '');
        }
        /** @type {?} */
        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');
        if (segment) {
            if (isDefaultLang) {
                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));
            }
            else {
                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 04.05.2017.
 * An XLIFF 2.0 file read from a source file.
 * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html
 *
 * Defines some relevant get and set method for reading and modifying such a file.
 */
class Xliff2File extends AbstractTranslationMessagesFile {
    /**
     * Create an XLIFF 2.0-File from source.
     * @param {?} xmlString source read from file.
     * @param {?} path Path to file
     * @param {?} encoding optional encoding of the xml.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     */
    constructor(xmlString, path, encoding) {
        super();
        this._warnings = [];
        this._numberOfTransUnitsWithMissingId = 0;
        this.initializeFromContent(xmlString, path, encoding);
    }
    /**
     * @param {?} xmlString
     * @param {?} path
     * @param {?} encoding
     * @return {?}
     */
    initializeFromContent(xmlString, path, encoding) {
        this.parseContent(xmlString, path, encoding);
        /** @type {?} */
        const xliffList = this._parsedDocument.getElementsByTagName('xliff');
        if (xliffList.length !== 1) {
            throw new Error(format('File "%s" seems to be no xliff file (should contain an xliff element)', path));
        }
        else {
            /** @type {?} */
            const version = xliffList.item(0).getAttribute('version');
            /** @type {?} */
            const expectedVersion = '2.0';
            if (version !== expectedVersion) {
                throw new Error(format('File "%s" seems to be no xliff 2 file, version should be %s, found %s', path, expectedVersion, version));
            }
        }
        return this;
    }
    /**
     * File format as it is used in config files.
     * Currently 'xlf', 'xmb', 'xmb2'
     * Returns one of the constants FORMAT_..
     * @return {?}
     */
    i18nFormat() {
        return FORMAT_XLIFF20;
    }
    /**
     * File type.
     * Here 'XLIFF 2.0'
     * @return {?}
     */
    fileType() {
        return FILETYPE_XLIFF20;
    }
    /**
     * return tag names of all elements that have mixed content.
     * These elements will not be beautified.
     * Typical candidates are source and target.
     * @return {?}
     */
    elementsWithMixedContent() {
        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];
    }
    /**
     * @return {?}
     */
    initializeTransUnits() {
        this.transUnits = [];
        /** @type {?} */
        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');
        for (let i = 0; i < transUnitsInFile.length; i++) {
            /** @type {?} */
            const transunit = transUnitsInFile.item(i);
            /** @type {?} */
            const id = transunit.getAttribute('id');
            if (!id) {
                this._warnings.push(format('oops, trans-unit without "id" found in master, please check file %s', this._filename));
            }
            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));
        }
    }
    /**
     * Get source language.
     * @return {?} source language.
     */
    sourceLanguage() {
        /** @type {?} */
        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');
        if (xliffElem) {
            return xliffElem.getAttribute('srcLang');
        }
        else {
            return null;
        }
    }
    /**
     * Edit the source language.
     * @param {?} language language
     * @return {?}
     */
    setSourceLanguage(language) {
        /** @type {?} */
        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');
        if (xliffElem) {
            xliffElem.setAttribute('srcLang', language);
        }
    }
    /**
     * Get target language.
     * @return {?} target language.
     */
    targetLanguage() {
        /** @type {?} */
        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');
        if (xliffElem) {
            return xliffElem.getAttribute('trgLang');
        }
        else {
            return null;
        }
    }
    /**
     * Edit the target language.
     * @param {?} language language
     * @return {?}
     */
    setTargetLanguage(language) {
        /** @type {?} */
        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');
        if (xliffElem) {
            xliffElem.setAttribute('trgLang', language);
        }
    }
    /**
     * Add a new trans-unit to this file.
     * The trans unit stems from another file.
     * It copies the source content of the tu to the target content too,
     * depending on the values of isDefaultLang and copyContent.
     * So the source can be used as a dummy translation.
     * (used by xliffmerge)
     * @throws an error if trans-unit with same id already is in the file.
     * @param {?} foreignTransUnit the trans unit to be imported.
     * @param {?} isDefaultLang Flag, wether file contains the default language.
     * Then source and target are just equal.
     * The content will be copied.
     * State will be final.
     * @param {?} copyContent Flag, wether to copy content or leave it empty.
     * Wben true, content will be copied from source.
     * When false, content will be left empty (if it is not the default language).
     * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
     * Newly imported trans unit is then inserted directly after this element.
     * If not set or not part of this file, new unit will be imported at the end.
     * If explicity set to null, new unit will be imported at the start.
     * @return {?} the newly imported trans unit (since version 1.7.0)
     */
    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {
        if (this.transUnitWithId(foreignTransUnit.id)) {
            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));
        }
        /** @type {?} */
        const newTu = (/** @type {?} */ (foreignTransUnit)).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);
        /** @type {?} */
        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
        if (!fileElement) {
            throw new Error(format('File "%s" seems to be no xliff 2.0 file (should contain a file element)', this._filename));
        }
        /** @type {?} */
        let inserted = false;
        /** @type {?} */
        let isAfterElementPartOfFile = false;
        if (!!importAfterElement) {
            /** @type {?} */
            const insertionPoint = this.transUnitWithId(importAfterElement.id);
            if (!!insertionPoint) {
                isAfterElementPartOfFile = true;
            }
        }
        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {
            fileElement.appendChild(newTu.asXmlElement());
            inserted = true;
        }
        else if (importAfterElement === null) {
            /** @type {?} */
            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');
            if (firstUnitElement) {
                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);
                inserted = true;
            }
            else {
                // no trans-unit, empty file, so add to first file element
                fileElement.appendChild(newTu.asXmlElement());
                inserted = true;
            }
        }
        else {
            /** @type {?} */
            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);
            if (refUnitElement) {
                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);
                inserted = true;
            }
        }
        if (inserted) {
            this.lazyInitializeTransUnits();
            this.transUnits.push(newTu);
            this.countNumbers();
            return newTu;
        }
        else {
            return null;
        }
    }
    /**
     * Create a new translation file for this file for a given language.
     * Normally, this is just a copy of the original one.
     * But for XMB the translation file has format 'XTB'.
     * @param {?} lang Language code
     * @param {?} filename expected filename to store file
     * @param {?} isDefaultLang Flag, wether file contains the default language.
     * Then source and target are just equal.
     * The content will be copied.
     * State will be final.
     * @param {?} copyContent Flag, wether to copy content or leave it empty.
     * Wben true, content will be copied from source.
     * When false, content will be left empty (if it is not the default language).
     * @return {?}
     */
    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {
        /** @type {?} */
        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());
        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);
        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);
        translationFile.setTargetLanguage(lang);
        translationFile.forEachTransUnit((transUnit) => {
            (/** @type {?} */ (transUnit)).useSourceAsTarget(isDefaultLang, copyContent);
        });
        return translationFile;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 23.05.2017.
 * A Translation Unit in an XTB file.
 */
class XtbTransUnit extends AbstractTransUnit {
    /**
     * @param {?} _element
     * @param {?} _id
     * @param {?} _translationMessagesFile
     * @param {?} _sourceTransUnitFromMaster
     */
    constructor(_element, _id, _translationMessagesFile, _sourceTransUnitFromMaster) {
        super(_element, _id, _translationMessagesFile);
        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;
    }
    /**
     * Get content to translate.
     * Source parts are excluded here.
     * @return {?} content to translate.
     */
    sourceContent() {
        if (this._sourceTransUnitFromMaster) {
            return this._sourceTransUnitFromMaster.sourceContent();
        }
        else {
            return null;
        }
    }
    /**
     * Test, wether setting of source content is supported.
     * If not, setSourceContent in trans-unit will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetSourceContent() {
        return false;
    }
    /**
     * Set new source content in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing changed source content.
     * @param {?} newContent the new content.
     * @return {?}
     */
    setSourceContent(newContent) {
        // xtb has no source content, they are part of the master
    }
    /**
     * Return a parser used for normalized messages.
     * @return {?}
     */
    messageParser() {
        return new XmbMessageParser(); // no typo!, Same as for Xmb
    }
    /**
     * The original text value, that is to be translated, as normalized message.
     * @return {?}
     */
    createSourceContentNormalized() {
        if (this._sourceTransUnitFromMaster) {
            return this._sourceTransUnitFromMaster.createSourceContentNormalized();
        }
        else {
            return null;
        }
    }
    /**
     * the translated value (containing all markup, depends on the concrete format used).
     * @return {?}
     */
    targetContent() {
        return DOMUtilities.getXMLContent(this._element);
    }
    /**
     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
     * and all embedded html is replaced by direct html markup.
     * @return {?}
     */
    targetContentNormalized() {
        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());
    }
    /**
     * State of the translation.
     * (not supported in xmb)
     * If we have a master, we assumed it is translated if the content is not the same as the masters one.
     * @return {?}
     */
    nativeTargetState() {
        if (this._sourceTransUnitFromMaster) {
            /** @type {?} */
            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();
            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {
                return 'new';
            }
            else {
                return 'final';
            }
        }
        return null; // not supported in xmb
    }
    /**
     * Map an abstract state (new, translated, final) to a concrete state used in the xml.
     * Returns the state to be used in the xml.
     * @throws error, if state is invalid.
     * @param {?} state one of Constants.STATE...
     * @return {?} a native state (depends on concrete format)
     */
    mapStateToNativeState(state) {
        return state;
    }
    /**
     * Map a native state (found in the document) to an abstract state (new, translated, final).
     * Returns the abstract state.
     * @param {?} nativeState nativeState
     * @return {?}
     */
    mapNativeStateToState(nativeState) {
        return nativeState;
    }
    /**
     * set state in xml.
     * (not supported in xmb)
     * @param {?} nativeState nativeState
     * @return {?}
     */
    setNativeTargetState(nativeState) {
        // TODO some logic to store it anywhere
    }
    /**
     * All the source elements in the trans unit.
     * The source element is a reference to the original template.
     * It contains the name of the template file and a line number with the position inside the template.
     * It is just a help for translators to find the context for the translation.
     * This is set when using Angular 4.0 or greater.
     * Otherwise it just returns an empty array.
     * @return {?}
     */
    sourceReferences() {
        if (this._sourceTransUnitFromMaster) {
            return this._sourceTransUnitFromMaster.sourceReferences();
        }
        else {
            return [];
        }
    }
    /**
     * Test, wether setting of source refs is supported.
     * If not, setSourceReferences will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetSourceReferences() {
        return false;
    }
    /**
     * Set source ref elements in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing source refs.
     * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
     * @return {?}
     */
    setSourceReferences(sourceRefs) {
        // xtb has no source refs, they are part of the master
    }
    /**
     * The description set in the template as value of the i18n-attribute.
     * e.g. i18n="mydescription".
     * In xtb only the master stores it.
     * @return {?}
     */
    description() {
        if (this._sourceTransUnitFromMaster) {
            return this._sourceTransUnitFromMaster.description();
        }
        else {
            return null;
        }
    }
    /**
     * The meaning (intent) set in the template as value of the i18n-attribute.
     * This is the part in front of the | symbol.
     * e.g. i18n="meaning|mydescription".
     * In xtb only the master stores it.
     * @return {?}
     */
    meaning() {
        if (this._sourceTransUnitFromMaster) {
            return this._sourceTransUnitFromMaster.meaning();
        }
        else {
            return null;
        }
    }
    /**
     * Test, wether setting of description and meaning is supported.
     * If not, setDescription and setMeaning will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetDescriptionAndMeaning() {
        return false;
    }
    /**
     * Change description property of trans-unit.
     * @param {?} description description
     * @return {?}
     */
    setDescription(description) {
        // not supported, do nothing
    }
    /**
     * Change meaning property of trans-unit.
     * @param {?} meaning meaning
     * @return {?}
     */
    setMeaning(meaning) {
        // not supported, do nothing
    }
    /**
     * Get all notes of the trans-unit.
     * There are NO notes in xmb/xtb
     * @return {?}
     */
    notes() {
        return [];
    }
    /**
     * Test, wether setting of notes is supported.
     * If not, setNotes will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetNotes() {
        return false;
    }
    /**
     * Add notes to trans unit.
     * @param {?} newNotes the notes to add.
     * NOT Supported in xmb/xtb
     * @return {?}
     */
    setNotes(newNotes) {
        // not supported, do nothing
    }
    /**
     * Copy source to target to use it as dummy translation.
     * Returns a changed copy of this trans unit.
     * receiver is not changed.
     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
     * In xtb there is nothing to do, because there is only a target, no source.
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @param {?} targetFile
     * @return {?}
     */
    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {
        return this;
    }
    /**
     * Copy source to target to use it as dummy translation.
     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @return {?}
     */
    useSourceAsTarget(isDefaultLang, copyContent) {
        // do nothing
    }
    /**
     * Set the translation to a given string (including markup).
     * @param {?} translation translation
     * @return {?}
     */
    translateNative(translation) {
        /** @type {?} */
        const target = this._element;
        if (isNullOrUndefined(translation)) {
            translation = '';
        }
        DOMUtilities.replaceContentWithXMLContent(target, translation);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Created by martin on 23.05.2017.
 * xtb-File access.
 * xtb is the translated counterpart to xmb.
 */
class XtbFile extends AbstractTranslationMessagesFile {
    /**
     * Create an xmb-File from source.
     * @param {?} _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file
     * @param {?} xmlString file content
     * @param {?} path Path to file
     * @param {?} encoding optional encoding of the xml.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     */
    constructor(_translationMessageFileFactory, xmlString, path, encoding, optionalMaster) {
        super();
        this._translationMessageFileFactory = _translationMessageFileFactory;
        this._warnings = [];
        this._numberOfTransUnitsWithMissingId = 0;
        this.initializeFromContent(xmlString, path, encoding, optionalMaster);
    }
    /**
     * @param {?} xmlString
     * @param {?} path
     * @param {?} encoding
     * @param {?=} optionalMaster
     * @return {?}
     */
    initializeFromContent(xmlString, path, encoding, optionalMaster) {
        this.parseContent(xmlString, path, encoding);
        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {
            throw new Error(format('File "%s" seems to be no xtb file (should contain a translationbundle element)', path));
        }
        if (optionalMaster) {
            try {
                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(FORMAT_XMB, optionalMaster.xmlContent, optionalMaster.path, optionalMaster.encoding);
                /** @type {?} */
                const numberInMaster = this._masterFile.numberOfTransUnits();
                /** @type {?} */
                const myNumber = this.numberOfTransUnits();
                if (numberInMaster !== myNumber) {
                    this._warnings.push(format('%s trans units found in master, but this file has %s. Check if it is the correct master', numberInMaster, myNumber));
                }
            }
            catch (error) {
                throw new Error(format('File "%s" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));
            }
        }
        return this;
    }
    /**
     * @return {?}
     */
    initializeTransUnits() {
        this.transUnits = [];
        /** @type {?} */
        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');
        for (let i = 0; i < transUnitsInFile.length; i++) {
            /** @type {?} */
            const msg = transUnitsInFile.item(i);
            /** @type {?} */
            const id = msg.getAttribute('id');
            if (!id) {
                this._warnings.push(format('oops, msg without "id" found in master, please check file %s', this._filename));
            }
            /** @type {?} */
            let masterUnit = null;
            if (this._masterFile) {
                masterUnit = this._masterFile.transUnitWithId(id);
            }
            this.transUnits.push(new XtbTransUnit(msg, id, this, /** @type {?} */ (masterUnit)));
        }
    }
    /**
     * File format as it is used in config files.
     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'
     * Returns one of the constants FORMAT_..
     * @return {?}
     */
    i18nFormat() {
        return FORMAT_XTB;
    }
    /**
     * File type.
     * Here 'XTB'
     * @return {?}
     */
    fileType() {
        return FILETYPE_XTB;
    }
    /**
     * return tag names of all elements that have mixed content.
     * These elements will not be beautified.
     * Typical candidates are source and target.
     * @return {?}
     */
    elementsWithMixedContent() {
        return ['translation'];
    }
    /**
     * Get source language.
     * Unsupported in xmb/xtb.
     * Try to guess it from master filename if any..
     * @return {?} source language.
     */
    sourceLanguage() {
        if (this._masterFile) {
            return this._masterFile.sourceLanguage();
        }
        else {
            return null;
        }
    }
    /**
     * Edit the source language.
     * Unsupported in xmb/xtb.
     * @param {?} language language
     * @return {?}
     */
    setSourceLanguage(language) {
        // do nothing, xtb has no notation for this.
    }
    /**
     * Get target language.
     * @return {?} target language.
     */
    targetLanguage() {
        /** @type {?} */
        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');
        if (translationbundleElem) {
            return translationbundleElem.getAttribute('lang');
        }
        else {
            return null;
        }
    }
    /**
     * Edit the target language.
     * @param {?} language language
     * @return {?}
     */
    setTargetLanguage(language) {
        /** @type {?} */
        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');
        if (translationbundleElem) {
            translationbundleElem.setAttribute('lang', language);
        }
    }
    /**
     * Add a new trans-unit to this file.
     * The trans unit stems from another file.
     * It copies the source content of the tu to the target content too,
     * depending on the values of isDefaultLang and copyContent.
     * So the source can be used as a dummy translation.
     * (used by xliffmerge)
     * @throws an error if trans-unit with same id already is in the file.
     * @param {?} foreignTransUnit the trans unit to be imported.
     * @param {?} isDefaultLang Flag, wether file contains the default language.
     * Then source and target are just equal.
     * The content will be copied.
     * State will be final.
     * @param {?} copyContent Flag, wether to copy content or leave it empty.
     * Wben true, content will be copied from source.
     * When false, content will be left empty (if it is not the default language).
     * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
     * Newly imported trans unit is then inserted directly after this element.
     * If not set or not part of this file, new unit will be imported at the end.
     * If explicity set to null, new unit will be imported at the start.
     * @return {?} the newly imported trans unit (since version 1.7.0)
     */
    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {
        if (this.transUnitWithId(foreignTransUnit.id)) {
            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));
        }
        /** @type {?} */
        const newMasterTu = (/** @type {?} */ (foreignTransUnit)).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);
        /** @type {?} */
        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');
        if (!translationbundleElem) {
            throw new Error(format('File "%s" seems to be no xtb file (should contain a translationbundle element)', this._filename));
        }
        /** @type {?} */
        const translationElement = translationbundleElem.ownerDocument.createElement('translation');
        translationElement.setAttribute('id', foreignTransUnit.id);
        /** @type {?} */
        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';
        if (!(/** @type {?} */ (foreignTransUnit)).isICUMessage(newContent)) {
            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();
        }
        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);
        /** @type {?} */
        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);
        /** @type {?} */
        let inserted = false;
        /** @type {?} */
        let isAfterElementPartOfFile = false;
        if (!!importAfterElement) {
            /** @type {?} */
            const insertionPoint = this.transUnitWithId(importAfterElement.id);
            if (!!insertionPoint) {
                isAfterElementPartOfFile = true;
            }
        }
        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {
            translationbundleElem.appendChild(newTu.asXmlElement());
            inserted = true;
        }
        else if (importAfterElement === null) {
            /** @type {?} */
            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');
            if (firstTranslationElement) {
                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);
                inserted = true;
            }
            else {
                // no trans-unit, empty file, so add to bundle at end
                translationbundleElem.appendChild(newTu.asXmlElement());
                inserted = true;
            }
        }
        else {
            /** @type {?} */
            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);
            if (refUnitElement) {
                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);
                inserted = true;
            }
        }
        if (inserted) {
            this.lazyInitializeTransUnits();
            this.transUnits.push(newTu);
            this.countNumbers();
            return newTu;
        }
        else {
            return null;
        }
    }
    /**
     * Create a new translation file for this file for a given language.
     * Normally, this is just a copy of the original one.
     * But for XMB the translation file has format 'XTB'.
     * @param {?} lang Language code
     * @param {?} filename expected filename to store file
     * @param {?} isDefaultLang Flag, wether file contains the default language.
     * Then source and target are just equal.
     * The content will be copied.
     * State will be final.
     * @param {?} copyContent Flag, wether to copy content or leave it empty.
     * Wben true, content will be copied from source.
     * When false, content will be left empty (if it is not the default language).
     * @return {?}
     */
    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {
        throw new Error(format('File "%s", xtb files are not translatable, they are already translations', filename));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Helper class to read translation files depending on format.
 * This is part of the public api
 */
class TranslationMessagesFileFactory {
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    static fromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster) {
        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);
    }
    /**
     * Read file function for any file with unknown format.
     * This functions tries to guess the format based on the filename and the content of the file.
     * Result depends on detected format, either XliffFile or XmbFile.
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    static fromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster) {
        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);
    }
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster) {
        if (i18nFormat === FORMAT_XLIFF12) {
            return new XliffFile(xmlContent, path, encoding);
        }
        if (i18nFormat === FORMAT_XLIFF20) {
            return new Xliff2File(xmlContent, path, encoding);
        }
        if (i18nFormat === FORMAT_XMB) {
            return new XmbFile(this, xmlContent, path, encoding);
        }
        if (i18nFormat === FORMAT_XTB) {
            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);
        }
        throw new Error(format('oops, unsupported format "%s"', i18nFormat));
    }
    /**
     * Read file function for any file with unknown format.
     * This functions tries to guess the format based on the filename and the content of the file.
     * Result depends on detected format, either XliffFile or XmbFile.
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster) {
        /** @type {?} */
        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];
        if (path && path.endsWith('xmb')) {
            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];
        }
        if (path && path.endsWith('xtb')) {
            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];
        }
        // try all candidate formats to get the right one
        for (let i = 0; i < formatCandidates.length; i++) {
            /** @type {?} */
            const formatCandidate = formatCandidates[i];
            try {
                /** @type {?} */
                const translationFile = TranslationMessagesFileFactory.fromFileContent(formatCandidate, xmlContent, path, encoding, optionalMaster);
                if (translationFile) {
                    return translationFile;
                }
            }
            catch (e) {
                // seams to be the wrong format
            }
        }
        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgxI18nsupportLibModule, TranslationMessagesFileFactory, FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB, FILETYPE_XLIFF12, FILETYPE_XLIFF20, FILETYPE_XMB, FILETYPE_XTB, STATE_NEW, STATE_TRANSLATED, STATE_FINAL, NORMALIZATION_FORMAT_DEFAULT, NORMALIZATION_FORMAT_NGXTRANSLATE };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWkxOG5zdXBwb3J0LW5neC1pMThuc3VwcG9ydC1saWIuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9saWIvbmd4LWkxOG5zdXBwb3J0LWxpYi5tb2R1bGUudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9hcGkvY29uc3RhbnRzLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9kb20tdXRpbGl0aWVzLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC94bWwtc2VyaWFsaXplci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwvYWJzdHJhY3QtdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZS50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwvYWJzdHJhY3QtdHJhbnMtdW5pdC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwvcGFyc2VkLW1lc3NhZ2UtcGFydC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwvcGFyc2VkLW1lc3NhZ2UtcGFydC10ZXh0LnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9wYXJzZWQtbWVzc2FnZS1wYXJ0LXBsYWNlaG9sZGVyLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9wYXJzZWQtbWVzc2FnZS1wYXJ0LXN0YXJ0LXRhZy50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwvcGFyc2VkLW1lc3NhZ2UtcGFydC1lbmQtdGFnLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9pY3UtbWVzc2FnZS10b2tlbml6ZXIudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL2ljdS1tZXNzYWdlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9wYXJzZWQtbWVzc2FnZS1wYXJ0LWljdS1tZXNzYWdlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9wYXJzZWQtbWVzc2FnZS1wYXJ0LWljdS1tZXNzYWdlLXJlZi50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwvcGFyc2VkLW1lc3NhZ2UtcGFydC1lbXB0eS10YWcudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3BhcnNlZC1tZXNzYWdlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9wYXJzZWQtbWVzc2FnZS10b2tlbml6ZXIudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL2Fic3RyYWN0LW1lc3NhZ2UtcGFyc2VyLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC90YWctbWFwcGluZy50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwveGxpZmYtbWVzc2FnZS1wYXJzZXIudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3hsaWZmLXRyYW5zLXVuaXQudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3hsaWZmLWZpbGUudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3htYi1tZXNzYWdlLXBhcnNlci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwveG1iLXRyYW5zLXVuaXQudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3htYi1maWxlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC94bGlmZjItbWVzc2FnZS1wYXJzZXIudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3hsaWZmMi10cmFucy11bml0LnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC94bGlmZjItZmlsZS50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwveHRiLXRyYW5zLXVuaXQudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3h0Yi1maWxlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvYXBpL3RyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUtZmFjdG9yeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICBpbXBvcnRzOiBbXHJcbiAgXSxcclxuICBkZWNsYXJhdGlvbnM6IFtdLFxyXG4gIGV4cG9ydHM6IFtdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ3hJMThuc3VwcG9ydExpYk1vZHVsZSB7IH1cclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMDguMDUuMjAxNy5cclxuICogU29tZSBjb25zdGFudCB2YWx1ZXMgdXNlZCBpbiB0aGUgQVBJLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBzdXBwb3J0ZWQgZmlsZSBmb3JtYXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRk9STUFUX1hMSUZGMTIgPSAneGxmJztcclxuZXhwb3J0IGNvbnN0IEZPUk1BVF9YTElGRjIwID0gJ3hsZjInO1xyXG5leHBvcnQgY29uc3QgRk9STUFUX1hNQiA9ICd4bWInO1xyXG5leHBvcnQgY29uc3QgRk9STUFUX1hUQiA9ICd4dGInO1xyXG5cclxuLyoqXHJcbiAqIEZpbGUgdHlwZXNcclxuICogKHJldHVybmVkIGJ5IGZpbGVUeXBlKCkgbWV0aG9kKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEZJTEVUWVBFX1hMSUZGMTIgPSAnWExJRkYgMS4yJztcclxuZXhwb3J0IGNvbnN0IEZJTEVUWVBFX1hMSUZGMjAgPSAnWExJRkYgMi4wJztcclxuZXhwb3J0IGNvbnN0IEZJTEVUWVBFX1hNQiA9ICdYTUInO1xyXG5leHBvcnQgY29uc3QgRklMRVRZUEVfWFRCID0gJ1hUQic7XHJcblxyXG4vKipcclxuICogYWJzdHJhY3Qgc3RhdGUgdmFsdWUuXHJcbiAqIFRoZXJlIGFyZSBvbmx5IDMgc3VwcG9ydGVkIHN0YXRlIHZhbHVlcy5cclxuICovXHJcblxyXG4vKipcclxuICogU3RhdGUgTkVXLlxyXG4gKiBTaWduYWxzIGFuIHVudHJhbnNsYXRlZCB1bml0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFNUQVRFX05FVyA9ICduZXcnO1xyXG4vKipcclxuICogU3RhdGUgVFJBTlNMQVRFRC5cclxuICogU2lnbmFscyBhIHRyYW5zbGF0ZWQgdW5pdCwgdGhhdCBpcyBub3QgcmV2aWV3ZWQgdW50aWwgbm93LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFNUQVRFX1RSQU5TTEFURUQgPSAndHJhbnNsYXRlZCc7XHJcbi8qKlxyXG4gKiBTdGF0ZSBGSU5BTC5cclxuICogU2lnbmFscyBhIHRyYW5zbGF0ZWQgdW5pdCwgdGhhdCBpcyByZXZpZXdlZCBhbmQgcmVhZHkgZm9yIHVzZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBTVEFURV9GSU5BTCA9ICdmaW5hbCc7XHJcblxyXG4vKipcclxuICogTm9ybWFsaXphdG9uIG1lc3NhZ2UgZm9ybWF0cy5cclxuICovXHJcblxyXG4vKipcclxuICogRGVmYXVsdCBmb3JtYXQsIGNvbnRhaW5zIHBsYWNlaG9sZGVycywgaHRtbCBtYXJrdXAuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTk9STUFMSVpBVElPTl9GT1JNQVRfREVGQVVMVCA9ICdkZWZhdWx0JztcclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgZm9yIHVzYWdlIGluIG5neHRyYW5zbGF0ZSBtZXNzYWdlcy5cclxuICogUGxhY2Vob2xkZXIgYXJlIGluIHRoZSBmb3JtIHt7bn19LCBubyBodG1sIG1hcmt1cC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBOT1JNQUxJWkFUSU9OX0ZPUk1BVF9OR1hUUkFOU0xBVEUgPSAnbmd4dHJhbnNsYXRlJztcclxuIiwiaW1wb3J0IHtET01QYXJzZXIsIFhNTFNlcmlhbGl6ZXJ9IGZyb20gJ3htbGRvbSc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwMS4wNS4yMDE3LlxyXG4gKiBTb21lIFRvb2wgZnVuY3Rpb25zIGZvciBYTUwgSGFuZGxpbmcuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIERPTVV0aWxpdGllcyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdGhlIGZpcnN0IHN1YmVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gdGFnLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnQgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHRhZ05hbWUgdGFnTmFtZVxyXG4gICAgICogQHJldHVybiBzdWJlbGVtZW50IG9yIG51bGwsIGlmIG5vdCBleGlzdGluZy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUoZWxlbWVudDogRWxlbWVudCB8IERvY3VtZW50LCB0YWdOYW1lOiBzdHJpbmcpOiBFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBtYXRjaGluZ0VsZW1lbnRzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcclxuICAgICAgICBpZiAobWF0Y2hpbmdFbGVtZW50cyAmJiBtYXRjaGluZ0VsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nRWxlbWVudHMuaXRlbSgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gYW4gZWxlbWVudCB3aXRoIHRoZSBnaXZlbiB0YWcgYW5kIGlkIGF0dHJpYnV0ZS5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB0YWdOYW1lIHRhZ05hbWVcclxuICAgICAqIEBwYXJhbSBpZCBpZFxyXG4gICAgICogQHJldHVybiBzdWJlbGVtZW50IG9yIG51bGwsIGlmIG5vdCBleGlzdGluZy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRFbGVtZW50QnlUYWdOYW1lQW5kSWQoZWxlbWVudDogRWxlbWVudCB8IERvY3VtZW50LCB0YWdOYW1lOiBzdHJpbmcsIGlkOiBzdHJpbmcpOiBFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBtYXRjaGluZ0VsZW1lbnRzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcclxuICAgICAgICBpZiAobWF0Y2hpbmdFbGVtZW50cyAmJiBtYXRjaGluZ0VsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGluZ0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlOiBFbGVtZW50ID0gbWF0Y2hpbmdFbGVtZW50cy5pdGVtKGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG5leHQgc2libGluZywgdGhhdCBpcyBhbiBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnQgZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEVsZW1lbnRGb2xsb3dpbmdTaWJsaW5nKGVsZW1lbnQ6IEVsZW1lbnQpOiBFbGVtZW50IHtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlID0gZWxlbWVudC5uZXh0U2libGluZztcclxuICAgICAgICB3aGlsZSAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZS5ub2RlVHlwZSA9PT0gZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8RWxlbWVudD4gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlID0gZS5uZXh0U2libGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgcHJldmlvdXMgc2libGluZywgdGhhdCBpcyBhbiBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnQgZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEVsZW1lbnRQcmVjZWRpbmdTaWJsaW5nKGVsZW1lbnQ6IEVsZW1lbnQpOiBFbGVtZW50IHtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlID0gZWxlbWVudC5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICAgICAgd2hpbGUgKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUubm9kZVR5cGUgPT09IGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPEVsZW1lbnQ+IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZSA9IGUucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiBjb250ZW50IG9mIGVsZW1lbnQgYXMgc3RyaW5nLCBpbmNsdWRpbmcgYWxsIG1hcmt1cC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gY29udGVudCBvZiBlbGVtZW50IGFzIHN0cmluZywgaW5jbHVkaW5nIGFsbCBtYXJrdXAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0WE1MQ29udGVudChlbGVtZW50OiBFbGVtZW50KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKGVsZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xyXG4gICAgICAgIGNvbnN0IHJlU3RhcnRNc2c6IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJzwnICsgdGFnTmFtZSArICdbXj5dKj4nLCAnZycpO1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHJlU3RhcnRNc2csICcnKTtcclxuICAgICAgICBjb25zdCByZUVuZE1zZzogUmVnRXhwID0gbmV3IFJlZ0V4cCgnPC8nICsgdGFnTmFtZSArICc+JywgJ2cnKTtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShyZUVuZE1zZywgJycpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gUENEQVRBIGNvbnRlbnQgb2YgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gUENEQVRBIGNvbnRlbnQgb2YgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRQQ0RBVEEoZWxlbWVudDogRWxlbWVudCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGVsZW1lbnQuY2hpbGROb2RlcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZE5vZGVzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gY2hpbGQuVEVYVF9OT0RFIHx8IGNoaWxkLm5vZGVUeXBlID09PSBjaGlsZC5DREFUQV9TRUNUSU9OX05PREUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIGNoaWxkLm5vZGVWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXBsYWNlIFBDREFUQSBjb250ZW50IHdpdGggYSBuZXcgb25lLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnQgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHBjZGF0YSBwY2RhdGFcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXBsYWNlQ29udGVudFdpdGhYTUxDb250ZW50KGVsZW1lbnQ6IEVsZW1lbnQsIHBjZGF0YTogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBjaGlsZHJlblxyXG4gICAgICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXJzZUlDVU1lc3NhZ2UgcGNkYXRhXHJcbiAgICAgICAgY29uc3QgcGNkYXRhRnJhZ21lbnQ6IERvY3VtZW50ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZygnPGZyYWdtZW50PicgKyBwY2RhdGEgKyAnPC9mcmFnbWVudD4nLCAnYXBwbGljYXRpb24veG1sJyk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBwY2RhdGFGcmFnbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZnJhZ21lbnQnKS5pdGVtKDApLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IG5ld0NoaWxkcmVuLml0ZW0oaik7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudC5vd25lckRvY3VtZW50LmltcG9ydE5vZGUobmV3Q2hpbGQsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmaW5kIHRoZSBwcmV2aW91cyBzaWJsaW5nIHRoYXQgaXMgYW4gZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gdGhlIHByZXZpb3VzIHNpYmxpbmcgdGhhdCBpcyBhbiBlbGVtZW50IG9yIG51bGwuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhlbGVtZW50OiBOb2RlKTogRWxlbWVudCB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBlbGVtZW50LnByZXZpb3VzU2libGluZztcclxuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8RWxlbWVudD4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIEVsZW1lbnQgTm9kZSB0aGF0IGlzIHRoZSBuZXh0IHNpYmxpbmcgb2YgYSBnaXZlbiBub2RlLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnROYW1lVG9DcmVhdGUgZWxlbWVudE5hbWVUb0NyZWF0ZVxyXG4gICAgICogQHBhcmFtIHByZXZpb3VzU2libGluZyBwcmV2aW91c1NpYmxpbmdcclxuICAgICAqIEByZXR1cm4gbmV3IGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVGb2xsb3dpbmdTaWJsaW5nKGVsZW1lbnROYW1lVG9DcmVhdGU6IHN0cmluZywgcHJldmlvdXNTaWJsaW5nOiBOb2RlKTogRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3QgbmV3RWxlbWVudCA9IHByZXZpb3VzU2libGluZy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudE5hbWVUb0NyZWF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIDxFbGVtZW50PiBET01VdGlsaXRpZXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcHJldmlvdXNTaWJsaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydCBuZXdFbGVtZW50IGRpcmVjdGx5IGFmdGVyIHByZXZpb3VzU2libGluZy5cclxuICAgICAqIEBwYXJhbSBuZXdFbGVtZW50IG5ld0VsZW1lbnRcclxuICAgICAqIEBwYXJhbSBwcmV2aW91c1NpYmxpbmcgcHJldmlvdXNTaWJsaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudDogTm9kZSwgcHJldmlvdXNTaWJsaW5nOiBOb2RlKTogTm9kZSB7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzU2libGluZy5uZXh0U2libGluZyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgcHJldmlvdXNTaWJsaW5nLm5leHRTaWJsaW5nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgbmV3RWxlbWVudCBkaXJlY3RseSBiZWZvcmUgbmV4dFNpYmxpbmcuXHJcbiAgICAgKiBAcGFyYW0gbmV3RWxlbWVudCBuZXdFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gbmV4dFNpYmxpbmcgbmV4dFNpYmxpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpbnNlcnRCZWZvcmUobmV3RWxlbWVudDogTm9kZSwgbmV4dFNpYmxpbmc6IE5vZGUpOiBOb2RlIHtcclxuICAgICAgICBuZXh0U2libGluZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdFbGVtZW50LCBuZXh0U2libGluZyk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEFuIFhtbFNlcmlhbGl6ZXIgdGhhdCBzdXBwb3J0cyBmb3JtYXR0aW5nLlxyXG4gKiBPcmlnaW5hbCBjb2RlIGlzIGJhc2VkIG9uIFt4bWxkb21dKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3htbGRvbSlcclxuICogSXQgaXMgZXh0ZW5kZWQgdG8gc3VwcG9ydCBmb3JtYXR0aW5nIGluY2x1ZGluZyBoYW5kbGluZyBvZiBlbGVtZW50cyB3aXRoIG1peGVkIGNvbnRlbnQuXHJcbiAqIEV4YW1wbGUgZm9ybWF0dGVkIG91dHB1dDpcclxuICogPHByZT5cclxuICogICAgIDxkb2M+XHJcbiAqICAgICAgICAgPGVsZW1lbnQ+QW4gZWxlbWVudCB3aXRoXHJcbiAqICAgICAgICAgICAgIDxiPm1peGVkPC9iPlxyXG4gKiAgICAgICAgICAgICAgY29udGVudFxyXG4gKiAgICAgICAgIDwvZWxlbWVudD5cclxuICogICAgIDwvZG9jPlxyXG4gKiA8L3ByZT5cclxuICogU2FtZSB3aGVuIFwiZWxlbWVudFwiIGlzIGluZGljYXRlZCBhcyBcIm1peGVkQ29udGVudEVsZW1lbnRcIjpcclxuICogPHByZT5cclxuICogICAgIDxkb2M+XHJcbiAqICAgICAgICAgPGVsZW1lbnQ+QW4gZWxlbWVudCB3aXRoIDxiPm1peGVkPC9iPiBjb250ZW50PC9lbGVtZW50PlxyXG4gKiAgICAgPC9kb2M+XHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbmludGVyZmFjZSBOYW1lc3BhY2Uge1xyXG4gICAgcHJlZml4OiBzdHJpbmc7XHJcbiAgICBuYW1lc3BhY2U6IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgdXNlZCB0byBjb250cm9sIHRoZSBmb3JtYXR0aW5nXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFhtbFNlcmlhbGl6ZXJPcHRpb25zIHtcclxuICAgIGJlYXV0aWZ5PzogYm9vbGVhbjsgLy8gc2V0IHRvIGFjdGl2YXRlIGJlYXV0aWZ5XHJcbiAgICBpbmRlbnRTdHJpbmc/OiBzdHJpbmc7IC8vIFNlcXVlbmNlIHVzZXMgZm9yIGluZGVudGF0aW9uLCBtdXN0IG9ubHkgY29udGFpbiB3aGl0ZSBzcGFjZSBjaGFycywgZS5nLiBcIiAgXCIgb3IgXCIgICAgXCIgb3IgXCJcXHRcIlxyXG4gICAgbWl4ZWRDb250ZW50RWxlbWVudHM/OiBzdHJpbmdbXTsgLy8gTmFtZXMgb2YgZWxlbWVudHMgY29udGFpbmluZyBtaXhlZCBjb250ZW50ICh0aGVzZSBhcmUgbm90IGJlYXV0aWZpZWQpXHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfSU5ERU5UX1NUUklORyA9ICcgICc7XHJcblxyXG5leHBvcnQgY2xhc3MgWG1sU2VyaWFsaXplciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VyaWFsemUgeG1sIGRvY3VtZW50IHRvIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSBkb2N1bWVudCB0aGUgZG9jdW1lbnRcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNhbiBiZSB1c2VkIHRvIGFjdGl2YXRlIGJlYXV0aWZ5aW5nLlxyXG4gICAgICovXHJcbiAgICBzZXJpYWxpemVUb1N0cmluZyhkb2N1bWVudDogRG9jdW1lbnQsIG9wdGlvbnM/OiBYbWxTZXJpYWxpemVyT3B0aW9ucyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgYnVmID0gW107XHJcbiAgICAgICAgbGV0IHZpc2libGVOYW1lc3BhY2VzOiBOYW1lc3BhY2VbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJlZk5vZGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IHByZWZpeCA9IHJlZk5vZGUucHJlZml4O1xyXG4gICAgICAgIGNvbnN0IHVyaSA9IHJlZk5vZGUubmFtZXNwYWNlVVJJO1xyXG5cclxuICAgICAgICBpZiAodXJpICYmIHByZWZpeCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IHJlZk5vZGUubG9va3VwUHJlZml4KHVyaSk7XHJcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJsZU5hbWVzcGFjZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge25hbWVzcGFjZTogdXJpLCBwcmVmaXg6IG51bGx9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8ge25hbWVzcGFjZTp1cmkscHJlZml4OicnfVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5pbmRlbnRTdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5zT25seVdoaXRlU3BhY2Uob3B0aW9ucy5pbmRlbnRTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGVudFN0cmluZyBtdXN0IG5vdCBjb250YWluIG5vbiB3aGl0ZSBjaGFyYWN0ZXJzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kb1NlcmlhbGl6ZVRvU3RyaW5nKGRvY3VtZW50LCBvcHRpb25zLCBidWYsIDAsIGZhbHNlLCB2aXNpYmxlTmFtZXNwYWNlcyk7XHJcbiAgICAgICAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1haW4gZm9ybWF0IG1ldGhvZCB0aGF0IGRvZXMgYWxsIHRoZSB3b3JrLlxyXG4gICAgICogT3V0cHV0cyBhIG5vZGUgdG8gdGhlIG91dHB1dGJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBub2RlIHRoZSBub2RlIHRvIGJlIGZvcm1hdHRlZC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSBidWYgb3V0cHV0YnVmZmVyLCBuZXcgb3V0cHV0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpcyBhcnJheS5cclxuICAgICAqIEBwYXJhbSBpbmRlbnRMZXZlbCBMZXZlciBvZiBpbmRlbnRhdGlvbiBmb3IgZm9ybWF0dGVkIG91dHB1dC5cclxuICAgICAqIEBwYXJhbSBwYXJ0T2ZNaXhlZENvbnRlbnQgdHJ1ZSwgaWYgbm9kZSBpcyBhIHN1YmVsZW1lbnQgb2YgYW4gZWxlbWVudCBjb250YWluaW5kIG1peGVkIGNvbnRlbnQuXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZU5hbWVzcGFjZXMgdmlzaWJsZU5hbWVzcGFjZXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkb1NlcmlhbGl6ZVRvU3RyaW5nKG5vZGU6IE5vZGUsIG9wdGlvbnM6IFhtbFNlcmlhbGl6ZXJPcHRpb25zLCBidWY6IHN0cmluZ1tdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudExldmVsOiBudW1iZXIsIHBhcnRPZk1peGVkQ29udGVudDogYm9vbGVhbiwgdmlzaWJsZU5hbWVzcGFjZXM6IE5hbWVzcGFjZVtdKSB7XHJcbiAgICAgICAgbGV0IGNoaWxkOiBOb2RlO1xyXG4gICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIG5vZGUuRUxFTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudE5vZGU6IEVsZW1lbnQgPSA8RWxlbWVudD4gbm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gZWxlbWVudE5vZGUuYXR0cmlidXRlcztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbiA9IGF0dHJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudE5vZGUuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVOYW1lID0gZWxlbWVudE5vZGUudGFnTmFtZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRIYXNNaXhlZENvbnRlbnQgPSB0aGlzLmlzTWl4ZWRDb250ZW50RWxlbWVudChub2RlTmFtZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFydE9mTWl4ZWRDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goJzwnICwgbm9kZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEluZGVudGVkKG9wdGlvbnMsIGJ1ZiwgaW5kZW50TGV2ZWwsICc8JyAsIG5vZGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG5hbWVzcGFjZXMgZm9yIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cnMuaXRlbShpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci5wcmVmaXggPT09ICd4bWxucycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZU5hbWVzcGFjZXMucHVzaCh7cHJlZml4OiBhdHRyLmxvY2FsTmFtZSwgbmFtZXNwYWNlOiBhdHRyLnZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyLm5vZGVOYW1lID09PSAneG1sbnMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVOYW1lc3BhY2VzLnB1c2goe3ByZWZpeDogJycsIG5hbWVzcGFjZTogYXR0ci52YWx1ZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cnMuaXRlbShpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZWVkTmFtZXNwYWNlRGVmaW5lKGF0dHIsIHZpc2libGVOYW1lc3BhY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBhdHRyLnByZWZpeCB8fCAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJpID0gYXR0ci5uYW1lc3BhY2VVUkk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5zID0gcHJlZml4ID8gJyB4bWxuczonICsgcHJlZml4IDogJyB4bWxucyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKG5zLCAnPVwiJywgdXJpLCAnXCInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZU5hbWVzcGFjZXMucHVzaCh7cHJlZml4OiBwcmVmaXgsIG5hbWVzcGFjZTogdXJpfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9TZXJpYWxpemVUb1N0cmluZyhhdHRyLCBvcHRpb25zLCBidWYsIGluZGVudExldmVsLCBmYWxzZSwgdmlzaWJsZU5hbWVzcGFjZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIG5hbWVzcGFjZSBmb3IgY3VycmVudCBub2RlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZWVkTmFtZXNwYWNlRGVmaW5lKGVsZW1lbnROb2RlLCB2aXNpYmxlTmFtZXNwYWNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBlbGVtZW50Tm9kZS5wcmVmaXggfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJpID0gbm9kZS5uYW1lc3BhY2VVUkk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnMgPSBwcmVmaXggPyAnIHhtbG5zOicgKyBwcmVmaXggOiAnIHhtbG5zJztcclxuICAgICAgICAgICAgICAgICAgICBidWYucHVzaChucywgJz1cIicsIHVyaSwgJ1wiJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZU5hbWVzcGFjZXMucHVzaCh7cHJlZml4OiBwcmVmaXgsIG5hbWVzcGFjZTogdXJpfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goJz4nKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpcyBjZGF0YSBjaGlsZCBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0NvbXBsZXhDb250ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gY2hpbGQuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNDb21wbGV4Q29udGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1NlcmlhbGl6ZVRvU3RyaW5nKGNoaWxkLCBvcHRpb25zLCBidWYsIGluZGVudExldmVsICsgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRPZk1peGVkQ29udGVudCB8fCBlbGVtZW50SGFzTWl4ZWRDb250ZW50LCB2aXNpYmxlTmFtZXNwYWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydE9mTWl4ZWRDb250ZW50ICYmICFlbGVtZW50SGFzTWl4ZWRDb250ZW50ICYmIGhhc0NvbXBsZXhDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0SW5kZW50ZWQob3B0aW9ucywgYnVmLCBpbmRlbnRMZXZlbCwgJzwvJywgbm9kZU5hbWUsICc+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goJzwvJywgbm9kZU5hbWUsICc+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBidWYucHVzaCgnLz4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBub2RlLkRPQ1VNRU5UX05PREU6XHJcbiAgICAgICAgICAgIGNhc2Ugbm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvU2VyaWFsaXplVG9TdHJpbmcoY2hpbGQsIG9wdGlvbnMsIGJ1ZiwgaW5kZW50TGV2ZWwsIGZhbHNlLCB2aXNpYmxlTmFtZXNwYWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBub2RlLkFUVFJJQlVURV9OT0RFOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ck5vZGUgPSA8QXR0cj4gbm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWYucHVzaCgnICcsIGF0dHJOb2RlLm5hbWUsICc9XCInLCBhdHRyTm9kZS52YWx1ZS5yZXBsYWNlKC9bPCZcIl0vZywgdGhpcy5feG1sRW5jb2RlciksICdcIicpO1xyXG4gICAgICAgICAgICBjYXNlIG5vZGUuVEVYVF9OT0RFOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSA8VGV4dD4gbm9kZTtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5iZWF1dGlmeSB8fCBwYXJ0T2ZNaXhlZENvbnRlbnQgfHwgIXRoaXMuY29udGFpbnNPbmx5V2hpdGVTcGFjZSh0ZXh0Tm9kZS5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWYucHVzaCh0ZXh0Tm9kZS5kYXRhLnJlcGxhY2UoL1s8Jl0vZywgdGhpcy5feG1sRW5jb2RlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjYXNlIG5vZGUuQ0RBVEFfU0VDVElPTl9OT0RFOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2RhdGFzZWN0aW9uTm9kZSA9IDxDREFUQVNlY3Rpb24+IG5vZGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmLnB1c2goJzwhW0NEQVRBWycsIGNkYXRhc2VjdGlvbk5vZGUuZGF0YSwgJ11dPicpO1xyXG4gICAgICAgICAgICBjYXNlIG5vZGUuQ09NTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWVudE5vZGUgPSA8Q29tbWVudD4gbm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWYucHVzaCgnPCEtLScsIGNvbW1lbnROb2RlLmRhdGEsICctLT4nKTtcclxuICAgICAgICAgICAgY2FzZSBub2RlLkRPQ1VNRU5UX1RZUEVfTk9ERTpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50dHlwZU5vZGUgPSA8RG9jdW1lbnRUeXBlPiBub2RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHViaWQgPSBkb2N1bWVudHR5cGVOb2RlLnB1YmxpY0lkO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3lzaWQgPSBkb2N1bWVudHR5cGVOb2RlLnN5c3RlbUlkO1xyXG4gICAgICAgICAgICAgICAgYnVmLnB1c2goJzwhRE9DVFlQRSAnLCBkb2N1bWVudHR5cGVOb2RlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHB1YmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goJyBQVUJMSUMgXCInLCBwdWJpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5c2lkICYmIHN5c2lkICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goJ1wiIFwiJywgc3lzaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBidWYucHVzaCgnXCI+Jyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN5c2lkICYmIHN5c2lkICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWYucHVzaCgnIFNZU1RFTSBcIicsIHN5c2lkLCAnXCI+Jyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YiA9IGRvY3VtZW50dHlwZU5vZGUuaW50ZXJuYWxTdWJzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYucHVzaCgnIFsnLCBzdWIsICddJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKCc+Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNhc2Ugbm9kZS5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaU5vZGUgPSA8UHJvY2Vzc2luZ0luc3RydWN0aW9uPiBub2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1Zi5wdXNoKCAnPD8nLCBwaU5vZGUudGFyZ2V0LCAnICcsIHBpTm9kZS5kYXRhLCAnPz4nKTtcclxuICAgICAgICAgICAgY2FzZSBub2RlLkVOVElUWV9SRUZFUkVOQ0VfTk9ERTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWYucHVzaCgnJicsIG5vZGUubm9kZU5hbWUsICc7Jyk7XHJcbiAgICAgICAgICAgIC8vIGNhc2UgRU5USVRZX05PREU6XHJcbiAgICAgICAgICAgIC8vIGNhc2UgTk9UQVRJT05fTk9ERTpcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKCc/PycsIG5vZGUubm9kZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG5lZWROYW1lc3BhY2VEZWZpbmUobm9kZTogRWxlbWVudCB8IEF0dHIsIHZpc2libGVOYW1lc3BhY2VzOiBOYW1lc3BhY2VbXSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5vZGUucHJlZml4IHx8ICcnO1xyXG4gICAgICAgIGNvbnN0IHVyaSA9IG5vZGUubmFtZXNwYWNlVVJJO1xyXG4gICAgICAgIGlmICghcHJlZml4ICYmICF1cmkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJlZml4ID09PSAneG1sJyAmJiB1cmkgPT09ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXHJcbiAgICAgICAgICAgIHx8IHVyaSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaSA9IHZpc2libGVOYW1lc3BhY2VzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5zID0gdmlzaWJsZU5hbWVzcGFjZXNbaV07XHJcbiAgICAgICAgICAgIC8vIGdldCBuYW1lc3BhY2UgcHJlZml4XHJcbiAgICAgICAgICAgIGlmIChucy5wcmVmaXggPT09IHByZWZpeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5zLm5hbWVzcGFjZSAhPT0gdXJpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3htbEVuY29kZXIoYzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gYyA9PT0gJzwnICYmICcmbHQ7JyB8fFxyXG4gICAgICAgICAgICBjID09PSAnPicgJiYgJyZndDsnIHx8XHJcbiAgICAgICAgICAgIGMgPT09ICcmJyAmJiAnJmFtcDsnIHx8XHJcbiAgICAgICAgICAgIGMgPT09ICdcIicgJiYgJyZxdW90OycgfHxcclxuICAgICAgICAgICAgJyYjJyArIGMuY2hhckNvZGVBdCgwKSArICc7JztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG91dHB1dEluZGVudGVkKG9wdGlvbnM6IFhtbFNlcmlhbGl6ZXJPcHRpb25zLCBidWY6IHN0cmluZ1tdLCBpbmRlbnRMZXZlbDogbnVtYmVyLCAuLi5vdXRwdXRQYXJ0czogc3RyaW5nW10pIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5iZWF1dGlmeSkge1xyXG4gICAgICAgICAgICBidWYucHVzaCgnXFxuJyk7XHJcbiAgICAgICAgICAgIGlmIChpbmRlbnRMZXZlbCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKHRoaXMuaW5kZW50YXRpb25TdHJpbmcob3B0aW9ucywgaW5kZW50TGV2ZWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBidWYucHVzaCguLi5vdXRwdXRQYXJ0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbmRlbnRhdGlvblN0cmluZyhvcHRpb25zOiBYbWxTZXJpYWxpemVyT3B0aW9ucywgaW5kZW50TGV2ZWw6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgaW5kZW50ID0gKG9wdGlvbnMuaW5kZW50U3RyaW5nKSA/IG9wdGlvbnMuaW5kZW50U3RyaW5nIDogREVGQVVMVF9JTkRFTlRfU1RSSU5HO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGVudExldmVsOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgaW5kZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHRhZ05hbWUgaXMgYW4gZWxlbWVudCBjb250YWluaW5nIG1peGVkIGNvbnRlbnQuXHJcbiAgICAgKiBAcGFyYW0gdGFnTmFtZSB0YWdOYW1lXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaXNNaXhlZENvbnRlbnRFbGVtZW50KHRhZ05hbWU6IHN0cmluZywgb3B0aW9uczogWG1sU2VyaWFsaXplck9wdGlvbnMpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1peGVkQ29udGVudEVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIW9wdGlvbnMubWl4ZWRDb250ZW50RWxlbWVudHMuZmluZCgodGFnKSA9PiB0YWcgPT09IHRhZ05hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjb250YWluc09ubHlXaGl0ZVNwYWNlKHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjID0gdGV4dC5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgIGlmICghKGMgPT09ICcgJyB8fCBjID09PSAnXFx0JyB8fCBjID09PSAnXFxyJyB8fCBjID09PSAnXFxuJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge1NUQVRFX05FVywgU1RBVEVfVFJBTlNMQVRFRH0gZnJvbSAnLi4vYXBpL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuLi9hcGkvaS10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuaW1wb3J0IHtJTm9ybWFsaXplZE1lc3NhZ2V9IGZyb20gJy4uL2FwaS9pLW5vcm1hbGl6ZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7SVRyYW5zVW5pdH0gZnJvbSAnLi4vYXBpL2ktdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0RPTVBhcnNlcn0gZnJvbSAneG1sZG9tJztcclxuaW1wb3J0IHtYbWxTZXJpYWxpemVyLCBYbWxTZXJpYWxpemVyT3B0aW9uc30gZnJvbSAnLi94bWwtc2VyaWFsaXplcic7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IHJvb2JtIG9uIDA5LjA1LjIwMTcuXHJcbiAqIEFic3RyYWN0IHN1cGVyY2xhc3MgZm9yIGFsbCBpbXBsZW1lbnRhdGlvbnMgb2YgSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIGltcGxlbWVudHMgSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbGVuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9lbmNvZGluZzogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCBfcGFyc2VkRG9jdW1lbnQ6IERvY3VtZW50O1xyXG5cclxuICAgIHByb3RlY3RlZCBfZmlsZUVuZHNXaXRoRU9MOiBib29sZWFuO1xyXG5cclxuICAgIC8vIHRyYW5zLXVuaXQgZWxlbWVudHMgYW5kIHRoZWlyIGlkIGZyb20gdGhlIGZpbGVcclxuICAgIHByb3RlY3RlZCB0cmFuc1VuaXRzOiBJVHJhbnNVbml0W107XHJcblxyXG4gICAgcHJvdGVjdGVkIF93YXJuaW5nczogc3RyaW5nW107XHJcblxyXG4gICAgcHJvdGVjdGVkIF9udW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkOiBudW1iZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9udW1iZXJPZlVudHJhbnNsYXRlZFRyYW5zVW5pdHM6IG51bWJlcjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX251bWJlck9mUmV2aWV3ZWRUcmFuc1VuaXRzOiBudW1iZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHRhcmdldFByYWVmaXg6IHN0cmluZztcclxuXHJcbiAgICBwcm90ZWN0ZWQgdGFyZ2V0U3VmZml4OiBzdHJpbmc7XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNVbml0cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fd2FybmluZ3MgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGZpbGUgY29udGVudC5cclxuICAgICAqIFNldHMgX3BhcnNlZERvY3VtZW50LCBsaW5lIGVuZGluZywgZW5jb2RpbmcsIGV0Yy5cclxuICAgICAqIEBwYXJhbSB4bWxTdHJpbmcgeG1sU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBwYXRoXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgZW5jb2RpbmdcclxuICAgICAqIEBwYXJhbSBvcHRpb25hbE1hc3RlciBvcHRpb25hbE1hc3RlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcGFyc2VDb250ZW50KFxyXG4gICAgICAgIHhtbFN0cmluZzogc3RyaW5nLFxyXG4gICAgICAgIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyxcclxuICAgICAgICBvcHRpb25hbE1hc3Rlcj86IHsgeG1sQ29udGVudDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcgfSlcclxuICAgICAgICA6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2ZpbGVuYW1lID0gcGF0aDtcclxuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xyXG4gICAgICAgIHRoaXMuX3BhcnNlZERvY3VtZW50ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcsICd0ZXh0L3htbCcpO1xyXG4gICAgICAgIHRoaXMuX2ZpbGVFbmRzV2l0aEVPTCA9IHhtbFN0cmluZy5lbmRzV2l0aCgnXFxuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgYWJzdHJhY3QgaTE4bkZvcm1hdCgpOiBzdHJpbmc7XHJcblxyXG4gICAgYWJzdHJhY3QgZmlsZVR5cGUoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRhZyBuYW1lcyBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIG1peGVkIGNvbnRlbnQuXHJcbiAgICAgKiBUaGVzZSBlbGVtZW50cyB3aWxsIG5vdCBiZSBiZWF1dGlmaWVkLlxyXG4gICAgICogVHlwaWNhbCBjYW5kaWRhdGVzIGFyZSBzb3VyY2UgYW5kIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGVsZW1lbnRzV2l0aE1peGVkQ29udGVudCgpOiBzdHJpbmdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYWxsIHRyYW5zIHVuaXRzIGZyb20geG1sIGNvbnRlbnQuXHJcbiAgICAgKiBQdXRzIHRoZSBmb3VuZCB1bml0cyBpbnRvIHRyYW5zVW5pdHMuXHJcbiAgICAgKiBQdXRzIHdhcm5pbmdzIGZvciBtaXNzaW5nIGlkcy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGluaXRpYWxpemVUcmFuc1VuaXRzKCk7XHJcblxyXG4gICAgcHJvdGVjdGVkIGxhenlJbml0aWFsaXplVHJhbnNVbml0cygpIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy50cmFuc1VuaXRzKSkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVUcmFuc1VuaXRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnROdW1iZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY291bnQgdW5pdHMgYWZ0ZXIgY2hhbmdlcyBvZiB0cmFucyB1bml0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY291bnROdW1iZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mVHJhbnNVbml0c1dpdGhNaXNzaW5nSWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mVW50cmFuc2xhdGVkVHJhbnNVbml0cyA9IDA7XHJcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZSZXZpZXdlZFRyYW5zVW5pdHMgPSAwO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaFRyYW5zVW5pdCgodHU6IElUcmFuc1VuaXQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHR1LmlkKSB8fCB0dS5pZCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX251bWJlck9mVHJhbnNVbml0c1dpdGhNaXNzaW5nSWQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHR1LnRhcmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChzdGF0ZSkgfHwgc3RhdGUgPT09IFNUQVRFX05FVykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyT2ZVbnRyYW5zbGF0ZWRUcmFuc1VuaXRzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBTVEFURV9UUkFOU0xBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJPZlJldmlld2VkVHJhbnNVbml0cysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHdhcm5pbmdzKCk6IHN0cmluZ1tdIHtcclxuICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93YXJuaW5ncztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvdGFsIG51bWJlciBvZiB0cmFuc2xhdGlvbiB1bml0cyBmb3VuZCBpbiB0aGUgZmlsZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG51bWJlck9mVHJhbnNVbml0cygpOiBudW1iZXIge1xyXG4gICAgICAgIHRoaXMubGF6eUluaXRpYWxpemVUcmFuc1VuaXRzKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNVbml0cy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1iZXIgb2YgdHJhbnNsYXRpb24gdW5pdHMgd2l0aG91dCB0cmFuc2xhdGlvbiBmb3VuZCBpbiB0aGUgZmlsZS5cclxuICAgICAqIFRoZXNlIHVuaXRzIGhhdmUgc3RhdGUgJ3RyYW5zbGF0ZWQnLlxyXG4gICAgICovXHJcbiAgICBudW1iZXJPZlVudHJhbnNsYXRlZFRyYW5zVW5pdHMoKTogbnVtYmVyIHtcclxuICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZlVudHJhbnNsYXRlZFRyYW5zVW5pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1iZXIgb2YgdHJhbnNsYXRpb24gdW5pdHMgd2l0aCBzdGF0ZSAnZmluYWwnLlxyXG4gICAgICovXHJcbiAgICBudW1iZXJPZlJldmlld2VkVHJhbnNVbml0cygpOiBudW1iZXIge1xyXG4gICAgICAgIHRoaXMubGF6eUluaXRpYWxpemVUcmFuc1VuaXRzKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX251bWJlck9mUmV2aWV3ZWRUcmFuc1VuaXRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIHRyYW5zbGF0aW9uIHVuaXRzIHdpdGhvdXQgdHJhbnNsYXRpb24gZm91bmQgaW4gdGhlIGZpbGUuXHJcbiAgICAgKiBUaGVzZSB1bml0cyBoYXZlIHN0YXRlICd0cmFuc2xhdGVkJy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG51bWJlck9mVHJhbnNVbml0c1dpdGhNaXNzaW5nSWQoKTogbnVtYmVyIHtcclxuICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqIEByZXR1cm4gc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzb3VyY2VMYW5ndWFnZSgpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICogQHJldHVybiB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHRhcmdldExhbmd1YWdlKCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvb3Agb3ZlciBhbGwgVHJhbnNsYXRpb24gVW5pdHMuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgcHVibGljIGZvckVhY2hUcmFuc1VuaXQoY2FsbGJhY2s6ICgodHJhbnN1bml0OiBJVHJhbnNVbml0KSA9PiB2b2lkKSkge1xyXG4gICAgICAgIHRoaXMubGF6eUluaXRpYWxpemVUcmFuc1VuaXRzKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc1VuaXRzLmZvckVhY2goKHR1KSA9PiBjYWxsYmFjayh0dSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRyYW5zLXVuaXQgd2l0aCBnaXZlbiBpZC5cclxuICAgICAqIEBwYXJhbSBpZCBpZFxyXG4gICAgICogQHJldHVybiB0cmFucy11bml0IHdpdGggZ2l2ZW4gaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc1VuaXRXaXRoSWQoaWQ6IHN0cmluZyk6IElUcmFuc1VuaXQge1xyXG4gICAgICAgIHRoaXMubGF6eUluaXRpYWxpemVUcmFuc1VuaXRzKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNVbml0cy5maW5kKCh0dSkgPT4gdHUuaWQgPT09IGlkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXQgZnVuY3Rpb25zIGZvbGxvd2luZyBoZXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdCB0aGUgc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlIGxhbmd1YWdlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldFNvdXJjZUxhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdCB0aGUgdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlIGxhbmd1YWdlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldFRhcmdldExhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwcmFlZml4IHVzZWQgd2hlbiBjb3B5aW5nIHNvdXJjZSB0byB0YXJnZXQuXHJcbiAgICAgKiBUaGlzIGlzIHVzZWQgYnkgaW1wb3J0TmV3VHJhbnNVbml0IGFuZCBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nIG1ldGhvZHMuXHJcbiAgICAgKiAoc2luY2UgMS44LjApXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0UHJhZWZpeCB0YXJnZXRQcmFlZml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXROZXdUcmFuc1VuaXRUYXJnZXRQcmFlZml4KHRhcmdldFByYWVmaXg6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0UHJhZWZpeCA9IHRhcmdldFByYWVmaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHByYWVmaXggdXNlZCB3aGVuIGNvcHlpbmcgc291cmNlIHRvIHRhcmdldC5cclxuICAgICAqIChzaW5jZSAxLjguMClcclxuICAgICAqIEByZXR1cm4gdGhlIHByYWVmaXggdXNlZCB3aGVuIGNvcHlpbmcgc291cmNlIHRvIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBpc051bGxPclVuZGVmaW5lZCh0aGlzLnRhcmdldFByYWVmaXgpID8gJycgOiB0aGlzLnRhcmdldFByYWVmaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHN1ZmZpeCB1c2VkIHdoZW4gY29weWluZyBzb3VyY2UgdG8gdGFyZ2V0LlxyXG4gICAgICogVGhpcyBpcyB1c2VkIGJ5IGltcG9ydE5ld1RyYW5zVW5pdCBhbmQgY3JlYXRlVHJhbnNsYXRpb25GaWxlRm9yTGFuZyBtZXRob2RzLlxyXG4gICAgICogKHNpbmNlIDEuOC4wKVxyXG4gICAgICogQHBhcmFtIHRhcmdldFN1ZmZpeCB0YXJnZXRTdWZmaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldE5ld1RyYW5zVW5pdFRhcmdldFN1ZmZpeCh0YXJnZXRTdWZmaXg6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0U3VmZml4ID0gdGFyZ2V0U3VmZml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdWZmaXggdXNlZCB3aGVuIGNvcHlpbmcgc291cmNlIHRvIHRhcmdldC5cclxuICAgICAqIChzaW5jZSAxLjguMClcclxuICAgICAqIEByZXR1cm4gdGhlIHN1ZmZpeCB1c2VkIHdoZW4gY29weWluZyBzb3VyY2UgdG8gdGFyZ2V0LlxyXG4gICAgICovXHJcbiAgICBnZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQodGhpcy50YXJnZXRTdWZmaXgpID8gJycgOiB0aGlzLnRhcmdldFN1ZmZpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIG5ldyB0cmFucy11bml0IHRvIHRoaXMgZmlsZS5cclxuICAgICAqIFRoZSB0cmFucyB1bml0IHN0ZW1zIGZyb20gYW5vdGhlciBmaWxlLlxyXG4gICAgICogSXQgY29waWVzIHRoZSBzb3VyY2UgY29udGVudCBvZiB0aGUgdHUgdG8gdGhlIHRhcmdldCBjb250ZW50IHRvbyxcclxuICAgICAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIGlzRGVmYXVsdExhbmcgYW5kIGNvcHlDb250ZW50LlxyXG4gICAgICogU28gdGhlIHNvdXJjZSBjYW4gYmUgdXNlZCBhcyBhIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKHVzZWQgYnkgeGxpZmZtZXJnZSlcclxuICAgICAqIEBwYXJhbSBmb3JlaWduVHJhbnNVbml0IHRoZSB0cmFucyB1bml0IHRvIGJlIGltcG9ydGVkLlxyXG4gICAgICogQHBhcmFtIGlzRGVmYXVsdExhbmcgRmxhZywgd2V0aGVyIGZpbGUgY29udGFpbnMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBUaGVuIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBqdXN0IGVxdWFsLlxyXG4gICAgICogVGhlIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQuXHJcbiAgICAgKiBTdGF0ZSB3aWxsIGJlIGZpbmFsLlxyXG4gICAgICogQHBhcmFtIGNvcHlDb250ZW50IEZsYWcsIHdldGhlciB0byBjb3B5IGNvbnRlbnQgb3IgbGVhdmUgaXQgZW1wdHkuXHJcbiAgICAgKiBXYmVuIHRydWUsIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQgZnJvbSBzb3VyY2UuXHJcbiAgICAgKiBXaGVuIGZhbHNlLCBjb250ZW50IHdpbGwgYmUgbGVmdCBlbXB0eSAoaWYgaXQgaXMgbm90IHRoZSBkZWZhdWx0IGxhbmd1YWdlKS5cclxuICAgICAqIEBwYXJhbSBpbXBvcnRBZnRlckVsZW1lbnQgb3B0aW9uYWwgKHNpbmNlIDEuMTApIG90aGVyIHRyYW5zdW5pdCAocGFydCBvZiB0aGlzIGZpbGUpLCB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIGFuY2VzdG9yLlxyXG4gICAgICogTmV3bHkgaW1wb3J0ZWQgdHJhbnMgdW5pdCBpcyB0aGVuIGluc2VydGVkIGRpcmVjdGx5IGFmdGVyIHRoaXMgZWxlbWVudC5cclxuICAgICAqIElmIG5vdCBzZXQgb3Igbm90IHBhcnQgb2YgdGhpcyBmaWxlLCBuZXcgdW5pdCB3aWxsIGJlIGltcG9ydGVkIGF0IHRoZSBlbmQuXHJcbiAgICAgKiBJZiBleHBsaWNpdHkgc2V0IHRvIG51bGwsIG5ldyB1bml0IHdpbGwgYmUgaW1wb3J0ZWQgYXQgdGhlIHN0YXJ0LlxyXG4gICAgICogQHJldHVybiB0aGUgbmV3bHkgaW1wb3J0ZWQgdHJhbnMgdW5pdCAoc2luY2UgdmVyc2lvbiAxLjcuMClcclxuICAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdHJhbnMtdW5pdCB3aXRoIHNhbWUgaWQgYWxyZWFkeSBpcyBpbiB0aGUgZmlsZS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgaW1wb3J0TmV3VHJhbnNVbml0KGZvcmVpZ25UcmFuc1VuaXQ6IElUcmFuc1VuaXQsIGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuLCBpbXBvcnRBZnRlckVsZW1lbnQ/OiBJVHJhbnNVbml0KVxyXG4gICAgICAgIDogSVRyYW5zVW5pdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSB0aGUgdHJhbnMtdW5pdCB3aXRoIHRoZSBnaXZlbiBpZC5cclxuICAgICAqIEBwYXJhbSBpZCBpZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlVHJhbnNVbml0V2l0aElkKGlkOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCB0dU5vZGU6IE5vZGUgPSB0aGlzLl9wYXJzZWREb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgICAgICAgaWYgKHR1Tm9kZSkge1xyXG4gICAgICAgICAgICB0dU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0dU5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zVW5pdHMgPSB0aGlzLnRyYW5zVW5pdHMuZmlsdGVyKCh0dSkgPT4gdHUuaWQgIT09IGlkKTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudE51bWJlcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmlsZW5hbWUgd2hlcmUgdGhlIGRhdGEgaXMgcmVhZCBmcm9tLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmlsZW5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW5jb2RpbmcgaWYgdGhlIHhtbCBjb250ZW50IChVVEYtOCwgSVNPLTg4NTktMSwgLi4uKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5jb2RpbmcoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgeG1sIGNvbnRlbnQgdG8gYmUgc2F2ZWQgYWZ0ZXIgY2hhbmdlcyBhcmUgbWFkZS5cclxuICAgICAqIEBwYXJhbSBiZWF1dGlmeU91dHB1dCBGbGFnIHdoZXRoZXIgdG8gdXNlIHByZXR0eS1kYXRhIHRvIGZvcm1hdCB0aGUgb3V0cHV0LlxyXG4gICAgICogWE1MU2VyaWFsaXplciBwcm9kdWNlcyBzb21lIGNvcnJlY3QgYnV0IHN0cmFuZ2VseSBmb3JtYXR0ZWQgb3V0cHV0LCB3aGljaCBwcmV0dHktZGF0YSBjYW4gY29ycmVjdC5cclxuICAgICAqIFNlZSBpc3N1ZSAjNjQgZm9yIGRldGFpbHMuXHJcbiAgICAgKiBEZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZWRpdGVkQ29udGVudChiZWF1dGlmeU91dHB1dD86IGJvb2xlYW4pOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IFhtbFNlcmlhbGl6ZXJPcHRpb25zID0ge307XHJcbiAgICAgICAgaWYgKGJlYXV0aWZ5T3V0cHV0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgb3B0aW9ucy5iZWF1dGlmeSA9IHRydWU7XHJcbiAgICAgICAgICAgb3B0aW9ucy5pbmRlbnRTdHJpbmcgPSAnICAnO1xyXG4gICAgICAgICAgIG9wdGlvbnMubWl4ZWRDb250ZW50RWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzV2l0aE1peGVkQ29udGVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgWG1sU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHRoaXMuX3BhcnNlZERvY3VtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5fZmlsZUVuZHNXaXRoRU9MKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZCBlb2wgaWYgdGhlcmUgd2FzIGVvbCBpbiBvcmlnaW5hbCBzb3VyY2VcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcXG4nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zbGF0aW9uIGZpbGUgZm9yIHRoaXMgZmlsZSBmb3IgYSBnaXZlbiBsYW5ndWFnZS5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGp1c3QgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvbmUuXHJcbiAgICAgKiBCdXQgZm9yIFhNQiB0aGUgdHJhbnNsYXRpb24gZmlsZSBoYXMgZm9ybWF0ICdYVEInLlxyXG4gICAgICogQHBhcmFtIGxhbmcgTGFuZ3VhZ2UgY29kZVxyXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIGV4cGVjdGVkIGZpbGVuYW1lIHRvIHN0b3JlIGZpbGVcclxuICAgICAqIEBwYXJhbSBpc0RlZmF1bHRMYW5nIEZsYWcsIHdldGhlciBmaWxlIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGxhbmd1YWdlLlxyXG4gICAgICogVGhlbiBzb3VyY2UgYW5kIHRhcmdldCBhcmUganVzdCBlcXVhbC5cclxuICAgICAqIFRoZSBjb250ZW50IHdpbGwgYmUgY29waWVkLlxyXG4gICAgICogU3RhdGUgd2lsbCBiZSBmaW5hbC5cclxuICAgICAqIEBwYXJhbSBjb3B5Q29udGVudCBGbGFnLCB3ZXRoZXIgdG8gY29weSBjb250ZW50IG9yIGxlYXZlIGl0IGVtcHR5LlxyXG4gICAgICogV2JlbiB0cnVlLCBjb250ZW50IHdpbGwgYmUgY29waWVkIGZyb20gc291cmNlLlxyXG4gICAgICogV2hlbiBmYWxzZSwgY29udGVudCB3aWxsIGJlIGxlZnQgZW1wdHkgKGlmIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBsYW5ndWFnZSkuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcobGFuZzogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nLCBpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbilcclxuICAgICAgICA6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZTtcclxufVxyXG4iLCJpbXBvcnQge1NUQVRFX1RSQU5TTEFURUQsIElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSwgSU5vcm1hbGl6ZWRNZXNzYWdlLCBJVHJhbnNVbml0LCBJTm90ZX0gZnJvbSAnLi9pbnRlcm5hbGFwaSc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi9hYnN0cmFjdC10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZCwgaXNTdHJpbmd9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2V9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge0Fic3RyYWN0TWVzc2FnZVBhcnNlcn0gZnJvbSAnLi9hYnN0cmFjdC1tZXNzYWdlLXBhcnNlcic7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IHJvb2JtIG9uIDEwLjA1LjIwMTcuXHJcbiAqIEFic3RyYWN0IHN1cGVyY2xhc3MgZm9yIGFsbCBpbXBsZW1lbnRhdGlvbnMgb2YgSVRyYW5zVW5pdC5cclxuICovXHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RUcmFuc1VuaXQgaW1wbGVtZW50cyBJVHJhbnNVbml0IHtcclxuXHJcbiAgICBwcml2YXRlIF9zb3VyY2VDb250ZW50Tm9ybWFsaXplZDogUGFyc2VkTWVzc2FnZTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IocHJvdGVjdGVkIF9lbGVtZW50OiBFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb3RlY3RlZCBfaWQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgX3RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpIHtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlkKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpbGUgdGhlIHVuaXQgYmVsb25ncyB0by4sXHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKCk6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWdpbmFsIHRleHQgdmFsdWUsIHRoYXQgaXMgdG8gYmUgdHJhbnNsYXRlZC5cclxuICAgICAqIENvbnRhaW5zIGFsbCBtYXJrdXAsIGRlcGVuZHMgb24gdGhlIGNvbmNyZXRlIGZvcm1hdCB1c2VkLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzb3VyY2VDb250ZW50KCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciBzZXR0aW5nIG9mIHNvdXJjZSBjb250ZW50IGlzIHN1cHBvcnRlZC5cclxuICAgICAqIElmIG5vdCwgc2V0U291cmNlQ29udGVudCBpbiB0cmFucy11bml0IHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBzdXBwb3J0c1NldFNvdXJjZUNvbnRlbnQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbmV3IHNvdXJjZSBjb250ZW50IGluIHRoZSB0cmFuc3VuaXQuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBkb25lIGJ5IG5nLWV4dHJhY3QuXHJcbiAgICAgKiBNZXRob2Qgb25seSBleGlzdHMgdG8gYWxsb3cgeGxpZmZtZXJnZSB0byBtZXJnZSBtaXNzaW5nIGNoYW5nZWQgc291cmNlIGNvbnRlbnQuXHJcbiAgICAgKiBAcGFyYW0gbmV3Q29udGVudCB0aGUgbmV3IGNvbnRlbnQuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldFNvdXJjZUNvbnRlbnQobmV3Q29udGVudDogc3RyaW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHZhbHVlLCB0aGF0IGlzIHRvIGJlIHRyYW5zbGF0ZWQsIGFzIG5vcm1hbGl6ZWQgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCk6IFBhcnNlZE1lc3NhZ2Uge1xyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9zb3VyY2VDb250ZW50Tm9ybWFsaXplZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc291cmNlQ29udGVudE5vcm1hbGl6ZWQgPSB0aGlzLmNyZWF0ZVNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VDb250ZW50Tm9ybWFsaXplZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHZhbHVlLCB0aGF0IGlzIHRvIGJlIHRyYW5zbGF0ZWQsIGFzIG5vcm1hbGl6ZWQgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgY3JlYXRlU291cmNlQ29udGVudE5vcm1hbGl6ZWQoKTogUGFyc2VkTWVzc2FnZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0cmFuc2xhdGVkIHZhbHVlLlxyXG4gICAgICogQ29udGFpbnMgYWxsIG1hcmt1cCwgZGVwZW5kcyBvbiB0aGUgY29uY3JldGUgZm9ybWF0IHVzZWQuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHRhcmdldENvbnRlbnQoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRyYW5zbGF0ZWQgdmFsdWUgYXMgbm9ybWFsaXplZCBtZXNzYWdlLlxyXG4gICAgICogQWxsIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgd2l0aCB7e259fSAoc3RhcnRpbmcgYXQgMClcclxuICAgICAqIGFuZCBhbGwgZW1iZWRkZWQgaHRtbCBpcyByZXBsYWNlZCBieSBkaXJlY3QgaHRtbCBtYXJrdXAuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHRhcmdldENvbnRlbnROb3JtYWxpemVkKCk6IElOb3JtYWxpemVkTWVzc2FnZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRlIG9mIHRoZSB0cmFuc2xhdGlvbiBhcyBzdG9yZWQgaW4gdGhlIHhtbC5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgbmF0aXZlVGFyZ2V0U3RhdGUoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGUgb2YgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogKG9uIG9mIG5ldywgdHJhbnNsYXRlZCwgZmluYWwpXHJcbiAgICAgKiBSZXR1cm4gdmFsdWVzIGFyZSBkZWZpbmVkIGFzIENvbnN0YW50cyBTVEFURV8uLi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldFN0YXRlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgbmF0aXZlU3RhdGUgPSB0aGlzLm5hdGl2ZVRhcmdldFN0YXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwTmF0aXZlU3RhdGVUb1N0YXRlKG5hdGl2ZVN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBhbiBhYnN0cmFjdCBzdGF0ZSAobmV3LCB0cmFuc2xhdGVkLCBmaW5hbCkgdG8gYSBjb25jcmV0ZSBzdGF0ZSB1c2VkIGluIHRoZSB4bWwuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSB0byBiZSB1c2VkIGluIHRoZSB4bWwuXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgb25lIG9mIENvbnN0YW50cy5TVEFURS4uLlxyXG4gICAgICogQHJldHVybnMgYSBuYXRpdmUgc3RhdGUgKGRlcGVuZHMgb24gY29uY3JldGUgZm9ybWF0KVxyXG4gICAgICogQHRocm93cyBlcnJvciwgaWYgc3RhdGUgaXMgaW52YWxpZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IG1hcFN0YXRlVG9OYXRpdmVTdGF0ZShzdGF0ZTogc3RyaW5nKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIGEgbmF0aXZlIHN0YXRlIChmb3VuZCBpbiB0aGUgZG9jdW1lbnQpIHRvIGFuIGFic3RyYWN0IHN0YXRlIChuZXcsIHRyYW5zbGF0ZWQsIGZpbmFsKS5cclxuICAgICAqIFJldHVybnMgdGhlIGFic3RyYWN0IHN0YXRlLlxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0YXRlIG5hdGl2ZVN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBtYXBOYXRpdmVTdGF0ZVRvU3RhdGUobmF0aXZlU3RhdGU6IHN0cmluZyk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldCBzdGF0ZSBpbiB4bWwuXHJcbiAgICAgKiBAcGFyYW0gbmF0aXZlU3RhdGUgbmF0aXZlU3RhdGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHNldE5hdGl2ZVRhcmdldFN0YXRlKG5hdGl2ZVN0YXRlOiBzdHJpbmcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZ5IHRoZSB0YXJnZXQgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgb25lIG9mIHRoZSAzIGFsbG93ZWQgdGFyZ2V0IHN0YXRlcyBuZXcsIHRyYW5zbGF0ZWQsIGZpbmFsLlxyXG4gICAgICogQ29uc3RhbnRzIFNUQVRFXy4uLlxyXG4gICAgICogSW52YWxpZCBzdGF0ZXMgdGhyb3cgYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIHNldFRhcmdldFN0YXRlKG5ld1N0YXRlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnNldE5hdGl2ZVRhcmdldFN0YXRlKHRoaXMubWFwU3RhdGVUb05hdGl2ZVN0YXRlKG5ld1N0YXRlKSk7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUoKSBpbnN0YW5jZW9mIEFic3RyYWN0VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpIHtcclxuICAgICAgICAgICAgKDxBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlPiB0aGlzLnRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKCkpLmNvdW50TnVtYmVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgc291cmNlIGVsZW1lbnRzIGluIHRoZSB0cmFucyB1bml0LlxyXG4gICAgICogVGhlIHNvdXJjZSBlbGVtZW50IGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cclxuICAgICAqIEl0IGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmaWxlIGFuZCBhIGxpbmUgbnVtYmVyIHdpdGggdGhlIHBvc2l0aW9uIGluc2lkZSB0aGUgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBpcyBqdXN0IGEgaGVscCBmb3IgdHJhbnNsYXRvcnMgdG8gZmluZCB0aGUgY29udGV4dCBmb3IgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogVGhpcyBpcyBzZXQgd2hlbiB1c2luZyBBbmd1bGFyIDQuMCBvciBncmVhdGVyLlxyXG4gICAgICogT3RoZXJ3aXNlIGl0IGp1c3QgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc291cmNlUmVmZXJlbmNlcygpOiB7c291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyOiBudW1iZXJ9W107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBzb3VyY2UgcmVmcyBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldFNvdXJjZVJlZmVyZW5jZXMgd2lsbCBkbyBub3RoaW5nLlxyXG4gICAgICogeHRiIGRvZXMgbm90IHN1cHBvcnQgdGhpcywgYWxsIG90aGVyIGZvcm1hdHMgZG8uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdXBwb3J0c1NldFNvdXJjZVJlZmVyZW5jZXMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc291cmNlIHJlZiBlbGVtZW50cyBpbiB0aGUgdHJhbnN1bml0LlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMgZG9uZSBieSBuZy1leHRyYWN0LlxyXG4gICAgICogTWV0aG9kIG9ubHkgZXhpc3RzIHRvIGFsbG93IHhsaWZmbWVyZ2UgdG8gbWVyZ2UgbWlzc2luZyBzb3VyY2UgcmVmcy5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VSZWZzIHRoZSBzb3VyY2VyZWZzIHRvIHNldC4gT2xkIG9uZXMgYXJlIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldFNvdXJjZVJlZmVyZW5jZXMoc291cmNlUmVmczoge3NvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyfVtdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBzZXQgaW4gdGhlIHRlbXBsYXRlIGFzIHZhbHVlIG9mIHRoZSBpMThuLWF0dHJpYnV0ZS5cclxuICAgICAqIGUuZy4gaTE4bj1cIm15ZGVzY3JpcHRpb25cIi5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZGVzY3JpcHRpb24oKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1lYW5pbmcgKGludGVudCkgc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBwYXJ0IGluIGZyb250IG9mIHRoZSB8IHN5bWJvbC5cclxuICAgICAqIGUuZy4gaTE4bj1cIm1lYW5pbmd8bXlkZXNjcmlwdGlvblwiLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBtZWFuaW5nKCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciBzZXR0aW5nIG9mIGRlc2NyaXB0aW9uIGFuZCBtZWFuaW5nIGlzIHN1cHBvcnRlZC5cclxuICAgICAqIElmIG5vdCwgc2V0RGVzY3JpcHRpb24gYW5kIHNldE1lYW5pbmcgd2lsbCBkbyBub3RoaW5nLlxyXG4gICAgICogeHRiIGRvZXMgbm90IHN1cHBvcnQgdGhpcywgYWxsIG90aGVyIGZvcm1hdHMgZG8uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdXBwb3J0c1NldERlc2NyaXB0aW9uQW5kTWVhbmluZygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBkZXNjcmlwdGlvbiBwcm9wZXJ0eSBvZiB0cmFucy11bml0LlxyXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uIGRlc2NyaXB0aW9uXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIG1lYW5pbmcgcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSBtZWFuaW5nIG1lYW5pbmdcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc2V0TWVhbmluZyhtZWFuaW5nOiBzdHJpbmcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBub3RlcyBvZiB0aGUgdHJhbnMtdW5pdC5cclxuICAgICAqIE5vdGVzIGFyZSByZW1hcmtzIG1hZGUgYnkgYSB0cmFuc2xhdG9yLlxyXG4gICAgICogKGRlc2NyaXB0aW9uIGFuZCBtZWFuaW5nIGFyZSBub3QgaW5jbHVkZWQgaGVyZSEpXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IG5vdGVzKCk6IElOb3RlW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBub3RlcyBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldE5vdGVzIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzdXBwb3J0c1NldE5vdGVzKCk6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgbm90ZXMgdG8gdHJhbnMgdW5pdC5cclxuICAgICAqIEBwYXJhbSBuZXdOb3RlcyB0aGUgbm90ZXMgdG8gYWRkLlxyXG4gICAgICogQHRocm93cyBhbiBFcnJvciBpZiBhbnkgbm90ZSBjb250YWlucyBkZXNjcHJpcHRpb24gb3IgbWVhbmluZyBhcyBmcm9tIGF0dHJpYnV0ZS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc2V0Tm90ZXMobmV3Tm90ZXM6IElOb3RlW10pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgbm90ZXNcclxuICAgICAqIEBwYXJhbSBuZXdOb3RlcyB0aGUgbm90ZXMgdG8gYWRkLlxyXG4gICAgICogQHRocm93cyBhbiBFcnJvciBpZiBhbnkgbm90ZSBjb250YWlucyBkZXNjcmlwdGlvbiBvciBtZWFuaW5nIGFzIGZyb20gYXR0cmlidXRlLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY2hlY2tOb3RlcyhuZXdOb3RlczogSU5vdGVbXSkge1xyXG4gICAgICAgIC8vIGNoZWNrIGZyb20gdmFsdWVzXHJcbiAgICAgICAgY29uc3QgZXJyb3JJbkZyb21Ob3RlID0gbmV3Tm90ZXMuZmluZCgobm90ZSkgPT4gbm90ZS5mcm9tID09PSAnZGVzY3JpcHRpb24nIHx8IG5vdGUuZnJvbSA9PT0gJ21lYW5pbmcnKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGVycm9ySW5Gcm9tTm90ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXNjcmlwdGlvbiBvciBtZWFuaW5nIGFyZSBub3QgYWxsb3dlZCBhcyBmcm9tIGF0dHRyaWJ1dGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVhbCB4bWwgZWxlbWVudCB1c2VkIGZvciB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgbmV2ZXIgbmVlZCB0aGlzKVxyXG4gICAgICogQHJldHVybiByZWFsIHhtbCBlbGVtZW50IHVzZWQgZm9yIHRoZSB0cmFucyB1bml0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXNYbWxFbGVtZW50KCk6IEVsZW1lbnQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBzb3VyY2UgdG8gdGFyZ2V0IHRvIHVzZSBpdCBhcyBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqIFJldHVybnMgYSBjaGFuZ2VkIGNvcHkgb2YgdGhpcyB0cmFucyB1bml0LlxyXG4gICAgICogcmVjZWl2ZXIgaXMgbm90IGNoYW5nZWQuXHJcbiAgICAgKiAoaW50ZXJuYWwgdXNhZ2Ugb25seSwgYSBjbGllbnQgc2hvdWxkIGNhbGwgaW1wb3J0TmV3VHJhbnNVbml0IG9uIElUcmFuc2xhdGlvbk1lc3NhZ2VGaWxlKVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBjbG9uZVdpdGhTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbiwgdGFyZ2V0RmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTogQWJzdHJhY3RUcmFuc1VuaXQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHVzZVNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZSB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiB0aGUgdHJhbnNsYXRlZCBzdHJpbmcgb3IgKHByZWZlcnJlZCkgYSBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKiBUaGUgcHVyZSBzdHJpbmcgY2FuIGNvbnRhaW4gYW55IG1hcmt1cCBhbmQgd2lsbCBub3QgYmUgY2hlY2tlZC5cclxuICAgICAqIFNvIGl0IGNhbiBkYW1hZ2UgdGhlIGRvY3VtZW50LlxyXG4gICAgICogQSBub3JtYWxpemVkIG1lc3NhZ2UgcHJldmVudHMgdGhpcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZSh0cmFuc2xhdGlvbjogc3RyaW5nIHwgSU5vcm1hbGl6ZWRNZXNzYWdlKSB7XHJcbiAgICAgICAgbGV0IHRyYW5zbGF0aW9uTmF0aXZlOiBzdHJpbmc7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHRyYW5zbGF0aW9uKSkge1xyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbk5hdGl2ZSA9IDxzdHJpbmc+IHRyYW5zbGF0aW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uTmF0aXZlID0gKDxJTm9ybWFsaXplZE1lc3NhZ2U+IHRyYW5zbGF0aW9uKS5hc05hdGl2ZVN0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZU5hdGl2ZSh0cmFuc2xhdGlvbk5hdGl2ZSk7XHJcbiAgICAgICAgdGhpcy5zZXRUYXJnZXRTdGF0ZShTVEFURV9UUkFOU0xBVEVEKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHBhcnNlciB1c2VkIGZvciBub3JtYWxpemVkIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgbWVzc2FnZVBhcnNlcigpOiBBYnN0cmFjdE1lc3NhZ2VQYXJzZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgbWVzc2FnZSBsb29rcyBsaWtlIElDVSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZVxyXG4gICAgICogQHJldHVybiB3ZXRoZXIgbWVzc2FnZSBsb29rcyBsaWtlIElDVSBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJQ1VNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VQYXJzZXIoKS5pc0lDVU1lc3NhZ2VTdGFydChtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdHJhbnNsYXRpb24gdG8gYSBnaXZlbiBzdHJpbmcgKGluY2x1ZGluZyBtYXJrdXApLlxyXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uIHRyYW5zbGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCB0cmFuc2xhdGVOYXRpdmUodHJhbnNsYXRpb246IHN0cmluZyk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDA1LjA1LjIwMTcuXHJcbiAqIEEgcGFydCBvZiBhIHBhcnNlZCBtZXNzYWdlLlxyXG4gKiBDYW4gYmUgYSB0ZXh0LCBhIHBsYWNlaG9sZGVyLCBhIHRhZ1xyXG4gKi9cclxuXHJcbmV4cG9ydCBlbnVtIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZSB7XHJcbiAgICBURVhULFxyXG4gICAgUExBQ0VIT0xERVIsXHJcbiAgICBTVEFSVF9UQUcsXHJcbiAgICBFTkRfVEFHLFxyXG4gICAgRU1QVFlfVEFHLFxyXG4gICAgSUNVX01FU1NBR0UsXHJcbiAgICBJQ1VfTUVTU0FHRV9SRUZcclxufVxyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBhcnNlZE1lc3NhZ2VQYXJ0IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdHlwZTogUGFyc2VkTWVzc2FnZVBhcnRUeXBlKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXJ0LlxyXG4gICAgICogQHBhcmFtIGZvcm1hdCBvcHRpb25hbCB3YXkgdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBzeW50YXguXHJcbiAgICAgKiBBbGxvd2VkIGZvcm1hdHMgYXJlIGRlZmluZWQgYXMgY29uc3RhbnRzIE5PUk1BTElaQVRJT05fRk9STUFULi4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBhc0Rpc3BsYXlTdHJpbmcoZm9ybWF0Pzogc3RyaW5nKTogc3RyaW5nO1xyXG5cclxufVxyXG4iLCJpbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0LCBQYXJzZWRNZXNzYWdlUGFydFR5cGV9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwNS4wNS4yMDE3LlxyXG4gKiBBIG1lc3NhZ2UgcGFydCBjb25zaXN0aW5nIG9mIGp1c3Qgc2ltcGxlIHRleHQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFBhcnNlZE1lc3NhZ2VQYXJ0VGV4dCBleHRlbmRzIFBhcnNlZE1lc3NhZ2VQYXJ0IHtcclxuXHJcbiAgICBwcml2YXRlIHRleHQ6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0OiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihQYXJzZWRNZXNzYWdlUGFydFR5cGUuVEVYVCk7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXNEaXNwbGF5U3RyaW5nKGZvcm1hdD86IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydCwgUGFyc2VkTWVzc2FnZVBhcnRUeXBlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQnO1xyXG5pbXBvcnQge05PUk1BTElaQVRJT05fRk9STUFUX05HWFRSQU5TTEFURX0gZnJvbSAnLi4vYXBpL2NvbnN0YW50cyc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwNS4wNS4yMDE3LlxyXG4gKiBBIG1lc3NhZ2UgcGFydCBjb25zaXN0aW5nIG9mIGEgcGxhY2Vob2xkZXIuXHJcbiAqIFBsYWNlaG9sZGVycyBhcmUgbnVtYmVyZWQgZnJvbSAwIHRvIG4uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFBhcnNlZE1lc3NhZ2VQYXJ0UGxhY2Vob2xkZXIgZXh0ZW5kcyBQYXJzZWRNZXNzYWdlUGFydCB7XHJcblxyXG4gICAgLy8gaW5kZXggMCAuLiBuXHJcbiAgICBwcml2YXRlIF9pbmRleDogbnVtYmVyO1xyXG4gICAgLy8gb3B0aW9uYWwgZGlzcC1BdHRyaWJ1dGUgdmFsdWUsIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCBleHByZXNzaW9uLlxyXG4gICAgcHJpdmF0ZSBfZGlzcD86IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleDogbnVtYmVyLCBkaXNwOiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihQYXJzZWRNZXNzYWdlUGFydFR5cGUuUExBQ0VIT0xERVIpO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZGlzcCA9IGRpc3A7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzRGlzcGxheVN0cmluZyhmb3JtYXQ/OiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoZm9ybWF0ID09PSBOT1JNQUxJWkFUSU9OX0ZPUk1BVF9OR1hUUkFOU0xBVEUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd7eycgKyB0aGlzLl9pbmRleCArICd9fSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAne3snICsgdGhpcy5faW5kZXggKyAnfX0nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGluZGV4KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkaXNwKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3A7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydCwgUGFyc2VkTWVzc2FnZVBhcnRUeXBlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDUuMDUuMjAxNy5cclxuICogQSBtZXNzYWdlIHBhcnQgY29uc2lzdGluZyBvZiBhbiBvcGVuaW5nIHRhZyBsaWtlIDxiPiBvciA8c3RyYW5nZT4uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFBhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWcgZXh0ZW5kcyBQYXJzZWRNZXNzYWdlUGFydCB7XHJcblxyXG4gICAgcHJpdmF0ZSBfdGFnbmFtZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaWRjb3VudGVyOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IodGFnbmFtZTogc3RyaW5nLCBpZGNvdW50ZXI6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyKFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5TVEFSVF9UQUcpO1xyXG4gICAgICAgIHRoaXMuX3RhZ25hbWUgPSB0YWduYW1lO1xyXG4gICAgICAgIHRoaXMuX2lkY291bnRlciA9IGlkY291bnRlcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXNEaXNwbGF5U3RyaW5nKGZvcm1hdD86IHN0cmluZykge1xyXG4gICAgICAgIGlmICh0aGlzLl9pZGNvdW50ZXIgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuX3RhZ25hbWUgKyAnPic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuX3RhZ25hbWUgKyAnIGlkPVwiJyArIHRoaXMuX2lkY291bnRlci50b1N0cmluZygpICsgJ1wiPic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0YWdOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlkQ291bnRlcigpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pZGNvdW50ZXI7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydCwgUGFyc2VkTWVzc2FnZVBhcnRUeXBlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDUuMDUuMjAxNy5cclxuICogQSBtZXNzYWdlIHBhcnQgY29uc2lzdGluZyBvZiBhIGNsb3NpbmcgdGFnIGxpa2UgPC9iPiBvciA8L3N0cmFuZ2U+LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBQYXJzZWRNZXNzYWdlUGFydEVuZFRhZyBleHRlbmRzIFBhcnNlZE1lc3NhZ2VQYXJ0IHtcclxuXHJcbiAgICBwcml2YXRlIF90YWduYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IodGFnbmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIoUGFyc2VkTWVzc2FnZVBhcnRUeXBlLkVORF9UQUcpO1xyXG4gICAgICAgIHRoaXMuX3RhZ25hbWUgPSB0YWduYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc0Rpc3BsYXlTdHJpbmcoZm9ybWF0Pzogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuICc8LycgKyB0aGlzLl90YWduYW1lICsgJz4nO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0YWdOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ25hbWU7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCAqIGFzIFRva2VuaXpyIGZyb20gJ3Rva2VuaXpyJztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwNC4wNi4yMDE3LlxyXG4gKiBBIHRva2VuaXplciBmb3IgSUNVIG1lc3NhZ2VzLlxyXG4gKi9cclxuXHJcbi8vIFRva2Vuc1xyXG5leHBvcnQgY29uc3QgVEVYVCA9ICdURVhUJztcclxuZXhwb3J0IGNvbnN0IENVUkxZX0JSQUNFX09QRU4gPSAnQ1VSTFlfQlJBQ0VfT1BFTic7XHJcbmV4cG9ydCBjb25zdCBDVVJMWV9CUkFDRV9DTE9TRSA9ICdDVVJMWV9CUkFDRV9DTE9TRSc7XHJcbmV4cG9ydCBjb25zdCBDT01NQSA9ICdDT01NQSc7XHJcbmV4cG9ydCBjb25zdCBQTFVSQUwgPSAnUExVUkFMJztcclxuZXhwb3J0IGNvbnN0IFNFTEVDVCA9ICdTRUxFQ1QnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQ1VUb2tlbiB7XHJcbiAgICB0eXBlOiBzdHJpbmc7XHJcbiAgICB2YWx1ZTogYW55O1xyXG59XHJcblxyXG4vLyBzdGF0ZXM6IGRlZmF1bHQgbm9ybWFsIGluX21lc3NhZ2VcclxuY29uc3QgU1RBVEVfREVGQVVMVCA9ICdkZWZhdWx0JztcclxuY29uc3QgU1RBVEVfTk9STUFMID0gJ25vcm1hbCc7XHJcbmNvbnN0IFNUQVRFX0lOX01FU1NBR0UgPSAnaW5fbWVzc2FnZSc7XHJcblxyXG5leHBvcnQgY2xhc3MgSUNVTWVzc2FnZVRva2VuaXplciB7XHJcbiAgICBwcml2YXRlIGxleGVyOiBUb2tlbml6cjtcclxuXHJcbiAgICBwcml2YXRlIGdldExleGVyKCk6IFRva2VuaXpyIHtcclxuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBUb2tlbml6cigpO1xyXG4gICAgICAgIGxldCBwbGFpbnRleHQgPSAnJztcclxuICAgICAgICBsZXQgb3BlbmVkQ3VybHlCcmFjZXNJblRleHRDb3VudGVyID0gMDtcclxuICAgICAgICBsZXhlci5iZWZvcmUoKGN0eCwgbWF0Y2gsIHJ1bGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHJ1bGUubmFtZSAhPT0gVEVYVCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbnNOb25XaGl0ZVNwYWNlKHBsYWludGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguYWNjZXB0KFRFWFQsIHBsYWludGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhaW50ZXh0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5pZ25vcmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxleGVyLmZpbmlzaCgoY3R4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zTm9uV2hpdGVTcGFjZShwbGFpbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguYWNjZXB0KFRFWFQsIHBsYWludGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY3VybHkgYnJhY2VcclxuICAgICAgICBsZXhlci5ydWxlKFNUQVRFX0RFRkFVTFQsIC97LywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChDVVJMWV9CUkFDRV9PUEVOLCBtYXRjaFswXSk7XHJcbiAgICAgICAgICAgIGN0eC5wdXNoKFNUQVRFX05PUk1BTCk7XHJcbiAgICAgICAgfSwgQ1VSTFlfQlJBQ0VfT1BFTik7XHJcbiAgICAgICAgbGV4ZXIucnVsZShTVEFURV9OT1JNQUwsIC97LywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChDVVJMWV9CUkFDRV9PUEVOLCBtYXRjaFswXSk7XHJcbiAgICAgICAgICAgIGN0eC5wdXNoKFNUQVRFX0lOX01FU1NBR0UpO1xyXG4gICAgICAgIH0sIENVUkxZX0JSQUNFX09QRU4pO1xyXG4gICAgICAgIGxleGVyLnJ1bGUoU1RBVEVfTk9STUFMLCAvfS8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGN0eC5wb3AoKTtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChDVVJMWV9CUkFDRV9DTE9TRSwgbWF0Y2hbMF0pO1xyXG4gICAgICAgIH0sIENVUkxZX0JSQUNFX0NMT1NFKTtcclxuICAgICAgICAvLyBtYXNrZWQgJyB7IGFuZCB9XHJcbiAgICAgICAgbGV4ZXIucnVsZShTVEFURV9JTl9NRVNTQUdFLCAvJ1t7fV0/Jy8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaFswXSA9PT0gJ1xcJ1xcJycpIHtcclxuICAgICAgICAgICAgICAgIHBsYWludGV4dCArPSAnXFwnJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJ1xcJ3tcXCcnKSB7XHJcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgKz0gJ3snO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnXFwnfVxcJycpIHtcclxuICAgICAgICAgICAgICAgIHBsYWludGV4dCArPSAnfSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4Lmlnbm9yZSgpO1xyXG4gICAgICAgIH0sIFRFWFQpO1xyXG4gICAgICAgIGxleGVyLnJ1bGUoU1RBVEVfSU5fTUVTU0FHRSwgLy4vLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFyID0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAneycpIHtcclxuICAgICAgICAgICAgICAgIG9wZW5lZEN1cmx5QnJhY2VzSW5UZXh0Q291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0ICs9IG1hdGNoWzBdO1xyXG4gICAgICAgICAgICAgICAgY3R4Lmlnbm9yZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZW5lZEN1cmx5QnJhY2VzSW5UZXh0Q291bnRlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuZWRDdXJseUJyYWNlc0luVGV4dENvdW50ZXItLTtcclxuICAgICAgICAgICAgICAgICAgICBwbGFpbnRleHQgKz0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmlnbm9yZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHgucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFjY2VwdChURVhULCBwbGFpbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYWludGV4dCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5hY2NlcHQoQ1VSTFlfQlJBQ0VfQ0xPU0UsIG1hdGNoWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBsYWludGV4dCArPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgICAgIGN0eC5pZ25vcmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFRFWFQpO1xyXG4gICAgICAgIC8vIGNvbW1hXHJcbiAgICAgICAgbGV4ZXIucnVsZShTVEFURV9OT1JNQUwsIC8sLywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChDT01NQSwgbWF0Y2hbMF0pO1xyXG4gICAgICAgIH0sIENPTU1BKTtcclxuICAgICAgICAvLyBrZXl3b3JkcyBwbHVyYWwgYW5kIHNlbGVjdFxyXG4gICAgICAgIGxleGVyLnJ1bGUoU1RBVEVfTk9STUFMLCAvcGx1cmFsLywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChQTFVSQUwsIG1hdGNoWzBdKTtcclxuICAgICAgICB9LCBQTFVSQUwpO1xyXG4gICAgICAgIGxleGVyLnJ1bGUoU1RBVEVfTk9STUFMLCAvc2VsZWN0LywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChTRUxFQ1QsIG1hdGNoWzBdKTtcclxuICAgICAgICB9LCBTRUxFQ1QpO1xyXG4gICAgICAgIC8vIHRleHRcclxuICAgICAgICBsZXhlci5ydWxlKC8uLywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgcGxhaW50ZXh0ICs9IG1hdGNoWzBdO1xyXG4gICAgICAgICAgICBjdHguaWdub3JlKCk7XHJcbiAgICAgICAgfSwgVEVYVCk7XHJcbiAgICAgICAgbGV4ZXIucnVsZSgvW1xcc10rLywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgcGxhaW50ZXh0ICs9IG1hdGNoWzBdO1xyXG4gICAgICAgICAgICBjdHguaWdub3JlKCk7XHJcbiAgICAgICAgfSwgVEVYVCk7XHJcbiAgICAgICAgcmV0dXJuIGxleGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29udGFpbnNOb25XaGl0ZVNwYWNlKHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIS9cXHMvLnRlc3QodGV4dC5jaGFyQXQoaSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdG9rZW5pemUobm9ybWFsaXplZE1lc3NhZ2U6IHN0cmluZyk6IElDVVRva2VuW10ge1xyXG4gICAgICAgIGNvbnN0IGxleGVyOiBUb2tlbml6ciA9IHRoaXMuZ2V0TGV4ZXIoKTtcclxuICAgICAgICBsZXhlci5pbnB1dChub3JtYWxpemVkTWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuIGxleGVyLnRva2VucygpO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0KG5vcm1hbGl6ZWRNZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmxleGVyID0gdGhpcy5nZXRMZXhlcigpO1xyXG4gICAgICAgIHRoaXMubGV4ZXIuaW5wdXQobm9ybWFsaXplZE1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIG5leHQoKTogSUNVVG9rZW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxleGVyLnRva2VuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcGVlaygpOiBJQ1VUb2tlbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGV4ZXIucGVlaygpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7SUlDVU1lc3NhZ2UsIElJQ1VNZXNzYWdlQ2F0ZWdvcnksIElJQ1VNZXNzYWdlVHJhbnNsYXRpb24sIElOb3JtYWxpemVkTWVzc2FnZX0gZnJvbSAnLi4vYXBpL2luZGV4JztcclxuaW1wb3J0IHtmb3JtYXQsIGlzTnVsbE9yVW5kZWZpbmVkLCBpc1N0cmluZ30gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7SU1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vaS1tZXNzYWdlLXBhcnNlcic7XHJcblxyXG5jbGFzcyBNZXNzYWdlQ2F0ZWdvcnkgaW1wbGVtZW50cyBJSUNVTWVzc2FnZUNhdGVnb3J5IHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jYXRlZ29yeTogc3RyaW5nLCBwcml2YXRlIF9tZXNzYWdlOiBJTm9ybWFsaXplZE1lc3NhZ2UpIHt9XHJcblxyXG4gICAgcHVibGljIGdldENhdGVnb3J5KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhdGVnb3J5O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNZXNzYWdlTm9ybWFsaXplZCgpOiBJTm9ybWFsaXplZE1lc3NhZ2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgYW4gSUNVIE1lc3NhZ2UuXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDA1LjA2LjIwMTcuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSUNVTWVzc2FnZSBpbXBsZW1lbnRzIElJQ1VNZXNzYWdlIHtcclxuXHJcbiAgICBwcml2YXRlIF9pc1BsdXJhbE1lc3NhZ2U6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBfY2F0ZWdvcmllczogSUlDVU1lc3NhZ2VDYXRlZ29yeVtdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BhcnNlcjogSU1lc3NhZ2VQYXJzZXIsIGlzUGx1cmFsTWVzc2FnZTogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX2lzUGx1cmFsTWVzc2FnZSA9IGlzUGx1cmFsTWVzc2FnZTtcclxuICAgICAgICB0aGlzLl9jYXRlZ29yaWVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgYWRkQ2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZywgbWVzc2FnZTogSU5vcm1hbGl6ZWRNZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcy5wdXNoKG5ldyBNZXNzYWdlQ2F0ZWdvcnkoY2F0ZWdvcnksIG1lc3NhZ2UpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElDVSBtZXNzYWdlIGFzIG5hdGl2ZSBzdHJpbmcuXHJcbiAgICAgKiBUaGlzIGlzLCBob3cgaXQgaXMgc3RvcmVkLCBzb21ldGhpbmcgbGlrZSAne3gsIHBsdXJhbCwgPTAgey4ufSdcclxuICAgICAqIEByZXR1cm4gSUNVIG1lc3NhZ2UgYXMgbmF0aXZlIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzTmF0aXZlU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgdmFybmFtZSA9ICh0aGlzLmlzUGx1cmFsTWVzc2FnZSgpKSA/ICdWQVJfUExVUkFMJyA6ICdWQVJfU0VMRUNUJztcclxuICAgICAgICBjb25zdCB0eXBlID0gKHRoaXMuaXNQbHVyYWxNZXNzYWdlKCkpID8gJ3BsdXJhbCcgOiAnc2VsZWN0JztcclxuICAgICAgICBsZXQgY2hvaWNlU3RyaW5nID0gJyc7XHJcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeTogSUlDVU1lc3NhZ2VDYXRlZ29yeSkgPT4ge1xyXG4gICAgICAgICAgICBjaG9pY2VTdHJpbmcgPSBjaG9pY2VTdHJpbmcgKyBmb3JtYXQoJyAlcyB7JXN9JywgY2F0ZWdvcnkuZ2V0Q2F0ZWdvcnkoKSwgY2F0ZWdvcnkuZ2V0TWVzc2FnZU5vcm1hbGl6ZWQoKS5hc05hdGl2ZVN0cmluZygpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm9ybWF0KCd7JXMsICVzLCVzfScsIHZhcm5hbWUsIHR5cGUsIGNob2ljZVN0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyBpdCBhIHBsdXJhbCBtZXNzYWdlP1xyXG4gICAgICovXHJcbiAgICBpc1BsdXJhbE1lc3NhZ2UoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGx1cmFsTWVzc2FnZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElzIGl0IGEgc2VsZWN0IG1lc3NhZ2U/XHJcbiAgICAgKi9cclxuICAgIGlzU2VsZWN0TWVzc2FnZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX2lzUGx1cmFsTWVzc2FnZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgcGFydHMgb2YgdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBFLmcuIHRoZSBJQ1UgbWVzc2FnZSB7d29sdmVzLCBwbHVyYWwsID0wIHtubyB3b2x2ZXN9ID0xIHtvbmUgd29sZn0gPTIge3R3byB3b2x2ZXN9IG90aGVyIHthIHdvbGYgcGFja319XHJcbiAgICAgKiBoYXMgNCBjYXRlZ29yeSBvYmplY3RzIHdpdGggdGhlIGNhdGVnb3JpZXMgPTAsID0xLCA9Miwgb3RoZXIuXHJcbiAgICAgKi9cclxuICAgIGdldENhdGVnb3JpZXMoKTogSUlDVU1lc3NhZ2VDYXRlZ29yeVtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcmllcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZSBtZXNzYWdlIGFuZCByZXR1cm4gYSBuZXcsIHRyYW5zbGF0ZWQgbWVzc2FnZVxyXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uIHRoZSB0cmFuc2xhdGlvbiAoaGFzaG1hcCBvZiBjYXRlZ29yaWVzIGFuZCB0cmFuc2xhdGlvbnMpLlxyXG4gICAgICogQHJldHVybiBuZXcgbWVzc2FnZSB3aXQgdHJhbnNsYXRlZCBjb250ZW50LlxyXG4gICAgICogQHRocm93cyBhbiBlcnJvciBpZiB0cmFuc2xhdGlvbiBkb2VzIG5vdCBtYXRjaCB0aGUgbWVzc2FnZS5cclxuICAgICAqIFRoaXMgaXMgdGhlIGNhc2UsIGlmIHRoZXJlIGFyZSBjYXRlZ29yaWVzIG5vdCBjb250YWluZWQgaW4gdGhlIG9yaWdpbmFsIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZSh0cmFuc2xhdGlvbjogSUlDVU1lc3NhZ2VUcmFuc2xhdGlvbik6IElJQ1VNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IElDVU1lc3NhZ2UodGhpcy5fcGFyc2VyLCB0aGlzLmlzUGx1cmFsTWVzc2FnZSgpKTtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGVkQ2F0ZWdvcmllczogU2V0PHN0cmluZz4gPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICB0aGlzLl9jYXRlZ29yaWVzLmZvckVhY2goKGNhdGVnb3J5KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2xhdGVkTWVzc2FnZTogSU5vcm1hbGl6ZWRNZXNzYWdlO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGlvbkZvckNhdGVnb3J5OiBzdHJpbmd8SUlDVU1lc3NhZ2VUcmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uW2NhdGVnb3J5LmdldENhdGVnb3J5KCldO1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodHJhbnNsYXRpb25Gb3JDYXRlZ29yeSkpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRNZXNzYWdlID0gY2F0ZWdvcnkuZ2V0TWVzc2FnZU5vcm1hbGl6ZWQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh0cmFuc2xhdGlvbkZvckNhdGVnb3J5KSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZENhdGVnb3JpZXMuYWRkKGNhdGVnb3J5LmdldENhdGVnb3J5KCkpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZE1lc3NhZ2UgPSB0aGlzLl9wYXJzZXIucGFyc2VOb3JtYWxpemVkU3RyaW5nKDxzdHJpbmc+IHRyYW5zbGF0aW9uRm9yQ2F0ZWdvcnksIG51bGwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBlbWJlZGRlZCBJQ1UgTWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZE1lc3NhZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1lc3NhZ2UuYWRkQ2F0ZWdvcnkoY2F0ZWdvcnkuZ2V0Q2F0ZWdvcnkoKSwgdHJhbnNsYXRlZE1lc3NhZ2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIG5ldyBjYXRlZ29yaWVzLCB3aGljaCBhcmUgbm90IHBhcnQgb2YgdGhlIG9yaWdpbmFsIG1lc3NhZ2VcclxuICAgICAgICBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbikuZm9yRWFjaCgoY2F0ZWdvcnlOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdHJhbnNsYXRlZENhdGVnb3JpZXMuaGFzKGNhdGVnb3J5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0TWVzc2FnZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnYWRkaW5nIGEgbmV3IGNhdGVnb3J5IG5vdCBhbGxvd2VkIGZvciBzZWxlY3QgbWVzc2FnZXMgKFwiJXNcIiBpcyBub3QgcGFydCBvZiBtZXNzYWdlKScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5TmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVmFsaWRQbHVyYWxDYXRlZ29yeShjYXRlZ29yeU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZW1iZWRkZWQgSUNVIE1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNsYXRlZE1lc3NhZ2UgPSB0aGlzLl9wYXJzZXIucGFyc2VOb3JtYWxpemVkU3RyaW5nKDxzdHJpbmc+IHRyYW5zbGF0aW9uW2NhdGVnb3J5TmFtZV0sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkQ2F0ZWdvcnkoY2F0ZWdvcnlOYW1lLCB0cmFuc2xhdGVkTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrLCB3ZXRoZXIgY2F0ZWdvcnkgaXMgdmFsaWQgcGx1cmFsIGNhdGVnb3J5LlxyXG4gICAgICogQWxsb3dlZCBhcmUgPW4sICd6ZXJvJywgJ29uZScsICd0d28nLCAnZmV3JywgJ21hbnknIGFuZCAnb3RoZXInXHJcbiAgICAgKiBAcGFyYW0gY2F0ZWdvcnlOYW1lIGNhdGVnb3J5XHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yLCBpZiBpdCBpcyBub3QgYSB2YWxpZCBjYXRlZ29yeSBuYW1lXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tWYWxpZFBsdXJhbENhdGVnb3J5KGNhdGVnb3J5TmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgYWxsb3dlZEtleXdvcmRzID0gWyd6ZXJvJywgJ29uZScsICd0d28nLCAnZmV3JywgJ21hbnknLCAnb3RoZXInXTtcclxuICAgICAgICBpZiAoY2F0ZWdvcnlOYW1lLm1hdGNoKC89XFxkKy8pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsbG93ZWRLZXl3b3Jkcy5maW5kKChrZXkpID0+IGtleSA9PT0gY2F0ZWdvcnlOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ2ludmFsaWQgcGx1cmFsIGNhdGVnb3J5IFwiJXNcIiwgYWxsb3dlZCBhcmUgPTxuPiBhbmQgJXMnLCBjYXRlZ29yeU5hbWUsIGFsbG93ZWRLZXl3b3JkcykpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnQsIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuaW1wb3J0IHtJSUNVTWVzc2FnZSwgSU5vcm1hbGl6ZWRNZXNzYWdlfSBmcm9tICcuLi9hcGkvaW5kZXgnO1xyXG5pbXBvcnQge1xyXG4gICAgQ09NTUEsIENVUkxZX0JSQUNFX0NMT1NFLCBDVVJMWV9CUkFDRV9PUEVOLCBJQ1VNZXNzYWdlVG9rZW5pemVyLCBJQ1VUb2tlbiwgUExVUkFMLCBTRUxFQ1QsXHJcbiAgICBURVhUXHJcbn0gZnJvbSAnLi9pY3UtbWVzc2FnZS10b2tlbml6ZXInO1xyXG5pbXBvcnQge0lDVU1lc3NhZ2V9IGZyb20gJy4vaWN1LW1lc3NhZ2UnO1xyXG5pbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7SU1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vaS1tZXNzYWdlLXBhcnNlcic7XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDIuMDYuMjAxNy5cclxuICogQSBtZXNzYWdlIHBhcnQgY29uc2lzdGluZyBvZiBhbiBpY3UgbWVzc2FnZS5cclxuICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGljdSBtZXNzYWdlIGluIGEgcGFyc2VkIG1lc3NhZ2UuXHJcbiAqIFN5bnRheCBvZiBJQ1UgbWVzc2FnZSBpcyAneycgPGtleW5hbWU+ICcsJyAnc2VsZWN0J3wncGx1cmFsJyAnLCcgKDxjYXRlZ29yeT4gJ3snIHRleHQgJ30nKSsgJ30nXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZSBleHRlbmRzIFBhcnNlZE1lc3NhZ2VQYXJ0IHtcclxuXHJcbiAgICBwcml2YXRlIF9tZXNzYWdlOiBJQ1VNZXNzYWdlO1xyXG4gICAgcHJpdmF0ZSBfbWVzc2FnZVRleHQ6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3Rva2VuaXplcjogSUNVTWVzc2FnZVRva2VuaXplcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpY3VNZXNzYWdlVGV4dDogc3RyaW5nLCBwcml2YXRlIF9wYXJzZXI6IElNZXNzYWdlUGFyc2VyKSB7XHJcbiAgICAgICAgc3VwZXIoUGFyc2VkTWVzc2FnZVBhcnRUeXBlLklDVV9NRVNTQUdFKTtcclxuICAgICAgICBpZiAoaWN1TWVzc2FnZVRleHQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZUlDVU1lc3NhZ2UoaWN1TWVzc2FnZVRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3Qgd2V0aGVyIHRleHQgbWlnaHQgYmUgYW4gSUNVIG1lc3NhZ2UuXHJcbiAgICAgKiBTaG91bGQgYXQgbGVhc3Qgc3RhcnQgd2l0aCBzb21ldGhpbmcgbGlrZSAnezxuYW1lPiwgc2VsZWN0LCAuLicgb3IgJ3s8bmFtZT4sIHBsdXJhbCwgLi4uJ1xyXG4gICAgICogQHBhcmFtIGljdU1lc3NhZ2VUZXh0IGljdU1lc3NhZ2VUZXh0XHJcbiAgICAgKiBAcmV0dXJuIHdldGhlciB0ZXh0IG1pZ2h0IGJlIGFuIElDVSBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbG9va3NMaWtlSUNVTWVzc2FnZShpY3VNZXNzYWdlVGV4dDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgcGFydCA9IG5ldyBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2UobnVsbCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnQubG9va3NMaWtlSUNVTWVzc2FnZShpY3VNZXNzYWdlVGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzRGlzcGxheVN0cmluZyhkaXNwbGF5Rm9ybWF0Pzogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuICc8SUNVLU1lc3NhZ2UvPic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdGhlIHBhcnNlZCBtZXNzYWdlLlxyXG4gICAgICogQHJldHVybiBwYXJzZWQgbWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SUNVTWVzc2FnZSgpOiBJSUNVTWVzc2FnZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSB0aGUgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSB0ZXh0IG1lc3NhZ2UgdGV4dCB0byBwYXJzZVxyXG4gICAgICogQHRocm93cyBhbiBlcnJvciBpZiB0aGUgc3ludGF4IGlzIG5vdCBvayBpbiBhbnkgd2F5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcnNlSUNVTWVzc2FnZSh0ZXh0OiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnbWVzc2FnZSAnLCB0ZXh0KTtcclxuICAgICAgICAvLyBjb25zdCB0b2tlbnMgPSBuZXcgSUNVTWVzc2FnZVRva2VuaXplcigpLnRva2VuaXplKHRleHQpO1xyXG4gICAgICAgIC8vIHRva2Vucy5mb3JFYWNoKCh0b2spID0+IHtcclxuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ1Rva2VuJywgdG9rLnR5cGUsIHRvay52YWx1ZSk7XHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZVRleHQgPSB0ZXh0O1xyXG4gICAgICAgIHRoaXMuX3Rva2VuaXplciA9IG5ldyBJQ1VNZXNzYWdlVG9rZW5pemVyKCk7XHJcbiAgICAgICAgdGhpcy5fdG9rZW5pemVyLmlucHV0KHRleHQpO1xyXG4gICAgICAgIHRoaXMuZXhwZWN0TmV4dChDVVJMWV9CUkFDRV9PUEVOKTtcclxuICAgICAgICB0aGlzLmV4cGVjdE5leHQoVEVYVCk7IC8vIHZhcm5hbWUsIG5vdCB1c2VkIGN1cnJlbnRseSwgbmcgYWx3YXlzIHVzZWQgVkFSX1BMVVJBTCBvciBWQVJfU0VMRUNUXHJcbiAgICAgICAgdGhpcy5leHBlY3ROZXh0KENPTU1BKTtcclxuICAgICAgICBsZXQgdG9rZW46IElDVVRva2VuID0gdGhpcy5fdG9rZW5pemVyLm5leHQoKTtcclxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gUExVUkFMKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2UgPSBuZXcgSUNVTWVzc2FnZSh0aGlzLl9wYXJzZXIsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gU0VMRUNUKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2UgPSBuZXcgSUNVTWVzc2FnZSh0aGlzLl9wYXJzZXIsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5leHBlY3ROZXh0KENPTU1BKTtcclxuICAgICAgICB0b2tlbiA9IHRoaXMuX3Rva2VuaXplci5wZWVrKCk7XHJcbiAgICAgICAgd2hpbGUgKHRva2VuLnR5cGUgIT09IENVUkxZX0JSQUNFX0NMT1NFKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gdGhpcy5leHBlY3ROZXh0KFRFWFQpLnZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgdGhpcy5leHBlY3ROZXh0KENVUkxZX0JSQUNFX09QRU4pO1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5leHBlY3ROZXh0KFRFWFQpLnZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlLmFkZENhdGVnb3J5KGNhdGVnb3J5LCB0aGlzLnBhcnNlTmF0aXZlU3ViTWVzc2FnZShtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0TmV4dChDVVJMWV9CUkFDRV9DTE9TRSk7XHJcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5fdG9rZW5pemVyLnBlZWsoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5leHBlY3ROZXh0KENVUkxZX0JSQUNFX0NMT1NFKTtcclxuICAgICAgICB0aGlzLmV4cGVjdE5leHQoJ0VPRicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgdGhlIG1lc3NhZ2UgdG8gY2hlY2ssIHdldGhlciBpdCBtaWdodCBiZSBhbiBJQ1UgbWVzc2FnZS5cclxuICAgICAqIFNob3VsZCBhdCBsZWFzdCBzdGFydCB3aXRoIHNvbWV0aGluZyBsaWtlICd7PG5hbWU+LCBzZWxlY3QsIC4uJyBvciAnezxuYW1lPiwgcGx1cmFsLCAuLi4nXHJcbiAgICAgKiBAcGFyYW0gdGV4dCBtZXNzYWdlIHRleHQgdG8gcGFyc2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb29rc0xpa2VJQ1VNZXNzYWdlKHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdtZXNzYWdlICcsIHRleHQpO1xyXG4gICAgICAgIC8vIGNvbnN0IHRva2VucyA9IG5ldyBJQ1VNZXNzYWdlVG9rZW5pemVyKCkudG9rZW5pemUodGV4dCk7XHJcbiAgICAgICAgLy8gdG9rZW5zLmZvckVhY2goKHRvaykgPT4ge1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZygnVG9rZW4nLCB0b2sudHlwZSwgdG9rLnZhbHVlKTtcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICB0aGlzLl90b2tlbml6ZXIgPSBuZXcgSUNVTWVzc2FnZVRva2VuaXplcigpO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuaXplci5pbnB1dCh0ZXh0KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdE5leHQoQ1VSTFlfQlJBQ0VfT1BFTik7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0TmV4dChURVhUKTsgLy8gdmFybmFtZSwgbm90IHVzZWQgY3VycmVudGx5LCBuZyBhbHdheXMgdXNlZCBWQVJfUExVUkFMIG9yIFZBUl9TRUxFQ1RcclxuICAgICAgICAgICAgdGhpcy5leHBlY3ROZXh0KENPTU1BKTtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW46IElDVVRva2VuID0gdGhpcy5fdG9rZW5pemVyLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFBMVVJBTCAmJiB0b2tlbi50eXBlICE9PSBTRUxFQ1QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdE5leHQoQ09NTUEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBuZXh0IHRva2VuIGFuZCBleHBlY3QsIHRoYXQgaXQgaXMgb2YgdGhlIGdpdmVuIHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gdG9rZW50eXBlIGV4cGVjdGVkIHR5cGUuXHJcbiAgICAgKiBAcmV0dXJuIFRva2VuXHJcbiAgICAgKiBAdGhyb3dzIGVycm9yLCBpZiBuZXh0IHRva2VuIGhhcyB3cm9uZyB0eXBlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGV4cGVjdE5leHQodG9rZW50eXBlOiBzdHJpbmcpOiBJQ1VUb2tlbiB7XHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLl90b2tlbml6ZXIubmV4dCgpO1xyXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSB0b2tlbnR5cGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRXJyb3IgcGFyc2luZyBJQ1UgTWVzc2FnZTogZXhwZWN0ZWQgJXMsIGZvdW5kICVzICglcykgKG1lc3NhZ2UgJXMpJyxcclxuICAgICAgICAgICAgICAgIHRva2VudHlwZSwgdG9rZW4udHlwZSwgdG9rZW4udmFsdWUsIHRoaXMuX21lc3NhZ2VUZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIFhNTCB0ZXh0IHRvIG5vcm1hbGl6ZWQgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2UgaW4gZm9ybWF0IGRlcGVuZGVudCB4bWwgc3ludGF4LlxyXG4gICAgICogQHJldHVybiBub3JtYWxpemVkIG1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXJzZU5hdGl2ZVN1Yk1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogSU5vcm1hbGl6ZWRNZXNzYWdlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VyLmNyZWF0ZU5vcm1hbGl6ZWRNZXNzYWdlRnJvbVhNTFN0cmluZyhtZXNzYWdlLCBudWxsKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0LCBQYXJzZWRNZXNzYWdlUGFydFR5cGV9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydCc7XHJcbmltcG9ydCB7Tk9STUFMSVpBVElPTl9GT1JNQVRfTkdYVFJBTlNMQVRFfSBmcm9tICcuLi9hcGkvY29uc3RhbnRzJztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDA1LjA1LjIwMTcuXHJcbiAqIEEgcmVmZXJlbmNlIHRvIGFuIElDVSBtZXNzYWdlXHJcbiAqIGljdSByZWZlcmVuY2VzIGFyZSBudW1iZXJlZCBmcm9tIDAgdG8gbi5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgUGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlUmVmIGV4dGVuZHMgUGFyc2VkTWVzc2FnZVBhcnQge1xyXG5cclxuICAgIC8vIGluZGV4IDAgLi4gblxyXG4gICAgcHJpdmF0ZSBfaW5kZXg6IG51bWJlcjtcclxuICAgIC8vIG9wdGlvbmFsIGRpc3AtQXR0cmlidXRlIHZhbHVlLCBjb250YWlucyB0aGUgb3JpZ2luYWwgZXhwcmVzc2lvbi5cclxuICAgIHByaXZhdGUgX2Rpc3A/OiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoaW5kZXg6IG51bWJlciwgZGlzcDogc3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIoUGFyc2VkTWVzc2FnZVBhcnRUeXBlLklDVV9NRVNTQUdFX1JFRik7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9kaXNwID0gZGlzcDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXNEaXNwbGF5U3RyaW5nKGZvcm1hdD86IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiAnPElDVS1NZXNzYWdlLVJlZl8nICsgdGhpcy5faW5kZXggKyAnLz4nO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbmRleCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGlzcCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnQsIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDE0LjA2LjIwMTcuXHJcbiAqIEEgbWVzc2FnZSBwYXJ0IGNvbnNpc3Rpbmcgb2YgYW4gZW1wdHkgdGFnIGxpa2UgPGJyLz4uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFBhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWcgZXh0ZW5kcyBQYXJzZWRNZXNzYWdlUGFydCB7XHJcblxyXG4gICAgcHJpdmF0ZSBfdGFnbmFtZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaWRjb3VudGVyOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IodGFnbmFtZTogc3RyaW5nLCBpZGNvdW50ZXI6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyKFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5FTVBUWV9UQUcpO1xyXG4gICAgICAgIHRoaXMuX3RhZ25hbWUgPSB0YWduYW1lO1xyXG4gICAgICAgIHRoaXMuX2lkY291bnRlciA9IGlkY291bnRlcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXNEaXNwbGF5U3RyaW5nKGZvcm1hdD86IHN0cmluZykge1xyXG4gICAgICAgIGlmICh0aGlzLl9pZGNvdW50ZXIgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuX3RhZ25hbWUgKyAnPic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuX3RhZ25hbWUgKyAnIGlkPVwiJyArIHRoaXMuX2lkY291bnRlci50b1N0cmluZygpICsgJ1wiPic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0YWdOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlkQ291bnRlcigpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pZGNvdW50ZXI7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydCwgUGFyc2VkTWVzc2FnZVBhcnRUeXBlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0VGV4dH0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXRleHQnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0UGxhY2Vob2xkZXJ9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1wbGFjZWhvbGRlcic7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZ30gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXN0YXJ0LXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRFbmRUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1lbmQtdGFnJztcclxuaW1wb3J0IHtJTm9ybWFsaXplZE1lc3NhZ2UsIFZhbGlkYXRpb25FcnJvcnN9IGZyb20gJy4uL2FwaS9pLW5vcm1hbGl6ZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7RE9NVXRpbGl0aWVzfSBmcm9tICcuL2RvbS11dGlsaXRpZXMnO1xyXG5pbXBvcnQge0lNZXNzYWdlUGFyc2VyfSBmcm9tICcuL2ktbWVzc2FnZS1wYXJzZXInO1xyXG5pbXBvcnQge2Zvcm1hdCwgaXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0lJQ1VNZXNzYWdlLCBJSUNVTWVzc2FnZVRyYW5zbGF0aW9ufSBmcm9tICcuLi9hcGkvaS1pY3UtbWVzc2FnZSc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtaWN1LW1lc3NhZ2UnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZn0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LWljdS1tZXNzYWdlLXJlZic7XHJcbmltcG9ydCB7SUNVTWVzc2FnZX0gZnJvbSAnLi9pY3UtbWVzc2FnZSc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRFbXB0eVRhZ30gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LWVtcHR5LXRhZyc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwNS4wNS4yMDE3LlxyXG4gKiBBIG1lc3NhZ2UgdGV4dCByZWFkIGZyb20gYSB0cmFuc2xhdGlvbiBmaWxlLlxyXG4gKiBDYW4gY29udGFpbiBwbGFjZWhvbGRlcnMsIHRhZ3MsIHRleHQuXHJcbiAqIFRoaXMgY2xhc3MgaXMgYSByZXByZXNlbnRhdGlvbiBpbmRlcGVuZGVudCBvZiB0aGUgY29uY3JldGUgZm9ybWF0LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBhcnNlZE1lc3NhZ2UgaW1wbGVtZW50cyBJTm9ybWFsaXplZE1lc3NhZ2Uge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VyIHRoYXQgY3JlYXRlZCB0aGlzIG1lc3NhZ2UgKGRldGVybWluZXMgdGhlIG5hdGl2ZSBmb3JtYXQpLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9wYXJzZXI6IElNZXNzYWdlUGFyc2VyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1lc3NhZ2Ugd2hlcmUgdGhpcyBvbmUgc3RlbXMgZnJvbSBhcyB0cmFuc2xhdGlvbi5cclxuICAgICAqIE9wdGlvbmFsLCBzZXQgb25seSBmb3IgbWVzc2FnZXMgY3JlYXRlZCBieSBjYWxsaW5nIHRyYW5zbGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzb3VyY2VNZXNzYWdlOiBQYXJzZWRNZXNzYWdlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhcnRzIG9mIHRoZSBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9wYXJ0czogUGFyc2VkTWVzc2FnZVBhcnRbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIG1lc3NhZ2VzIHhtbCByZXByZXNlbnRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfeG1sUmVwcmVzZW50YXRpb246IEVsZW1lbnQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyc2VyOiBJTWVzc2FnZVBhcnNlciwgc291cmNlTWVzc2FnZTogUGFyc2VkTWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMuX3BhcnNlciA9IHBhcnNlcjtcclxuICAgICAgICB0aGlzLnNvdXJjZU1lc3NhZ2UgPSBzb3VyY2VNZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuX3BhcnRzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHBhcnNlciAoZm9yIHRlc3RzIG9ubHksIG5vdCBwYXJ0IG9mIEFQSSlcclxuICAgICAqIEByZXR1cm4gcGFyc2VyXHJcbiAgICAgKi9cclxuICAgIGdldFBhcnNlcigpOiBJTWVzc2FnZVBhcnNlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBub3JtYWxpemVkIG1lc3NhZ2UgYXMgYSB0cmFuc2xhdGlvbiBvZiB0aGlzIG9uZS5cclxuICAgICAqIEBwYXJhbSBub3JtYWxpemVkU3RyaW5nIHRoZSB0cmFuc2xhdGlvbiBpbiBub3JtYWxpemVkIGZvcm0uXHJcbiAgICAgKiBJZiB0aGUgbWVzc2FnZSBpcyBhbiBJQ1VNZXNzYWdlIChnZXRJQ1VNZXNzYWdlIHJldHVybnMgYSB2YWx1ZSksIHVzZSB0cmFuc2xhdGVJQ1VNZXNzYWdlIGluc3RlYWQuXHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yIGlmIG5vcm1hbGl6ZWQgc3RyaW5nIGlzIG5vdCB3ZWxsIGZvcm1lZC5cclxuICAgICAqIFRocm93cyBhbiBlcnJvciB0b28sIGlmIHRoaXMgaXMgYW4gSUNVIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZShub3JtYWxpemVkU3RyaW5nOiBzdHJpbmcpOiBJTm9ybWFsaXplZE1lc3NhZ2Uge1xyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh0aGlzLmdldElDVU1lc3NhZ2UoKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlci5wYXJzZU5vcm1hbGl6ZWRTdHJpbmcoPHN0cmluZz4gbm9ybWFsaXplZFN0cmluZywgdGhpcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnY2Fubm90IHRyYW5zbGF0ZSBJQ1UgbWVzc2FnZSB3aXRoIHNpbXBsZSBzdHJpbmcsIHVzZSB0cmFuc2xhdGVJQ1VNZXNzYWdlKCkgaW5zdGVhZCAoXCIlc1wiLCBcIiVzXCIpJyxcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRTdHJpbmcsIHRoaXMuYXNOYXRpdmVTdHJpbmcoKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBub3JtYWxpemVkIGljdSBtZXNzYWdlIGFzIGEgdHJhbnNsYXRpb24gb2YgdGhpcyBvbmUuXHJcbiAgICAgKiBAcGFyYW0gaWN1VHJhbnNsYXRpb24gdGhlIHRyYW5zbGF0aW9uLCB0aGlzIGlzIHRoZSB0cmFuc2xhdGlvbiBvZiB0aGUgSUNVIG1lc3NhZ2UsXHJcbiAgICAgKiB3aGljaCBpcyBub3QgYSBzdHJpbmcsIGJ1dCBhIGNvbGxlY3Rpb25zIG9mIHRoZSB0cmFuc2xhdGlvbnMgb2YgdGhlIGRpZmZlcmVudCBjYXRlZ29yaWVzLlxyXG4gICAgICogVGhlIG1lc3NhZ2UgbXVzdCBiZSBhbiBJQ1VNZXNzYWdlIChnZXRJQ1VNZXNzYWdlIHJldHVybnMgYSB2YWx1ZSlcclxuICAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgbm9ybWFsaXplZCBzdHJpbmcgaXMgbm90IHdlbGwgZm9ybWVkLlxyXG4gICAgICogVGhyb3dzIGFuIGVycm9yIHRvbywgaWYgdGhpcyBpcyBub3QgYW4gSUNVIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZUlDVU1lc3NhZ2UoaWN1VHJhbnNsYXRpb246IElJQ1VNZXNzYWdlVHJhbnNsYXRpb24pOiBJTm9ybWFsaXplZE1lc3NhZ2Uge1xyXG4gICAgICAgIGNvbnN0IGljdU1lc3NhZ2U6IElJQ1VNZXNzYWdlID0gdGhpcy5nZXRJQ1VNZXNzYWdlKCk7XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGljdU1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ3RoaXMgaXMgbm90IGFuIElDVSBtZXNzYWdlLCB1c2UgdHJhbnNsYXRlKCkgaW5zdGVhZCAoXCIlc1wiLCBcIiVzXCIpJyxcclxuICAgICAgICAgICAgICAgIGljdVRyYW5zbGF0aW9uLCAgdGhpcy5hc05hdGl2ZVN0cmluZygpKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlZElDVU1lc3NhZ2U6IElJQ1VNZXNzYWdlID0gaWN1TWVzc2FnZS50cmFuc2xhdGUoaWN1VHJhbnNsYXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VyLnBhcnNlSUNVTWVzc2FnZSh0cmFuc2xhdGVkSUNVTWVzc2FnZS5hc05hdGl2ZVN0cmluZygpLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9ybWFsaXplZCBtZXNzYWdlIGZyb20gYSBuYXRpdmUgeG1sIHN0cmluZyBhcyBhIHRyYW5zbGF0aW9uIG9mIHRoaXMgb25lLlxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0cmluZyB4bWwgc3RyaW5nIGluIHRoZSBmb3JtYXQgb2YgdGhlIHVuZGVybHlpbmcgZmlsZSBmb3JtYXQuXHJcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbmF0aXZlIHN0cmluZyBpcyBub3QgYWNjZXB0YWJsZS5cclxuICAgICAqL1xyXG4gICAgdHJhbnNsYXRlTmF0aXZlU3RyaW5nKG5hdGl2ZVN0cmluZzogc3RyaW5nKTogSU5vcm1hbGl6ZWRNZXNzYWdlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VyLmNyZWF0ZU5vcm1hbGl6ZWRNZXNzYWdlRnJvbVhNTFN0cmluZyhuYXRpdmVTdHJpbmcsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogbm9ybWFsaXplZCBtZXNzYWdlIGFzIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSBkaXNwbGF5Rm9ybWF0IG9wdGlvbmFsIHdheSB0byBkZXRlcm1pbmUgdGhlIGV4YWN0IHN5bnRheC5cclxuICAgICAqIEFsbG93ZWQgZm9ybWF0cyBhcmUgZGVmaW5lZCBhcyBjb25zdGFudHMgTk9STUFMSVpBVElPTl9GT1JNQVQuLi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzRGlzcGxheVN0cmluZyhkaXNwbGF5Rm9ybWF0Pzogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzLm1hcCgocGFydCkgPT4gcGFydC5hc0Rpc3BsYXlTdHJpbmcoZGlzcGxheUZvcm1hdCkpLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBjb250ZW50IGFzIGZvcm1hdCBkZXBlbmRlbnQgbmF0aXZlIHN0cmluZy5cclxuICAgICAqIEluY2x1ZGVzIGFsbCBmb3JtYXQgc3BlY2lmaWMgbWFya3VwIGxpa2UgPHBoIGlkPVwiSU5URVJQT0xBVElPTlwiIC4uLz4gLi5cclxuICAgICAqL1xyXG4gICAgYXNOYXRpdmVTdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5nZXRJQ1VNZXNzYWdlKCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBET01VdGlsaXRpZXMuZ2V0WE1MQ29udGVudCh0aGlzLl94bWxSZXByZXNlbnRhdGlvbik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SUNVTWVzc2FnZSgpLmFzTmF0aXZlU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcmV0dXJuIG51bGwsIGlmIG9rLCBlcnJvciBvYmplY3Qgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdmFsaWRhdGUoKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xyXG4gICAgICAgIGxldCBoYXNFcnJvcnMgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMgPSB7fTtcclxuICAgICAgICBsZXQgZTtcclxuICAgICAgICBlID0gdGhpcy5jaGVja1BsYWNlaG9sZGVyQWRkZWQoKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGUpKSB7XHJcbiAgICAgICAgICAgIGVycm9ycy5wbGFjZWhvbGRlckFkZGVkID0gZTtcclxuICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZSA9IHRoaXMuY2hlY2tJQ1VNZXNzYWdlUmVmUmVtb3ZlZCgpO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoZSkpIHtcclxuICAgICAgICAgICAgZXJyb3JzLmljdU1lc3NhZ2VSZWZSZW1vdmVkID0gZTtcclxuICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZSA9IHRoaXMuY2hlY2tJQ1VNZXNzYWdlUmVmQWRkZWQoKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGUpKSB7XHJcbiAgICAgICAgICAgIGVycm9ycy5pY3VNZXNzYWdlUmVmQWRkZWQgPSBlO1xyXG4gICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzRXJyb3JzID8gZXJyb3JzIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBtZXNzYWdlLCBjaGVjayBmb3Igd2FybmluZ3Mgb25seS5cclxuICAgICAqIEEgd2FybmluZyBzaG93cywgdGhhdCB0aGUgbWVzc2FnZSBpcyBhY2NlcHRhYmxlLCBidXQgbWlzc2VzIHNvbWV0aGluZy5cclxuICAgICAqIEUuZy4gaWYgeW91IHJlbW92ZSBhIHBsYWNlaG9sZGVyIG9yIGEgc3BlY2lhbCB0YWcgZnJvbSB0aGUgb3JpZ2luYWwgbWVzc2FnZSwgdGhpcyBnZW5lcmF0ZXMgYSB3YXJuaW5nLlxyXG4gICAgICogQHJldHVybiBudWxsLCBpZiBubyB3YXJuaW5nLCB3YXJuaW5ncyBhcyBlcnJvciBvYmplY3Qgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZVdhcm5pbmdzKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcclxuICAgICAgICBsZXQgaGFzV2FybmluZ3MgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB3YXJuaW5nczogVmFsaWRhdGlvbkVycm9ycyA9IHt9O1xyXG4gICAgICAgIGxldCB3O1xyXG4gICAgICAgIHcgPSB0aGlzLmNoZWNrUGxhY2Vob2xkZXJSZW1vdmVkKCk7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh3KSkge1xyXG4gICAgICAgICAgICB3YXJuaW5ncy5wbGFjZWhvbGRlclJlbW92ZWQgPSB3O1xyXG4gICAgICAgICAgICBoYXNXYXJuaW5ncyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHcgPSB0aGlzLmNoZWNrVGFnUmVtb3ZlZCgpO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodykpIHtcclxuICAgICAgICAgICAgd2FybmluZ3MudGFnUmVtb3ZlZCA9IHc7XHJcbiAgICAgICAgICAgIGhhc1dhcm5pbmdzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdyA9IHRoaXMuY2hlY2tUYWdBZGRlZCgpO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodykpIHtcclxuICAgICAgICAgICAgd2FybmluZ3MudGFnQWRkZWQgPSB3O1xyXG4gICAgICAgICAgICBoYXNXYXJuaW5ncyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNXYXJuaW5ncyA/IHdhcm5pbmdzIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoaXMgbWVzc2FnZSBpcyBhbiBJQ1UgbWVzc2FnZSwgcmV0dXJucyBpdHMgc3RydWN0dXJlLlxyXG4gICAgICogT3RoZXJ3aXNlIHRoaXMgbWV0aG9kIHJldHVybnMgbnVsbC5cclxuICAgICAqIEByZXR1cm4gSUNVTWVzc2FnZSBvciBudWxsLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SUNVTWVzc2FnZSgpOiBJSUNVTWVzc2FnZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcnRzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLl9wYXJ0c1swXS50eXBlID09PSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuSUNVX01FU1NBR0UpIHtcclxuICAgICAgICAgICAgY29uc3QgaWN1UGFydCA9IDxQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2U+IHRoaXMuX3BhcnRzWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gaWN1UGFydC5nZXRJQ1VNZXNzYWdlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGZvciBhZGRlZCBwbGFjZWhvbGRlci5cclxuICAgICAqIEByZXR1cm4gbnVsbCBvciBtZXNzYWdlLCBpZiBmdWxmaWxsZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tQbGFjZWhvbGRlckFkZGVkKCk6IGFueSB7XHJcbiAgICAgICAgbGV0IGUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHN1c3BpY2lvdXNJbmRleGVzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlTWVzc2FnZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQbGFjZWhvbGRlcnMgPSB0aGlzLnNvdXJjZU1lc3NhZ2UuYWxsUGxhY2Vob2xkZXJzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG15UGxhY2Vob2xkZXJzID0gdGhpcy5hbGxQbGFjZWhvbGRlcnMoKTtcclxuICAgICAgICAgICAgbXlQbGFjZWhvbGRlcnMuZm9yRWFjaCgoaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghc291cmNlUGxhY2Vob2xkZXJzLmhhcyhpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwaWNpb3VzSW5kZXhlcy5wdXNoKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdXNwaWNpb3VzSW5kZXhlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgZSA9ICdhZGRlZCBwbGFjZWhvbGRlciAnICsgc3VzcGljaW91c0luZGV4ZXNbMF0gKyAnLCB3aGljaCBpcyBub3QgaW4gb3JpZ2luYWwgbWVzc2FnZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdXNwaWNpb3VzSW5kZXhlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGxldCBhbGxTdXNwaWNpb3VzSW5kZXhlcyA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdXNwaWNpb3VzSW5kZXhlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbFN1c3BpY2lvdXNJbmRleGVzID0gYWxsU3VzcGljaW91c0luZGV4ZXMgKyAnLCAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWxsU3VzcGljaW91c0luZGV4ZXMgPSBhbGxTdXNwaWNpb3VzSW5kZXhlcyArIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGUgPSAnYWRkZWQgcGxhY2Vob2xkZXJzICcgKyBhbGxTdXNwaWNpb3VzSW5kZXhlcyArICcsIHdoaWNoIGFyZSBub3QgaW4gb3JpZ2luYWwgbWVzc2FnZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgZm9yIHJlbW92ZWQgcGxhY2Vob2xkZXIuXHJcbiAgICAgKiBAcmV0dXJuIG51bGwgb3IgbWVzc2FnZSwgaWYgZnVsZmlsbGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoZWNrUGxhY2Vob2xkZXJSZW1vdmVkKCk6IGFueSB7XHJcbiAgICAgICAgbGV0IHcgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHN1c3BpY2lvdXNJbmRleGVzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlTWVzc2FnZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQbGFjZWhvbGRlcnMgPSB0aGlzLnNvdXJjZU1lc3NhZ2UuYWxsUGxhY2Vob2xkZXJzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG15UGxhY2Vob2xkZXJzID0gdGhpcy5hbGxQbGFjZWhvbGRlcnMoKTtcclxuICAgICAgICAgICAgc291cmNlUGxhY2Vob2xkZXJzLmZvckVhY2goKGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW15UGxhY2Vob2xkZXJzLmhhcyhpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwaWNpb3VzSW5kZXhlcy5wdXNoKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdXNwaWNpb3VzSW5kZXhlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgdyA9ICdyZW1vdmVkIHBsYWNlaG9sZGVyICcgKyBzdXNwaWNpb3VzSW5kZXhlc1swXSArICcgZnJvbSBvcmlnaW5hbCBtZXNzYWdlJztcclxuICAgICAgICB9IGVsc2UgaWYgKHN1c3BpY2lvdXNJbmRleGVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgbGV0IGFsbFN1c3BpY2lvdXNJbmRleGVzID0gJyc7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHN1c3BpY2lvdXNJbmRleGVzLmZvckVhY2goKGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsU3VzcGljaW91c0luZGV4ZXMgPSBhbGxTdXNwaWNpb3VzSW5kZXhlcyArICcsICc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbGxTdXNwaWNpb3VzSW5kZXhlcyA9IGFsbFN1c3BpY2lvdXNJbmRleGVzICsgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdyA9ICdyZW1vdmVkIHBsYWNlaG9sZGVycyAnICsgYWxsU3VzcGljaW91c0luZGV4ZXMgKyAnIGZyb20gb3JpZ2luYWwgbWVzc2FnZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgZm9yIGFkZGVkIElDVSBNZXNzYWdlIFJlZnMuXHJcbiAgICAgKiBAcmV0dXJuIG51bGwgb3IgbWVzc2FnZSwgaWYgZnVsZmlsbGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoZWNrSUNVTWVzc2FnZVJlZkFkZGVkKCk6IGFueSB7XHJcbiAgICAgICAgbGV0IGUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHN1c3BpY2lvdXNJbmRleGVzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlTWVzc2FnZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VJQ1VSZWZzID0gdGhpcy5zb3VyY2VNZXNzYWdlLmFsbElDVU1lc3NhZ2VSZWZzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG15SUNVUmVmcyA9IHRoaXMuYWxsSUNVTWVzc2FnZVJlZnMoKTtcclxuICAgICAgICAgICAgbXlJQ1VSZWZzLmZvckVhY2goKGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZUlDVVJlZnMuaGFzKGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BpY2lvdXNJbmRleGVzLnB1c2goaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1c3BpY2lvdXNJbmRleGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBlID0gJ2FkZGVkIElDVSBtZXNzYWdlIHJlZmVyZW5jZSAnICsgc3VzcGljaW91c0luZGV4ZXNbMF0gKyAnLCB3aGljaCBpcyBub3QgaW4gb3JpZ2luYWwgbWVzc2FnZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdXNwaWNpb3VzSW5kZXhlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGxldCBhbGxTdXNwaWNpb3VzSW5kZXhlcyA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdXNwaWNpb3VzSW5kZXhlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbFN1c3BpY2lvdXNJbmRleGVzID0gYWxsU3VzcGljaW91c0luZGV4ZXMgKyAnLCAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWxsU3VzcGljaW91c0luZGV4ZXMgPSBhbGxTdXNwaWNpb3VzSW5kZXhlcyArIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGUgPSAnYWRkZWQgSUNVIG1lc3NhZ2UgcmVmZXJlbmNlcyAnICsgYWxsU3VzcGljaW91c0luZGV4ZXMgKyAnLCB3aGljaCBhcmUgbm90IGluIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGZvciByZW1vdmVkIElDVSBNZXNzYWdlIFJlZnMuXHJcbiAgICAgKiBAcmV0dXJuIG51bGwgb3IgbWVzc2FnZSwgaWYgZnVsZmlsbGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoZWNrSUNVTWVzc2FnZVJlZlJlbW92ZWQoKTogYW55IHtcclxuICAgICAgICBsZXQgZSA9IG51bGw7XHJcbiAgICAgICAgY29uc3Qgc3VzcGljaW91c0luZGV4ZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5zb3VyY2VNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUlDVVJlZnMgPSB0aGlzLnNvdXJjZU1lc3NhZ2UuYWxsSUNVTWVzc2FnZVJlZnMoKTtcclxuICAgICAgICAgICAgY29uc3QgbXlJQ1VSZWZzID0gdGhpcy5hbGxJQ1VNZXNzYWdlUmVmcygpO1xyXG4gICAgICAgICAgICBzb3VyY2VJQ1VSZWZzLmZvckVhY2goKGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW15SUNVUmVmcy5oYXMoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGljaW91c0luZGV4ZXMucHVzaChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VzcGljaW91c0luZGV4ZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGUgPSAncmVtb3ZlZCBJQ1UgbWVzc2FnZSByZWZlcmVuY2UgJyArIHN1c3BpY2lvdXNJbmRleGVzWzBdICsgJyBmcm9tIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3VzcGljaW91c0luZGV4ZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBsZXQgYWxsU3VzcGljaW91c0luZGV4ZXMgPSAnJztcclxuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3VzcGljaW91c0luZGV4ZXMuZm9yRWFjaCgoaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxTdXNwaWNpb3VzSW5kZXhlcyA9IGFsbFN1c3BpY2lvdXNJbmRleGVzICsgJywgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFsbFN1c3BpY2lvdXNJbmRleGVzID0gYWxsU3VzcGljaW91c0luZGV4ZXMgKyBpbmRleDtcclxuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBlID0gJ3JlbW92ZWQgSUNVIG1lc3NhZ2UgcmVmZXJlbmNlcyAnICsgYWxsU3VzcGljaW91c0luZGV4ZXMgKyAnIGZyb20gb3JpZ2luYWwgbWVzc2FnZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBpbmRleGVzIG9mIHBsYWNlaG9sZGVycyB1c2VkIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFsbFBsYWNlaG9sZGVycygpOiBTZXQ8bnVtYmVyPiB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxudW1iZXI+KCk7XHJcbiAgICAgICAgdGhpcy5wYXJ0cygpLmZvckVhY2goKHBhcnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gUGFyc2VkTWVzc2FnZVBhcnRUeXBlLlBMQUNFSE9MREVSKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9ICg8UGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlcj4gcGFydCkuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZGlzcC1BdHRyaWJ1dGUgb2YgcGxhY2Vob2xkZXJcclxuICAgICAqIEBwYXJhbSBpbmRleCBpbmRleCBvZiBwbGFjZWhvbGRlclxyXG4gICAgICogQHJldHVybiBkaXNwIG9yIG51bGxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFBsYWNlaG9sZGVyRGlzcChpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgcGxhY2VIb2xkZXI6IFBhcnNlZE1lc3NhZ2VQYXJ0UGxhY2Vob2xkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFydHMoKS5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5QTEFDRUhPTERFUikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGhQYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyID0gPFBhcnNlZE1lc3NhZ2VQYXJ0UGxhY2Vob2xkZXI+IHBhcnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocGhQYXJ0LmluZGV4KCkgPT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VIb2xkZXIgPSBwaFBhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGxhY2VIb2xkZXIgPyBwbGFjZUhvbGRlci5kaXNwKCkgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBpbmRleGVzIG9mIElDVSBtZXNzYWdlIHJlZnMgdXNlZCBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhbGxJQ1VNZXNzYWdlUmVmcygpOiBTZXQ8bnVtYmVyPiB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxudW1iZXI+KCk7XHJcbiAgICAgICAgdGhpcy5wYXJ0cygpLmZvckVhY2goKHBhcnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gUGFyc2VkTWVzc2FnZVBhcnRUeXBlLklDVV9NRVNTQUdFX1JFRikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSAoPFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZj4gcGFydCkuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZGlzcC1BdHRyaWJ1dGUgb2YgaWN1IG1lc3NhZ2UgcmVmXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggb2YgcmVmXHJcbiAgICAgKiBAcmV0dXJuIGRpc3Agb3IgbnVsbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SUNVTWVzc2FnZVJlZkRpc3AoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGljdU1lc3NhZ2VSZWZQYXJ0OiBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFydHMoKS5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5JQ1VfTUVTU0FHRV9SRUYpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZlBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZiA9IDxQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWY+IHBhcnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVmUGFydC5pbmRleCgpID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGljdU1lc3NhZ2VSZWZQYXJ0ID0gcmVmUGFydDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpY3VNZXNzYWdlUmVmUGFydCA/IGljdU1lc3NhZ2VSZWZQYXJ0LmRpc3AoKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBmb3IgYWRkZWQgdGFncy5cclxuICAgICAqIEByZXR1cm4gbnVsbCBvciBtZXNzYWdlLCBpZiBmdWxmaWxsZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tUYWdBZGRlZCgpOiBhbnkge1xyXG4gICAgICAgIGxldCBlID0gbnVsbDtcclxuICAgICAgICBjb25zdCBzdXNwaWNpb3VzVGFncyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZU1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlVGFncyA9IHRoaXMuc291cmNlTWVzc2FnZS5hbGxUYWdzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG15VGFncyA9IHRoaXMuYWxsVGFncygpO1xyXG4gICAgICAgICAgICBteVRhZ3MuZm9yRWFjaCgodGFnTmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VUYWdzLmhhcyh0YWdOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BpY2lvdXNUYWdzLnB1c2godGFnTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VzcGljaW91c1RhZ3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGUgPSAnYWRkZWQgdGFnIDwnICsgc3VzcGljaW91c1RhZ3NbMF0gKyAnPiwgd2hpY2ggaXMgbm90IGluIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3VzcGljaW91c1RhZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBsZXQgYWxsU3VzcGljaW91c1RhZ3MgPSAnJztcclxuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3VzcGljaW91c1RhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsU3VzcGljaW91c1RhZ3MgPSBhbGxTdXNwaWNpb3VzVGFncyArICcsICc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbGxTdXNwaWNpb3VzVGFncyA9IGFsbFN1c3BpY2lvdXNUYWdzICsgJzwnICsgdGFnICsgJz4nO1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGUgPSAnYWRkZWQgdGFncyAnICsgYWxsU3VzcGljaW91c1RhZ3MgKyAnLCB3aGljaCBhcmUgbm90IGluIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGZvciByZW1vdmVkIHRhZ3MuXHJcbiAgICAgKiBAcmV0dXJuIG51bGwgb3IgbWVzc2FnZSwgaWYgZnVsZmlsbGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoZWNrVGFnUmVtb3ZlZCgpOiBhbnkge1xyXG4gICAgICAgIGxldCB3ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBzdXNwaWNpb3VzVGFncyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZU1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlVGFncyA9IHRoaXMuc291cmNlTWVzc2FnZS5hbGxUYWdzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG15VGFncyA9IHRoaXMuYWxsVGFncygpO1xyXG4gICAgICAgICAgICBzb3VyY2VUYWdzLmZvckVhY2goKHRhZ05hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghbXlUYWdzLmhhcyh0YWdOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BpY2lvdXNUYWdzLnB1c2godGFnTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VzcGljaW91c1RhZ3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHcgPSAncmVtb3ZlZCB0YWcgPCcgKyBzdXNwaWNpb3VzVGFnc1swXSArICc+IGZyb20gb3JpZ2luYWwgbWVzc2FnZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdXNwaWNpb3VzVGFncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGxldCBhbGxTdXNwaWNpb3VzVGFncyA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdXNwaWNpb3VzVGFncy5mb3JFYWNoKCh0YWcpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxTdXNwaWNpb3VzVGFncyA9IGFsbFN1c3BpY2lvdXNUYWdzICsgJywgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFsbFN1c3BpY2lvdXNUYWdzID0gYWxsU3VzcGljaW91c1RhZ3MgKyAnPCcgKyB0YWcgKyAnPic7XHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdyA9ICdyZW1vdmVkIHRhZ3MgJyArIGFsbFN1c3BpY2lvdXNUYWdzICsgJyBmcm9tIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgdGFnIG5hbWVzIHVzZWQgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYWxsVGFncygpOiBTZXQ8c3RyaW5nPiB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICAgICAgdGhpcy5wYXJ0cygpLmZvckVhY2goKHBhcnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gUGFyc2VkTWVzc2FnZVBhcnRUeXBlLlNUQVJUX1RBRyB8fCBwYXJ0LnR5cGUgPT09IFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5FTVBUWV9UQUcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSAoPFBhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWc+IHBhcnQpLnRhZ05hbWUoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQodGFnTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBwYXJ0cygpOiBQYXJzZWRNZXNzYWdlUGFydFtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFydHM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0WG1sUmVwcmVzZW50YXRpb24oeG1sUmVwcmVzZW50YXRpb246IEVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLl94bWxSZXByZXNlbnRhdGlvbiA9IHhtbFJlcHJlc2VudGF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFRleHQodGV4dDogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fcGFydHMucHVzaChuZXcgUGFyc2VkTWVzc2FnZVBhcnRUZXh0KHRleHQpKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRQbGFjZWhvbGRlcihpbmRleDogbnVtYmVyLCBkaXNwOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9wYXJ0cy5wdXNoKG5ldyBQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyKGluZGV4LCBkaXNwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkU3RhcnRUYWcodGFnbmFtZTogc3RyaW5nLCBpZGNvdW50ZXI6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX3BhcnRzLnB1c2gobmV3IFBhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWcodGFnbmFtZSwgaWRjb3VudGVyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRW5kVGFnKHRhZ25hbWU6IHN0cmluZykge1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlbGwgZm9ybWVkXHJcbiAgICAgICAgY29uc3Qgb3BlblRhZyA9IHRoaXMuY2FsY3VsYXRlT3BlblRhZ05hbWUoKTtcclxuICAgICAgICBpZiAoIW9wZW5UYWcgfHwgb3BlblRhZyAhPT0gdGFnbmFtZSkge1xyXG4gICAgICAgICAgICAvLyBvb3BzLCBub3Qgd2VsbCBmb3JtZWRcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgndW5leHBlY3RlZCBjbG9zZSB0YWcgJXMgKGN1cnJlbnRseSBvcGVuIGlzICVzLCBuYXRpdmUgeG1sIGlzIFwiJXNcIiknLFxyXG4gICAgICAgICAgICAgICAgdGFnbmFtZSwgb3BlblRhZywgdGhpcy5hc05hdGl2ZVN0cmluZygpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3BhcnRzLnB1c2gobmV3IFBhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnKHRhZ25hbWUpKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRFbXB0eVRhZyh0YWduYW1lOiBzdHJpbmcsIGlkY291bnRlcjogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fcGFydHMucHVzaChuZXcgUGFyc2VkTWVzc2FnZVBhcnRFbXB0eVRhZyh0YWduYW1lLCBpZGNvdW50ZXIpKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRJQ1VNZXNzYWdlUmVmKGluZGV4OiBudW1iZXIsIGRpc3ApIHtcclxuICAgICAgICB0aGlzLl9wYXJ0cy5wdXNoKG5ldyBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWYoaW5kZXgsIGRpc3ApKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRJQ1VNZXNzYWdlKHRleHQ6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3BhcnRzLnB1c2gobmV3IFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZSh0ZXh0LCB0aGlzLl9wYXJzZXIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSwgd2V0aGVyIHRoZXJlIGlzIGFuIG9wZW4gdGFnLCB0aGF0IGlzIG5vdCBjbG9zZWQuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXRlc3Qgb25lIG9yIG51bGwsIGlmIHRoZXJlIGlzIG5vIG9wZW4gdGFnLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZU9wZW5UYWdOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgb3BlblRhZ3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9wYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5TVEFSVF9UQUc6XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlblRhZ3MucHVzaCgoPFBhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWc+IHBhcnQpLnRhZ05hbWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5FTkRfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSAoPFBhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnPiBwYXJ0KS50YWdOYW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5UYWdzLmxlbmd0aCA9PT0gMCB8fCBvcGVuVGFnc1tvcGVuVGFncy5sZW5ndGggLSAxXSAhPT0gdGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvb3BzLCBub3Qgd2VsbCBmb3JtZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlblRhZyA9IChvcGVuVGFncy5sZW5ndGggPT09IDApID8gJ25vdGhpbmcnIDogb3BlblRhZ3Nbb3BlblRhZ3MubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ3VuZXhwZWN0ZWQgY2xvc2UgdGFnICVzIChjdXJyZW50bHkgb3BlbiBpcyAlcywgbmF0aXZlIHhtbCBpcyBcIiVzXCIpJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWUsIG9wZW5UYWcsIHRoaXMuYXNOYXRpdmVTdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvcGVuVGFncy5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvcGVuVGFncy5sZW5ndGggPT09IDAgPyBudWxsIDogb3BlblRhZ3Nbb3BlblRhZ3MubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgVG9rZW5penIgZnJvbSAndG9rZW5penInO1xyXG5pbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICd1dGlsJztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxNC4wNS4yMDE3LlxyXG4gKiBBIHRva2VuaXplciBmb3Igbm9ybWFsaXplZCBtZXNzYWdlcy5cclxuICovXHJcblxyXG4vLyBUb2tlbnNcclxuZXhwb3J0IGNvbnN0IFRFWFQgPSAnVEVYVCc7XHJcbmV4cG9ydCBjb25zdCBTVEFSVF9UQUcgPSAnU1RBUlRfVEFHJztcclxuZXhwb3J0IGNvbnN0IEVORF9UQUcgPSAnRU5EX1RBRyc7XHJcbmV4cG9ydCBjb25zdCBFTVBUWV9UQUcgPSAnRU1QVFlfVEFHJztcclxuZXhwb3J0IGNvbnN0IFBMQUNFSE9MREVSID0gJ1BMQUNFSE9MREVSJztcclxuZXhwb3J0IGNvbnN0IElDVV9NRVNTQUdFX1JFRiA9ICdJQ1VfTUVTU0FHRV9SRUYnO1xyXG5leHBvcnQgY29uc3QgSUNVX01FU1NBR0UgPSAnSUNVX01FU1NBR0UnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUb2tlbiB7XHJcbiAgICB0eXBlOiBzdHJpbmc7XHJcbiAgICB2YWx1ZTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUGFyc2VkTWVzYWdlVG9rZW5pemVyIHtcclxuXHJcbiAgICBwcml2YXRlIGdldExleGVyKCk6IFRva2VuaXpyIHtcclxuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBUb2tlbml6cigpO1xyXG4gICAgICAgIGxldCBwbGFpbnRleHQgPSAnJztcclxuICAgICAgICBsZXhlci5iZWZvcmUoKGN0eCwgbWF0Y2gsIHJ1bGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHJ1bGUubmFtZSAhPT0gVEVYVCAmJiBwbGFpbnRleHQgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguYWNjZXB0KFRFWFQsIHt0ZXh0OiBwbGFpbnRleHR9KTtcclxuICAgICAgICAgICAgICAgIHBsYWludGV4dCA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV4ZXIuZmluaXNoKChjdHgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBsYWludGV4dCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5hY2NlcHQoVEVYVCwge3RleHQ6IHBsYWludGV4dH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGVtcHR5IHRhZywgdGhlcmUgYXJlIG9ubHkgYSBmZXcgYWxsb3dlZCAoc2VlIHRhZy1tYXBwaW5ncyk6IFsnQlInLCAnSFInLCAnSU1HJywgJ0FSRUEnLCAnTElOSycsICdXQlInXVxyXG4gICAgICAgIC8vIGZvcm1hdCBpcyA8bmFtZSBpZD1cIm5yXCI+LCBuciBpc3Qgb3B0aW9uYWwsIHouQi4gPGltZz4gb2RlciA8aW1nIGlkPVwiMlwiPlxyXG4gICAgICAgIGxleGVyLnJ1bGUoLzwoYnJ8aHJ8aW1nfGFyZWF8bGlua3x3YnIpKCBpZD1cIihbMC05XSkqXCIpP1xcPi8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkY291bnQgPSBpc051bGxPclVuZGVmaW5lZChtYXRjaFszXSkgPyAwIDogcGFyc2VJbnQobWF0Y2hbM10sIDEwKTtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChFTVBUWV9UQUcsIHtuYW1lOiBtYXRjaFsxXSwgaWRjb3VudGVyOiBpZGNvdW50fSk7XHJcbiAgICAgICAgfSwgRU1QVFlfVEFHKTtcclxuICAgICAgICAvLyBzdGFydCB0YWcsIEZvcm1hdCA8bmFtZSBpZD1cIm5yXCI+LCBuciBpc3Qgb3B0aW9uYWwsIHouQi4gPG15dGFnPiBvZGVyIDxteXRhZyBpZD1cIjJcIj5cclxuICAgICAgICBsZXhlci5ydWxlKC88KFthLXpBLVpdW2EtekEtWi0wLTldKikoIGlkPVwiKFswLTldKilcIik/Pi8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkY291bnQgPSBpc051bGxPclVuZGVmaW5lZChtYXRjaFszXSkgPyAwIDogcGFyc2VJbnQobWF0Y2hbM10sIDEwKTtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChTVEFSVF9UQUcsIHtuYW1lOiBtYXRjaFsxXSwgaWRjb3VudGVyOiBpZGNvdW50fSk7XHJcbiAgICAgICAgfSwgU1RBUlRfVEFHKTtcclxuICAgICAgICAvLyBlbmQgdGFnXHJcbiAgICAgICAgbGV4ZXIucnVsZSgvPFxcLyhbYS16QS1aXVthLXpBLVotMC05XSopPi8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoRU5EX1RBRywge25hbWU6IG1hdGNoWzFdfSk7XHJcbiAgICAgICAgfSwgRU5EX1RBRyk7XHJcbiAgICAgICAgLy8gcGxhY2Vob2xkZXJcclxuICAgICAgICBsZXhlci5ydWxlKC97eyhbMC05XSspfX0vLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBjdHguYWNjZXB0KFBMQUNFSE9MREVSLCB7aWRjb3VudGVyOiBwYXJzZUludChtYXRjaFsxXSwgMTApfSk7XHJcbiAgICAgICAgfSwgUExBQ0VIT0xERVIpO1xyXG4gICAgICAgIC8vIGljdSBtZXNzYWdlIHJlZlxyXG4gICAgICAgIGxleGVyLnJ1bGUoLzxJQ1UtTWVzc2FnZS1SZWZfKFswLTldKylcXC8+LywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChJQ1VfTUVTU0FHRV9SRUYsIHtpZGNvdW50ZXI6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCl9KTtcclxuICAgICAgICB9LCBJQ1VfTUVTU0FHRV9SRUYpO1xyXG4gICAgICAgIC8vIGljdSBtZXNzYWdlXHJcbiAgICAgICAgbGV4ZXIucnVsZSgvPElDVS1NZXNzYWdlXFwvPi8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoSUNVX01FU1NBR0UsIHttZXNzYWdlOiBtYXRjaFswXX0pO1xyXG4gICAgICAgIH0sIElDVV9NRVNTQUdFKTtcclxuICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgbGV4ZXIucnVsZSgvLi8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIHBsYWludGV4dCArPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgY3R4Lmlnbm9yZSgpO1xyXG4gICAgICAgIH0sIFRFWFQpO1xyXG4gICAgICAgIGxleGVyLnJ1bGUoL1tcXHRcXHJcXG5dKy8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIHBsYWludGV4dCArPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgY3R4Lmlnbm9yZSgpO1xyXG4gICAgICAgIH0sIFRFWFQpO1xyXG4gICAgICAgIHJldHVybiBsZXhlcjtcclxuICAgIH1cclxuXHJcbiAgICB0b2tlbml6ZShub3JtYWxpemVkTWVzc2FnZTogc3RyaW5nKTogVG9rZW5bXSB7XHJcbiAgICAgICAgY29uc3QgbGV4ZXI6IFRva2VuaXpyID0gdGhpcy5nZXRMZXhlcigpO1xyXG4gICAgICAgIGxleGVyLnJlc2V0KCk7XHJcbiAgICAgICAgbGV4ZXIuaW5wdXQobm9ybWFsaXplZE1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiBsZXhlci50b2tlbnMoKTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtQYXJzZWRNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlJztcclxuaW1wb3J0IHtcclxuICAgIEVNUFRZX1RBRyxcclxuICAgIEVORF9UQUcsIElDVV9NRVNTQUdFLCBJQ1VfTUVTU0FHRV9SRUYsIFBhcnNlZE1lc2FnZVRva2VuaXplciwgUExBQ0VIT0xERVIsIFNUQVJUX1RBRywgVEVYVCxcclxuICAgIFRva2VuXHJcbn0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS10b2tlbml6ZXInO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0VGV4dH0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXRleHQnO1xyXG5pbXBvcnQge0RPTVBhcnNlcn0gZnJvbSAneG1sZG9tJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtc3RhcnQtdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtcGxhY2Vob2xkZXInO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW5kLXRhZyc7XHJcbmltcG9ydCB7SU1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vaS1tZXNzYWdlLXBhcnNlcic7XHJcbmltcG9ydCB7Zm9ybWF0LCBpc051bGxPclVuZGVmaW5lZH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7RE9NVXRpbGl0aWVzfSBmcm9tICcuL2RvbS11dGlsaXRpZXMnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1lbXB0eS10YWcnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZn0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LWljdS1tZXNzYWdlLXJlZic7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtaWN1LW1lc3NhZ2UnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAxMC4wNS4yMDE3LlxyXG4gKiBBIG1lc3NhZ2UgcGFyc2VyIGNhbiBwYXJzZSB0aGUgeG1sIGNvbnRlbnQgb2YgYSB0cmFuc2xhdGFibGUgbWVzc2FnZS5cclxuICogSXQgZ2VuZXJhdGVzIGEgUGFyc2VkTWVzc2FnZSBmcm9tIGl0LlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0TWVzc2FnZVBhcnNlciBpbXBsZW1lbnRzIElNZXNzYWdlUGFyc2VyIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIFhNTCB0byBQYXJzZWRNZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHhtbEVsZW1lbnQgdGhlIHhtbCByZXByZXNlbnRhdGlvblxyXG4gICAgICogQHBhcmFtIHNvdXJjZU1lc3NhZ2Ugb3B0aW9uYWwgb3JpZ2luYWwgbWVzc2FnZSB0aGF0IHdpbGwgYmUgdHJhbnNsYXRlZCBieSBub3JtYWxpemVkIG5ldyBvbmVcclxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBub3JtYWxpemVkIHhtbCBpcyBub3Qgd2VsbCBmb3JtZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUwoeG1sRWxlbWVudDogRWxlbWVudCwgc291cmNlTWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IFBhcnNlZE1lc3NhZ2Uge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UgPSBuZXcgUGFyc2VkTWVzc2FnZSh0aGlzLCBzb3VyY2VNZXNzYWdlKTtcclxuICAgICAgICBpZiAoeG1sRWxlbWVudCkge1xyXG4gICAgICAgICAgICBtZXNzYWdlLnNldFhtbFJlcHJlc2VudGF0aW9uKHhtbEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFBhcnRzT2ZOb2RlVG9NZXNzYWdlKHhtbEVsZW1lbnQsIG1lc3NhZ2UsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBYTUwgc3RyaW5nIHRvIFBhcnNlZE1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0geG1sU3RyaW5nIHRoZSB4bWwgcmVwcmVzZW50YXRpb24gd2l0aG91dCByb290IGVsZW1lbnQsIGUuZy4gdGhpcyBpcyA8cGggeD48L3BoPiBhbiBleGFtcGxlLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZU1lc3NhZ2Ugb3B0aW9uYWwgb3JpZ2luYWwgbWVzc2FnZSB0aGF0IHdpbGwgYmUgdHJhbnNsYXRlZCBieSBub3JtYWxpemVkIG5ldyBvbmVcclxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBub3JtYWxpemVkIHhtbCBpcyBub3Qgd2VsbCBmb3JtZWQuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZU5vcm1hbGl6ZWRNZXNzYWdlRnJvbVhNTFN0cmluZyh4bWxTdHJpbmc6IHN0cmluZywgc291cmNlTWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IFBhcnNlZE1lc3NhZ2Uge1xyXG4gICAgICAgIGNvbnN0IGRvYzogRG9jdW1lbnQgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCc8ZHVtbXk+JyArIHhtbFN0cmluZyArICc8L2R1bW15PicsICd0ZXh0L3htbCcpO1xyXG4gICAgICAgIGNvbnN0IHhtbEVsZW1lbnQ6IEVsZW1lbnQgPSA8RWxlbWVudD4gZG9jLmNoaWxkTm9kZXMuaXRlbSgwKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUwoeG1sRWxlbWVudCwgc291cmNlTWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZWN1cnNpdmVseSBydW4gdGhyb3VnaCBhIG5vZGUgYW5kIGFkZCBhbGwgaWRlbnRpZmllZCBwYXJ0cyB0byB0aGUgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBub2RlIG5vZGVcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2UgdG8gYmUgZ2VuZXJhdGVkLlxyXG4gICAgICogQHBhcmFtIGluY2x1ZGVTZWxmIGlmIHRydWUsIGFkZCBub2RlIGJ5IGl0c2VsZiwgb3RoZXJ3aXNlIG9ubHkgY2hpbGRyZW4uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYWRkUGFydHNPZk5vZGVUb01lc3NhZ2Uobm9kZTogTm9kZSwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSwgaW5jbHVkZVNlbGY6IGJvb2xlYW4pIHtcclxuICAgICAgICBsZXQgcHJvY2Vzc0NoaWxkcmVuID0gdHJ1ZTtcclxuICAgICAgICBpZiAoaW5jbHVkZVNlbGYpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuVEVYVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZFRleHQobm9kZS50ZXh0Q29udGVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ2hpbGRyZW4gPSB0aGlzLnByb2Nlc3NTdGFydEVsZW1lbnQoPEVsZW1lbnQ+IG5vZGUsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9jZXNzQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgaWN1TWVzc2FnZVRleHQgPSB0aGlzLmdldElDVU1lc3NhZ2VUZXh0KG5vZGUpO1xyXG4gICAgICAgICAgICBsZXQgaXNJQ1UgPSAhaXNOdWxsT3JVbmRlZmluZWQoaWN1TWVzc2FnZVRleHQpO1xyXG4gICAgICAgICAgICBpZiAoaXNJQ1UpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRJQ1VNZXNzYWdlKGljdU1lc3NhZ2VUZXh0KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgbm90IHBhcnNhYmxlLCBoYW5kbGUgaXQgYXMgbm9uIElDVVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdub24gSUNVIG1lc3NhZ2U6ICcsIGljdU1lc3NhZ2VUZXh0LCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNJQ1UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzSUNVKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhcnRzT2ZOb2RlVG9NZXNzYWdlKGNoaWxkcmVuLml0ZW0oaSksIG1lc3NhZ2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFbmRFbGVtZW50KDxFbGVtZW50PiBub2RlLCBtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIElDVSBtZXNzYWdlIGNvbnRlbnQgb2YgdGhlIG5vZGUsIGlmIGl0IGlzIGFuIElDVSBNZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIG5vZGUgbm9kZVxyXG4gICAgICogQHJldHVybiBtZXNzYWdlIG9yIG51bGwsIGlmIGl0IGlzIG5vIElDVSBNZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0SUNVTWVzc2FnZVRleHQobm9kZTogTm9kZSk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGNoaWxkcmVuLml0ZW0oMCk7XHJcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IGZpcnN0Q2hpbGQuVEVYVF9OT0RFKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSUNVTWVzc2FnZVN0YXJ0KGZpcnN0Q2hpbGQudGV4dENvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFhNTENvbnRlbnQoPEVsZW1lbnQ+IG5vZGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgdGV4dCBpcyBiZWdpbm5pbmcgb2YgSUNVIE1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gdGV4dCB0ZXh0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0lDVU1lc3NhZ2VTdGFydCh0ZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gUGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlLmxvb2tzTGlrZUlDVU1lc3NhZ2UodGV4dCk7XHJcbi8vICAgICAgICByZXR1cm4gdGV4dC5zdGFydHNXaXRoKCd7VkFSX1BMVVJBTCcpIHx8IHRleHQuc3RhcnRzV2l0aCgne1ZBUl9TRUxFQ1QnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSB0aGlzIG5vZGUuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGNoaWxkcmVuIGFyZSBkb25lLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnROb2RlIGVsZW1lbnROb2RlXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlIHRvIGJlIGFsdGVyZWRcclxuICAgICAqIEByZXR1cm4gdHJ1ZSwgaWYgY2hpbGRyZW4gc2hvdWxkIGJlIHByb2Nlc3NlZCB0b28sIGZhbHNlIG90aGVyd2lzZSAoY2hpbGRyZW4gaWdub3JlZCB0aGVuKVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcHJvY2Vzc1N0YXJ0RWxlbWVudChlbGVtZW50Tm9kZTogRWxlbWVudCwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgZW5kIG9mIHRoaXMgbm9kZS5cclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGFmdGVyIGFsbCBjaGlsZHJlbiBhcmUgcHJvY2Vzc2VkLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnROb2RlIGVsZW1lbnROb2RlXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlIHRvIGJlIGFsdGVyZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHByb2Nlc3NFbmRFbGVtZW50KGVsZW1lbnROb2RlOiBFbGVtZW50LCBtZXNzYWdlOiBQYXJzZWRNZXNzYWdlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIG5vcm1hbGl6ZWQgc3RyaW5nIHRvIFBhcnNlZE1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gbm9ybWFsaXplZFN0cmluZyBub3JtYWxpemVkIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHNvdXJjZU1lc3NhZ2Ugb3B0aW9uYWwgb3JpZ2luYWwgbWVzc2FnZSB0aGF0IHdpbGwgYmUgdHJhbnNsYXRlZCBieSBub3JtYWxpemVkIG5ldyBvbmVcclxuICAgICAqIEByZXR1cm4gYSBuZXcgcGFyc2VkIG1lc3NhZ2UuXHJcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm9ybWFsaXplZCBzdHJpbmcgaXMgbm90IHdlbGwgZm9ybWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcGFyc2VOb3JtYWxpemVkU3RyaW5nKG5vcm1hbGl6ZWRTdHJpbmc6IHN0cmluZywgc291cmNlTWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IFBhcnNlZE1lc3NhZ2Uge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UgPSBuZXcgUGFyc2VkTWVzc2FnZSh0aGlzLCBzb3VyY2VNZXNzYWdlKTtcclxuICAgICAgICBjb25zdCBvcGVuVGFncyA9IFtdO1xyXG4gICAgICAgIGxldCB0b2tlbnM6IFRva2VuW107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdG9rZW5zID0gbmV3IFBhcnNlZE1lc2FnZVRva2VuaXplcigpLnRva2VuaXplKG5vcm1hbGl6ZWRTdHJpbmcpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ3VuZXhwZWN0ZWQgZXJyb3Igd2hpbGUgcGFyc2luZyBtZXNzYWdlOiBcIiVzXCIgKHBhcnNlZCBcIiVcIiknLCBlcnJvci5tZXNzYWdlLCBub3JtYWxpemVkU3RyaW5nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2Vucy5mb3JFYWNoKCh0b2tlbjogVG9rZW4pID0+IHtcclxuICAgICAgICAgICAgbGV0IGRpc3A6IHN0cmluZyA9IG51bGw7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBURVhUOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkVGV4dCh0b2tlbi52YWx1ZS50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU1RBUlRfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkU3RhcnRUYWcodG9rZW4udmFsdWUubmFtZSwgdG9rZW4udmFsdWUuaWRjb3VudGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuVGFncy5wdXNoKHRva2VuLnZhbHVlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFTkRfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkRW5kVGFnKHRva2VuLnZhbHVlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuVGFncy5sZW5ndGggPT09IDAgfHwgb3BlblRhZ3Nbb3BlblRhZ3MubGVuZ3RoIC0gMV0gIT09IHRva2VuLnZhbHVlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb29wcywgbm90IHdlbGwgZm9ybWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ3VuZXhwZWN0ZWQgY2xvc2UgdGFnIFwiJXNcIiAocGFyc2VkIFwiJXNcIiknLCB0b2tlbi52YWx1ZS5uYW1lLCBub3JtYWxpemVkU3RyaW5nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5UYWdzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFTVBUWV9UQUc6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRFbXB0eVRhZyh0b2tlbi52YWx1ZS5uYW1lLCB0b2tlbi52YWx1ZS5pZGNvdW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQTEFDRUhPTERFUjpcclxuICAgICAgICAgICAgICAgICAgICBkaXNwID0gKHNvdXJjZU1lc3NhZ2UpID8gc291cmNlTWVzc2FnZS5nZXRQbGFjZWhvbGRlckRpc3AodG9rZW4udmFsdWUuaWRjb3VudGVyKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRQbGFjZWhvbGRlcih0b2tlbi52YWx1ZS5pZGNvdW50ZXIsIGRpc3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBJQ1VfTUVTU0FHRV9SRUY6XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcCA9IChzb3VyY2VNZXNzYWdlKSA/IHNvdXJjZU1lc3NhZ2UuZ2V0SUNVTWVzc2FnZVJlZkRpc3AodG9rZW4udmFsdWUuaWRjb3VudGVyKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRJQ1VNZXNzYWdlUmVmKHRva2VuLnZhbHVlLmlkY291bnRlciwgZGlzcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIElDVV9NRVNTQUdFOlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJzxJQ1VNZXNzYWdlLz4gbm90IGFsbG93ZWQgaGVyZSwgdXNlIHBhcnNlSUNVTWVzc2FnZSBpbnN0ZWFkIChwYXJzZWQgXCIlXCIpJywgbm9ybWFsaXplZFN0cmluZykpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvcGVuVGFncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIG9vcHMsIG5vdCB3ZWxsIGNsb3NlZCB0YWdzXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ21pc3NpbmcgY2xvc2UgdGFnIFwiJXNcIiAocGFyc2VkIFwiJXNcIiknLCBvcGVuVGFnc1tvcGVuVGFncy5sZW5ndGggLSAxXSwgbm9ybWFsaXplZFN0cmluZykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXNzYWdlLnNldFhtbFJlcHJlc2VudGF0aW9uKHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb24obWVzc2FnZSkpO1xyXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgYSBzdHJpbmcsIHRoYXQgaXMgYW4gSUNVIG1lc3NhZ2UsIHRvIFBhcnNlZE1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gaWN1TWVzc2FnZVN0cmluZyB0aGUgbWVzc2FnZSwgbGlrZSAne3gsIHBsdXJhbCwgPTAge25vdGhpbmd9ID0xIHtvbmV9IG90aGVyIHttYW55fX0nLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZU1lc3NhZ2Ugb3B0aW9uYWwgb3JpZ2luYWwgbWVzc2FnZSB0aGF0IHdpbGwgYmUgdHJhbnNsYXRlZCBieSBub3JtYWxpemVkIG5ldyBvbmVcclxuICAgICAqIEByZXR1cm4gYSBuZXcgcGFyc2VkIG1lc3NhZ2UuXHJcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgaWN1TWVzc2FnZVN0cmluZyBoYXMgbm90IHRoZSBjb3JyZWN0IHN5bnRheC5cclxuICAgICAqL1xyXG4gICAgcGFyc2VJQ1VNZXNzYWdlKGljdU1lc3NhZ2VTdHJpbmc6IHN0cmluZywgc291cmNlTWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IFBhcnNlZE1lc3NhZ2Uge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UgPSBuZXcgUGFyc2VkTWVzc2FnZSh0aGlzLCBzb3VyY2VNZXNzYWdlKTtcclxuICAgICAgICBtZXNzYWdlLmFkZElDVU1lc3NhZ2UoaWN1TWVzc2FnZVN0cmluZyk7XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb246IFBhcnNlIElEIGZyb20gYSBuYW1lLlxyXG4gICAgICogbmFtZSBvcHRpb25hbGx5IGVuZHMgd2l0aCBfPG51bWJlcj4uIFRoaXMgaXMgdGhlIGlkY291bnQuXHJcbiAgICAgKiBFLmcuIG5hbWU9XCJUQUdfSU1HXCIgcmV0dXJucyAwXHJcbiAgICAgKiBuYW1lID0gXCJUQUdfSU1HXzFcIiByZXR1cm5zIDFcclxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWVcclxuICAgICAqIEByZXR1cm4gaWQgY291bnRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBhcnNlSWRDb3VudEZyb21OYW1lKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSAvLipfKFswLTldKikvO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhuYW1lKTtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobWF0Y2gpIHx8IG1hdGNoWzFdID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBudW0gPSBtYXRjaFsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bSwgMTApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGUgbmF0aXZlIHhtbCBmb3IgYSBtZXNzYWdlLlxyXG4gICAgICogUGFydHMgYXJlIGFscmVhZHkgc2V0IGhlcmUuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbihtZXNzYWdlOiBQYXJzZWRNZXNzYWdlKTogRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3Qgcm9vdDogRG9jdW1lbnQgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCc8ZHVtbXkvPicsICd0ZXh0L3htbCcpO1xyXG4gICAgICAgIGNvbnN0IHJvb3RFbGVtOiBFbGVtZW50ID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZHVtbXknKS5pdGVtKDApO1xyXG4gICAgICAgIHRoaXMuYWRkWG1sUmVwcmVzZW50YXRpb25Ub1Jvb3QobWVzc2FnZSwgcm9vdEVsZW0pO1xyXG4gICAgICAgIHJldHVybiByb290RWxlbTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgYWRkWG1sUmVwcmVzZW50YXRpb25Ub1Jvb3QobWVzc2FnZTogUGFyc2VkTWVzc2FnZSwgcm9vdEVsZW06IEVsZW1lbnQpO1xyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mVGV4dFBhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRUZXh0LCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIHJldHVybiByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhcnQuYXNEaXNwbGF5U3RyaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBzdGFydCB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqIEBwYXJhbSBpZCBpZCBudW1iZXIgaW4geGxpZmYyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mU3RhcnRUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWcsIHJvb3RFbGVtOiBFbGVtZW50LCBpZD86IG51bWJlcik6IE5vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGVuZCB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZFbmRUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnLCByb290RWxlbTogRWxlbWVudCk6IE5vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGVtcHR5IHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICogQHBhcmFtIGlkIGlkIG51bWJlciBpbiB4bGlmZjJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZFbXB0eVRhZ1BhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRFbXB0eVRhZywgcm9vdEVsZW06IEVsZW1lbnQsIGlkPzogbnVtYmVyKTogTm9kZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgcGxhY2Vob2xkZXIgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqIEBwYXJhbSBpZCBpZCBudW1iZXIgaW4geGxpZmYyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mUGxhY2Vob2xkZXJQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0UGxhY2Vob2xkZXIsIHJvb3RFbGVtOiBFbGVtZW50LCBpZD86IG51bWJlcik6IE5vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGljdSBtZXNzYWdlIHJlZnMgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZJQ1VNZXNzYWdlUmVmUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWYsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZTtcclxufVxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAxNi4wNS4yMDE3LlxyXG4gKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCB0YWcgbmFtZXMgdG8gcGxhY2Vob2xkZXIgbmFtZXMuXHJcbiAqL1xyXG5cclxuLypcclxuY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL21hc3Rlci9wYWNrYWdlcy9jb21waWxlci9zcmMvaTE4bi9zZXJpYWxpemVycy9wbGFjZWhvbGRlci50c1xyXG4gKi9cclxuY29uc3QgVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTOiB7W2s6IHN0cmluZ106IHN0cmluZ30gPSB7XHJcbiAgICAnQSc6ICdMSU5LJyxcclxuICAgICdCJzogJ0JPTERfVEVYVCcsXHJcbiAgICAnQlInOiAnTElORV9CUkVBSycsXHJcbiAgICAnRU0nOiAnRU1QSEFTSVNFRF9URVhUJyxcclxuICAgICdIMSc6ICdIRUFESU5HX0xFVkVMMScsXHJcbiAgICAnSDInOiAnSEVBRElOR19MRVZFTDInLFxyXG4gICAgJ0gzJzogJ0hFQURJTkdfTEVWRUwzJyxcclxuICAgICdINCc6ICdIRUFESU5HX0xFVkVMNCcsXHJcbiAgICAnSDUnOiAnSEVBRElOR19MRVZFTDUnLFxyXG4gICAgJ0g2JzogJ0hFQURJTkdfTEVWRUw2JyxcclxuICAgICdIUic6ICdIT1JJWk9OVEFMX1JVTEUnLFxyXG4gICAgJ0knOiAnSVRBTElDX1RFWFQnLFxyXG4gICAgJ0xJJzogJ0xJU1RfSVRFTScsXHJcbiAgICAnTElOSyc6ICdNRURJQV9MSU5LJyxcclxuICAgICdPTCc6ICdPUkRFUkVEX0xJU1QnLFxyXG4gICAgJ1AnOiAnUEFSQUdSQVBIJyxcclxuICAgICdRJzogJ1FVT1RBVElPTicsXHJcbiAgICAnUyc6ICdTVFJJS0VUSFJPVUdIX1RFWFQnLFxyXG4gICAgJ1NNQUxMJzogJ1NNQUxMX1RFWFQnLFxyXG4gICAgJ1NVQic6ICdTVUJTVFJJUFQnLFxyXG4gICAgJ1NVUCc6ICdTVVBFUlNDUklQVCcsXHJcbiAgICAnVEJPRFknOiAnVEFCTEVfQk9EWScsXHJcbiAgICAnVEQnOiAnVEFCTEVfQ0VMTCcsXHJcbiAgICAnVEZPT1QnOiAnVEFCTEVfRk9PVEVSJyxcclxuICAgICdUSCc6ICdUQUJMRV9IRUFERVJfQ0VMTCcsXHJcbiAgICAnVEhFQUQnOiAnVEFCTEVfSEVBREVSJyxcclxuICAgICdUUic6ICdUQUJMRV9ST1cnLFxyXG4gICAgJ1RUJzogJ01PTk9TUEFDRURfVEVYVCcsXHJcbiAgICAnVSc6ICdVTkRFUkxJTkVEX1RFWFQnLFxyXG4gICAgJ1VMJzogJ1VOT1JERVJFRF9MSVNUJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIVE1MIFRhZ3MgKGluIHVwcGVyY2FzZSkgdGhhdCBhcmUgZW1wdHksIHRoZXkgaGF2ZSBubyBjb250ZW50LCBidXQgZG8gbm90IG5lZWQgYSBjbG9zZSB0YWcsIGUuZy4gPGJyPiwgPGltZz4sIDxocj4uXHJcbiAqL1xyXG5jb25zdCBWT0lEX1RBR1MgPSBbJ0JSJywgJ0hSJywgJ0lNRycsICdBUkVBJywgJ0xJTksnLCAnV0JSJ107XHJcblxyXG5leHBvcnQgY2xhc3MgVGFnTWFwcGluZyB7XHJcblxyXG4gICAgcHVibGljIGdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lKHRhZzogc3RyaW5nLCBpZDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB1cHBlclRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBgVEFHXyR7dXBwZXJUYWd9YDtcclxuICAgICAgICByZXR1cm4gYFNUQVJUXyR7YmFzZU5hbWV9YCArIHRoaXMuY291bnRlclN0cmluZyhpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldENsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKHRhZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB1cHBlclRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBgVEFHXyR7dXBwZXJUYWd9YDtcclxuICAgICAgICByZXR1cm4gYENMT1NFXyR7YmFzZU5hbWV9YDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0RW1wdHlUYWdQbGFjZWhvbGRlck5hbWUodGFnOiBzdHJpbmcsIGlkOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHVwcGVyVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgYmFzZU5hbWUgPSAgVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBgVEFHXyR7dXBwZXJUYWd9YDtcclxuICAgICAgICByZXR1cm4gYmFzZU5hbWUgKyB0aGlzLmNvdW50ZXJTdHJpbmcoaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDdHlwZUZvclRhZyh0YWc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgc3dpdGNoICh0YWcudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlICdicic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2xiJztcclxuICAgICAgICAgICAgY2FzZSAnaW1nJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGB4LSR7dGFnfWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRUYWduYW1lRnJvbVN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lKHBsYWNlaG9sZGVyTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAocGxhY2Vob2xkZXJOYW1lLnN0YXJ0c1dpdGgoJ1NUQVJUX1RBR18nKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpcENvdW50ZXIocGxhY2Vob2xkZXJOYW1lLnN1YnN0cmluZygnU1RBUlRfVEFHXycubGVuZ3RoKSkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBsYWNlaG9sZGVyTmFtZS5zdGFydHNXaXRoKCdTVEFSVF8nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBwaCA9IHRoaXMuc3RyaXBDb3VudGVyKHBsYWNlaG9sZGVyTmFtZS5zdWJzdHJpbmcoJ1NUQVJUXycubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoS2V5ID0gT2JqZWN0LmtleXMoVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTKS5maW5kKChrZXkpID0+IFRBR19UT19QTEFDRUhPTERFUl9OQU1FU1trZXldID09PSBwaCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaEtleSA/IG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VGFnbmFtZUZyb21DbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZShwbGFjZWhvbGRlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyTmFtZS5zdGFydHNXaXRoKCdDTE9TRV9UQUdfJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaXBDb3VudGVyKHBsYWNlaG9sZGVyTmFtZS5zdWJzdHJpbmcoJ0NMT1NFX1RBR18nLmxlbmd0aCkpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwbGFjZWhvbGRlck5hbWUuc3RhcnRzV2l0aCgnQ0xPU0VfJykpIHtcclxuICAgICAgICAgICAgY29uc3QgcGggPSB0aGlzLnN0cmlwQ291bnRlcihwbGFjZWhvbGRlck5hbWUuc3Vic3RyaW5nKCdDTE9TRV8nLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaEtleSA9IE9iamVjdC5rZXlzKFRBR19UT19QTEFDRUhPTERFUl9OQU1FUykuZmluZCgoa2V5KSA9PiBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNba2V5XSA9PT0gcGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hLZXkgPyBtYXRjaEtleS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgcGxhY2Vob2xkZXIgbmFtZSBzdGFuZHMgZm9yIGVtcHR5IGh0bWwgdGFnLlxyXG4gICAgICogQHBhcmFtIHBsYWNlaG9sZGVyTmFtZSBjYW4gYmUgVEFHXzxuYW1lPiBvciBqdXN0IDxuYW1lPlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNFbXB0eVRhZ1BsYWNlaG9sZGVyTmFtZShwbGFjZWhvbGRlck5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHBoID0gdGhpcy5zdHJpcENvdW50ZXIocGxhY2Vob2xkZXJOYW1lKTtcclxuICAgICAgICBsZXQgbWF0Y2hLZXk7XHJcbiAgICAgICAgaWYgKHBoLnN0YXJ0c1dpdGgoJ1RBR18nKSkge1xyXG4gICAgICAgICAgICBtYXRjaEtleSA9IHBoLnN1YnN0cmluZyg0KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdGNoS2V5ID0gT2JqZWN0LmtleXMoVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTKS5maW5kKChrZXkpID0+IFRBR19UT19QTEFDRUhPTERFUl9OQU1FU1trZXldID09PSBwaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaEtleSkge1xyXG4gICAgICAgICAgICBpZiAoVk9JRF9UQUdTLmluZGV4T2YobWF0Y2hLZXkpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRhZ25hbWUgb2YgZW1wdHkgdGFnIHBsYWNlaG9sZGVyLlxyXG4gICAgICogQHBhcmFtIHBsYWNlaG9sZGVyTmFtZSBjYW4gYmUgVEFHXzxuYW1lPiBvciBqdXN0IDxuYW1lPlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGFnbmFtZUZyb21FbXB0eVRhZ1BsYWNlaG9sZGVyTmFtZShwbGFjZWhvbGRlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgcGggPSB0aGlzLnN0cmlwQ291bnRlcihwbGFjZWhvbGRlck5hbWUpO1xyXG4gICAgICAgIGxldCBtYXRjaEtleTtcclxuICAgICAgICBpZiAocGguc3RhcnRzV2l0aCgnVEFHXycpKSB7XHJcbiAgICAgICAgICAgIG1hdGNoS2V5ID0gcGguc3Vic3RyaW5nKDQpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0Y2hLZXkgPSBPYmplY3Qua2V5cyhUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVMpLmZpbmQoKGtleSkgPT4gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW2tleV0gPT09IHBoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hdGNoS2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChWT0lEX1RBR1MuaW5kZXhPZihtYXRjaEtleSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHBsYWNlaG9sZGVyIGVuZHMgd2l0aCBfWzAtOV0rLCBzdHJpcCB0aGF0IG51bWJlci5cclxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlck5hbWUgcGxhY2Vob2xkZXJOYW1lXHJcbiAgICAgKiBAcmV0dXJuIHBsYWNlaG9sZGVyTmFtZSB3aXRob3V0IGNvdW50ZXIgYXQgZW5kLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0cmlwQ291bnRlcihwbGFjZWhvbGRlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyTmFtZSkge1xyXG4gICAgICAgICAgICBjb25zdCByZSA9IC8oLiopX1swLTldKyQvO1xyXG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXJOYW1lLm1hdGNoKHJlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyTmFtZS5yZXBsYWNlKHJlLCAnJDEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXJOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RyaW5nIHN1ZmZpeCBmb3IgY291bnRlci5cclxuICAgICAqIElmIGNvdW50ZXIgaXMgMCwgaXQgaXMgZW1wdHksIG90aGVyd2lzZSBfPGlkPi5cclxuICAgICAqIEBwYXJhbSBpZCBpZFxyXG4gICAgICogQHJldHVybiBzdWZmaXggZm9yIGNvdW50ZXIuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY291bnRlclN0cmluZyhpZDogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKGlkID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ18nICsgaWQudG9TdHJpbmcoMTApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge0Fic3RyYWN0TWVzc2FnZVBhcnNlcn0gZnJvbSAnLi9hYnN0cmFjdC1tZXNzYWdlLXBhcnNlcic7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZ30gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXN0YXJ0LXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRFbmRUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1lbmQtdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtcGxhY2Vob2xkZXInO1xyXG5pbXBvcnQge1RhZ01hcHBpbmd9IGZyb20gJy4vdGFnLW1hcHBpbmcnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1lbXB0eS10YWcnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZn0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LWljdS1tZXNzYWdlLXJlZic7XHJcbmltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFRleHR9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC10ZXh0JztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMTAuMDUuMjAxNy5cclxuICogQSBtZXNzYWdlIHBhcnNlciBmb3IgWExJRkYgMS4yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgWGxpZmZNZXNzYWdlUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlUGFyc2VyIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSB0aGlzIGVsZW1lbnQgbm9kZS5cclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgY2hpbGRyZW4gYXJlIGRvbmUuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudE5vZGUgZWxlbWVudE5vZGVcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2UgdG8gYmUgYWx0ZXJlZFxyXG4gICAgICogQHJldHVybiB0cnVlLCBpZiBjaGlsZHJlbiBzaG91bGQgYmUgcHJvY2Vzc2VkIHRvbywgZmFsc2Ugb3RoZXJ3aXNlIChjaGlsZHJlbiBpZ25vcmVkIHRoZW4pXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwcm9jZXNzU3RhcnRFbGVtZW50KGVsZW1lbnROb2RlOiBFbGVtZW50LCBtZXNzYWdlOiBQYXJzZWRNZXNzYWdlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnROb2RlLnRhZ05hbWU7XHJcbiAgICAgICAgY29uc3QgdGFnTWFwcGluZyA9IG5ldyBUYWdNYXBwaW5nKCk7XHJcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICd4Jykge1xyXG4gICAgICAgICAgICAvLyBwbGFjZWhvbGRlciBhcmUgbGlrZSA8eCBpZD1cIklOVEVSUE9MQVRJT05cIi8+IG9yIDx4IGlkPVwiSU5URVJQT0xBVElPTl8xXCI+XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZWxlbWVudE5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xyXG4gICAgICAgICAgICBpZiAoIWlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHNob3VsZCBub3QgaGFwcGVuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlkLnN0YXJ0c1dpdGgoJ0lOVEVSUE9MQVRJT04nKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXJJbmRleEZyb21JZChpZCk7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZFBsYWNlaG9sZGVyKGluZGV4LCBudWxsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpZC5zdGFydHNXaXRoKCdJQ1UnKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnBhcnNlSUNVTWVzc2FnZVJlZkluZGV4RnJvbUlkKGlkKTtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkSUNVTWVzc2FnZVJlZihpbmRleCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQuc3RhcnRzV2l0aCgnU1RBUlRfJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUYWdOYW1lID0gdGFnTWFwcGluZy5nZXRUYWduYW1lRnJvbVN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lKGlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkVGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkY291bnQgPSB0aGlzLnBhcnNlSWRDb3VudEZyb21OYW1lKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZFN0YXJ0VGFnKG5vcm1hbGl6ZWRUYWdOYW1lLCBpZGNvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpZC5zdGFydHNXaXRoKCdDTE9TRV8nKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFRhZ05hbWUgPSB0YWdNYXBwaW5nLmdldFRhZ25hbWVGcm9tQ2xvc2VUYWdQbGFjZWhvbGRlck5hbWUoaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRUYWdOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRFbmRUYWcobm9ybWFsaXplZFRhZ05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ01hcHBpbmcuaXNFbXB0eVRhZ1BsYWNlaG9sZGVyTmFtZShpZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUYWdOYW1lID0gdGFnTWFwcGluZy5nZXRUYWduYW1lRnJvbUVtcHR5VGFnUGxhY2Vob2xkZXJOYW1lKGlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkVGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkY291bnQgPSB0aGlzLnBhcnNlSWRDb3VudEZyb21OYW1lKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZEVtcHR5VGFnKG5vcm1hbGl6ZWRUYWdOYW1lLCBpZGNvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBlbmQgb2YgdGhpcyBlbGVtZW50IG5vZGUuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciBhbGwgY2hpbGRyZW4gYXJlIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50Tm9kZSBlbGVtZW50Tm9kZVxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZSB0byBiZSBhbHRlcmVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwcm9jZXNzRW5kRWxlbWVudChlbGVtZW50Tm9kZTogRWxlbWVudCwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSkge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgaWQgYXR0cmlidXRlIG9mIHggZWxlbWVudCBhcyBwbGFjZWhvbGRlciBpbmRleC5cclxuICAgICAqIGlkIGNhbiBiZSBcIklOVEVSUE9MQVRJT05cIiBvciBcIklOVEVSUE9MQVRJT05fblwiXHJcbiAgICAgKiBAcGFyYW0gaWQgaWRcclxuICAgICAqIEByZXR1cm4gaW5kZXhcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXJzZVBsYWNlaG9sZGVySW5kZXhGcm9tSWQoaWQ6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IGluZGV4U3RyaW5nID0gJyc7XHJcblxyXG4gICAgICAgIGlmIChpZCA9PT0gJ0lOVEVSUE9MQVRJT04nKSB7XHJcbiAgICAgICAgICAgIGluZGV4U3RyaW5nID0gJzAnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZGV4U3RyaW5nID0gaWQuc3Vic3RyaW5nKCdJTlRFUlBPTEFUSU9OXycubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChpbmRleFN0cmluZywgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgaWQgYXR0cmlidXRlIG9mIHggZWxlbWVudCBhcyBwbGFjZWhvbGRlciBpbmRleC5cclxuICAgICAqIGlkIGNhbiBiZSBcIklOVEVSUE9MQVRJT05cIiBvciBcIklOVEVSUE9MQVRJT05fblwiXHJcbiAgICAgKiBAcGFyYW0gaWQgaWRcclxuICAgICAqIEByZXR1cm4gaWQgYXMgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGFyc2VJQ1VNZXNzYWdlUmVmSW5kZXhGcm9tSWQoaWQ6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IGluZGV4U3RyaW5nID0gJyc7XHJcblxyXG4gICAgICAgIGlmIChpZCA9PT0gJ0lDVScpIHtcclxuICAgICAgICAgICAgaW5kZXhTdHJpbmcgPSAnMCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5kZXhTdHJpbmcgPSBpZC5zdWJzdHJpbmcoJ0lDVV8nLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoaW5kZXhTdHJpbmcsIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWRkWG1sUmVwcmVzZW50YXRpb25Ub1Jvb3QobWVzc2FnZTogUGFyc2VkTWVzc2FnZSwgcm9vdEVsZW06IEVsZW1lbnQpIHtcclxuICAgICAgICBtZXNzYWdlLnBhcnRzKCkuZm9yRWFjaCgocGFydCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGQ6IE5vZGU7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5URVhUOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mVGV4dFBhcnQoPFBhcnNlZE1lc3NhZ2VQYXJ0VGV4dD4gcGFydCwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuU1RBUlRfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mU3RhcnRUYWdQYXJ0KCg8UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZz5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuRU5EX1RBRzpcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVuZFRhZ1BhcnQoKDxQYXJzZWRNZXNzYWdlUGFydEVuZFRhZz5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuRU1QVFlfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mRW1wdHlUYWdQYXJ0KCg8UGFyc2VkTWVzc2FnZVBhcnRFbXB0eVRhZz5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuUExBQ0VIT0xERVI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZQbGFjZWhvbGRlclBhcnQoKDxQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyPnBhcnQpLCByb290RWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5JQ1VfTUVTU0FHRV9SRUY6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZJQ1VNZXNzYWdlUmVmUGFydCgoPFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZj5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcm9vdEVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIHN0YXJ0IHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgPHgvPi1FbGVtZW50IHdpdGggYXR0cmlidXRlcyBpZCBhbmQgY3R5cGVcclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlN0YXJ0VGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4Jyk7XHJcbiAgICAgICAgY29uc3QgdGFnTWFwcGluZyA9IG5ldyBUYWdNYXBwaW5nKCk7XHJcbiAgICAgICAgY29uc3QgaWRBdHRyaWIgPSB0YWdNYXBwaW5nLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lKHBhcnQudGFnTmFtZSgpLCBwYXJ0LmlkQ291bnRlcigpKTtcclxuICAgICAgICBjb25zdCBjdHlwZUF0dHJpYiA9IHRhZ01hcHBpbmcuZ2V0Q3R5cGVGb3JUYWcocGFydC50YWdOYW1lKCkpO1xyXG4gICAgICAgIGNvbnN0IGVxdWl2VGV4dEF0dHIgPSAnPCcgKyBwYXJ0LnRhZ05hbWUoKSArICc+JztcclxuICAgICAgICB4RWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWRBdHRyaWIpO1xyXG4gICAgICAgIHhFbGVtLnNldEF0dHJpYnV0ZSgnY3R5cGUnLCBjdHlwZUF0dHJpYik7XHJcbiAgICAgICAgeEVsZW0uc2V0QXR0cmlidXRlKCdlcXVpdi10ZXh0JywgZXF1aXZUZXh0QXR0cik7XHJcbiAgICAgICAgcmV0dXJuIHhFbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBlbmQgdGFnIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSA8eC8+LUVsZW1lbnQgd2l0aCBhdHRyaWJ1dGVzIGlkIGFuZCBjdHlwZVxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mRW5kVGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydEVuZFRhZywgcm9vdEVsZW06IEVsZW1lbnQpOiBOb2RlIHtcclxuICAgICAgICBjb25zdCB4RWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xyXG4gICAgICAgIGNvbnN0IHRhZ01hcHBpbmcgPSBuZXcgVGFnTWFwcGluZygpO1xyXG4gICAgICAgIGNvbnN0IGlkQXR0cmliID0gdGFnTWFwcGluZy5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZShwYXJ0LnRhZ05hbWUoKSk7XHJcbiAgICAgICAgY29uc3QgY3R5cGVBdHRyaWIgPSAneC0nICsgcGFydC50YWdOYW1lKCk7XHJcbiAgICAgICAgeEVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIGlkQXR0cmliKTtcclxuICAgICAgICB4RWxlbS5zZXRBdHRyaWJ1dGUoJ2N0eXBlJywgY3R5cGVBdHRyaWIpO1xyXG4gICAgICAgIHJldHVybiB4RWxlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgZW1wdHkgdGFnIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSA8eC8+LUVsZW1lbnQgd2l0aCBhdHRyaWJ1dGVzIGlkIGFuZCBjdHlwZVxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mRW1wdHlUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWcsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgeEVsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3gnKTtcclxuICAgICAgICBjb25zdCB0YWdNYXBwaW5nID0gbmV3IFRhZ01hcHBpbmcoKTtcclxuICAgICAgICBjb25zdCBpZEF0dHJpYiA9IHRhZ01hcHBpbmcuZ2V0RW1wdHlUYWdQbGFjZWhvbGRlck5hbWUocGFydC50YWdOYW1lKCksIHBhcnQuaWRDb3VudGVyKCkpO1xyXG4gICAgICAgIGNvbnN0IGN0eXBlQXR0cmliID0gdGFnTWFwcGluZy5nZXRDdHlwZUZvclRhZyhwYXJ0LnRhZ05hbWUoKSk7XHJcbiAgICAgICAgY29uc3QgZXF1aXZUZXh0QXR0ciA9ICc8JyArIHBhcnQudGFnTmFtZSgpICsgJy8+JztcclxuICAgICAgICB4RWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWRBdHRyaWIpO1xyXG4gICAgICAgIHhFbGVtLnNldEF0dHJpYnV0ZSgnY3R5cGUnLCBjdHlwZUF0dHJpYik7XHJcbiAgICAgICAgeEVsZW0uc2V0QXR0cmlidXRlKCdlcXVpdi10ZXh0JywgZXF1aXZUZXh0QXR0cik7XHJcbiAgICAgICAgcmV0dXJuIHhFbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBwbGFjZWhvbGRlciBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgPHgvPi1FbGVtZW50IHdpdGggYXR0cmlidXRlIGlkPVwiSU5URVJQT0xBVElPTlwiIG9yIGlkPVwiSU5URVJQT0xBVElPTl9uXCJcclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlBsYWNlaG9sZGVyUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4Jyk7XHJcbiAgICAgICAgbGV0IGlkQXR0cmliID0gJ0lOVEVSUE9MQVRJT04nO1xyXG4gICAgICAgIGlmIChwYXJ0LmluZGV4KCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlkQXR0cmliID0gJ0lOVEVSUE9MQVRJT05fJyArIHBhcnQuaW5kZXgoKS50b1N0cmluZygxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVxdWl2VGV4dEF0dHIgPSBwYXJ0LmRpc3AoKTtcclxuICAgICAgICB4RWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWRBdHRyaWIpO1xyXG4gICAgICAgIGlmIChlcXVpdlRleHRBdHRyKSB7XHJcbiAgICAgICAgICAgIHhFbGVtLnNldEF0dHJpYnV0ZSgnZXF1aXYtdGV4dCcsIGVxdWl2VGV4dEF0dHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGljdSBtZXNzYWdlIHJlZnMgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZJQ1VNZXNzYWdlUmVmUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWYsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgeEVsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3gnKTtcclxuICAgICAgICBsZXQgaWRBdHRyaWIgPSAnSUNVJztcclxuICAgICAgICBpZiAocGFydC5pbmRleCgpID4gMCkge1xyXG4gICAgICAgICAgICBpZEF0dHJpYiA9ICdJQ1VfJyArIHBhcnQuaW5kZXgoKS50b1N0cmluZygxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHhFbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCBpZEF0dHJpYik7XHJcbiAgICAgICAgcmV0dXJuIHhFbGVtO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge1NUQVRFX05FVywgU1RBVEVfVFJBTlNMQVRFRCwgU1RBVEVfRklOQUx9IGZyb20gJy4uL2FwaS9jb25zdGFudHMnO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7SU5vcm1hbGl6ZWRNZXNzYWdlfSBmcm9tICcuLi9hcGkvaS1ub3JtYWxpemVkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge0lUcmFuc1VuaXR9IGZyb20gJy4uL2FwaS9pLXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge0lOb3RlfSBmcm9tICcuLi9hcGkvaS1ub3RlJztcclxuaW1wb3J0IHtET01VdGlsaXRpZXN9IGZyb20gJy4vZG9tLXV0aWxpdGllcyc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc1VuaXR9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7WGxpZmZNZXNzYWdlUGFyc2VyfSBmcm9tICcuL3hsaWZmLW1lc3NhZ2UtcGFyc2VyJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXInO1xyXG5pbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICd1dGlsJztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDAxLjA1LjIwMTcuXHJcbiAqIEEgVHJhbnNsYXRpb24gVW5pdCBpbiBhbiBYTElGRiAxLjIgZmlsZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgWGxpZmZUcmFuc1VuaXQgZXh0ZW5kcyBBYnN0cmFjdFRyYW5zVW5pdCBpbXBsZW1lbnRzIElUcmFuc1VuaXQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50OiBFbGVtZW50LCBfaWQ6IHN0cmluZywgX3RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpIHtcclxuICAgICAgICBzdXBlcihfZWxlbWVudCwgX2lkLCBfdHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzb3VyY2VDb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlRWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NvdXJjZScpO1xyXG4gICAgICAgIHJldHVybiBET01VdGlsaXRpZXMuZ2V0WE1MQ29udGVudChzb3VyY2VFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBuZXcgc291cmNlIGNvbnRlbnQgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3NpbmcgY2hhbmdlZCBzb3VyY2UgY29udGVudC5cclxuICAgICAqIEBwYXJhbSBuZXdDb250ZW50IHRoZSBuZXcgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZUNvbnRlbnQobmV3Q29udGVudDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IHNvdXJjZSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NvdXJjZScpO1xyXG4gICAgICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuLCB0aGVyZSBhbHdheXMgaGFzIHRvIGJlIGEgc291cmNlLCBidXQgd2hvIGtub3dzLi5cclxuICAgICAgICAgICAgc291cmNlID0gdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChzb3VyY2UsIG5ld0NvbnRlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcGFyc2VyIHVzZWQgZm9yIG5vcm1hbGl6ZWQgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBtZXNzYWdlUGFyc2VyKCk6IEFic3RyYWN0TWVzc2FnZVBhcnNlciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBYbGlmZk1lc3NhZ2VQYXJzZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHZhbHVlLCB0aGF0IGlzIHRvIGJlIHRyYW5zbGF0ZWQsIGFzIG5vcm1hbGl6ZWQgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCk6IFBhcnNlZE1lc3NhZ2Uge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICBpZiAoc291cmNlRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlUGFyc2VyKCkuY3JlYXRlTm9ybWFsaXplZE1lc3NhZ2VGcm9tWE1MKHNvdXJjZUVsZW1lbnQsIG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB0cmFuc2xhdGVkIHZhbHVlIChjb250YWluaW5nIGFsbCBtYXJrdXAsIGRlcGVuZHMgb24gdGhlIGNvbmNyZXRlIGZvcm1hdCB1c2VkKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldENvbnRlbnQoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAndGFyZ2V0Jyk7XHJcbiAgICAgICAgcmV0dXJuIERPTVV0aWxpdGllcy5nZXRYTUxDb250ZW50KHRhcmdldEVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHRyYW5zbGF0ZWQgdmFsdWUsIGJ1dCBhbGwgcGxhY2Vob2xkZXJzIGFyZSByZXBsYWNlZCB3aXRoIHt7bn19IChzdGFydGluZyBhdCAwKVxyXG4gICAgICogYW5kIGFsbCBlbWJlZGRlZCBodG1sIGlzIHJlcGxhY2VkIGJ5IGRpcmVjdCBodG1sIG1hcmt1cC5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0Q29udGVudE5vcm1hbGl6ZWQoKTogSU5vcm1hbGl6ZWRNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAndGFyZ2V0Jyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBYbGlmZk1lc3NhZ2VQYXJzZXIoKS5jcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUwodGFyZ2V0RWxlbWVudCwgdGhpcy5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRlIG9mIHRoZSB0cmFuc2xhdGlvbiBhcyBzdG9yZWQgaW4gdGhlIHhtbC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5hdGl2ZVRhcmdldFN0YXRlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3RhcmdldCcpO1xyXG4gICAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRFbGVtZW50LmdldEF0dHJpYnV0ZSgnc3RhdGUnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgc3RhdGUgaW4geG1sLlxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0YXRlIG5hdGl2ZVN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzZXROYXRpdmVUYXJnZXRTdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3RhcmdldCcpO1xyXG4gICAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdGF0ZScsIG5hdGl2ZVN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgYW4gYWJzdHJhY3Qgc3RhdGUgKG5ldywgdHJhbnNsYXRlZCwgZmluYWwpIHRvIGEgY29uY3JldGUgc3RhdGUgdXNlZCBpbiB0aGUgeG1sLlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdG8gYmUgdXNlZCBpbiB0aGUgeG1sLlxyXG4gICAgICogQHBhcmFtIHN0YXRlIG9uZSBvZiBDb25zdGFudHMuU1RBVEUuLi5cclxuICAgICAqIEByZXR1cm5zIGEgbmF0aXZlIHN0YXRlIChkZXBlbmRzIG9uIGNvbmNyZXRlIGZvcm1hdClcclxuICAgICAqIEB0aHJvd3MgZXJyb3IsIGlmIHN0YXRlIGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBtYXBTdGF0ZVRvTmF0aXZlU3RhdGUoc3RhdGU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgc3dpdGNoICggc3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSBTVEFURV9ORVc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25ldyc7XHJcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfVFJBTlNMQVRFRDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlZCc7XHJcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfRklOQUw6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2ZpbmFsJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBzdGF0ZSAnICsgIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgYSBuYXRpdmUgc3RhdGUgKGZvdW5kIGluIHRoZSBkb2N1bWVudCkgdG8gYW4gYWJzdHJhY3Qgc3RhdGUgKG5ldywgdHJhbnNsYXRlZCwgZmluYWwpLlxyXG4gICAgICogUmV0dXJucyB0aGUgYWJzdHJhY3Qgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gbmF0aXZlU3RhdGUgbmF0aXZlU3RhdGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1hcE5hdGl2ZVN0YXRlVG9TdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKCBuYXRpdmVTdGF0ZSkge1xyXG4gICAgICAgICAgICBjYXNlICduZXcnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX05FVztcclxuICAgICAgICAgICAgY2FzZSAnbmVlZHMtdHJhbnNsYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX05FVztcclxuICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlZCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVFJBTlNMQVRFRDtcclxuICAgICAgICAgICAgY2FzZSAnbmVlZHMtYWRhcHRhdGlvbic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVFJBTlNMQVRFRDtcclxuICAgICAgICAgICAgY2FzZSAnbmVlZHMtbDEwbic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVFJBTlNMQVRFRDtcclxuICAgICAgICAgICAgY2FzZSAnbmVlZHMtcmV2aWV3LWFkYXB0YXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1RSQU5TTEFURUQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ25lZWRzLXJldmlldy1sMTBuJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9UUkFOU0xBVEVEO1xyXG4gICAgICAgICAgICBjYXNlICduZWVkcy1yZXZpZXctdHJhbnNsYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1RSQU5TTEFURUQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmFsJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9GSU5BTDtcclxuICAgICAgICAgICAgY2FzZSAnc2lnbmVkLW9mZic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfRklOQUw7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfTkVXO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgc291cmNlIGVsZW1lbnRzIGluIHRoZSB0cmFucyB1bml0LlxyXG4gICAgICogVGhlIHNvdXJjZSBlbGVtZW50IGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cclxuICAgICAqIEl0IGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmaWxlIGFuZCBhIGxpbmUgbnVtYmVyIHdpdGggdGhlIHBvc2l0aW9uIGluc2lkZSB0aGUgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBpcyBqdXN0IGEgaGVscCBmb3IgdHJhbnNsYXRvcnMgdG8gZmluZCB0aGUgY29udGV4dCBmb3IgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogVGhpcyBpcyBzZXQgd2hlbiB1c2luZyBBbmd1bGFyIDQuMCBvciBncmVhdGVyLlxyXG4gICAgICogT3RoZXJ3aXNlIGl0IGp1c3QgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNvdXJjZVJlZmVyZW5jZXMoKToge3NvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyfVtdIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NvbnRleHQtZ3JvdXAnKTtcclxuICAgICAgICBjb25zdCBzb3VyY2VSZWZzOiB7IHNvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyIH1bXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHNvdXJjZUVsZW1lbnRzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtLmdldEF0dHJpYnV0ZSgncHVycG9zZScpID09PSAnbG9jYXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0RWxlbWVudHMgPSBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb250ZXh0Jyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlZmlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGluZW51bWJlciA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbnRleHRFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRFbGVtID0gY29udGV4dEVsZW1lbnRzLml0ZW0oaik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRFbGVtLmdldEF0dHJpYnV0ZSgnY29udGV4dC10eXBlJykgPT09ICdzb3VyY2VmaWxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VmaWxlID0gRE9NVXRpbGl0aWVzLmdldFBDREFUQShjb250ZXh0RWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0RWxlbS5nZXRBdHRyaWJ1dGUoJ2NvbnRleHQtdHlwZScpID09PSAnbGluZW51bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZW51bWJlciA9IE51bWJlci5wYXJzZUludChET01VdGlsaXRpZXMuZ2V0UENEQVRBKGNvbnRleHRFbGVtKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNvdXJjZVJlZnMucHVzaCh7c291cmNlZmlsZTogc291cmNlZmlsZSwgbGluZW51bWJlcjogbGluZW51bWJlcn0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzb3VyY2VSZWZzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNvdXJjZSByZWYgZWxlbWVudHMgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3Npbmcgc291cmNlIHJlZnMuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlUmVmcyB0aGUgc291cmNlcmVmcyB0byBzZXQuIE9sZCBvbmVzIGFyZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U291cmNlUmVmZXJlbmNlcyhzb3VyY2VSZWZzOiB7c291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyOiBudW1iZXJ9W10pIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbFNvdXJjZVJlZmVyZW5jZXMoKTtcclxuICAgICAgICBzb3VyY2VSZWZzLmZvckVhY2goKHJlZikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0R3JvdXAgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29udGV4dC1ncm91cCcpO1xyXG4gICAgICAgICAgICBjb250ZXh0R3JvdXAuc2V0QXR0cmlidXRlKCdwdXJwb3NlJywgJ2xvY2F0aW9uJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRTb3VyY2UgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29udGV4dCcpO1xyXG4gICAgICAgICAgICBjb250ZXh0U291cmNlLnNldEF0dHJpYnV0ZSgnY29udGV4dC10eXBlJywgJ3NvdXJjZWZpbGUnKTtcclxuICAgICAgICAgICAgY29udGV4dFNvdXJjZS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmVmLnNvdXJjZWZpbGUpKTtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dExpbmUgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29udGV4dCcpO1xyXG4gICAgICAgICAgICBjb250ZXh0TGluZS5zZXRBdHRyaWJ1dGUoJ2NvbnRleHQtdHlwZScsICdsaW5lbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGNvbnRleHRMaW5lLmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyZWYubGluZW51bWJlci50b1N0cmluZygxMCkpKTtcclxuICAgICAgICAgICAgY29udGV4dEdyb3VwLmFwcGVuZENoaWxkKGNvbnRleHRTb3VyY2UpO1xyXG4gICAgICAgICAgICBjb250ZXh0R3JvdXAuYXBwZW5kQ2hpbGQoY29udGV4dExpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRleHRHcm91cCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZW1vdmVBbGxTb3VyY2VSZWZlcmVuY2VzKCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29udGV4dC1ncm91cCcpO1xyXG4gICAgICAgIGNvbnN0IHRvQmVSZW1vdmVkID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtID0gc291cmNlRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgaWYgKGVsZW0uZ2V0QXR0cmlidXRlKCdwdXJwb3NlJykgPT09ICdsb2NhdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRvQmVSZW1vdmVkLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdG9CZVJlbW92ZWQuZm9yRWFjaCgoZWxlbSkgPT4ge2VsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKiBJbiB4bGlmZiB0aGlzIGlzIHN0b3JlZCBhcyBhIG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBmcm9tPVwiZGVzY3JpcHRpb25cIi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlc2NyaXB0aW9uKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSB0aGlzLmZpbmROb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKCdkZXNjcmlwdGlvbicpO1xyXG4gICAgICAgIGlmIChub3RlRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFBDREFUQShub3RlRWxlbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIGRlc2NyaXB0aW9uIHByb3BlcnR5IG9mIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gZGVzY3JpcHRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgbm90ZUVsZW0gPSB0aGlzLmZpbmROb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKCdkZXNjcmlwdGlvbicpO1xyXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xyXG4gICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChub3RlRWxlbSkpIHtcclxuICAgICAgICAgICAgICAgLy8gY3JlYXRlIGl0XHJcbiAgICAgICAgICAgICAgIG5vdGVFbGVtID0gdGhpcy5jcmVhdGVOb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKCdkZXNjcmlwdGlvbicsIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChub3RlRWxlbSwgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5vdGVFbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnZGVzY3JpcHRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgYSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgZnJvbT0nPGF0dHJWYWx1ZT4nXHJcbiAgICAgKiBAcGFyYW0gYXR0clZhbHVlIGF0dHJWYWx1ZVxyXG4gICAgICogQHJldHVybiBlbGVtZW50IG9yIG51bGwgaXMgYWJzZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluZE5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoYXR0clZhbHVlOiBzdHJpbmcpOiBFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdub3RlJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3RlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSBub3RlRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgaWYgKG5vdGVFbGVtLmdldEF0dHJpYnV0ZSgnZnJvbScpID09PSBhdHRyVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub3RlRWxlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbm90ZSBlbGVtZW50cyB3aGVyZSBmcm9tIGF0dHJpYnV0ZSBpcyBub3QgZGVzY3JpcHRpb24gb3IgbWVhbmluZ1xyXG4gICAgICogQHJldHVybiBlbGVtZW50c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmRBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCk6IEVsZW1lbnRbXSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbm90ZScpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogRWxlbWVudFtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3RlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSBub3RlRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgY29uc3QgZnJvbUF0dHJpYnV0ZSA9IG5vdGVFbGVtLmdldEF0dHJpYnV0ZSgnZnJvbScpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbUF0dHJpYnV0ZSAhPT0gJ2Rlc2NyaXB0aW9uJyAmJiBmcm9tQXR0cmlidXRlICE9PSAnbWVhbmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vdGVFbGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBmcm9tPSc8YXR0clZhbHVlPidcclxuICAgICAqIEBwYXJhbSBmcm9tQXR0clZhbHVlIHZhbHVlIG9mIFwiZnJvbVwiIGF0dHJpYnV0ZVxyXG4gICAgICogQHBhcmFtIGNvbnRlbnQgdGV4dCB2YWx1ZSBvZiBub3RlIGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gdGhlIG5ldyBjcmVhdGVkIGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVOb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKGZyb21BdHRyVmFsdWU6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbm90ZScpO1xyXG4gICAgICAgIGlmIChmcm9tQXR0clZhbHVlKSB7XHJcbiAgICAgICAgICAgIG5vdGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnZnJvbScsIGZyb21BdHRyVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub3RlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ByaW9yaXR5JywgJzEnKTtcclxuICAgICAgICBpZiAoY29udGVudCkge1xyXG4gICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChub3RlRWxlbWVudCwgY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQobm90ZUVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiBub3RlRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgZnJvbT0nPGF0dHJWYWx1ZT4nXHJcbiAgICAgKiBAcGFyYW0gYXR0clZhbHVlIGF0dHJWYWx1ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlbW92ZU5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoYXR0clZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbWVudCA9IHRoaXMuZmluZE5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoYXR0clZhbHVlKTtcclxuICAgICAgICBpZiAobm90ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZChub3RlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBub3RlIGVsZW1lbnRzIHdoZXJlIGF0dHJpYnV0ZSBcImZyb21cIiBpcyBub3QgZGVzY3JpcHRpb24gb3IgbWVhbmluZy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW1vdmVBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCkge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW50cyA9IHRoaXMuZmluZEFsbEFkZGl0aW9uYWxOb3RlRWxlbWVudHMoKTtcclxuICAgICAgICBub3RlRWxlbWVudHMuZm9yRWFjaCgobm90ZUVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZChub3RlRWxlbWVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWVhbmluZyAoaW50ZW50KSBzZXQgaW4gdGhlIHRlbXBsYXRlIGFzIHZhbHVlIG9mIHRoZSBpMThuLWF0dHJpYnV0ZS5cclxuICAgICAqIFRoaXMgaXMgdGhlIHBhcnQgaW4gZnJvbnQgb2YgdGhlIHwgc3ltYm9sLlxyXG4gICAgICogZS5nLiBpMThuPVwibWVhbmluZ3xteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKiBJbiB4bGlmZiB0aGlzIGlzIHN0b3JlZCBhcyBhIG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBmcm9tPVwibWVhbmluZ1wiLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWVhbmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtID0gdGhpcy5maW5kTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnbWVhbmluZycpO1xyXG4gICAgICAgIGlmIChub3RlRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFBDREFUQShub3RlRWxlbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIG1lYW5pbmcgcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSAgbWVhbmluZyBtZWFuaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRNZWFuaW5nKG1lYW5pbmc6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBub3RlRWxlbSA9IHRoaXMuZmluZE5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoJ21lYW5pbmcnKTtcclxuICAgICAgICBpZiAobWVhbmluZykge1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobm90ZUVsZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaXRcclxuICAgICAgICAgICAgICAgIG5vdGVFbGVtID0gdGhpcy5jcmVhdGVOb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKCdtZWFuaW5nJywgbWVhbmluZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChub3RlRWxlbSwgbWVhbmluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5vdGVFbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnbWVhbmluZycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBub3RlcyBvZiB0aGUgdHJhbnMtdW5pdC5cclxuICAgICAqIE5vdGVzIGFyZSByZW1hcmtzIG1hZGUgYnkgYSB0cmFuc2xhdG9yLlxyXG4gICAgICogKGRlc2NyaXB0aW9uIGFuZCBtZWFuaW5nIGFyZSBub3QgaW5jbHVkZWQgaGVyZSEpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3RlcygpOiBJTm90ZVtdIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbWVtdHM6IEVsZW1lbnRbXSA9IHRoaXMuZmluZEFsbEFkZGl0aW9uYWxOb3RlRWxlbWVudHMoKTtcclxuICAgICAgICByZXR1cm4gbm90ZUVsZW1lbXRzLm1hcChlbGVtID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGZyb206IGVsZW0uZ2V0QXR0cmlidXRlKCdmcm9tJyksXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBET01VdGlsaXRpZXMuZ2V0UENEQVRBKGVsZW0pXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2Ygbm90ZXMgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXROb3RlcyB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1cHBvcnRzU2V0Tm90ZXMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgbm90ZXMgdG8gdHJhbnMgdW5pdC5cclxuICAgICAqIEBwYXJhbSBuZXdOb3RlcyB0aGUgbm90ZXMgdG8gYWRkLlxyXG4gICAgICogQHRocm93cyBhbiBFcnJvciBpZiBhbnkgbm90ZSBjb250YWlucyBkZXNjcmlwdGlvbiBvciBtZWFuaW5nIGFzIGZyb20gYXR0cmlidXRlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Tm90ZXMobmV3Tm90ZXM6IElOb3RlW10pIHtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5ld05vdGVzKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrTm90ZXMobmV3Tm90ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbW92ZUFsbEFkZGl0aW9uYWxOb3RlRWxlbWVudHMoKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5ld05vdGVzKSkge1xyXG4gICAgICAgICAgICBuZXdOb3Rlcy5mb3JFYWNoKChub3RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3RlRWxlbSA9IHRoaXMuY3JlYXRlTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZShub3RlLmZyb20sIG5vdGUudGV4dCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdHJhbnNsYXRpb24gdG8gYSBnaXZlbiBzdHJpbmcgKGluY2x1ZGluZyBtYXJrdXApLlxyXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uIHRyYW5zbGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCB0cmFuc2xhdGVOYXRpdmUodHJhbnNsYXRpb246IHN0cmluZykge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gRE9NVXRpbGl0aWVzLmNyZWF0ZUZvbGxvd2luZ1NpYmxpbmcoJ3RhcmdldCcsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERPTVV0aWxpdGllcy5yZXBsYWNlQ29udGVudFdpdGhYTUxDb250ZW50KHRhcmdldCwgPHN0cmluZz4gdHJhbnNsYXRpb24pO1xyXG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfVFJBTlNMQVRFRCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogUmV0dXJucyBhIGNoYW5nZWQgY29weSBvZiB0aGlzIHRyYW5zIHVuaXQuXHJcbiAgICAgKiByZWNlaXZlciBpcyBub3QgY2hhbmdlZC5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgY2FsbCBpbXBvcnROZXdUcmFuc1VuaXQgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbG9uZVdpdGhTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbiwgdGFyZ2V0RmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTogQWJzdHJhY3RUcmFuc1VuaXQge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSA8RWxlbWVudD4gdGhpcy5fZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgWGxpZmZUcmFuc1VuaXQoZWxlbWVudCwgdGhpcy5faWQsIHRhcmdldEZpbGUpO1xyXG4gICAgICAgIGNsb25lLnVzZVNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmcsIGNvcHlDb250ZW50KTtcclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbikge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NvdXJjZScpO1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBET01VdGlsaXRpZXMuY3JlYXRlRm9sbG93aW5nU2libGluZygndGFyZ2V0Jywgc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVmYXVsdExhbmcgfHwgY29weUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlU3RyaW5nID0gRE9NVXRpbGl0aWVzLmdldFhNTENvbnRlbnQoc291cmNlKTtcclxuICAgICAgICAgICAgbGV0IG5ld1RhcmdldFN0cmluZyA9IHNvdXJjZVN0cmluZztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSUNVTWVzc2FnZShzb3VyY2VTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRTdHJpbmcgPSB0aGlzLnRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKCkuZ2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCgpXHJcbiAgICAgICAgICAgICAgICAgICAgKyBzb3VyY2VTdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICArIHRoaXMudHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUoKS5nZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudCh0YXJnZXQsIG5ld1RhcmdldFN0cmluZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQodGFyZ2V0LCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmF1bHRMYW5nKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ3N0YXRlJywgdGhpcy5tYXBTdGF0ZVRvTmF0aXZlU3RhdGUoU1RBVEVfRklOQUwpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHRoaXMubWFwU3RhdGVUb05hdGl2ZVN0YXRlKFNUQVRFX05FVykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuLi9hcGkvaS10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuaW1wb3J0IHtJVHJhbnNVbml0fSBmcm9tICcuLi9hcGkvaS10cmFucy11bml0JztcclxuaW1wb3J0IHtGT1JNQVRfWExJRkYxMiwgRklMRVRZUEVfWExJRkYxMn0gZnJvbSAnLi4vYXBpL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7RE9NVXRpbGl0aWVzfSBmcm9tICcuL2RvbS11dGlsaXRpZXMnO1xyXG5pbXBvcnQge1hsaWZmVHJhbnNVbml0fSBmcm9tICcuL3hsaWZmLXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc1VuaXR9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnMtdW5pdCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAyMy4wMi4yMDE3LlxyXG4gKiBBYiB4bGlmZiBmaWxlIHJlYWQgZnJvbSBhIHNvdXJjZSBmaWxlLlxyXG4gKiBEZWZpbmVzIHNvbWUgcmVsZXZhbnQgZ2V0IGFuZCBzZXQgbWV0aG9kIGZvciByZWFkaW5nIGFuZCBtb2RpZnlpbmcgc3VjaCBhIGZpbGUuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFhsaWZmRmlsZSBleHRlbmRzIEFic3RyYWN0VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUgaW1wbGVtZW50cyBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIHhsZi1GaWxlIGZyb20gc291cmNlLlxyXG4gICAgICogQHBhcmFtIHhtbFN0cmluZyBzb3VyY2UgcmVhZCBmcm9tIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBQYXRoIHRvIGZpbGVcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyBvcHRpb25hbCBlbmNvZGluZyBvZiB0aGUgeG1sLlxyXG4gICAgICogVGhpcyBpcyByZWFkIGZyb20gdGhlIGZpbGUsIGJ1dCBpZiB5b3Uga25vdyBpdCBiZWZvcmUsIHlvdSBjYW4gYXZvaWQgcmVhZGluZyB0aGUgZmlsZSB0d2ljZS5cclxuICAgICAqIEByZXR1cm4gWGxpZmZGaWxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHhtbFN0cmluZzogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3dhcm5pbmdzID0gW107XHJcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZUcmFuc1VuaXRzV2l0aE1pc3NpbmdJZCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplRnJvbUNvbnRlbnQoeG1sU3RyaW5nLCBwYXRoLCBlbmNvZGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplRnJvbUNvbnRlbnQoeG1sU3RyaW5nOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyk6IFhsaWZmRmlsZSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZUNvbnRlbnQoeG1sU3RyaW5nLCBwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgY29uc3QgeGxpZmZMaXN0ID0gdGhpcy5fcGFyc2VkRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3hsaWZmJyk7XHJcbiAgICAgICAgaWYgKHhsaWZmTGlzdC5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRmlsZSBcIiVzXCIgc2VlbXMgdG8gYmUgbm8geGxpZmYgZmlsZSAoc2hvdWxkIGNvbnRhaW4gYW4geGxpZmYgZWxlbWVudCknLCBwYXRoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHhsaWZmTGlzdC5pdGVtKDApLmdldEF0dHJpYnV0ZSgndmVyc2lvbicpO1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZlcnNpb24gPSAnMS4yJztcclxuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09IGV4cGVjdGVkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRmlsZSBcIiVzXCIgc2VlbXMgdG8gYmUgbm8geGxpZmYgMS4yIGZpbGUsIHZlcnNpb24gc2hvdWxkIGJlICVzLCBmb3VuZCAlcycsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCwgZXhwZWN0ZWRWZXJzaW9uLCB2ZXJzaW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxlIGZvcm1hdCBhcyBpdCBpcyB1c2VkIGluIGNvbmZpZyBmaWxlcy5cclxuICAgICAqIEN1cnJlbnRseSAneGxmJywgJ3htYicsICd4bWIyJ1xyXG4gICAgICogUmV0dXJucyBvbmUgb2YgdGhlIGNvbnN0YW50cyBGT1JNQVRfLi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGkxOG5Gb3JtYXQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gRk9STUFUX1hMSUZGMTI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxlIHR5cGUuXHJcbiAgICAgKiBIZXJlICdYTElGRiAxLjInXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmaWxlVHlwZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBGSUxFVFlQRV9YTElGRjEyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRhZyBuYW1lcyBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIG1peGVkIGNvbnRlbnQuXHJcbiAgICAgKiBUaGVzZSBlbGVtZW50cyB3aWxsIG5vdCBiZSBiZWF1dGlmaWVkLlxyXG4gICAgICogVHlwaWNhbCBjYW5kaWRhdGVzIGFyZSBzb3VyY2UgYW5kIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGVsZW1lbnRzV2l0aE1peGVkQ29udGVudCgpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgcmV0dXJuIFsnc291cmNlJywgJ3RhcmdldCcsICd0b29sJywgJ3NlZy1zb3VyY2UnLCAnZycsICdwaCcsICdicHQnLCAnZXB0JywgJ2l0JywgJ3N1YicsICdtcmsnXTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZVRyYW5zVW5pdHMoKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc1VuaXRzID0gW107XHJcbiAgICAgICAgY29uc3QgdHJhbnNVbml0c0luRmlsZSA9IHRoaXMuX3BhcnNlZERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0cmFucy11bml0Jyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc1VuaXRzSW5GaWxlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zdW5pdCA9IHRyYW5zVW5pdHNJbkZpbGUuaXRlbShpKTtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSB0cmFuc3VuaXQuZ2V0QXR0cmlidXRlKCdpZCcpO1xyXG4gICAgICAgICAgICBpZiAoIWlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93YXJuaW5ncy5wdXNoKGZvcm1hdCgnb29wcywgdHJhbnMtdW5pdCB3aXRob3V0IFwiaWRcIiBmb3VuZCBpbiBtYXN0ZXIsIHBsZWFzZSBjaGVjayBmaWxlICVzJywgdGhpcy5fZmlsZW5hbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zVW5pdHMucHVzaChuZXcgWGxpZmZUcmFuc1VuaXQodHJhbnN1bml0LCBpZCwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBzb3VyY2UgbGFuZ3VhZ2UuXHJcbiAgICAgKiBAcmV0dXJuIHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNvdXJjZUxhbmd1YWdlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgZmlsZUVsZW0gPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAnZmlsZScpO1xyXG4gICAgICAgIGlmIChmaWxlRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsZUVsZW0uZ2V0QXR0cmlidXRlKCdzb3VyY2UtbGFuZ3VhZ2UnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFZGl0IHRoZSBzb3VyY2UgbGFuZ3VhZ2UuXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2UgbGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZUxhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBmaWxlRWxlbSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fcGFyc2VkRG9jdW1lbnQsICdmaWxlJyk7XHJcbiAgICAgICAgaWYgKGZpbGVFbGVtKSB7XHJcbiAgICAgICAgICAgIGZpbGVFbGVtLnNldEF0dHJpYnV0ZSgnc291cmNlLWxhbmd1YWdlJywgbGFuZ3VhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBAcmV0dXJuIHRhcmdldCBsYW5ndWFnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldExhbmd1YWdlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgZmlsZUVsZW0gPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAnZmlsZScpO1xyXG4gICAgICAgIGlmIChmaWxlRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsZUVsZW0uZ2V0QXR0cmlidXRlKCd0YXJnZXQtbGFuZ3VhZ2UnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFZGl0IHRoZSB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2UgbGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRhcmdldExhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBmaWxlRWxlbSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fcGFyc2VkRG9jdW1lbnQsICdmaWxlJyk7XHJcbiAgICAgICAgaWYgKGZpbGVFbGVtKSB7XHJcbiAgICAgICAgICAgIGZpbGVFbGVtLnNldEF0dHJpYnV0ZSgndGFyZ2V0LWxhbmd1YWdlJywgbGFuZ3VhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIG5ldyB0cmFucy11bml0IHRvIHRoaXMgZmlsZS5cclxuICAgICAqIFRoZSB0cmFucyB1bml0IHN0ZW1zIGZyb20gYW5vdGhlciBmaWxlLlxyXG4gICAgICogSXQgY29waWVzIHRoZSBzb3VyY2UgY29udGVudCBvZiB0aGUgdHUgdG8gdGhlIHRhcmdldCBjb250ZW50IHRvbyxcclxuICAgICAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIGlzRGVmYXVsdExhbmcgYW5kIGNvcHlDb250ZW50LlxyXG4gICAgICogU28gdGhlIHNvdXJjZSBjYW4gYmUgdXNlZCBhcyBhIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKHVzZWQgYnkgeGxpZmZtZXJnZSlcclxuICAgICAqIEBwYXJhbSBmb3JlaWduVHJhbnNVbml0IHRoZSB0cmFucyB1bml0IHRvIGJlIGltcG9ydGVkLlxyXG4gICAgICogQHBhcmFtIGlzRGVmYXVsdExhbmcgRmxhZywgd2V0aGVyIGZpbGUgY29udGFpbnMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBUaGVuIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBqdXN0IGVxdWFsLlxyXG4gICAgICogVGhlIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQuXHJcbiAgICAgKiBTdGF0ZSB3aWxsIGJlIGZpbmFsLlxyXG4gICAgICogQHBhcmFtIGNvcHlDb250ZW50IEZsYWcsIHdldGhlciB0byBjb3B5IGNvbnRlbnQgb3IgbGVhdmUgaXQgZW1wdHkuXHJcbiAgICAgKiBXYmVuIHRydWUsIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQgZnJvbSBzb3VyY2UuXHJcbiAgICAgKiBXaGVuIGZhbHNlLCBjb250ZW50IHdpbGwgYmUgbGVmdCBlbXB0eSAoaWYgaXQgaXMgbm90IHRoZSBkZWZhdWx0IGxhbmd1YWdlKS5cclxuICAgICAqIEBwYXJhbSBpbXBvcnRBZnRlckVsZW1lbnQgb3B0aW9uYWwgKHNpbmNlIDEuMTApIG90aGVyIHRyYW5zdW5pdCAocGFydCBvZiB0aGlzIGZpbGUpLCB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIGFuY2VzdG9yLlxyXG4gICAgICogTmV3bHkgaW1wb3J0ZWQgdHJhbnMgdW5pdCBpcyB0aGVuIGluc2VydGVkIGRpcmVjdGx5IGFmdGVyIHRoaXMgZWxlbWVudC5cclxuICAgICAqIElmIG5vdCBzZXQgb3Igbm90IHBhcnQgb2YgdGhpcyBmaWxlLCBuZXcgdW5pdCB3aWxsIGJlIGltcG9ydGVkIGF0IHRoZSBlbmQuXHJcbiAgICAgKiBJZiBleHBsaWNpdHkgc2V0IHRvIG51bGwsIG5ldyB1bml0IHdpbGwgYmUgaW1wb3J0ZWQgYXQgdGhlIHN0YXJ0LlxyXG4gICAgICogQHJldHVybiB0aGUgbmV3bHkgaW1wb3J0ZWQgdHJhbnMgdW5pdCAoc2luY2UgdmVyc2lvbiAxLjcuMClcclxuICAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdHJhbnMtdW5pdCB3aXRoIHNhbWUgaWQgYWxyZWFkeSBpcyBpbiB0aGUgZmlsZS5cclxuICAgICAqL1xyXG4gICAgaW1wb3J0TmV3VHJhbnNVbml0KGZvcmVpZ25UcmFuc1VuaXQ6IElUcmFuc1VuaXQsIGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuLCBpbXBvcnRBZnRlckVsZW1lbnQ/OiBJVHJhbnNVbml0KVxyXG4gICAgICAgIDogSVRyYW5zVW5pdCB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNVbml0V2l0aElkKGZvcmVpZ25UcmFuc1VuaXQuaWQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ3R1IHdpdGggaWQgJXMgYWxyZWFkeSBleGlzdHMgaW4gZmlsZSwgY2Fubm90IGltcG9ydCBpdCcsIGZvcmVpZ25UcmFuc1VuaXQuaWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3VHUgPSAoPEFic3RyYWN0VHJhbnNVbml0PiBmb3JlaWduVHJhbnNVbml0KS5jbG9uZVdpdGhTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nLCBjb3B5Q29udGVudCwgdGhpcyk7XHJcbiAgICAgICAgY29uc3QgYm9keUVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAnYm9keScpO1xyXG4gICAgICAgIGlmICghYm9keUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRmlsZSBcIiVzXCIgc2VlbXMgdG8gYmUgbm8geGxpZmYgMS4yIGZpbGUgKHNob3VsZCBjb250YWluIGEgYm9keSBlbGVtZW50KScsIHRoaXMuX2ZpbGVuYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpbnNlcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBpc0FmdGVyRWxlbWVudFBhcnRPZkZpbGUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoISFpbXBvcnRBZnRlckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uUG9pbnQgPSB0aGlzLnRyYW5zVW5pdFdpdGhJZChpbXBvcnRBZnRlckVsZW1lbnQuaWQpO1xyXG4gICAgICAgICAgICBpZiAoISFpbnNlcnRpb25Qb2ludCkge1xyXG4gICAgICAgICAgICAgICAgaXNBZnRlckVsZW1lbnRQYXJ0T2ZGaWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW1wb3J0QWZ0ZXJFbGVtZW50ID09PSB1bmRlZmluZWQgfHwgKGltcG9ydEFmdGVyRWxlbWVudCAmJiAhaXNBZnRlckVsZW1lbnRQYXJ0T2ZGaWxlKSkge1xyXG4gICAgICAgICAgICBib2R5RWxlbWVudC5hcHBlbmRDaGlsZChuZXdUdS5hc1htbEVsZW1lbnQoKSk7XHJcbiAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGltcG9ydEFmdGVyRWxlbWVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdFVuaXRFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3RyYW5zLXVuaXQnKTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0VW5pdEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIERPTVV0aWxpdGllcy5pbnNlcnRCZWZvcmUobmV3VHUuYXNYbWxFbGVtZW50KCksIGZpcnN0VW5pdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gdHJhbnMtdW5pdCwgZW1wdHkgZmlsZSwgc28gYWRkIHRvIGJvZHlcclxuICAgICAgICAgICAgICAgIGJvZHlFbGVtZW50LmFwcGVuZENoaWxkKG5ld1R1LmFzWG1sRWxlbWVudCgpKTtcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZlVuaXRFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEVsZW1lbnRCeVRhZ05hbWVBbmRJZCh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3RyYW5zLXVuaXQnLCBpbXBvcnRBZnRlckVsZW1lbnQuaWQpO1xyXG4gICAgICAgICAgICBpZiAocmVmVW5pdEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIERPTVV0aWxpdGllcy5pbnNlcnRBZnRlcihuZXdUdS5hc1htbEVsZW1lbnQoKSwgcmVmVW5pdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnNlcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zVW5pdHMucHVzaChuZXdUdSk7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnROdW1iZXJzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdUdTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNsYXRpb24gZmlsZSBmb3IgdGhpcyBmaWxlIGZvciBhIGdpdmVuIGxhbmd1YWdlLlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMganVzdCBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9uZS5cclxuICAgICAqIEJ1dCBmb3IgWE1CIHRoZSB0cmFuc2xhdGlvbiBmaWxlIGhhcyBmb3JtYXQgJ1hUQicuXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBMYW5ndWFnZSBjb2RlXHJcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgZXhwZWN0ZWQgZmlsZW5hbWUgdG8gc3RvcmUgZmlsZVxyXG4gICAgICogQHBhcmFtIGlzRGVmYXVsdExhbmcgRmxhZywgd2V0aGVyIGZpbGUgY29udGFpbnMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBUaGVuIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBqdXN0IGVxdWFsLlxyXG4gICAgICogVGhlIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQuXHJcbiAgICAgKiBTdGF0ZSB3aWxsIGJlIGZpbmFsLlxyXG4gICAgICogQHBhcmFtIGNvcHlDb250ZW50IEZsYWcsIHdldGhlciB0byBjb3B5IGNvbnRlbnQgb3IgbGVhdmUgaXQgZW1wdHkuXHJcbiAgICAgKiBXYmVuIHRydWUsIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQgZnJvbSBzb3VyY2UuXHJcbiAgICAgKiBXaGVuIGZhbHNlLCBjb250ZW50IHdpbGwgYmUgbGVmdCBlbXB0eSAoaWYgaXQgaXMgbm90IHRoZSBkZWZhdWx0IGxhbmd1YWdlKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcobGFuZzogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nLCBpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbilcclxuICAgICAgICA6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25GaWxlID0gbmV3IFhsaWZmRmlsZSh0aGlzLmVkaXRlZENvbnRlbnQoKSwgZmlsZW5hbWUsIHRoaXMuZW5jb2RpbmcoKSk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25GaWxlLnNldE5ld1RyYW5zVW5pdFRhcmdldFByYWVmaXgodGhpcy50YXJnZXRQcmFlZml4KTtcclxuICAgICAgICB0cmFuc2xhdGlvbkZpbGUuc2V0TmV3VHJhbnNVbml0VGFyZ2V0U3VmZml4KHRoaXMudGFyZ2V0U3VmZml4KTtcclxuICAgICAgICB0cmFuc2xhdGlvbkZpbGUuc2V0VGFyZ2V0TGFuZ3VhZ2UobGFuZyk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25GaWxlLmZvckVhY2hUcmFuc1VuaXQoKHRyYW5zVW5pdDogSVRyYW5zVW5pdCkgPT4ge1xyXG4gICAgICAgICAgICAoPEFic3RyYWN0VHJhbnNVbml0PiB0cmFuc1VuaXQpLnVzZVNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmcsIGNvcHlDb250ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25GaWxlO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7QWJzdHJhY3RNZXNzYWdlUGFyc2VyfSBmcm9tICcuL2Fic3RyYWN0LW1lc3NhZ2UtcGFyc2VyJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlJztcclxuaW1wb3J0IHtET01VdGlsaXRpZXN9IGZyb20gJy4vZG9tLXV0aWxpdGllcyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZ30gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXN0YXJ0LXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRFbmRUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1lbmQtdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtcGxhY2Vob2xkZXInO1xyXG5pbXBvcnQge1RhZ01hcHBpbmd9IGZyb20gJy4vdGFnLW1hcHBpbmcnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1lbXB0eS10YWcnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZn0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LWljdS1tZXNzYWdlLXJlZic7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnQsIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFRleHR9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC10ZXh0JztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMTAuMDUuMjAxNy5cclxuICogQSBtZXNzYWdlIHBhcnNlciBmb3IgWE1CXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgWG1iTWVzc2FnZVBhcnNlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVBhcnNlciB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdGhpcyBlbGVtZW50IG5vZGUuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGNoaWxkcmVuIGFyZSBkb25lLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnROb2RlIGVsZW1lbnROb2RlXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlIHRvIGJlIGFsdGVyZWRcclxuICAgICAqIEByZXR1cm4gdHJ1ZSwgaWYgY2hpbGRyZW4gc2hvdWxkIGJlIHByb2Nlc3NlZCB0b28sIGZhbHNlIG90aGVyd2lzZSAoY2hpbGRyZW4gaWdub3JlZCB0aGVuKVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcHJvY2Vzc1N0YXJ0RWxlbWVudChlbGVtZW50Tm9kZTogRWxlbWVudCwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50Tm9kZS50YWdOYW1lO1xyXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAncGgnKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSA0IGRpZmZlcmVudCB1c2FnZXMgb2YgcGggZWxlbWVudDpcclxuICAgICAgICAgICAgLy8gMS4gcGxhY2Vob2xkZXJzIGFyZSBsaWtlIDxwaCBuYW1lPVwiSU5URVJQT0xBVElPTlwiPjxleD5JTlRFUlBPTEFUSU9OPC9leD48L3BoPlxyXG4gICAgICAgICAgICAvLyBvciA8cGggbmFtZT1cIklOVEVSUE9MQVRJT05fMVwiPjxleD5JTlRFUlBPTEFUSU9OXzE8L2V4PjwvcGg+XHJcbiAgICAgICAgICAgIC8vIDIuIHN0YXJ0IHRhZ3M6XHJcbiAgICAgICAgICAgIC8vIDxwaCBuYW1lPVwiU1RBUlRfTElOS1wiPjxleD4mbHQ7YSZndDs8L2V4PjwvcGg+XHJcbiAgICAgICAgICAgIC8vIDMuIGVtcHR5IHRhZ3M6XHJcbiAgICAgICAgICAgIC8vIDxwaCBuYW1lPVwiVEFHX0lNR1wiPjxleD4mbHQ7aW1nJmd0OzwvZXg+PC9waD5cclxuICAgICAgICAgICAgLy8gNC4gSUNVOlxyXG4gICAgICAgICAgICAvLyA8cGggbmFtZT1cIklDVVwiPjxleD5JQ1U8L2V4PjwvcGg+XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcclxuICAgICAgICAgICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc2hvdWxkIG5vdCBoYXBwZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdJTlRFUlBPTEFUSU9OJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVySW5kZXhGcm9tTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkUGxhY2Vob2xkZXIoaW5kZXgsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBpZ25vcmUgY2hpbGRyZW5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ1NUQVJUXycpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWcgPSB0aGlzLnBhcnNlVGFnbmFtZUZyb21QaEVsZW1lbnQoZWxlbWVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWRjb3VudGVyID0gdGhpcy5wYXJzZUlkQ291bnRGcm9tTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZFN0YXJ0VGFnKHRhZywgaWRjb3VudGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gaWdub3JlIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdDTE9TRV8nKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFnID0gdGhpcy5wYXJzZVRhZ25hbWVGcm9tUGhFbGVtZW50KGVsZW1lbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZEVuZFRhZyh0YWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBpZ25vcmUgY2hpbGRyZW5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXcgVGFnTWFwcGluZygpLmlzRW1wdHlUYWdQbGFjZWhvbGRlck5hbWUobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5VGFnTmFtZSA9IG5ldyBUYWdNYXBwaW5nKCkuZ2V0VGFnbmFtZUZyb21FbXB0eVRhZ1BsYWNlaG9sZGVyTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkY291bnRlciA9IHRoaXMucGFyc2VJZENvdW50RnJvbU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZEVtcHR5VGFnKGVtcHR5VGFnTmFtZSwgaWRjb3VudGVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gaWdub3JlIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdJQ1UnKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnBhcnNlSUNVTWVzc2FnZUluZGV4RnJvbU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZElDVU1lc3NhZ2VSZWYoaW5kZXgsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBpZ25vcmUgY2hpbGRyZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ3NvdXJjZScpIHtcclxuICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBJQ1UgbWVzc2FnZSBjb250ZW50IG9mIHRoZSBub2RlLCBpZiBpdCBpcyBhbiBJQ1UgTWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBub2RlIG5vZGVcclxuICAgICAqIEByZXR1cm4gbWVzc2FnZSBvciBudWxsLCBpZiBpdCBpcyBubyBJQ1UgTWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGdldElDVU1lc3NhZ2VUZXh0KG5vZGU6IE5vZGUpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBmaXJzdENoaWxkID0gbnVsbDtcclxuICAgICAgICAvLyBmaW5kIGZpcnN0IGNoaWxkIHRoYXQgaXMgbm8gc291cmNlIGVsZW1lbnQuXHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW4uaXRlbShpKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlICE9PSBjaGlsZC5FTEVNRU5UX05PREUgfHwgKDxFbGVtZW50PiBjaGlsZCkudGFnTmFtZSAhPT0gJ3NvdXJjZScpIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGQgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IGZpcnN0Q2hpbGQuVEVYVF9OT0RFKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSUNVTWVzc2FnZVN0YXJ0KGZpcnN0Q2hpbGQudGV4dENvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVGV4dCA9IERPTVV0aWxpdGllcy5nZXRYTUxDb250ZW50KDxFbGVtZW50PiBub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRyb3AgPHNvdXJjZT4gZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZVNvdXJjZTogUmVnRXhwID0gbmV3IFJlZ0V4cCgnPHNvdXJjZVtePl0qPi4qPC9zb3VyY2U+JywgJ2cnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVRleHQucmVwbGFjZShyZVNvdXJjZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBlbmQgb2YgdGhpcyBlbGVtZW50IG5vZGUuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciBhbGwgY2hpbGRyZW4gYXJlIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50Tm9kZSBlbGVtZW50Tm9kZVxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZSB0byBiZSBhbHRlcmVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwcm9jZXNzRW5kRWxlbWVudChlbGVtZW50Tm9kZTogRWxlbWVudCwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSkge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgaWQgYXR0cmlidXRlIG9mIHggZWxlbWVudCBhcyBwbGFjZWhvbGRlciBpbmRleC5cclxuICAgICAqIGlkIGNhbiBiZSBcIklOVEVSUE9MQVRJT05cIiBvciBcIklOVEVSUE9MQVRJT05fblwiXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIGlkIGFzIG51bWJlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcnNlUGxhY2Vob2xkZXJJbmRleEZyb21OYW1lKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IGluZGV4U3RyaW5nID0gJyc7XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09PSAnSU5URVJQT0xBVElPTicpIHtcclxuICAgICAgICAgICAgaW5kZXhTdHJpbmcgPSAnMCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5kZXhTdHJpbmcgPSBuYW1lLnN1YnN0cmluZygnSU5URVJQT0xBVElPTl8nLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoaW5kZXhTdHJpbmcsIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGlkIGF0dHJpYnV0ZSBvZiB4IGVsZW1lbnQgYXMgSUNVIG1lc3NhZ2UgcmVmIGluZGV4LlxyXG4gICAgICogaWQgY2FuIGJlIFwiSUNVXCIgb3IgXCJJQ1VfblwiXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIGlkIGFzIG51bWJlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcnNlSUNVTWVzc2FnZUluZGV4RnJvbU5hbWUobmFtZTogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgaW5kZXhTdHJpbmcgPSAnJztcclxuXHJcbiAgICAgICAgaWYgKG5hbWUgPT09ICdJQ1UnKSB7XHJcbiAgICAgICAgICAgIGluZGV4U3RyaW5nID0gJzAnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZGV4U3RyaW5nID0gbmFtZS5zdWJzdHJpbmcoJ0lDVV8nLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoaW5kZXhTdHJpbmcsIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIHRoZSB0YWcgbmFtZSBmcm9tIGEgcGggZWxlbWVudC5cclxuICAgICAqIEl0IGNvbnRhaW5lZCBpbiB0aGUgPGV4PiBzdWJlbGVtZW50cyB2YWx1ZSBhbmQgZW5jbG9zZWQgaW4gPD4uXHJcbiAgICAgKiBFeGFtcGxlOiA8cGggbmFtZT1cIlNUQVJUX0JPTERfVEVYVFwiPjxleD4mbHQ7YiZndDs8L2V4PjwvcGg+XHJcbiAgICAgKiBAcGFyYW0gcGhFbGVtZW50IHBoRWxlbWVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcnNlVGFnbmFtZUZyb21QaEVsZW1lbnQocGhFbGVtZW50OiBFbGVtZW50KTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBleEVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHBoRWxlbWVudCwgJ2V4Jyk7XHJcbiAgICAgICAgaWYgKGV4RWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IERPTVV0aWxpdGllcy5nZXRQQ0RBVEEoZXhFbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuc3RhcnRzV2l0aCgnPCcpIHx8ICF2YWx1ZS5lbmRzV2l0aCgnPicpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvb3BzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUuY2hhckF0KDEpID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMiwgdmFsdWUubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhZGRYbWxSZXByZXNlbnRhdGlvblRvUm9vdChtZXNzYWdlOiBQYXJzZWRNZXNzYWdlLCByb290RWxlbTogRWxlbWVudCkge1xyXG4gICAgICAgIG1lc3NhZ2UucGFydHMoKS5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mUGFydChwYXJ0LCByb290RWxlbSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcm9vdEVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0LCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLlRFWFQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mVGV4dFBhcnQoPFBhcnNlZE1lc3NhZ2VQYXJ0VGV4dD4gcGFydCwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5TVEFSVF9UQUc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mU3RhcnRUYWdQYXJ0KCg8UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZz5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5FTkRfVEFHOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVuZFRhZ1BhcnQoKDxQYXJzZWRNZXNzYWdlUGFydEVuZFRhZz5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5FTVBUWV9UQUc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mRW1wdHlUYWdQYXJ0KCg8UGFyc2VkTWVzc2FnZVBhcnRFbXB0eVRhZz5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5QTEFDRUhPTERFUjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZQbGFjZWhvbGRlclBhcnQoKDxQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyPnBhcnQpLCByb290RWxlbSk7XHJcbiAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLklDVV9NRVNTQUdFX1JFRjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZJQ1VNZXNzYWdlUmVmUGFydCgoPFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZj5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3Igc3RhcnQgdGFnIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogUmV0dXJucyBhbiA8cGg+LUVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgbmFtZSBhbmQgc3ViZWxlbWVudCBleFxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mU3RhcnRUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWcsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgcGhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwaCcpO1xyXG4gICAgICAgIGNvbnN0IHRhZ01hcHBpbmcgPSBuZXcgVGFnTWFwcGluZygpO1xyXG4gICAgICAgIGNvbnN0IG5hbWVBdHRyaWIgPSB0YWdNYXBwaW5nLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lKHBhcnQudGFnTmFtZSgpLCBwYXJ0LmlkQ291bnRlcigpKTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCduYW1lJywgbmFtZUF0dHJpYik7XHJcbiAgICAgICAgY29uc3QgZXhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdleCcpO1xyXG4gICAgICAgIGV4RWxlbS5hcHBlbmRDaGlsZChyb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCc8JyArIHBhcnQudGFnTmFtZSgpICsgJz4nKSk7XHJcbiAgICAgICAgcGhFbGVtLmFwcGVuZENoaWxkKGV4RWxlbSk7XHJcbiAgICAgICAgcmV0dXJuIHBoRWxlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgZW5kIHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gPHBoPi1FbGVtZW50IHdpdGggYXR0cmlidXRlIG5hbWUgYW5kIHN1YmVsZW1lbnQgZXhcclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVuZFRhZ1BhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRFbmRUYWcsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgcGhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwaCcpO1xyXG4gICAgICAgIGNvbnN0IHRhZ01hcHBpbmcgPSBuZXcgVGFnTWFwcGluZygpO1xyXG4gICAgICAgIGNvbnN0IG5hbWVBdHRyaWIgPSB0YWdNYXBwaW5nLmdldENsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKHBhcnQudGFnTmFtZSgpKTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCduYW1lJywgbmFtZUF0dHJpYik7XHJcbiAgICAgICAgY29uc3QgZXhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdleCcpO1xyXG4gICAgICAgIGV4RWxlbS5hcHBlbmRDaGlsZChyb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCc8LycgKyBwYXJ0LnRhZ05hbWUoKSArICc+JykpO1xyXG4gICAgICAgIHBoRWxlbS5hcHBlbmRDaGlsZChleEVsZW0pO1xyXG4gICAgICAgIHJldHVybiBwaEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGVtcHR5IHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gPHBoPi1FbGVtZW50IHdpdGggYXR0cmlidXRlIG5hbWUgYW5kIHN1YmVsZW1lbnQgZXhcclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVtcHR5VGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydEVtcHR5VGFnLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHBoRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGgnKTtcclxuICAgICAgICBjb25zdCB0YWdNYXBwaW5nID0gbmV3IFRhZ01hcHBpbmcoKTtcclxuICAgICAgICBjb25zdCBuYW1lQXR0cmliID0gdGFnTWFwcGluZy5nZXRFbXB0eVRhZ1BsYWNlaG9sZGVyTmFtZShwYXJ0LnRhZ05hbWUoKSwgcGFydC5pZENvdW50ZXIoKSk7XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnbmFtZScsIG5hbWVBdHRyaWIpO1xyXG4gICAgICAgIGNvbnN0IGV4RWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZXgnKTtcclxuICAgICAgICBleEVsZW0uYXBwZW5kQ2hpbGQocm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnPCcgKyBwYXJ0LnRhZ05hbWUoKSArICc+JykpO1xyXG4gICAgICAgIHBoRWxlbS5hcHBlbmRDaGlsZChleEVsZW0pO1xyXG4gICAgICAgIHJldHVybiBwaEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIHBsYWNlaG9sZGVyIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogUmV0dXJucyBhbiA8cGg+LUVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgbmFtZSBhbmQgc3ViZWxlbWVudCBleFxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mUGxhY2Vob2xkZXJQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0UGxhY2Vob2xkZXIsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgcGhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwaCcpO1xyXG4gICAgICAgIGxldCBuYW1lQXR0cmliID0gJ0lOVEVSUE9MQVRJT04nO1xyXG4gICAgICAgIGlmIChwYXJ0LmluZGV4KCkgPiAwKSB7XHJcbiAgICAgICAgICAgIG5hbWVBdHRyaWIgPSAnSU5URVJQT0xBVElPTl8nICsgcGFydC5pbmRleCgpLnRvU3RyaW5nKDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnbmFtZScsIG5hbWVBdHRyaWIpO1xyXG4gICAgICAgIGNvbnN0IGV4RWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZXgnKTtcclxuICAgICAgICBleEVsZW0uYXBwZW5kQ2hpbGQocm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuYW1lQXR0cmliKSk7XHJcbiAgICAgICAgcGhFbGVtLmFwcGVuZENoaWxkKGV4RWxlbSk7XHJcbiAgICAgICAgcmV0dXJuIHBoRWxlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgaWN1IG1lc3NhZ2UgcmVmcyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZklDVU1lc3NhZ2VSZWZQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZiwgcm9vdEVsZW06IEVsZW1lbnQpOiBOb2RlIHtcclxuICAgICAgICBjb25zdCBwaEVsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BoJyk7XHJcbiAgICAgICAgbGV0IG5hbWVBdHRyaWIgPSAnSUNVJztcclxuICAgICAgICBpZiAocGFydC5pbmRleCgpID4gMCkge1xyXG4gICAgICAgICAgICBuYW1lQXR0cmliID0gJ0lDVV8nICsgcGFydC5pbmRleCgpLnRvU3RyaW5nKDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnbmFtZScsIG5hbWVBdHRyaWIpO1xyXG4gICAgICAgIGNvbnN0IGV4RWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZXgnKTtcclxuICAgICAgICBleEVsZW0uYXBwZW5kQ2hpbGQocm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuYW1lQXR0cmliKSk7XHJcbiAgICAgICAgcGhFbGVtLmFwcGVuZENoaWxkKGV4RWxlbSk7XHJcbiAgICAgICAgcmV0dXJuIHBoRWxlbTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7SU5vcm1hbGl6ZWRNZXNzYWdlfSBmcm9tICcuLi9hcGkvaS1ub3JtYWxpemVkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge0lUcmFuc1VuaXR9IGZyb20gJy4uL2FwaS9pLXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge0lOb3RlfSBmcm9tICcuLi9hcGkvaS1ub3RlJztcclxuaW1wb3J0IHtET01VdGlsaXRpZXN9IGZyb20gJy4vZG9tLXV0aWxpdGllcyc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc1VuaXR9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7WG1iTWVzc2FnZVBhcnNlcn0gZnJvbSAnLi94bWItbWVzc2FnZS1wYXJzZXInO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2V9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge0Fic3RyYWN0TWVzc2FnZVBhcnNlcn0gZnJvbSAnLi9hYnN0cmFjdC1tZXNzYWdlLXBhcnNlcic7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwMS4wNS4yMDE3LlxyXG4gKiBBIFRyYW5zbGF0aW9uIFVuaXQgaW4gYW4gWE1CIGZpbGUuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFhtYlRyYW5zVW5pdCBleHRlbmRzIEFic3RyYWN0VHJhbnNVbml0IGltcGxlbWVudHMgSVRyYW5zVW5pdCB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnQ6IEVsZW1lbnQsIF9pZDogc3RyaW5nLCBfdHJhbnNsYXRpb25NZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSkge1xyXG4gICAgICAgIHN1cGVyKF9lbGVtZW50LCBfaWQsIF90cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgc29tZXRoaW5nIGxpa2UgJ2M6XFx4eHg6NycgYW5kIHJldHVybnMgc291cmNlIGFuZCBsaW5lbnVtYmVyLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZUFuZFBvcyBzb21ldGhpbmcgbGlrZSAnYzpcXHh4eDo3JywgbGFzdCBjb2xvbiBpcyB0aGUgc2VwYXJhdG9yXHJcbiAgICAgKiBAcmV0dXJuIHNvdXJjZSBhbmQgbGluZW51bWJlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwYXJzZVNvdXJjZUFuZFBvcyhzb3VyY2VBbmRQb3M6IHN0cmluZyk6IHsgc291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyIH0ge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gc291cmNlQW5kUG9zLmxhc3RJbmRleE9mKCc6Jyk7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc291cmNlZmlsZTogc291cmNlQW5kUG9zLFxyXG4gICAgICAgICAgICAgICAgbGluZW51bWJlcjogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VmaWxlOiBzb3VyY2VBbmRQb3Muc3Vic3RyaW5nKDAsIGluZGV4KSxcclxuICAgICAgICAgICAgICAgIGxpbmVudW1iZXI6IFhtYlRyYW5zVW5pdC5wYXJzZUxpbmVOdW1iZXIoc291cmNlQW5kUG9zLnN1YnN0cmluZyhpbmRleCArIDEpKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwYXJzZUxpbmVOdW1iZXIobGluZU51bWJlclN0cmluZzogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGxpbmVOdW1iZXJTdHJpbmcsIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBjb250ZW50IHRvIHRyYW5zbGF0ZS5cclxuICAgICAqIFNvdXJjZSBwYXJ0cyBhcmUgZXhjbHVkZWQgaGVyZS5cclxuICAgICAqIEByZXR1cm4gc291cmNlIGNvbnRlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNvdXJjZUNvbnRlbnQoKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgbXNnQ29udGVudCA9IERPTVV0aWxpdGllcy5nZXRYTUxDb250ZW50KHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IHJlU291cmNlRWxlbTogUmVnRXhwID0gLzxzb3VyY2U+Lio8XFwvc291cmNlPi9nO1xyXG4gICAgICAgIG1zZ0NvbnRlbnQgPSBtc2dDb250ZW50LnJlcGxhY2UocmVTb3VyY2VFbGVtLCAnJyk7XHJcbiAgICAgICAgcmV0dXJuIG1zZ0NvbnRlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBzb3VyY2UgY29udGVudCBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldFNvdXJjZUNvbnRlbnQgaW4gdHJhbnMtdW5pdCB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgc3VwcG9ydHNTZXRTb3VyY2VDb250ZW50KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBuZXcgc291cmNlIGNvbnRlbnQgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3NpbmcgY2hhbmdlZCBzb3VyY2UgY29udGVudC5cclxuICAgICAqIEBwYXJhbSBuZXdDb250ZW50IHRoZSBuZXcgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZUNvbnRlbnQobmV3Q29udGVudDogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcGFyc2VyIHVzZWQgZm9yIG5vcm1hbGl6ZWQgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBtZXNzYWdlUGFyc2VyKCk6IEFic3RyYWN0TWVzc2FnZVBhcnNlciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBYbWJNZXNzYWdlUGFyc2VyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCB2YWx1ZSwgdGhhdCBpcyB0byBiZSB0cmFuc2xhdGVkLCBhcyBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVTb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlUGFyc2VyKCkuY3JlYXRlTm9ybWFsaXplZE1lc3NhZ2VGcm9tWE1MKHRoaXMuX2VsZW1lbnQsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHRyYW5zbGF0ZWQgdmFsdWUgKGNvbnRhaW5pbmcgYWxsIG1hcmt1cCwgZGVwZW5kcyBvbiB0aGUgY29uY3JldGUgZm9ybWF0IHVzZWQpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdGFyZ2V0Q29udGVudCgpOiBzdHJpbmcge1xyXG4gICAgICAgIC8vIGluIGZhY3QsIHRhcmdldCBhbmQgc291cmNlIGFyZSBqdXN0IHRoZSBzYW1lIGluIHhtYlxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUNvbnRlbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB0cmFuc2xhdGVkIHZhbHVlLCBidXQgYWxsIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgd2l0aCB7e259fSAoc3RhcnRpbmcgYXQgMClcclxuICAgICAqIGFuZCBhbGwgZW1iZWRkZWQgaHRtbCBpcyByZXBsYWNlZCBieSBkaXJlY3QgaHRtbCBtYXJrdXAuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldENvbnRlbnROb3JtYWxpemVkKCk6IElOb3JtYWxpemVkTWVzc2FnZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBYbWJNZXNzYWdlUGFyc2VyKCkuY3JlYXRlTm9ybWFsaXplZE1lc3NhZ2VGcm9tWE1MKHRoaXMuX2VsZW1lbnQsIHRoaXMuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0ZSBvZiB0aGUgdHJhbnNsYXRpb24uXHJcbiAgICAgKiAobm90IHN1cHBvcnRlZCBpbiB4bWIpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuYXRpdmVUYXJnZXRTdGF0ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBudWxsOyAvLyBub3Qgc3VwcG9ydGVkIGluIHhtYlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIGFuIGFic3RyYWN0IHN0YXRlIChuZXcsIHRyYW5zbGF0ZWQsIGZpbmFsKSB0byBhIGNvbmNyZXRlIHN0YXRlIHVzZWQgaW4gdGhlIHhtbC5cclxuICAgICAqIFJldHVybnMgdGhlIHN0YXRlIHRvIGJlIHVzZWQgaW4gdGhlIHhtbC5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSBvbmUgb2YgQ29uc3RhbnRzLlNUQVRFLi4uXHJcbiAgICAgKiBAcmV0dXJucyBhIG5hdGl2ZSBzdGF0ZSAoZGVwZW5kcyBvbiBjb25jcmV0ZSBmb3JtYXQpXHJcbiAgICAgKiBAdGhyb3dzIGVycm9yLCBpZiBzdGF0ZSBpcyBpbnZhbGlkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWFwU3RhdGVUb05hdGl2ZVN0YXRlKHN0YXRlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBhIG5hdGl2ZSBzdGF0ZSAoZm91bmQgaW4gdGhlIGRvY3VtZW50KSB0byBhbiBhYnN0cmFjdCBzdGF0ZSAobmV3LCB0cmFuc2xhdGVkLCBmaW5hbCkuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhYnN0cmFjdCBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSBuYXRpdmVTdGF0ZSBuYXRpdmVTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWFwTmF0aXZlU3RhdGVUb1N0YXRlKG5hdGl2ZVN0YXRlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBuYXRpdmVTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldCBzdGF0ZSBpbiB4bWwuXHJcbiAgICAgKiAobm90IHN1cHBvcnRlZCBpbiB4bWIpXHJcbiAgICAgKiBAcGFyYW0gbmF0aXZlU3RhdGUgbmF0aXZlU3RhdGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHNldE5hdGl2ZVRhcmdldFN0YXRlKG5hdGl2ZVN0YXRlOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGZvciB4bWJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgc291cmNlIGVsZW1lbnRzIGluIHRoZSB0cmFucyB1bml0LlxyXG4gICAgICogVGhlIHNvdXJjZSBlbGVtZW50IGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cclxuICAgICAqIEl0IGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmaWxlIGFuZCBhIGxpbmUgbnVtYmVyIHdpdGggdGhlIHBvc2l0aW9uIGluc2lkZSB0aGUgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBpcyBqdXN0IGEgaGVscCBmb3IgdHJhbnNsYXRvcnMgdG8gZmluZCB0aGUgY29udGV4dCBmb3IgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogVGhpcyBpcyBzZXQgd2hlbiB1c2luZyBBbmd1bGFyIDQuMCBvciBncmVhdGVyLlxyXG4gICAgICogT3RoZXJ3aXNlIGl0IGp1c3QgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNvdXJjZVJlZmVyZW5jZXMoKTogeyBzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlciB9W10ge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcbiAgICAgICAgY29uc3Qgc291cmNlUmVmczogeyBzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlciB9W10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBzb3VyY2VFbGVtZW50cy5pdGVtKGkpO1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VBbmRQb3M6IHN0cmluZyA9IERPTVV0aWxpdGllcy5nZXRQQ0RBVEEoZWxlbSk7XHJcbiAgICAgICAgICAgIHNvdXJjZVJlZnMucHVzaChYbWJUcmFuc1VuaXQucGFyc2VTb3VyY2VBbmRQb3Moc291cmNlQW5kUG9zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzb3VyY2VSZWZzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNvdXJjZSByZWYgZWxlbWVudHMgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3Npbmcgc291cmNlIHJlZnMuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlUmVmcyB0aGUgc291cmNlcmVmcyB0byBzZXQuIE9sZCBvbmVzIGFyZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U291cmNlUmVmZXJlbmNlcyhzb3VyY2VSZWZzOiB7c291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyOiBudW1iZXJ9W10pIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbFNvdXJjZVJlZmVyZW5jZXMoKTtcclxuICAgICAgICBsZXQgaW5zZXJ0UG9zaXRpb24gPSB0aGlzLl9lbGVtZW50LmNoaWxkTm9kZXMuaXRlbSgwKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gc291cmNlUmVmcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCByZWYgPSBzb3VyY2VSZWZzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XHJcbiAgICAgICAgICAgIHNvdXJjZS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmVmLnNvdXJjZWZpbGUgKyAnOicgKyByZWYubGluZW51bWJlci50b1N0cmluZygxMCkpKTtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5pbnNlcnRCZWZvcmUoc291cmNlLCBpbnNlcnRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGluc2VydFBvc2l0aW9uID0gc291cmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbW92ZUFsbFNvdXJjZVJlZmVyZW5jZXMoKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuICAgICAgICBjb25zdCB0b0JlUmVtb3ZlZCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHNvdXJjZUVsZW1lbnRzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIHRvQmVSZW1vdmVkLnB1c2goZWxlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvQmVSZW1vdmVkLmZvckVhY2goKGVsZW0pID0+IHtlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIHNldCBpbiB0aGUgdGVtcGxhdGUgYXMgdmFsdWUgb2YgdGhlIGkxOG4tYXR0cmlidXRlLlxyXG4gICAgICogZS5nLiBpMThuPVwibXlkZXNjcmlwdGlvblwiLlxyXG4gICAgICogSW4geG1iIHRoaXMgaXMgc3RvcmVkIGluIHRoZSBhdHRyaWJ1dGUgXCJkZXNjXCIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGVzYycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1lYW5pbmcgKGludGVudCkgc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBwYXJ0IGluIGZyb250IG9mIHRoZSB8IHN5bWJvbC5cclxuICAgICAqIGUuZy4gaTE4bj1cIm1lYW5pbmd8bXlkZXNjcmlwdGlvblwiLlxyXG4gICAgICogSW4geG1iIHRoaXMgaXMgc3RvcmVkIGluIHRoZSBhdHRyaWJ1dGUgXCJtZWFuaW5nXCIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtZWFuaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdtZWFuaW5nJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBkZXNjcmlwdGlvbiBhbmQgbWVhbmluZyBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldERlc2NyaXB0aW9uIGFuZCBzZXRNZWFuaW5nIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTZXREZXNjcmlwdGlvbkFuZE1lYW5pbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIGRlc2NyaXB0aW9uIHByb3BlcnR5IG9mIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gZGVzY3JpcHRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkLCBkbyBub3RoaW5nXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgbWVhbmluZyBwcm9wZXJ0eSBvZiB0cmFucy11bml0LlxyXG4gICAgICogQHBhcmFtIG1lYW5pbmcgbWVhbmluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0TWVhbmluZyhtZWFuaW5nOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkLCBkbyBub3RoaW5nXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIG5vdGVzIG9mIHRoZSB0cmFucy11bml0LlxyXG4gICAgICogVGhlcmUgYXJlIE5PIG5vdGVzIGluIHhtYi94dGJcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vdGVzKCk6IElOb3RlW10ge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciBzZXR0aW5nIG9mIG5vdGVzIGlzIHN1cHBvcnRlZC5cclxuICAgICAqIElmIG5vdCwgc2V0Tm90ZXMgd2lsbCBkbyBub3RoaW5nLlxyXG4gICAgICogeHRiIGRvZXMgbm90IHN1cHBvcnQgdGhpcywgYWxsIG90aGVyIGZvcm1hdHMgZG8uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdXBwb3J0c1NldE5vdGVzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBub3RlcyB0byB0cmFucyB1bml0LlxyXG4gICAgICogQHBhcmFtIG5ld05vdGVzIHRoZSBub3RlcyB0byBhZGQuXHJcbiAgICAgKiBOT1QgU3VwcG9ydGVkIGluIHhtYi94dGJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldE5vdGVzKG5ld05vdGVzOiBJTm90ZVtdKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCwgZG8gbm90aGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBzb3VyY2UgdG8gdGFyZ2V0IHRvIHVzZSBpdCBhcyBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqIFJldHVybnMgYSBjaGFuZ2VkIGNvcHkgb2YgdGhpcyB0cmFucyB1bml0LlxyXG4gICAgICogcmVjZWl2ZXIgaXMgbm90IGNoYW5nZWQuXHJcbiAgICAgKiAoaW50ZXJuYWwgdXNhZ2Ugb25seSwgYSBjbGllbnQgc2hvdWxkIGNhbGwgaW1wb3J0TmV3VHJhbnNVbml0IG9uIElUcmFuc2xhdGlvbk1lc3NhZ2VGaWxlKVxyXG4gICAgICogSW4geG1iIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8sIGJlY2F1c2UgdGhlcmUgaXMgb25seSBhIHRhcmdldCwgbm8gc291cmNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xvbmVXaXRoU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4sIHRhcmdldEZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSk6IEFic3RyYWN0VHJhbnNVbml0IHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcHkgc291cmNlIHRvIHRhcmdldCB0byB1c2UgaXQgYXMgZHVtbXkgdHJhbnNsYXRpb24uXHJcbiAgICAgKiAoaW50ZXJuYWwgdXNhZ2Ugb25seSwgYSBjbGllbnQgc2hvdWxkIGNhbGwgY3JlYXRlVHJhbnNsYXRpb25GaWxlRm9yTGFuZyBvbiBJVHJhbnNsYXRpb25NZXNzYWdlRmlsZSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVzZVNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0cmFuc2xhdGlvbiB0byBhIGdpdmVuIHN0cmluZyAoaW5jbHVkaW5nIG1hcmt1cCkuXHJcbiAgICAgKiBJbiBmYWN0LCB4bWIgY2Fubm90IGJlIHRyYW5zbGF0ZWQuXHJcbiAgICAgKiBTbyB0aGlzIHRocm93cyBhbiBlcnJvci5cclxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiB0cmFuc2xhdGlvblxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdHJhbnNsYXRlTmF0aXZlKHRyYW5zbGF0aW9uOiBzdHJpbmcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgdHJhbnNsYXRlIHhtYiBmaWxlcywgdXNlIHh0YiBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZUZhY3Rvcnl9IGZyb20gJy4uL2FwaS9pLXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUtZmFjdG9yeSc7XHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuLi9hcGkvaS10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuaW1wb3J0IHtJVHJhbnNVbml0fSBmcm9tICcuLi9hcGkvaS10cmFucy11bml0JztcclxuaW1wb3J0IHtGT1JNQVRfWE1CLCBGSUxFVFlQRV9YTUIsIEZPUk1BVF9YVEJ9IGZyb20gJy4uL2FwaS9jb25zdGFudHMnO1xyXG5pbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7WG1iVHJhbnNVbml0fSBmcm9tICcuL3htYi10cmFucy11bml0JztcclxuaW1wb3J0IHtBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuL2Fic3RyYWN0LXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUnO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDEwLjAzLjIwMTcuXHJcbiAqIHhtYi1GaWxlIGFjY2Vzcy5cclxuICovXHJcblxyXG4vKipcclxuICogRG9jdHlwZSBvZiB4dGIgdHJhbnNsYXRpb24gZmlsZSBjb3JyZXNwb25kaW5nIHdpdGggdGhvcyB4bWIgZmlsZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBYVEJfRE9DVFlQRSA9IGA8IURPQ1RZUEUgdHJhbnNsYXRpb25idW5kbGUgW1xyXG4gIDwhRUxFTUVOVCB0cmFuc2xhdGlvbmJ1bmRsZSAodHJhbnNsYXRpb24pKj5cclxuICA8IUFUVExJU1QgdHJhbnNsYXRpb25idW5kbGUgbGFuZyBDREFUQSAjUkVRVUlSRUQ+XHJcbiAgPCFFTEVNRU5UIHRyYW5zbGF0aW9uICgjUENEQVRBfHBoKSo+XHJcbiAgPCFBVFRMSVNUIHRyYW5zbGF0aW9uIGlkIENEQVRBICNSRVFVSVJFRD5cclxuICA8IUVMRU1FTlQgcGggRU1QVFk+XHJcbiAgPCFBVFRMSVNUIHBoIG5hbWUgQ0RBVEEgI1JFUVVJUkVEPlxyXG5dPmA7XHJcblxyXG5leHBvcnQgY2xhc3MgWG1iRmlsZSBleHRlbmRzIEFic3RyYWN0VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUgaW1wbGVtZW50cyBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIHhtYi1GaWxlIGZyb20gc291cmNlLlxyXG4gICAgICogQHBhcmFtIF90cmFuc2xhdGlvbk1lc3NhZ2VGaWxlRmFjdG9yeSBmYWN0b3J5IHRvIGNyZWF0ZSBhIHRyYW5zbGF0aW9uIGZpbGUgKHh0YikgZm9yIHRoZSB4bWIgZmlsZVxyXG4gICAgICogQHBhcmFtIHhtbFN0cmluZyBmaWxlIGNvbnRlbnRcclxuICAgICAqIEBwYXJhbSBwYXRoIFBhdGggdG8gZmlsZVxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIG9wdGlvbmFsIGVuY29kaW5nIG9mIHRoZSB4bWwuXHJcbiAgICAgKiBUaGlzIGlzIHJlYWQgZnJvbSB0aGUgZmlsZSwgYnV0IGlmIHlvdSBrbm93IGl0IGJlZm9yZSwgeW91IGNhbiBhdm9pZCByZWFkaW5nIHRoZSBmaWxlIHR3aWNlLlxyXG4gICAgICogQHJldHVybiBYbWJGaWxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgX3RyYW5zbGF0aW9uTWVzc2FnZUZpbGVGYWN0b3J5OiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5LFxyXG4gICAgICAgIHhtbFN0cmluZzogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpIHtcclxuXHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl93YXJuaW5ncyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mVHJhbnNVbml0c1dpdGhNaXNzaW5nSWQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZyb21Db250ZW50KHhtbFN0cmluZywgcGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZUZyb21Db250ZW50KHhtbFN0cmluZzogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpOiBYbWJGaWxlIHtcclxuICAgICAgICB0aGlzLnBhcnNlQ29udGVudCh4bWxTdHJpbmcsIHBhdGgsIGVuY29kaW5nKTtcclxuICAgICAgICBpZiAodGhpcy5fcGFyc2VkRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ21lc3NhZ2VidW5kbGUnKS5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRmlsZSBcIiVzXCIgc2VlbXMgdG8gYmUgbm8geG1iIGZpbGUgKHNob3VsZCBjb250YWluIGEgbWVzc2FnZWJ1bmRsZSBlbGVtZW50KScsIHBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVUcmFuc1VuaXRzKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNVbml0cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zVW5pdHNJbkZpbGUgPSB0aGlzLl9wYXJzZWREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbXNnJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc1VuaXRzSW5GaWxlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRyYW5zVW5pdHNJbkZpbGUuaXRlbShpKTtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBtc2cuZ2V0QXR0cmlidXRlKCdpZCcpO1xyXG4gICAgICAgICAgICBpZiAoIWlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93YXJuaW5ncy5wdXNoKGZvcm1hdCgnb29wcywgbXNnIHdpdGhvdXQgXCJpZFwiIGZvdW5kIGluIG1hc3RlciwgcGxlYXNlIGNoZWNrIGZpbGUgJXMnLCB0aGlzLl9maWxlbmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNVbml0cy5wdXNoKG5ldyBYbWJUcmFuc1VuaXQobXNnLCBpZCwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGUgZm9ybWF0IGFzIGl0IGlzIHVzZWQgaW4gY29uZmlnIGZpbGVzLlxyXG4gICAgICogQ3VycmVudGx5ICd4bGYnLCAneG1iJywgJ3htYjInXHJcbiAgICAgKiBSZXR1cm5zIG9uZSBvZiB0aGUgY29uc3RhbnRzIEZPUk1BVF8uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaTE4bkZvcm1hdCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBGT1JNQVRfWE1CO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsZSB0eXBlLlxyXG4gICAgICogSGVyZSAnWE1CJ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmlsZVR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gRklMRVRZUEVfWE1CO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRhZyBuYW1lcyBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIG1peGVkIGNvbnRlbnQuXHJcbiAgICAgKiBUaGVzZSBlbGVtZW50cyB3aWxsIG5vdCBiZSBiZWF1dGlmaWVkLlxyXG4gICAgICogVHlwaWNhbCBjYW5kaWRhdGVzIGFyZSBzb3VyY2UgYW5kIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGVsZW1lbnRzV2l0aE1peGVkQ29udGVudCgpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgcmV0dXJuIFsnbWVzc2FnZSddO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3Vlc3MgbGFuZ3VhZ2UgZnJvbSBmaWxlbmFtZS5cclxuICAgICAqIElmIGZpbGVuYW1lIGlzIGZvby54eS54bWIsIHRoYW4gbGFuZ3VhZ2UgaXMgYXNzdW1lZCB0byBiZSB4eS5cclxuICAgICAqIEByZXR1cm4gTGFuZ3VhZ2Ugb3IgbnVsbFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGd1ZXNzTGFuZ3VhZ2VGcm9tRmlsZW5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5fZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gdGhpcy5fZmlsZW5hbWUuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIgJiYgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3htYicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBzb3VyY2UgbGFuZ3VhZ2UuXHJcbiAgICAgKiBVbnN1cHBvcnRlZCBpbiB4bWIuXHJcbiAgICAgKiBUcnkgdG8gZ3Vlc3MgaXQgZnJvbSBmaWxlbmFtZSBpZiBhbnkuLlxyXG4gICAgICogQHJldHVybiBzb3VyY2UgbGFuZ3VhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VMYW5ndWFnZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmd1ZXNzTGFuZ3VhZ2VGcm9tRmlsZW5hbWUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXQgdGhlIHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqIFVuc3VwcG9ydGVkIGluIHhtYi5cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZSBsYW5ndWFnZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U291cmNlTGFuZ3VhZ2UobGFuZ3VhZ2U6IHN0cmluZykge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmcsIHhtYiBoYXMgbm8gbm90YXRpb24gZm9yIHRoaXMuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICogVW5zdXBwb3J0ZWQgaW4geG1iLlxyXG4gICAgICogVHJ5IHRvIGd1ZXNzIGl0IGZyb20gZmlsZW5hbWUgaWYgYW55Li5cclxuICAgICAqIEByZXR1cm4gdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdGFyZ2V0TGFuZ3VhZ2UoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ndWVzc0xhbmd1YWdlRnJvbUZpbGVuYW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFZGl0IHRoZSB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBVbnN1cHBvcnRlZCBpbiB4bWIuXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2UgbGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRhcmdldExhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nLCB4bWIgaGFzIG5vIG5vdGF0aW9uIGZvciB0aGlzLlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgbmV3IHRyYW5zLXVuaXQgdG8gdGhpcyBmaWxlLlxyXG4gICAgICogVGhlIHRyYW5zIHVuaXQgc3RlbXMgZnJvbSBhbm90aGVyIGZpbGUuXHJcbiAgICAgKiBJdCBjb3BpZXMgdGhlIHNvdXJjZSBjb250ZW50IG9mIHRoZSB0dSB0byB0aGUgdGFyZ2V0IGNvbnRlbnQgdG9vLFxyXG4gICAgICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgaXNEZWZhdWx0TGFuZyBhbmQgY29weUNvbnRlbnQuXHJcbiAgICAgKiBTbyB0aGUgc291cmNlIGNhbiBiZSB1c2VkIGFzIGEgZHVtbXkgdHJhbnNsYXRpb24uXHJcbiAgICAgKiAodXNlZCBieSB4bGlmZm1lcmdlKVxyXG4gICAgICogQHBhcmFtIGZvcmVpZ25UcmFuc1VuaXQgdGhlIHRyYW5zIHVuaXQgdG8gYmUgaW1wb3J0ZWQuXHJcbiAgICAgKiBAcGFyYW0gaXNEZWZhdWx0TGFuZyBGbGFnLCB3ZXRoZXIgZmlsZSBjb250YWlucyB0aGUgZGVmYXVsdCBsYW5ndWFnZS5cclxuICAgICAqIFRoZW4gc291cmNlIGFuZCB0YXJnZXQgYXJlIGp1c3QgZXF1YWwuXHJcbiAgICAgKiBUaGUgY29udGVudCB3aWxsIGJlIGNvcGllZC5cclxuICAgICAqIFN0YXRlIHdpbGwgYmUgZmluYWwuXHJcbiAgICAgKiBAcGFyYW0gY29weUNvbnRlbnQgRmxhZywgd2V0aGVyIHRvIGNvcHkgY29udGVudCBvciBsZWF2ZSBpdCBlbXB0eS5cclxuICAgICAqIFdiZW4gdHJ1ZSwgY29udGVudCB3aWxsIGJlIGNvcGllZCBmcm9tIHNvdXJjZS5cclxuICAgICAqIFdoZW4gZmFsc2UsIGNvbnRlbnQgd2lsbCBiZSBsZWZ0IGVtcHR5IChpZiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UpLlxyXG4gICAgICogQHBhcmFtIGltcG9ydEFmdGVyRWxlbWVudCBvcHRpb25hbCAoc2luY2UgMS4xMCkgb3RoZXIgdHJhbnN1bml0IChwYXJ0IG9mIHRoaXMgZmlsZSksIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgYW5jZXN0b3IuXHJcbiAgICAgKiBOZXdseSBpbXBvcnRlZCB0cmFucyB1bml0IGlzIHRoZW4gaW5zZXJ0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhpcyBlbGVtZW50LlxyXG4gICAgICogSWYgbm90IHNldCBvciBub3QgcGFydCBvZiB0aGlzIGZpbGUsIG5ldyB1bml0IHdpbGwgYmUgaW1wb3J0ZWQgYXQgdGhlIGVuZC5cclxuICAgICAqIElmIGV4cGxpY2l0eSBzZXQgdG8gbnVsbCwgbmV3IHVuaXQgd2lsbCBiZSBpbXBvcnRlZCBhdCB0aGUgc3RhcnQuXHJcbiAgICAgKiBAcmV0dXJuIHRoZSBuZXdseSBpbXBvcnRlZCB0cmFucyB1bml0IChzaW5jZSB2ZXJzaW9uIDEuNy4wKVxyXG4gICAgICogQHRocm93cyBhbiBlcnJvciBpZiB0cmFucy11bml0IHdpdGggc2FtZSBpZCBhbHJlYWR5IGlzIGluIHRoZSBmaWxlLlxyXG4gICAgICovXHJcbiAgICBpbXBvcnROZXdUcmFuc1VuaXQoZm9yZWlnblRyYW5zVW5pdDogSVRyYW5zVW5pdCwgaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4sIGltcG9ydEFmdGVyRWxlbWVudD86IElUcmFuc1VuaXQpXHJcbiAgICAgICAgOiBJVHJhbnNVbml0IHtcclxuICAgICAgICB0aHJvdyBFcnJvcigneG1iIGZpbGUgY2Fubm90IGJlIHVzZWQgdG8gc3RvcmUgdHJhbnNsYXRpb25zLCB1c2UgeHRiIGZpbGUnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2xhdGlvbiBmaWxlIGZvciB0aGlzIGZpbGUgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBqdXN0IGEgY29weSBvZiB0aGUgb3JpZ2luYWwgb25lLlxyXG4gICAgICogQnV0IGZvciBYTUIgdGhlIHRyYW5zbGF0aW9uIGZpbGUgaGFzIGZvcm1hdCAnWFRCJy5cclxuICAgICAqIEBwYXJhbSBsYW5nIExhbmd1YWdlIGNvZGVcclxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBleHBlY3RlZCBmaWxlbmFtZSB0byBzdG9yZSBmaWxlXHJcbiAgICAgKiBAcGFyYW0gaXNEZWZhdWx0TGFuZyBGbGFnLCB3ZXRoZXIgZmlsZSBjb250YWlucyB0aGUgZGVmYXVsdCBsYW5ndWFnZS5cclxuICAgICAqIFRoZW4gc291cmNlIGFuZCB0YXJnZXQgYXJlIGp1c3QgZXF1YWwuXHJcbiAgICAgKiBUaGUgY29udGVudCB3aWxsIGJlIGNvcGllZC5cclxuICAgICAqIFN0YXRlIHdpbGwgYmUgZmluYWwuXHJcbiAgICAgKiBAcGFyYW0gY29weUNvbnRlbnQgRmxhZywgd2V0aGVyIHRvIGNvcHkgY29udGVudCBvciBsZWF2ZSBpdCBlbXB0eS5cclxuICAgICAqIFdiZW4gdHJ1ZSwgY29udGVudCB3aWxsIGJlIGNvcGllZCBmcm9tIHNvdXJjZS5cclxuICAgICAqIFdoZW4gZmFsc2UsIGNvbnRlbnQgd2lsbCBiZSBsZWZ0IGVtcHR5IChpZiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlVHJhbnNsYXRpb25GaWxlRm9yTGFuZyhsYW5nOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcsIGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuKVxyXG4gICAgICAgIDogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbmJ1bmRsZVhNTFNvdXJjZSA9XHJcbiAgICAgICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG4nICsgWFRCX0RPQ1RZUEUgKyAnXFxuPHRyYW5zbGF0aW9uYnVuZGxlPlxcbjwvdHJhbnNsYXRpb25idW5kbGU+XFxuJztcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbkZpbGUgPSB0aGlzLl90cmFuc2xhdGlvbk1lc3NhZ2VGaWxlRmFjdG9yeS5jcmVhdGVGaWxlRnJvbUZpbGVDb250ZW50KFxyXG4gICAgICAgICAgICBGT1JNQVRfWFRCLFxyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbmJ1bmRsZVhNTFNvdXJjZSwgZmlsZW5hbWUsIHRoaXMuZW5jb2RpbmcoKSxcclxuICAgICAgICAgICAge3htbENvbnRlbnQ6IHRoaXMuZWRpdGVkQ29udGVudCgpLCBwYXRoOiB0aGlzLmZpbGVuYW1lKCksIGVuY29kaW5nOiB0aGlzLmVuY29kaW5nKCl9KTtcclxuICAgICAgICB0cmFuc2xhdGlvbkZpbGUuc2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCh0aGlzLnRhcmdldFByYWVmaXgpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRmlsZS5zZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgodGhpcy50YXJnZXRTdWZmaXgpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRmlsZS5zZXRUYXJnZXRMYW5ndWFnZShsYW5nKTtcclxuICAgICAgICB0cmFuc2xhdGlvbkZpbGUuc2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCh0aGlzLmdldE5ld1RyYW5zVW5pdFRhcmdldFByYWVmaXgoKSk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25GaWxlLnNldE5ld1RyYW5zVW5pdFRhcmdldFN1ZmZpeCh0aGlzLmdldE5ld1RyYW5zVW5pdFRhcmdldFN1ZmZpeCgpKTtcclxuICAgICAgICB0aGlzLmZvckVhY2hUcmFuc1VuaXQoKHR1KSA9PiB7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uRmlsZS5pbXBvcnROZXdUcmFuc1VuaXQodHUsIGlzRGVmYXVsdExhbmcsIGNvcHlDb250ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25GaWxlO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge0Fic3RyYWN0TWVzc2FnZVBhcnNlcn0gZnJvbSAnLi9hYnN0cmFjdC1tZXNzYWdlLXBhcnNlcic7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZ30gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXN0YXJ0LXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRFbmRUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1lbmQtdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtcGxhY2Vob2xkZXInO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0VGV4dH0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXRleHQnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuaW1wb3J0IHtUYWdNYXBwaW5nfSBmcm9tICcuL3RhZy1tYXBwaW5nJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydEVtcHR5VGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW1wdHktdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWZ9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1pY3UtbWVzc2FnZS1yZWYnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAxMC4wNS4yMDE3LlxyXG4gKiBBIG1lc3NhZ2UgcGFyc2VyIGZvciBYTElGRiAyLjBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBYbGlmZjJNZXNzYWdlUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlUGFyc2VyIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSB0aGlzIGVsZW1lbnQgbm9kZS5cclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgY2hpbGRyZW4gYXJlIGRvbmUuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudE5vZGUgZWxlbWVudE5vZGVcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2UgdG8gYmUgYWx0ZXJlZFxyXG4gICAgICogQHJldHVybiB0cnVlLCBpZiBjaGlsZHJlbiBzaG91bGQgYmUgcHJvY2Vzc2VkIHRvbywgZmFsc2Ugb3RoZXJ3aXNlIChjaGlsZHJlbiBpZ25vcmVkIHRoZW4pXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwcm9jZXNzU3RhcnRFbGVtZW50KGVsZW1lbnROb2RlOiBFbGVtZW50LCBtZXNzYWdlOiBQYXJzZWRNZXNzYWdlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnROb2RlLnRhZ05hbWU7XHJcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdwaCcpIHtcclxuICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYXJlIGxpa2UgPHBoIGlkPVwiMFwiIGVxdWl2PVwiSU5URVJQT0xBVElPTlwiIGRpc3A9XCJ7e251bWJlcigpfX1cIi8+XHJcbiAgICAgICAgICAgIC8vIFRoZXkgY29udGFpbiB0aGUgaWQgYW5kIGFsc28gYSBuYW1lIChudW1iZXIgaW4gdGhlIGV4YW1wbGUpXHJcbiAgICAgICAgICAgIC8vIFRPRE8gbWFrZSBzb21lIHVzZSBvZiB0aGUgbmFtZSAoYnV0IGl0IGlzIG5vdCBhdmFpbGFibGUgaW4gWExJRkYgMS4yKVxyXG4gICAgICAgICAgICAvLyBJQ1UgbWVzc2FnZSBhcmUgaGFuZGxlZCB3aXRoIHRoZSBzYW1lIHRhZ1xyXG4gICAgICAgICAgICAvLyBCZWZvcmUgNC4zLjIgdGhleSBkaWQgbm90IGhhdmUgYW4gZXF1aXYgYW5kIGRpc3AgKEJ1ZyAjMTczNDQpOlxyXG4gICAgICAgICAgICAvLyBlLmcuIDxwaCBpZD1cIjBcIi8+XHJcbiAgICAgICAgICAgIC8vIEJlZ2lubmluZyB3aXRoIDQuMy4yIHRoZXkgZG8gaGF2ZSBhbiBlcXVpdiBJQ1UgYW5kIGRpc3A6XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPHBoIGlkPVwiMFwiIGVxdWl2PVwiSUNVXCIgZGlzcD1cIntjb3VudCwgcGx1cmFsLCA9MCB7Li4ufSA9MSB7Li4ufSBvdGhlciB7Li4ufX1cIi8+XHJcbiAgICAgICAgICAgIC8vIGFuZCBlbXB0eSB0YWdzIGhhdmUgZXF1aXYgb3RoZXIgdGhlbiBJTlRFUlBPTEFUSU9OOlxyXG4gICAgICAgICAgICAvLyBlLmcuIDxwaCBpZD1cIjNcIiBlcXVpdj1cIlRBR19JTUdcIiB0eXBlPVwiaW1hZ2VcIiBkaXNwPVwiJmx0O2ltZy8+XCIvPlxyXG4gICAgICAgICAgICAvLyBvciA8cGggZXF1aXY9XCJMSU5FX0JSRUFLXCIgdHlwZT1cImxiXCIgZGlzcD1cIiZsdDtici8+XCIvPlxyXG4gICAgICAgICAgICBsZXQgaXNJbnRlcnBvbGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBpc0lDVSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgaXNFbXB0eVRhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBlcXVpdiA9IGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnZXF1aXYnKTtcclxuICAgICAgICAgICAgY29uc3QgZGlzcCA9IGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnZGlzcCcpO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXhTdHJpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBsZXQgZW1wdHlUYWdOYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFlcXVpdikge1xyXG4gICAgICAgICAgICAgICAgLy8gb2xkIElDVSBzeW50YXgsIGZpeGVkIHdpdGggIzE3MzQ0XHJcbiAgICAgICAgICAgICAgICBpc0lDVSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpbmRleFN0cmluZyA9IGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KGluZGV4U3RyaW5nLCAxMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXF1aXYuc3RhcnRzV2l0aCgnSUNVJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBJQ1Ugc3ludGF4LCBmaXhlZCB3aXRoICMxNzM0NFxyXG4gICAgICAgICAgICAgICAgaXNJQ1UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVxdWl2ID09PSAnSUNVJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4U3RyaW5nID0gJzAnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleFN0cmluZyA9IGVxdWl2LnN1YnN0cmluZygnSUNVXycubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KGluZGV4U3RyaW5nLCAxMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXF1aXYuc3RhcnRzV2l0aCgnSU5URVJQT0xBVElPTicpKSB7XHJcbiAgICAgICAgICAgICAgICBpc0ludGVycG9sYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVxdWl2ID09PSAnSU5URVJQT0xBVElPTicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleFN0cmluZyA9ICcwJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhTdHJpbmcgPSBlcXVpdi5zdWJzdHJpbmcoJ0lOVEVSUE9MQVRJT05fJy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBOdW1iZXIucGFyc2VJbnQoaW5kZXhTdHJpbmcsIDEwKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXcgVGFnTWFwcGluZygpLmlzRW1wdHlUYWdQbGFjZWhvbGRlck5hbWUoZXF1aXYpKSB7XHJcbiAgICAgICAgICAgICAgICBpc0VtcHR5VGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGVtcHR5VGFnTmFtZSA9IG5ldyBUYWdNYXBwaW5nKCkuZ2V0VGFnbmFtZUZyb21FbXB0eVRhZ1BsYWNlaG9sZGVyTmFtZShlcXVpdik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZFBsYWNlaG9sZGVyKGluZGV4LCBkaXNwKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0lDVSkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRJQ1VNZXNzYWdlUmVmKGluZGV4LCBkaXNwKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0VtcHR5VGFnKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZEVtcHR5VGFnKGVtcHR5VGFnTmFtZSwgdGhpcy5wYXJzZUlkQ291bnRGcm9tTmFtZShlcXVpdikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAncGMnKSB7XHJcbiAgICAgICAgICAgIC8vIHBjIGV4YW1wbGU6IDxwYyBpZD1cIjBcIiBlcXVpdlN0YXJ0PVwiU1RBUlRfQk9MRF9URVhUXCIgZXF1aXZFbmQ9XCJDTE9TRV9CT0xEX1RFWFRcIiB0eXBlPVwiZm10XCJcclxuICAgICAgICAgICAgLy8gZGlzcFN0YXJ0PVwiJmx0O2ImZ3Q7XCIgZGlzcEVuZD1cIiZsdDsvYiZndDtcIj5JTVBPUlRBTlQ8L3BjPlxyXG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFRhZ05hbWUgPSB0aGlzLnRhZ05hbWVGcm9tUENFbGVtZW50KGVsZW1lbnROb2RlKTtcclxuICAgICAgICAgICAgaWYgKGVtYmVkZGVkVGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRTdGFydFRhZyhlbWJlZGRlZFRhZ05hbWUsIHRoaXMucGFyc2VJZENvdW50RnJvbU5hbWUoZWxlbWVudE5vZGUuZ2V0QXR0cmlidXRlKCdlcXVpdlN0YXJ0JykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBlbmQgb2YgdGhpcyBlbGVtZW50IG5vZGUuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciBhbGwgY2hpbGRyZW4gYXJlIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50Tm9kZSBlbGVtZW50Tm9kZVxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZSB0byBiZSBhbHRlcmVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwcm9jZXNzRW5kRWxlbWVudChlbGVtZW50Tm9kZTogRWxlbWVudCwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50Tm9kZS50YWdOYW1lO1xyXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAncGMnKSB7XHJcbiAgICAgICAgICAgIC8vIHBjIGV4YW1wbGU6IDxwYyBpZD1cIjBcIiBlcXVpdlN0YXJ0PVwiU1RBUlRfQk9MRF9URVhUXCIgZXF1aXZFbmQ9XCJDTE9TRV9CT0xEX1RFWFRcIiB0eXBlPVwiZm10XCJcclxuICAgICAgICAgICAgLy8gZGlzcFN0YXJ0PVwiJmx0O2ImZ3Q7XCIgZGlzcEVuZD1cIiZsdDsvYiZndDtcIj5JTVBPUlRBTlQ8L3BjPlxyXG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFRhZ05hbWUgPSB0aGlzLnRhZ05hbWVGcm9tUENFbGVtZW50KGVsZW1lbnROb2RlKTtcclxuICAgICAgICAgICAgaWYgKGVtYmVkZGVkVGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRFbmRUYWcoZW1iZWRkZWRUYWdOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFnTmFtZUZyb21QQ0VsZW1lbnQocGNOb2RlOiBFbGVtZW50KTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgZGlzcFN0YXJ0ID0gcGNOb2RlLmdldEF0dHJpYnV0ZSgnZGlzcFN0YXJ0Jyk7XHJcbiAgICAgICAgaWYgKGRpc3BTdGFydC5zdGFydHNXaXRoKCc8JykpIHtcclxuICAgICAgICAgICAgZGlzcFN0YXJ0ID0gZGlzcFN0YXJ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3BTdGFydC5lbmRzV2l0aCgnPicpKSB7XHJcbiAgICAgICAgICAgIGRpc3BTdGFydCA9IGRpc3BTdGFydC5zdWJzdHJpbmcoMCwgZGlzcFN0YXJ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlzcFN0YXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVpbXBsZW1lbnRlZCBoZXJlLCBiZWNhdXNlIFhMSUZGIDIuMCB1c2VzIGEgZGVlcGVyIHhtbCBtb2RlbC5cclxuICAgICAqIFNvIHdlIGNhbm5vdCBzaW1wbHkgcmVwbGFjZSB0aGUgbWVzc2FnZSBwYXJ0cyBieSB4bWwgcGFydHMuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlXHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFkZFhtbFJlcHJlc2VudGF0aW9uVG9Sb290KG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UsIHJvb3RFbGVtOiBFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbe2VsZW1lbnQ6IHJvb3RFbGVtLCB0YWdOYW1lOiAncm9vdCd9XTtcclxuICAgICAgICBsZXQgaWQgPSAwO1xyXG4gICAgICAgIG1lc3NhZ2UucGFydHMoKS5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5URVhUOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmVsZW1lbnQuYXBwZW5kQ2hpbGQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlRleHRQYXJ0KDxQYXJzZWRNZXNzYWdlUGFydFRleHQ+IHBhcnQsIHJvb3RFbGVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5QTEFDRUhPTERFUjpcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5lbGVtZW50LmFwcGVuZENoaWxkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZQbGFjZWhvbGRlclBhcnQoPFBhcnNlZE1lc3NhZ2VQYXJ0UGxhY2Vob2xkZXI+IHBhcnQsIHJvb3RFbGVtLCBpZCsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5JQ1VfTUVTU0FHRV9SRUY6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uZWxlbWVudC5hcHBlbmRDaGlsZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mSUNVTWVzc2FnZVJlZlBhcnQoPFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZj4gcGFydCwgcm9vdEVsZW0pKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLlNUQVJUX1RBRzpcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUYWdFbGVtID0gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mU3RhcnRUYWdQYXJ0KDxQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnPiBwYXJ0LCByb290RWxlbSwgaWQrKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uZWxlbWVudC5hcHBlbmRDaGlsZChuZXdUYWdFbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHtlbGVtZW50OiA8RWxlbWVudD4gbmV3VGFnRWxlbSwgdGFnTmFtZTogKDxQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnPiBwYXJ0KS50YWdOYW1lKCl9KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLkVORF9UQUc6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvc2VUYWdOYW1lID0gKDxQYXJzZWRNZXNzYWdlUGFydEVuZFRhZz4gcGFydCkudGFnTmFtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPD0gMSB8fCBzdGFja1tzdGFjay5sZW5ndGggLSAxXS50YWdOYW1lICE9PSBjbG9zZVRhZ05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb29wcywgbm90IHdlbGwgZm9ybWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBjbG9zZSB0YWcgJyArIGNsb3NlVGFnTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuRU1QVFlfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5VGFnRWxlbSA9IHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVtcHR5VGFnUGFydCg8UGFyc2VkTWVzc2FnZVBhcnRFbXB0eVRhZz4gcGFydCwgcm9vdEVsZW0sIGlkKyspO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZW1wdHlUYWdFbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgLy8gb29wcywgbm90IHdlbGwgY2xvc2VkIHRhZ3NcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNsb3NlIHRhZyAnICsgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0udGFnTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBzdGFydCB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IHBjLUVsZW1lbnQuXHJcbiAgICAgKiBlLmcuIDxwYyBpZD1cIjBcIiBlcXVpdlN0YXJ0PVwiU1RBUlRfQk9MRF9URVhUXCIgZXF1aXZFbmQ9XCJDTE9TRV9CT0xEX1RFWFRcIiB0eXBlPVwiZm10XCIgZGlzcFN0YXJ0PVwiJmx0O2ImZ3Q7XCIgZGlzcEVuZD1cIiZsdDsvYiZndDtcIj5cclxuICAgICAqIFRleHQgY29udGVudCB3aWxsIGJlIGFkZGVkIGxhdGVyLlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKiBAcGFyYW0gaWQgaWQgbnVtYmVyIGluIHhsaWZmMlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlN0YXJ0VGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnLCByb290RWxlbTogRWxlbWVudCwgaWQ6IG51bWJlcik6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHRhZ01hcHBpbmcgPSBuZXcgVGFnTWFwcGluZygpO1xyXG4gICAgICAgIGNvbnN0IHBjRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGMnKTtcclxuICAgICAgICBjb25zdCB0YWdOYW1lID0gcGFydC50YWdOYW1lKCk7XHJcbiAgICAgICAgY29uc3QgZXF1aXZTdGFydCA9IHRhZ01hcHBpbmcuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUodGFnTmFtZSwgcGFydC5pZENvdW50ZXIoKSk7XHJcbiAgICAgICAgY29uc3QgZXF1aXZFbmQgPSB0YWdNYXBwaW5nLmdldENsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKHRhZ05hbWUpO1xyXG4gICAgICAgIGNvbnN0IGRpc3BTdGFydCA9ICc8JyArIHRhZ05hbWUgKyAnPic7XHJcbiAgICAgICAgY29uc3QgZGlzcEVuZCA9ICc8LycgKyB0YWdOYW1lICsgJz4nO1xyXG4gICAgICAgIHBjRWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQudG9TdHJpbmcoMTApKTtcclxuICAgICAgICBwY0VsZW0uc2V0QXR0cmlidXRlKCdlcXVpdlN0YXJ0JywgZXF1aXZTdGFydCk7XHJcbiAgICAgICAgcGNFbGVtLnNldEF0dHJpYnV0ZSgnZXF1aXZFbmQnLCBlcXVpdkVuZCk7XHJcbiAgICAgICAgcGNFbGVtLnNldEF0dHJpYnV0ZSgndHlwZScsIHRoaXMuZ2V0VHlwZUZvclRhZyh0YWdOYW1lKSk7XHJcbiAgICAgICAgcGNFbGVtLnNldEF0dHJpYnV0ZSgnZGlzcFN0YXJ0JywgZGlzcFN0YXJ0KTtcclxuICAgICAgICBwY0VsZW0uc2V0QXR0cmlidXRlKCdkaXNwRW5kJywgZGlzcEVuZCk7XHJcbiAgICAgICAgcmV0dXJuIHBjRWxlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgZW5kIHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIE5vdCB1c2VkIGhlcmUsIGJlY2F1c2UgY29udGVudCBpcyBjaGlsZCBvZiBzdGFydCB0YWcuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZFbmRUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIC8vIG5vdCB1c2VkXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGVtcHR5IHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgcGgtRWxlbWVudC5cclxuICAgICAqIGUuZy4gPHBoIGlkPVwiM1wiIGVxdWl2PVwiVEFHX0lNR1wiIHR5cGU9XCJpbWFnZVwiIGRpc3A9XCImbHQ7aW1nLz5cIi8+XHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqIEBwYXJhbSBpZCBpZCBudW1iZXIgaW4geGxpZmYyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mRW1wdHlUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWcsIHJvb3RFbGVtOiBFbGVtZW50LCBpZDogbnVtYmVyKTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgdGFnTWFwcGluZyA9IG5ldyBUYWdNYXBwaW5nKCk7XHJcbiAgICAgICAgY29uc3QgcGhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwaCcpO1xyXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBwYXJ0LnRhZ05hbWUoKTtcclxuICAgICAgICBjb25zdCBlcXVpdiA9IHRhZ01hcHBpbmcuZ2V0RW1wdHlUYWdQbGFjZWhvbGRlck5hbWUodGFnTmFtZSwgcGFydC5pZENvdW50ZXIoKSk7XHJcbiAgICAgICAgY29uc3QgZGlzcCA9ICc8JyArIHRhZ05hbWUgKyAnLz4nO1xyXG4gICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQudG9TdHJpbmcoMTApKTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdlcXVpdicsIGVxdWl2KTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCd0eXBlJywgdGhpcy5nZXRUeXBlRm9yVGFnKHRhZ05hbWUpKTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdkaXNwJywgZGlzcCk7XHJcbiAgICAgICAgcmV0dXJuIHBoRWxlbTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFR5cGVGb3JUYWcodGFnOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSAnYnInOlxyXG4gICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgY2FzZSAnaSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3UnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbXQnO1xyXG4gICAgICAgICAgICBjYXNlICdpbWcnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XHJcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnb3RoZXInO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgcGxhY2Vob2xkZXIgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBSZXR1cm5zIGUuZy4gPHBoIGlkPVwiMVwiIGVxdWl2PVwiSU5URVJQT0xBVElPTl8xXCIgZGlzcD1cInt7dG90YWwoKX19XCIvPlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKiBAcGFyYW0gaWQgaWQgbnVtYmVyIGluIHhsaWZmMlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlBsYWNlaG9sZGVyUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyLCByb290RWxlbTogRWxlbWVudCwgaWQ6IG51bWJlcik6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHBoRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGgnKTtcclxuICAgICAgICBsZXQgZXF1aXZBdHRyaWIgPSAnSU5URVJQT0xBVElPTic7XHJcbiAgICAgICAgaWYgKHBhcnQuaW5kZXgoKSA+IDApIHtcclxuICAgICAgICAgICAgZXF1aXZBdHRyaWIgPSAnSU5URVJQT0xBVElPTl8nICsgcGFydC5pbmRleCgpLnRvU3RyaW5nKDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCBpZC50b1N0cmluZygxMCkpO1xyXG4gICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ2VxdWl2JywgZXF1aXZBdHRyaWIpO1xyXG4gICAgICAgIGNvbnN0IGRpc3AgPSBwYXJ0LmRpc3AoKTtcclxuICAgICAgICBpZiAoZGlzcCkge1xyXG4gICAgICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdkaXNwJywgZGlzcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwaEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGljdSBtZXNzYWdlIHJlZnMgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZJQ1VNZXNzYWdlUmVmUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWYsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgcGhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwaCcpO1xyXG4gICAgICAgIGxldCBlcXVpdkF0dHJpYiA9ICdJQ1UnO1xyXG4gICAgICAgIGlmIChwYXJ0LmluZGV4KCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGVxdWl2QXR0cmliID0gJ0lDVV8nICsgcGFydC5pbmRleCgpLnRvU3RyaW5nKDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCBwYXJ0LmluZGV4KCkudG9TdHJpbmcoMTApKTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdlcXVpdicsIGVxdWl2QXR0cmliKTtcclxuICAgICAgICBjb25zdCBkaXNwID0gcGFydC5kaXNwKCk7XHJcbiAgICAgICAgaWYgKGRpc3ApIHtcclxuICAgICAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnZGlzcCcsIGRpc3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGhFbGVtO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge1NUQVRFX05FVywgU1RBVEVfVFJBTlNMQVRFRCwgU1RBVEVfRklOQUx9IGZyb20gJy4uL2FwaS9jb25zdGFudHMnO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7SU5vcm1hbGl6ZWRNZXNzYWdlfSBmcm9tICcuLi9hcGkvaS1ub3JtYWxpemVkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge0lUcmFuc1VuaXR9IGZyb20gJy4uL2FwaS9pLXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge0lOb3RlfSBmcm9tICcuLi9hcGkvaS1ub3RlJztcclxuaW1wb3J0IHtET01VdGlsaXRpZXN9IGZyb20gJy4vZG9tLXV0aWxpdGllcyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc1VuaXR9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7WGxpZmYyTWVzc2FnZVBhcnNlcn0gZnJvbSAnLi94bGlmZjItbWVzc2FnZS1wYXJzZXInO1xyXG5pbXBvcnQge0Fic3RyYWN0TWVzc2FnZVBhcnNlcn0gZnJvbSAnLi9hYnN0cmFjdC1tZXNzYWdlLXBhcnNlcic7XHJcbmltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJ3V0aWwnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDQuMDUuMjAxNy5cclxuICogQSBUcmFuc2xhdGlvbiBVbml0IGluIGFuIFhMSUZGIDIuMCBmaWxlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZjJUcmFuc1VuaXQgZXh0ZW5kcyBBYnN0cmFjdFRyYW5zVW5pdCAgaW1wbGVtZW50cyBJVHJhbnNVbml0IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudDogRWxlbWVudCwgX2lkOiBzdHJpbmcsIF90cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKSB7XHJcbiAgICAgICAgc3VwZXIoX2VsZW1lbnQsIF9pZCwgX3RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc291cmNlQ29udGVudCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFhNTENvbnRlbnQoc291cmNlRWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbmV3IHNvdXJjZSBjb250ZW50IGluIHRoZSB0cmFuc3VuaXQuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBkb25lIGJ5IG5nLWV4dHJhY3QuXHJcbiAgICAgKiBNZXRob2Qgb25seSBleGlzdHMgdG8gYWxsb3cgeGxpZmZtZXJnZSB0byBtZXJnZSBtaXNzaW5nIGNoYW5nZWQgc291cmNlIGNvbnRlbnQuXHJcbiAgICAgKiBAcGFyYW0gbmV3Q29udGVudCB0aGUgbmV3IGNvbnRlbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTb3VyY2VDb250ZW50KG5ld0NvbnRlbnQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBzb3VyY2UgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICBpZiAoIXNvdXJjZSkge1xyXG4gICAgICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlbiwgdGhlcmUgYWx3YXlzIGhhcyB0byBiZSBhIHNvdXJjZSwgYnV0IHdobyBrbm93cy4uXHJcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzZWdtZW50Jyk7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IHNlZ21lbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChzb3VyY2UsIG5ld0NvbnRlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcGFyc2VyIHVzZWQgZm9yIG5vcm1hbGl6ZWQgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBtZXNzYWdlUGFyc2VyKCk6IEFic3RyYWN0TWVzc2FnZVBhcnNlciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBYbGlmZjJNZXNzYWdlUGFyc2VyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCB2YWx1ZSwgdGhhdCBpcyB0byBiZSB0cmFuc2xhdGVkLCBhcyBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVTb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnc291cmNlJyk7XHJcbiAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZVBhcnNlcigpLmNyZWF0ZU5vcm1hbGl6ZWRNZXNzYWdlRnJvbVhNTChzb3VyY2VFbGVtZW50LCBudWxsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgdHJhbnNsYXRlZCB2YWx1ZSAoY29udGFpbmluZyBhbGwgbWFya3VwLCBkZXBlbmRzIG9uIHRoZSBjb25jcmV0ZSBmb3JtYXQgdXNlZCkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRDb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3RhcmdldCcpO1xyXG4gICAgICAgIHJldHVybiBET01VdGlsaXRpZXMuZ2V0WE1MQ29udGVudCh0YXJnZXRFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB0cmFuc2xhdGVkIHZhbHVlLCBidXQgYWxsIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgd2l0aCB7e259fSAoc3RhcnRpbmcgYXQgMClcclxuICAgICAqIGFuZCBhbGwgZW1iZWRkZWQgaHRtbCBpcyByZXBsYWNlZCBieSBkaXJlY3QgaHRtbCBtYXJrdXAuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldENvbnRlbnROb3JtYWxpemVkKCk6IElOb3JtYWxpemVkTWVzc2FnZSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3RhcmdldCcpO1xyXG4gICAgICAgIHJldHVybiBuZXcgWGxpZmYyTWVzc2FnZVBhcnNlcigpLmNyZWF0ZU5vcm1hbGl6ZWRNZXNzYWdlRnJvbVhNTCh0YXJnZXRFbGVtZW50LCB0aGlzLnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGUgb2YgdGhlIHRyYW5zbGF0aW9uIGFzIHN0b3JlZCBpbiB0aGUgeG1sLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmF0aXZlVGFyZ2V0U3RhdGUoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NlZ21lbnQnKTtcclxuICAgICAgICBpZiAoc2VnbWVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnc3RhdGUnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgc3RhdGUgaW4geG1sLlxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0YXRlIG5hdGl2ZVN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzZXROYXRpdmVUYXJnZXRTdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudEVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzZWdtZW50Jyk7XHJcbiAgICAgICAgaWYgKHNlZ21lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHNlZ21lbnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3RhdGUnLCBuYXRpdmVTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIGFuIGFic3RyYWN0IHN0YXRlIChuZXcsIHRyYW5zbGF0ZWQsIGZpbmFsKSB0byBhIGNvbmNyZXRlIHN0YXRlIHVzZWQgaW4gdGhlIHhtbC5cclxuICAgICAqIFJldHVybnMgdGhlIHN0YXRlIHRvIGJlIHVzZWQgaW4gdGhlIHhtbC5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSBvbmUgb2YgQ29uc3RhbnRzLlNUQVRFLi4uXHJcbiAgICAgKiBAcmV0dXJucyBhIG5hdGl2ZSBzdGF0ZSAoZGVwZW5kcyBvbiBjb25jcmV0ZSBmb3JtYXQpXHJcbiAgICAgKiBAdGhyb3dzIGVycm9yLCBpZiBzdGF0ZSBpcyBpbnZhbGlkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWFwU3RhdGVUb05hdGl2ZVN0YXRlKHN0YXRlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAoIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfTkVXOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbml0aWFsJztcclxuICAgICAgICAgICAgY2FzZSBTVEFURV9UUkFOU0xBVEVEOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGVkJztcclxuICAgICAgICAgICAgY2FzZSBTVEFURV9GSU5BTDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnZmluYWwnO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHN0YXRlICcgKyAgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBhIG5hdGl2ZSBzdGF0ZSAoZm91bmQgaW4gdGhlIGRvY3VtZW50KSB0byBhbiBhYnN0cmFjdCBzdGF0ZSAobmV3LCB0cmFuc2xhdGVkLCBmaW5hbCkuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhYnN0cmFjdCBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSBuYXRpdmVTdGF0ZSBuYXRpdmVTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWFwTmF0aXZlU3RhdGVUb1N0YXRlKG5hdGl2ZVN0YXRlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAoIG5hdGl2ZVN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWwnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX05FVztcclxuICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlZCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVFJBTlNMQVRFRDtcclxuICAgICAgICAgICAgY2FzZSAncmV2aWV3ZWQnOiAvLyBzYW1lIGFzIHRyYW5zbGF0ZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9UUkFOU0xBVEVEO1xyXG4gICAgICAgICAgICBjYXNlICdmaW5hbCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfRklOQUw7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfTkVXO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgc291cmNlIGVsZW1lbnRzIGluIHRoZSB0cmFucyB1bml0LlxyXG4gICAgICogVGhlIHNvdXJjZSBlbGVtZW50IGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cclxuICAgICAqIEl0IGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmaWxlIGFuZCBhIGxpbmUgbnVtYmVyIHdpdGggdGhlIHBvc2l0aW9uIGluc2lkZSB0aGUgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBpcyBqdXN0IGEgaGVscCBmb3IgdHJhbnNsYXRvcnMgdG8gZmluZCB0aGUgY29udGV4dCBmb3IgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogVGhpcyBpcyBzZXQgd2hlbiB1c2luZyBBbmd1bGFyIDQuMCBvciBncmVhdGVyLlxyXG4gICAgICogT3RoZXJ3aXNlIGl0IGp1c3QgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNvdXJjZVJlZmVyZW5jZXMoKToge3NvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyfVtdIHtcclxuICAgICAgICAvLyBTb3VyY2UgaXMgZm91bmQgYXMgPGZpbGU+OjxsaW5lPiBpbiA8bm90ZSBjYXRlZ29yeT1cImxvY2F0aW9uXCI+Li4uXHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbm90ZScpO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZVJlZnM6IHsgc291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyOiBudW1iZXIgfVtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3RlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSBub3RlRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgaWYgKG5vdGVFbGVtLmdldEF0dHJpYnV0ZSgnY2F0ZWdvcnknKSA9PT0gJ2xvY2F0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlQW5kUG9zOiBzdHJpbmcgPSBET01VdGlsaXRpZXMuZ2V0UENEQVRBKG5vdGVFbGVtKTtcclxuICAgICAgICAgICAgICAgIHNvdXJjZVJlZnMucHVzaCh0aGlzLnBhcnNlU291cmNlQW5kUG9zKHNvdXJjZUFuZFBvcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzb3VyY2VSZWZzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHNvbWV0aGluZyBsaWtlICdjOlxceHh4OjcnIGFuZCByZXR1cm5zIHNvdXJjZSBhbmQgbGluZW51bWJlci5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VBbmRQb3Mgc29tZXRoaW5nIGxpa2UgJ2M6XFx4eHg6NycsIGxhc3QgY29sb24gaXMgdGhlIHNlcGFyYXRvclxyXG4gICAgICogQHJldHVybiBzb3VyY2UgYW5kIGxpbmUgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGFyc2VTb3VyY2VBbmRQb3Moc291cmNlQW5kUG9zOiBzdHJpbmcpOiB7IHNvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlciB9IHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHNvdXJjZUFuZFBvcy5sYXN0SW5kZXhPZignOicpO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZWZpbGU6IHNvdXJjZUFuZFBvcyxcclxuICAgICAgICAgICAgICAgIGxpbmVudW1iZXI6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc291cmNlZmlsZTogc291cmNlQW5kUG9zLnN1YnN0cmluZygwLCBpbmRleCksXHJcbiAgICAgICAgICAgICAgICBsaW5lbnVtYmVyOiB0aGlzLnBhcnNlTGluZU51bWJlcihzb3VyY2VBbmRQb3Muc3Vic3RyaW5nKGluZGV4ICsgMSkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcGFyc2VMaW5lTnVtYmVyKGxpbmVOdW1iZXJTdHJpbmc6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChsaW5lTnVtYmVyU3RyaW5nLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc291cmNlIHJlZiBlbGVtZW50cyBpbiB0aGUgdHJhbnN1bml0LlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMgZG9uZSBieSBuZy1leHRyYWN0LlxyXG4gICAgICogTWV0aG9kIG9ubHkgZXhpc3RzIHRvIGFsbG93IHhsaWZmbWVyZ2UgdG8gbWVyZ2UgbWlzc2luZyBzb3VyY2UgcmVmcy5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VSZWZzIHRoZSBzb3VyY2VyZWZzIHRvIHNldC4gT2xkIG9uZXMgYXJlIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTb3VyY2VSZWZlcmVuY2VzKHNvdXJjZVJlZnM6IHtzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlcn1bXSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsU291cmNlUmVmZXJlbmNlcygpO1xyXG4gICAgICAgIGxldCBub3Rlc0VsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdub3RlcycpO1xyXG4gICAgICAgIGlmIChzb3VyY2VSZWZzLmxlbmd0aCA9PT0gMCAmJiAhaXNOdWxsT3JVbmRlZmluZWQobm90ZXNFbGVtZW50KSAmJiBub3Rlc0VsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IG5vdGVzIGVsZW1lbnRcclxuICAgICAgICAgICAgbm90ZXNFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm90ZXNFbGVtZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobm90ZXNFbGVtZW50KSkge1xyXG4gICAgICAgICAgICBub3Rlc0VsZW1lbnQgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbm90ZXMnKTtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5pbnNlcnRCZWZvcmUobm90ZXNFbGVtZW50LCB0aGlzLl9lbGVtZW50LmNoaWxkTm9kZXMuaXRlbSgwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvdXJjZVJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdGUgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbm90ZScpO1xyXG4gICAgICAgICAgICBub3RlLnNldEF0dHJpYnV0ZSgnY2F0ZWdvcnknLCAnbG9jYXRpb24nKTtcclxuICAgICAgICAgICAgbm90ZS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmVmLnNvdXJjZWZpbGUgKyAnOicgKyByZWYubGluZW51bWJlci50b1N0cmluZygxMCkpKTtcclxuICAgICAgICAgICAgbm90ZXNFbGVtZW50LmFwcGVuZENoaWxkKG5vdGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVtb3ZlQWxsU291cmNlUmVmZXJlbmNlcygpIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdub3RlJyk7XHJcbiAgICAgICAgY29uc3QgdG9CZVJlbW92ZWQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vdGVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtID0gbm90ZUVsZW1lbnRzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtLmdldEF0dHJpYnV0ZSgnY2F0ZWdvcnknKSA9PT0gJ2xvY2F0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdG9CZVJlbW92ZWQucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0b0JlUmVtb3ZlZC5mb3JFYWNoKChlbGVtKSA9PiB7ZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBzZXQgaW4gdGhlIHRlbXBsYXRlIGFzIHZhbHVlIG9mIHRoZSBpMThuLWF0dHJpYnV0ZS5cclxuICAgICAqIGUuZy4gaTE4bj1cIm15ZGVzY3JpcHRpb25cIi5cclxuICAgICAqIEluIHhsaWZmIDIuMCB0aGlzIGlzIHN0b3JlZCBhcyBhIG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBjYXRlZ29yeT1cImRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtID0gdGhpcy5maW5kTm90ZUVsZW1lbnRXaXRoQ2F0ZWdvcnlBdHRyaWJ1dGUoJ2Rlc2NyaXB0aW9uJyk7XHJcbiAgICAgICAgaWYgKG5vdGVFbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBET01VdGlsaXRpZXMuZ2V0UENEQVRBKG5vdGVFbGVtKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgZGVzY3JpcHRpb24gcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBkZXNjcmlwdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RGVzY3JpcHRpb24oZGVzY3JpcHRpb246IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtID0gdGhpcy5maW5kTm90ZUVsZW1lbnRXaXRoQ2F0ZWdvcnlBdHRyaWJ1dGUoJ2Rlc2NyaXB0aW9uJyk7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChub3RlRWxlbSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBpdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVOb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZSgnZGVzY3JpcHRpb24nLCBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChub3RlRWxlbSwgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChub3RlRWxlbSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKCdkZXNjcmlwdGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZCBhIG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBjYXRlZ29yeT0nPGF0dHJWYWx1ZT4nXHJcbiAgICAgKiBAcGFyYW0gYXR0clZhbHVlIHZhbHVlIG9mIGNhdGVnb3J5IGF0dHJpYnV0ZVxyXG4gICAgICogQHJldHVybiBlbGVtZW50IG9yIG51bGwgaXMgYWJzZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluZE5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKGF0dHJWYWx1ZTogc3RyaW5nKTogRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbm90ZScpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm90ZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdGVFbGVtID0gbm90ZUVsZW1lbnRzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChub3RlRWxlbS5nZXRBdHRyaWJ1dGUoJ2NhdGVnb3J5JykgPT09IGF0dHJWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGVFbGVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBub3RlIGVsZW1lbnRzIHdoZXJlIGZyb20gYXR0cmlidXRlIGlzIG5vdCBkZXNjcmlwdGlvbiBvciBtZWFuaW5nXHJcbiAgICAgKiBAcmV0dXJuIGVsZW1lbnRzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluZEFsbEFkZGl0aW9uYWxOb3RlRWxlbWVudHMoKTogRWxlbWVudFtdIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdub3RlJyk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBFbGVtZW50W10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vdGVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub3RlRWxlbSA9IG5vdGVFbGVtZW50cy5pdGVtKGkpO1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tQXR0cmlidXRlID0gbm90ZUVsZW0uZ2V0QXR0cmlidXRlKCdjYXRlZ29yeScpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbUF0dHJpYnV0ZSAhPT0gJ2Rlc2NyaXB0aW9uJyAmJiBmcm9tQXR0cmlidXRlICE9PSAnbWVhbmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vdGVFbGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBmcm9tPSc8YXR0clZhbHVlPidcclxuICAgICAqIEBwYXJhbSBhdHRyVmFsdWUgY2F0ZWdvcnkgYXR0cmlidXRlIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gY29udGVudCBjb250ZW50IG9mIG5vdGUgZWxlbWVudFxyXG4gICAgICogQHJldHVybiB0aGUgbmV3IGNyZWF0ZWQgZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZU5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKGF0dHJWYWx1ZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiBFbGVtZW50IHtcclxuICAgICAgICBsZXQgbm90ZXNFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnbm90ZXMnKTtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobm90ZXNFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgaXRcclxuICAgICAgICAgICAgbm90ZXNFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25vdGVzJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQobm90ZXNFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbm90ZScpO1xyXG4gICAgICAgIGlmIChhdHRyVmFsdWUpIHtcclxuICAgICAgICAgICAgbm90ZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjYXRlZ29yeScsIGF0dHJWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250ZW50KSB7XHJcbiAgICAgICAgICAgIERPTVV0aWxpdGllcy5yZXBsYWNlQ29udGVudFdpdGhYTUxDb250ZW50KG5vdGVFbGVtZW50LCBjb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm90ZXNFbGVtZW50LmFwcGVuZENoaWxkKG5vdGVFbGVtZW50KTtcclxuICAgICAgICByZXR1cm4gbm90ZUVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZW1vdmVOb3Rlc0VsZW1lbnRJZkVtcHR5KCkge1xyXG4gICAgICAgIGNvbnN0IG5vdGVzRWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ25vdGVzJyk7XHJcbiAgICAgICAgaWYgKG5vdGVzRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZE5vdGUgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdub3RlJyk7XHJcbiAgICAgICAgICAgIGlmICghY2hpbGROb3RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbm90ZXMgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgbm90ZXNFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm90ZXNFbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgZnJvbT0nPGF0dHJWYWx1ZT4nXHJcbiAgICAgKiBAcGFyYW0gYXR0clZhbHVlIGF0dHJWYWx1ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlbW92ZU5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKGF0dHJWYWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnQgPSB0aGlzLmZpbmROb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZShhdHRyVmFsdWUpO1xyXG4gICAgICAgIGlmIChub3RlRWxlbWVudCkge1xyXG4gICAgICAgICAgICBub3RlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vdGVFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW1vdmVOb3Rlc0VsZW1lbnRJZkVtcHR5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYWxsIG5vdGUgZWxlbWVudHMgd2hlcmUgYXR0cmlidXRlIFwiZnJvbVwiIGlzIG5vdCBkZXNjcmlwdGlvbiBvciBtZWFuaW5nLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlbW92ZUFsbEFkZGl0aW9uYWxOb3RlRWxlbWVudHMoKSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnRzID0gdGhpcy5maW5kQWxsQWRkaXRpb25hbE5vdGVFbGVtZW50cygpO1xyXG4gICAgICAgIG5vdGVFbGVtZW50cy5mb3JFYWNoKChub3RlRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBub3RlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vdGVFbGVtZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlbW92ZU5vdGVzRWxlbWVudElmRW1wdHkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtZWFuaW5nIChpbnRlbnQpIHNldCBpbiB0aGUgdGVtcGxhdGUgYXMgdmFsdWUgb2YgdGhlIGkxOG4tYXR0cmlidXRlLlxyXG4gICAgICogVGhpcyBpcyB0aGUgcGFydCBpbiBmcm9udCBvZiB0aGUgfCBzeW1ib2wuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJtZWFuaW5nfG15ZGVzY3JpcHRpb25cIi5cclxuICAgICAqIEluIHhsaWZmIDIuMCB0aGlzIGlzIHN0b3JlZCBhcyBhIG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBjYXRlZ29yeT1cIm1lYW5pbmdcIi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1lYW5pbmcoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbSA9IHRoaXMuZmluZE5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKCdtZWFuaW5nJyk7XHJcbiAgICAgICAgaWYgKG5vdGVFbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBET01VdGlsaXRpZXMuZ2V0UENEQVRBKG5vdGVFbGVtKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgbWVhbmluZyBwcm9wZXJ0eSBvZiB0cmFucy11bml0LlxyXG4gICAgICogQHBhcmFtIG1lYW5pbmcgbWVhbmluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0TWVhbmluZyhtZWFuaW5nOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbSA9IHRoaXMuZmluZE5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKCdtZWFuaW5nJyk7XHJcbiAgICAgICAgaWYgKG1lYW5pbmcpIHtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG5vdGVFbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGl0XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZU5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKCdtZWFuaW5nJywgbWVhbmluZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChub3RlRWxlbSwgbWVhbmluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5vdGVFbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm90ZUVsZW1lbnRXaXRoQ2F0ZWdvcnlBdHRyaWJ1dGUoJ21lYW5pbmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbm90ZXMgb2YgdGhlIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBOb3RlcyBhcmUgcmVtYXJrcyBtYWRlIGJ5IGEgdHJhbnNsYXRvci5cclxuICAgICAqIChkZXNjcmlwdGlvbiBhbmQgbWVhbmluZyBhcmUgbm90IGluY2x1ZGVkIGhlcmUhKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbm90ZXMoKTogSU5vdGVbXSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbXRzOiBFbGVtZW50W10gPSB0aGlzLmZpbmRBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCk7XHJcbiAgICAgICAgcmV0dXJuIG5vdGVFbGVtZW10cy5tYXAoZWxlbSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBmcm9tOiBlbGVtLmdldEF0dHJpYnV0ZSgnY2F0ZWdvcnknKSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IERPTVV0aWxpdGllcy5nZXRQQ0RBVEEoZWxlbSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciBzZXR0aW5nIG9mIG5vdGVzIGlzIHN1cHBvcnRlZC5cclxuICAgICAqIElmIG5vdCwgc2V0Tm90ZXMgd2lsbCBkbyBub3RoaW5nLlxyXG4gICAgICogeHRiIGRvZXMgbm90IHN1cHBvcnQgdGhpcywgYWxsIG90aGVyIGZvcm1hdHMgZG8uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdXBwb3J0c1NldE5vdGVzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIG5vdGVzIHRvIHRyYW5zIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0gbmV3Tm90ZXMgdGhlIG5vdGVzIHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldE5vdGVzKG5ld05vdGVzOiBJTm90ZVtdKSB7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChuZXdOb3RlcykpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVja05vdGVzKG5ld05vdGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCk7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChuZXdOb3RlcykpIHtcclxuICAgICAgICAgICAgbmV3Tm90ZXMuZm9yRWFjaCgobm90ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVOb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZShub3RlLmZyb20sIG5vdGUudGV4dCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdHJhbnNsYXRpb24gdG8gYSBnaXZlbiBzdHJpbmcgKGluY2x1ZGluZyBtYXJrdXApLlxyXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uIHRyYW5zbGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCB0cmFuc2xhdGVOYXRpdmUodHJhbnNsYXRpb246IHN0cmluZykge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gc291cmNlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhcmdldCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQodGFyZ2V0LCA8c3RyaW5nPiB0cmFuc2xhdGlvbik7XHJcbiAgICAgICAgdGhpcy5zZXRUYXJnZXRTdGF0ZShTVEFURV9UUkFOU0xBVEVEKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcHkgc291cmNlIHRvIHRhcmdldCB0byB1c2UgaXQgYXMgZHVtbXkgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBSZXR1cm5zIGEgY2hhbmdlZCBjb3B5IG9mIHRoaXMgdHJhbnMgdW5pdC5cclxuICAgICAqIHJlY2VpdmVyIGlzIG5vdCBjaGFuZ2VkLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGltcG9ydE5ld1RyYW5zVW5pdCBvbiBJVHJhbnNsYXRpb25NZXNzYWdlRmlsZSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNsb25lV2l0aFNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuLCB0YXJnZXRGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpOiBBYnN0cmFjdFRyYW5zVW5pdCB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IDxFbGVtZW50PiB0aGlzLl9lbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBYbGlmZjJUcmFuc1VuaXQoZWxlbWVudCwgdGhpcy5faWQsIHRhcmdldEZpbGUpO1xyXG4gICAgICAgIGNsb25lLnVzZVNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmcsIGNvcHlDb250ZW50KTtcclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbikge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NvdXJjZScpO1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBzb3VyY2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFyZ2V0JykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWZhdWx0TGFuZyB8fCBjb3B5Q29udGVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VTdHJpbmcgPSBET01VdGlsaXRpZXMuZ2V0WE1MQ29udGVudChzb3VyY2UpO1xyXG4gICAgICAgICAgICBsZXQgbmV3VGFyZ2V0U3RyaW5nID0gc291cmNlU3RyaW5nO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNJQ1VNZXNzYWdlKHNvdXJjZVN0cmluZykpIHtcclxuICAgICAgICAgICAgICAgIG5ld1RhcmdldFN0cmluZyA9IHRoaXMudHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUoKS5nZXROZXdUcmFuc1VuaXRUYXJnZXRQcmFlZml4KClcclxuICAgICAgICAgICAgICAgICAgICArIHNvdXJjZVN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICsgdGhpcy50cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSgpLmdldE5ld1RyYW5zVW5pdFRhcmdldFN1ZmZpeCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIERPTVV0aWxpdGllcy5yZXBsYWNlQ29udGVudFdpdGhYTUxDb250ZW50KHRhcmdldCwgbmV3VGFyZ2V0U3RyaW5nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudCh0YXJnZXQsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NlZ21lbnQnKTtcclxuICAgICAgICBpZiAoc2VnbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWZhdWx0TGFuZykge1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudC5zZXRBdHRyaWJ1dGUoJ3N0YXRlJywgdGhpcy5tYXBTdGF0ZVRvTmF0aXZlU3RhdGUoU1RBVEVfRklOQUwpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnQuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHRoaXMubWFwU3RhdGVUb05hdGl2ZVN0YXRlKFNUQVRFX05FVykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuLi9hcGkvaS10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuaW1wb3J0IHtJVHJhbnNVbml0fSBmcm9tICcuLi9hcGkvaS10cmFucy11bml0JztcclxuaW1wb3J0IHtGT1JNQVRfWExJRkYyMCwgRklMRVRZUEVfWExJRkYyMH0gZnJvbSAnLi4vYXBpL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7RE9NVXRpbGl0aWVzfSBmcm9tICcuL2RvbS11dGlsaXRpZXMnO1xyXG5pbXBvcnQge1hsaWZmMlRyYW5zVW5pdH0gZnJvbSAnLi94bGlmZjItdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi9hYnN0cmFjdC10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuaW1wb3J0IHtBYnN0cmFjdFRyYW5zVW5pdH0gZnJvbSAnLi9hYnN0cmFjdC10cmFucy11bml0JztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDA0LjA1LjIwMTcuXHJcbiAqIEFuIFhMSUZGIDIuMCBmaWxlIHJlYWQgZnJvbSBhIHNvdXJjZSBmaWxlLlxyXG4gKiBGb3JtYXQgZGVmaW5pdGlvbiBpczogaHR0cDovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYveGxpZmYtY29yZS92Mi4wL29zL3hsaWZmLWNvcmUtdjIuMC1vcy5odG1sXHJcbiAqXHJcbiAqIERlZmluZXMgc29tZSByZWxldmFudCBnZXQgYW5kIHNldCBtZXRob2QgZm9yIHJlYWRpbmcgYW5kIG1vZGlmeWluZyBzdWNoIGEgZmlsZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgWGxpZmYyRmlsZSBleHRlbmRzIEFic3RyYWN0VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUgaW1wbGVtZW50cyBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIFhMSUZGIDIuMC1GaWxlIGZyb20gc291cmNlLlxyXG4gICAgICogQHBhcmFtIHhtbFN0cmluZyBzb3VyY2UgcmVhZCBmcm9tIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBQYXRoIHRvIGZpbGVcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyBvcHRpb25hbCBlbmNvZGluZyBvZiB0aGUgeG1sLlxyXG4gICAgICogVGhpcyBpcyByZWFkIGZyb20gdGhlIGZpbGUsIGJ1dCBpZiB5b3Uga25vdyBpdCBiZWZvcmUsIHlvdSBjYW4gYXZvaWQgcmVhZGluZyB0aGUgZmlsZSB0d2ljZS5cclxuICAgICAqIEByZXR1cm4geGxpZmYgZmlsZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih4bWxTdHJpbmc6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl93YXJuaW5ncyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mVHJhbnNVbml0c1dpdGhNaXNzaW5nSWQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZyb21Db250ZW50KHhtbFN0cmluZywgcGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZUZyb21Db250ZW50KHhtbFN0cmluZzogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpOiBYbGlmZjJGaWxlIHtcclxuICAgICAgICB0aGlzLnBhcnNlQ29udGVudCh4bWxTdHJpbmcsIHBhdGgsIGVuY29kaW5nKTtcclxuICAgICAgICBjb25zdCB4bGlmZkxpc3QgPSB0aGlzLl9wYXJzZWREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgneGxpZmYnKTtcclxuICAgICAgICBpZiAoeGxpZmZMaXN0Lmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdGaWxlIFwiJXNcIiBzZWVtcyB0byBiZSBubyB4bGlmZiBmaWxlIChzaG91bGQgY29udGFpbiBhbiB4bGlmZiBlbGVtZW50KScsIHBhdGgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0geGxpZmZMaXN0Lml0ZW0oMCkuZ2V0QXR0cmlidXRlKCd2ZXJzaW9uJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmVyc2lvbiA9ICcyLjAnO1xyXG4gICAgICAgICAgICBpZiAodmVyc2lvbiAhPT0gZXhwZWN0ZWRWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdGaWxlIFwiJXNcIiBzZWVtcyB0byBiZSBubyB4bGlmZiAyIGZpbGUsIHZlcnNpb24gc2hvdWxkIGJlICVzLCBmb3VuZCAlcycsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCwgZXhwZWN0ZWRWZXJzaW9uLCB2ZXJzaW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxlIGZvcm1hdCBhcyBpdCBpcyB1c2VkIGluIGNvbmZpZyBmaWxlcy5cclxuICAgICAqIEN1cnJlbnRseSAneGxmJywgJ3htYicsICd4bWIyJ1xyXG4gICAgICogUmV0dXJucyBvbmUgb2YgdGhlIGNvbnN0YW50cyBGT1JNQVRfLi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGkxOG5Gb3JtYXQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gRk9STUFUX1hMSUZGMjA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxlIHR5cGUuXHJcbiAgICAgKiBIZXJlICdYTElGRiAyLjAnXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmaWxlVHlwZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBGSUxFVFlQRV9YTElGRjIwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRhZyBuYW1lcyBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIG1peGVkIGNvbnRlbnQuXHJcbiAgICAgKiBUaGVzZSBlbGVtZW50cyB3aWxsIG5vdCBiZSBiZWF1dGlmaWVkLlxyXG4gICAgICogVHlwaWNhbCBjYW5kaWRhdGVzIGFyZSBzb3VyY2UgYW5kIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGVsZW1lbnRzV2l0aE1peGVkQ29udGVudCgpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgcmV0dXJuIFsnc2tlbGV0b24nLCAnbm90ZScsICdkYXRhJywgJ3NvdXJjZScsICd0YXJnZXQnLCAncGMnLCAnbXJrJ107XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVUcmFuc1VuaXRzKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNVbml0cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zVW5pdHNJbkZpbGUgPSB0aGlzLl9wYXJzZWREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndW5pdCcpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNVbml0c0luRmlsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc3VuaXQgPSB0cmFuc1VuaXRzSW5GaWxlLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdHJhbnN1bml0LmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuICAgICAgICAgICAgaWYgKCFpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2FybmluZ3MucHVzaChmb3JtYXQoJ29vcHMsIHRyYW5zLXVuaXQgd2l0aG91dCBcImlkXCIgZm91bmQgaW4gbWFzdGVyLCBwbGVhc2UgY2hlY2sgZmlsZSAlcycsIHRoaXMuX2ZpbGVuYW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFuc1VuaXRzLnB1c2gobmV3IFhsaWZmMlRyYW5zVW5pdCh0cmFuc3VuaXQsIGlkLCB0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqIEByZXR1cm4gc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc291cmNlTGFuZ3VhZ2UoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB4bGlmZkVsZW0gPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAneGxpZmYnKTtcclxuICAgICAgICBpZiAoeGxpZmZFbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4bGlmZkVsZW0uZ2V0QXR0cmlidXRlKCdzcmNMYW5nJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdCB0aGUgc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlIGxhbmd1YWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTb3VyY2VMYW5ndWFnZShsYW5ndWFnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgeGxpZmZFbGVtID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3hsaWZmJyk7XHJcbiAgICAgICAgaWYgKHhsaWZmRWxlbSkge1xyXG4gICAgICAgICAgICB4bGlmZkVsZW0uc2V0QXR0cmlidXRlKCdzcmNMYW5nJywgbGFuZ3VhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBAcmV0dXJuIHRhcmdldCBsYW5ndWFnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldExhbmd1YWdlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgeGxpZmZFbGVtID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3hsaWZmJyk7XHJcbiAgICAgICAgaWYgKHhsaWZmRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4geGxpZmZFbGVtLmdldEF0dHJpYnV0ZSgndHJnTGFuZycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXQgdGhlIHRhcmdldCBsYW5ndWFnZS5cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZSBsYW5ndWFnZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VGFyZ2V0TGFuZ3VhZ2UobGFuZ3VhZ2U6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHhsaWZmRWxlbSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fcGFyc2VkRG9jdW1lbnQsICd4bGlmZicpO1xyXG4gICAgICAgIGlmICh4bGlmZkVsZW0pIHtcclxuICAgICAgICAgICAgeGxpZmZFbGVtLnNldEF0dHJpYnV0ZSgndHJnTGFuZycsIGxhbmd1YWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBuZXcgdHJhbnMtdW5pdCB0byB0aGlzIGZpbGUuXHJcbiAgICAgKiBUaGUgdHJhbnMgdW5pdCBzdGVtcyBmcm9tIGFub3RoZXIgZmlsZS5cclxuICAgICAqIEl0IGNvcGllcyB0aGUgc291cmNlIGNvbnRlbnQgb2YgdGhlIHR1IHRvIHRoZSB0YXJnZXQgY29udGVudCB0b28sXHJcbiAgICAgKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiBpc0RlZmF1bHRMYW5nIGFuZCBjb3B5Q29udGVudC5cclxuICAgICAqIFNvIHRoZSBzb3VyY2UgY2FuIGJlIHVzZWQgYXMgYSBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqICh1c2VkIGJ5IHhsaWZmbWVyZ2UpXHJcbiAgICAgKiBAcGFyYW0gZm9yZWlnblRyYW5zVW5pdCB0aGUgdHJhbnMgdW5pdCB0byBiZSBpbXBvcnRlZC5cclxuICAgICAqIEBwYXJhbSBpc0RlZmF1bHRMYW5nIEZsYWcsIHdldGhlciBmaWxlIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGxhbmd1YWdlLlxyXG4gICAgICogVGhlbiBzb3VyY2UgYW5kIHRhcmdldCBhcmUganVzdCBlcXVhbC5cclxuICAgICAqIFRoZSBjb250ZW50IHdpbGwgYmUgY29waWVkLlxyXG4gICAgICogU3RhdGUgd2lsbCBiZSBmaW5hbC5cclxuICAgICAqIEBwYXJhbSBjb3B5Q29udGVudCBGbGFnLCB3ZXRoZXIgdG8gY29weSBjb250ZW50IG9yIGxlYXZlIGl0IGVtcHR5LlxyXG4gICAgICogV2JlbiB0cnVlLCBjb250ZW50IHdpbGwgYmUgY29waWVkIGZyb20gc291cmNlLlxyXG4gICAgICogV2hlbiBmYWxzZSwgY29udGVudCB3aWxsIGJlIGxlZnQgZW1wdHkgKGlmIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBsYW5ndWFnZSkuXHJcbiAgICAgKiBAcGFyYW0gaW1wb3J0QWZ0ZXJFbGVtZW50IG9wdGlvbmFsIChzaW5jZSAxLjEwKSBvdGhlciB0cmFuc3VuaXQgKHBhcnQgb2YgdGhpcyBmaWxlKSwgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBhbmNlc3Rvci5cclxuICAgICAqIE5ld2x5IGltcG9ydGVkIHRyYW5zIHVuaXQgaXMgdGhlbiBpbnNlcnRlZCBkaXJlY3RseSBhZnRlciB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBJZiBub3Qgc2V0IG9yIG5vdCBwYXJ0IG9mIHRoaXMgZmlsZSwgbmV3IHVuaXQgd2lsbCBiZSBpbXBvcnRlZCBhdCB0aGUgZW5kLlxyXG4gICAgICogSWYgZXhwbGljaXR5IHNldCB0byBudWxsLCBuZXcgdW5pdCB3aWxsIGJlIGltcG9ydGVkIGF0IHRoZSBzdGFydC5cclxuICAgICAqIEByZXR1cm4gdGhlIG5ld2x5IGltcG9ydGVkIHRyYW5zIHVuaXQgKHNpbmNlIHZlcnNpb24gMS43LjApXHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yIGlmIHRyYW5zLXVuaXQgd2l0aCBzYW1lIGlkIGFscmVhZHkgaXMgaW4gdGhlIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIGltcG9ydE5ld1RyYW5zVW5pdChmb3JlaWduVHJhbnNVbml0OiBJVHJhbnNVbml0LCBpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbiwgaW1wb3J0QWZ0ZXJFbGVtZW50PzogSVRyYW5zVW5pdClcclxuICAgICAgICA6IElUcmFuc1VuaXQge1xyXG4gICAgICAgIGlmICh0aGlzLnRyYW5zVW5pdFdpdGhJZChmb3JlaWduVHJhbnNVbml0LmlkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCd0dSB3aXRoIGlkICVzIGFscmVhZHkgZXhpc3RzIGluIGZpbGUsIGNhbm5vdCBpbXBvcnQgaXQnLCBmb3JlaWduVHJhbnNVbml0LmlkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1R1ID0gKDxBYnN0cmFjdFRyYW5zVW5pdD4gZm9yZWlnblRyYW5zVW5pdCkuY2xvbmVXaXRoU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZywgY29weUNvbnRlbnQsIHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IGZpbGVFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ2ZpbGUnKTtcclxuICAgICAgICBpZiAoIWZpbGVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0ZpbGUgXCIlc1wiIHNlZW1zIHRvIGJlIG5vIHhsaWZmIDIuMCBmaWxlIChzaG91bGQgY29udGFpbiBhIGZpbGUgZWxlbWVudCknLCB0aGlzLl9maWxlbmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaW5zZXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgaXNBZnRlckVsZW1lbnRQYXJ0T2ZGaWxlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCEhaW1wb3J0QWZ0ZXJFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc2VydGlvblBvaW50ID0gdGhpcy50cmFuc1VuaXRXaXRoSWQoaW1wb3J0QWZ0ZXJFbGVtZW50LmlkKTtcclxuICAgICAgICAgICAgaWYgKCEhaW5zZXJ0aW9uUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIGlzQWZ0ZXJFbGVtZW50UGFydE9mRmlsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGltcG9ydEFmdGVyRWxlbWVudCA9PT0gdW5kZWZpbmVkIHx8IChpbXBvcnRBZnRlckVsZW1lbnQgJiYgIWlzQWZ0ZXJFbGVtZW50UGFydE9mRmlsZSkpIHtcclxuICAgICAgICAgICAgZmlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3VHUuYXNYbWxFbGVtZW50KCkpO1xyXG4gICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRBZnRlckVsZW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3RVbml0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fcGFyc2VkRG9jdW1lbnQsICd1bml0Jyk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdFVuaXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMuaW5zZXJ0QmVmb3JlKG5ld1R1LmFzWG1sRWxlbWVudCgpLCBmaXJzdFVuaXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIHRyYW5zLXVuaXQsIGVtcHR5IGZpbGUsIHNvIGFkZCB0byBmaXJzdCBmaWxlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGZpbGVFbGVtZW50LmFwcGVuZENoaWxkKG5ld1R1LmFzWG1sRWxlbWVudCgpKTtcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZlVuaXRFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEVsZW1lbnRCeVRhZ05hbWVBbmRJZCh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3VuaXQnLCBpbXBvcnRBZnRlckVsZW1lbnQuaWQpO1xyXG4gICAgICAgICAgICBpZiAocmVmVW5pdEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIERPTVV0aWxpdGllcy5pbnNlcnRBZnRlcihuZXdUdS5hc1htbEVsZW1lbnQoKSwgcmVmVW5pdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnNlcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zVW5pdHMucHVzaChuZXdUdSk7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnROdW1iZXJzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdUdTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNsYXRpb24gZmlsZSBmb3IgdGhpcyBmaWxlIGZvciBhIGdpdmVuIGxhbmd1YWdlLlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMganVzdCBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9uZS5cclxuICAgICAqIEJ1dCBmb3IgWE1CIHRoZSB0cmFuc2xhdGlvbiBmaWxlIGhhcyBmb3JtYXQgJ1hUQicuXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBMYW5ndWFnZSBjb2RlXHJcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgZXhwZWN0ZWQgZmlsZW5hbWUgdG8gc3RvcmUgZmlsZVxyXG4gICAgICogQHBhcmFtIGlzRGVmYXVsdExhbmcgRmxhZywgd2V0aGVyIGZpbGUgY29udGFpbnMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBUaGVuIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBqdXN0IGVxdWFsLlxyXG4gICAgICogVGhlIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQuXHJcbiAgICAgKiBTdGF0ZSB3aWxsIGJlIGZpbmFsLlxyXG4gICAgICogQHBhcmFtIGNvcHlDb250ZW50IEZsYWcsIHdldGhlciB0byBjb3B5IGNvbnRlbnQgb3IgbGVhdmUgaXQgZW1wdHkuXHJcbiAgICAgKiBXYmVuIHRydWUsIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQgZnJvbSBzb3VyY2UuXHJcbiAgICAgKiBXaGVuIGZhbHNlLCBjb250ZW50IHdpbGwgYmUgbGVmdCBlbXB0eSAoaWYgaXQgaXMgbm90IHRoZSBkZWZhdWx0IGxhbmd1YWdlKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcobGFuZzogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nLCBpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbilcclxuICAgICAgICA6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25GaWxlID0gbmV3IFhsaWZmMkZpbGUodGhpcy5lZGl0ZWRDb250ZW50KCksIGZpbGVuYW1lLCB0aGlzLmVuY29kaW5nKCkpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRmlsZS5zZXROZXdUcmFuc1VuaXRUYXJnZXRQcmFlZml4KHRoaXMudGFyZ2V0UHJhZWZpeCk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25GaWxlLnNldE5ld1RyYW5zVW5pdFRhcmdldFN1ZmZpeCh0aGlzLnRhcmdldFN1ZmZpeCk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25GaWxlLnNldFRhcmdldExhbmd1YWdlKGxhbmcpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRmlsZS5mb3JFYWNoVHJhbnNVbml0KCh0cmFuc1VuaXQ6IElUcmFuc1VuaXQpID0+IHtcclxuICAgICAgICAgICAgKDxBYnN0cmFjdFRyYW5zVW5pdD4gdHJhbnNVbml0KS51c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nLCBjb3B5Q29udGVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uRmlsZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4uL2FwaS9pLXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUnO1xyXG5pbXBvcnQge0lOb3JtYWxpemVkTWVzc2FnZX0gZnJvbSAnLi4vYXBpL2ktbm9ybWFsaXplZC1tZXNzYWdlJztcclxuaW1wb3J0IHtJVHJhbnNVbml0fSBmcm9tICcuLi9hcGkvaS10cmFucy11bml0JztcclxuaW1wb3J0IHtJTm90ZX0gZnJvbSAnLi4vYXBpL2ktbm90ZSc7XHJcbmltcG9ydCB7RE9NVXRpbGl0aWVzfSBmcm9tICcuL2RvbS11dGlsaXRpZXMnO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNVbml0fSBmcm9tICcuL2Fic3RyYWN0LXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge1htYk1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4veG1iLW1lc3NhZ2UtcGFyc2VyJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXInO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMjMuMDUuMjAxNy5cclxuICogQSBUcmFuc2xhdGlvbiBVbml0IGluIGFuIFhUQiBmaWxlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYdGJUcmFuc1VuaXQgZXh0ZW5kcyBBYnN0cmFjdFRyYW5zVW5pdCBpbXBsZW1lbnRzIElUcmFuc1VuaXQge1xyXG5cclxuICAgIHByaXZhdGUgX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXI6IEFic3RyYWN0VHJhbnNVbml0O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50OiBFbGVtZW50LCBfaWQ6IHN0cmluZywgX3RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsXHJcbiAgICAgICAgICAgICAgICBfc291cmNlVHJhbnNVbml0RnJvbU1hc3RlcjogQWJzdHJhY3RUcmFuc1VuaXQpIHtcclxuICAgICAgICBzdXBlcihfZWxlbWVudCwgX2lkLCBfdHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpO1xyXG4gICAgICAgIHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIgPSBfc291cmNlVHJhbnNVbml0RnJvbU1hc3RlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBjb250ZW50IHRvIHRyYW5zbGF0ZS5cclxuICAgICAqIFNvdXJjZSBwYXJ0cyBhcmUgZXhjbHVkZWQgaGVyZS5cclxuICAgICAqIEByZXR1cm4gY29udGVudCB0byB0cmFuc2xhdGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VDb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIuc291cmNlQ29udGVudCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciBzZXR0aW5nIG9mIHNvdXJjZSBjb250ZW50IGlzIHN1cHBvcnRlZC5cclxuICAgICAqIElmIG5vdCwgc2V0U291cmNlQ29udGVudCBpbiB0cmFucy11bml0IHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBzdXBwb3J0c1NldFNvdXJjZUNvbnRlbnQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG5ldyBzb3VyY2UgY29udGVudCBpbiB0aGUgdHJhbnN1bml0LlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMgZG9uZSBieSBuZy1leHRyYWN0LlxyXG4gICAgICogTWV0aG9kIG9ubHkgZXhpc3RzIHRvIGFsbG93IHhsaWZmbWVyZ2UgdG8gbWVyZ2UgbWlzc2luZyBjaGFuZ2VkIHNvdXJjZSBjb250ZW50LlxyXG4gICAgICogQHBhcmFtIG5ld0NvbnRlbnQgdGhlIG5ldyBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U291cmNlQ29udGVudChuZXdDb250ZW50OiBzdHJpbmcpIHtcclxuICAgICAgICAvLyB4dGIgaGFzIG5vIHNvdXJjZSBjb250ZW50LCB0aGV5IGFyZSBwYXJ0IG9mIHRoZSBtYXN0ZXJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHBhcnNlciB1c2VkIGZvciBub3JtYWxpemVkIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWVzc2FnZVBhcnNlcigpOiBBYnN0cmFjdE1lc3NhZ2VQYXJzZXIge1xyXG4gICAgICAgIHJldHVybiBuZXcgWG1iTWVzc2FnZVBhcnNlcigpOyAvLyBubyB0eXBvISwgU2FtZSBhcyBmb3IgWG1iXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCB2YWx1ZSwgdGhhdCBpcyB0byBiZSB0cmFuc2xhdGVkLCBhcyBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVTb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICBpZiAodGhpcy5fc291cmNlVHJhbnNVbml0RnJvbU1hc3Rlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlVHJhbnNVbml0RnJvbU1hc3Rlci5jcmVhdGVTb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB0cmFuc2xhdGVkIHZhbHVlIChjb250YWluaW5nIGFsbCBtYXJrdXAsIGRlcGVuZHMgb24gdGhlIGNvbmNyZXRlIGZvcm1hdCB1c2VkKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldENvbnRlbnQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFhNTENvbnRlbnQodGhpcy5fZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgdHJhbnNsYXRlZCB2YWx1ZSwgYnV0IGFsbCBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGgge3tufX0gKHN0YXJ0aW5nIGF0IDApXHJcbiAgICAgKiBhbmQgYWxsIGVtYmVkZGVkIGh0bWwgaXMgcmVwbGFjZWQgYnkgZGlyZWN0IGh0bWwgbWFya3VwLlxyXG4gICAgICovXHJcbiAgICB0YXJnZXRDb250ZW50Tm9ybWFsaXplZCgpOiBJTm9ybWFsaXplZE1lc3NhZ2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VQYXJzZXIoKS5jcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUwodGhpcy5fZWxlbWVudCwgdGhpcy5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRlIG9mIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIChub3Qgc3VwcG9ydGVkIGluIHhtYilcclxuICAgICAqIElmIHdlIGhhdmUgYSBtYXN0ZXIsIHdlIGFzc3VtZWQgaXQgaXMgdHJhbnNsYXRlZCBpZiB0aGUgY29udGVudCBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIG1hc3RlcnMgb25lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmF0aXZlVGFyZ2V0U3RhdGUoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5fc291cmNlVHJhbnNVbml0RnJvbU1hc3Rlcikge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VDb250ZW50ID0gdGhpcy5fc291cmNlVHJhbnNVbml0RnJvbU1hc3Rlci5zb3VyY2VDb250ZW50KCk7XHJcbiAgICAgICAgICAgIGlmICghc291cmNlQ29udGVudCB8fCBzb3VyY2VDb250ZW50ID09PSB0aGlzLnRhcmdldENvbnRlbnQoKSB8fCAhdGhpcy50YXJnZXRDb250ZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnbmV3JztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnZmluYWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsOyAvLyBub3Qgc3VwcG9ydGVkIGluIHhtYlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIGFuIGFic3RyYWN0IHN0YXRlIChuZXcsIHRyYW5zbGF0ZWQsIGZpbmFsKSB0byBhIGNvbmNyZXRlIHN0YXRlIHVzZWQgaW4gdGhlIHhtbC5cclxuICAgICAqIFJldHVybnMgdGhlIHN0YXRlIHRvIGJlIHVzZWQgaW4gdGhlIHhtbC5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSBvbmUgb2YgQ29uc3RhbnRzLlNUQVRFLi4uXHJcbiAgICAgKiBAcmV0dXJucyBhIG5hdGl2ZSBzdGF0ZSAoZGVwZW5kcyBvbiBjb25jcmV0ZSBmb3JtYXQpXHJcbiAgICAgKiBAdGhyb3dzIGVycm9yLCBpZiBzdGF0ZSBpcyBpbnZhbGlkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWFwU3RhdGVUb05hdGl2ZVN0YXRlKHN0YXRlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBhIG5hdGl2ZSBzdGF0ZSAoZm91bmQgaW4gdGhlIGRvY3VtZW50KSB0byBhbiBhYnN0cmFjdCBzdGF0ZSAobmV3LCB0cmFuc2xhdGVkLCBmaW5hbCkuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhYnN0cmFjdCBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSBuYXRpdmVTdGF0ZSBuYXRpdmVTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWFwTmF0aXZlU3RhdGVUb1N0YXRlKG5hdGl2ZVN0YXRlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBuYXRpdmVTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldCBzdGF0ZSBpbiB4bWwuXHJcbiAgICAgKiAobm90IHN1cHBvcnRlZCBpbiB4bWIpXHJcbiAgICAgKiBAcGFyYW0gbmF0aXZlU3RhdGUgbmF0aXZlU3RhdGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHNldE5hdGl2ZVRhcmdldFN0YXRlKG5hdGl2ZVN0YXRlOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBUT0RPIHNvbWUgbG9naWMgdG8gc3RvcmUgaXQgYW55d2hlcmVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgc291cmNlIGVsZW1lbnRzIGluIHRoZSB0cmFucyB1bml0LlxyXG4gICAgICogVGhlIHNvdXJjZSBlbGVtZW50IGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cclxuICAgICAqIEl0IGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmaWxlIGFuZCBhIGxpbmUgbnVtYmVyIHdpdGggdGhlIHBvc2l0aW9uIGluc2lkZSB0aGUgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBpcyBqdXN0IGEgaGVscCBmb3IgdHJhbnNsYXRvcnMgdG8gZmluZCB0aGUgY29udGV4dCBmb3IgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogVGhpcyBpcyBzZXQgd2hlbiB1c2luZyBBbmd1bGFyIDQuMCBvciBncmVhdGVyLlxyXG4gICAgICogT3RoZXJ3aXNlIGl0IGp1c3QgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNvdXJjZVJlZmVyZW5jZXMoKTogeyBzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlciB9W10ge1xyXG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2VUcmFuc1VuaXRGcm9tTWFzdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VUcmFuc1VuaXRGcm9tTWFzdGVyLnNvdXJjZVJlZmVyZW5jZXMoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2Ygc291cmNlIHJlZnMgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXRTb3VyY2VSZWZlcmVuY2VzIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTZXRTb3VyY2VSZWZlcmVuY2VzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBzb3VyY2UgcmVmIGVsZW1lbnRzIGluIHRoZSB0cmFuc3VuaXQuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBkb25lIGJ5IG5nLWV4dHJhY3QuXHJcbiAgICAgKiBNZXRob2Qgb25seSBleGlzdHMgdG8gYWxsb3cgeGxpZmZtZXJnZSB0byBtZXJnZSBtaXNzaW5nIHNvdXJjZSByZWZzLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZVJlZnMgdGhlIHNvdXJjZXJlZnMgdG8gc2V0LiBPbGQgb25lcyBhcmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZVJlZmVyZW5jZXMoc291cmNlUmVmczoge3NvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyfVtdKSB7XHJcbiAgICAgICAgLy8geHRiIGhhcyBubyBzb3VyY2UgcmVmcywgdGhleSBhcmUgcGFydCBvZiB0aGUgbWFzdGVyXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKiBJbiB4dGIgb25seSB0aGUgbWFzdGVyIHN0b3JlcyBpdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlc2NyaXB0aW9uKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIuZGVzY3JpcHRpb24oKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWVhbmluZyAoaW50ZW50KSBzZXQgaW4gdGhlIHRlbXBsYXRlIGFzIHZhbHVlIG9mIHRoZSBpMThuLWF0dHJpYnV0ZS5cclxuICAgICAqIFRoaXMgaXMgdGhlIHBhcnQgaW4gZnJvbnQgb2YgdGhlIHwgc3ltYm9sLlxyXG4gICAgICogZS5nLiBpMThuPVwibWVhbmluZ3xteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKiBJbiB4dGIgb25seSB0aGUgbWFzdGVyIHN0b3JlcyBpdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1lYW5pbmcoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5fc291cmNlVHJhbnNVbml0RnJvbU1hc3Rlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlVHJhbnNVbml0RnJvbU1hc3Rlci5tZWFuaW5nKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2YgZGVzY3JpcHRpb24gYW5kIG1lYW5pbmcgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXREZXNjcmlwdGlvbiBhbmQgc2V0TWVhbmluZyB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1cHBvcnRzU2V0RGVzY3JpcHRpb25BbmRNZWFuaW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBkZXNjcmlwdGlvbiBwcm9wZXJ0eSBvZiB0cmFucy11bml0LlxyXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uIGRlc2NyaXB0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXREZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCwgZG8gbm90aGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIG1lYW5pbmcgcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSBtZWFuaW5nIG1lYW5pbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldE1lYW5pbmcobWVhbmluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCwgZG8gbm90aGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBub3RlcyBvZiB0aGUgdHJhbnMtdW5pdC5cclxuICAgICAqIFRoZXJlIGFyZSBOTyBub3RlcyBpbiB4bWIveHRiXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3RlcygpOiBJTm90ZVtdIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBub3RlcyBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldE5vdGVzIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTZXROb3RlcygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgbm90ZXMgdG8gdHJhbnMgdW5pdC5cclxuICAgICAqIEBwYXJhbSBuZXdOb3RlcyB0aGUgbm90ZXMgdG8gYWRkLlxyXG4gICAgICogTk9UIFN1cHBvcnRlZCBpbiB4bWIveHRiXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXROb3RlcyhuZXdOb3RlczogSU5vdGVbXSkge1xyXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQsIGRvIG5vdGhpbmdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcHkgc291cmNlIHRvIHRhcmdldCB0byB1c2UgaXQgYXMgZHVtbXkgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBSZXR1cm5zIGEgY2hhbmdlZCBjb3B5IG9mIHRoaXMgdHJhbnMgdW5pdC5cclxuICAgICAqIHJlY2VpdmVyIGlzIG5vdCBjaGFuZ2VkLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGltcG9ydE5ld1RyYW5zVW5pdCBvbiBJVHJhbnNsYXRpb25NZXNzYWdlRmlsZSlcclxuICAgICAqIEluIHh0YiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvLCBiZWNhdXNlIHRoZXJlIGlzIG9ubHkgYSB0YXJnZXQsIG5vIHNvdXJjZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNsb25lV2l0aFNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuLCB0YXJnZXRGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpOiBBYnN0cmFjdFRyYW5zVW5pdCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbikge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdHJhbnNsYXRpb24gdG8gYSBnaXZlbiBzdHJpbmcgKGluY2x1ZGluZyBtYXJrdXApLlxyXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uIHRyYW5zbGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCB0cmFuc2xhdGVOYXRpdmUodHJhbnNsYXRpb246IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2VsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHRyYW5zbGF0aW9uKSkge1xyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbiA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudCh0YXJnZXQsIHRyYW5zbGF0aW9uKTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5fSBmcm9tICcuLi9hcGkvaS10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlLWZhY3RvcnknO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7SVRyYW5zVW5pdH0gZnJvbSAnLi4vYXBpL2ktdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7Rk9STUFUX1hUQiwgRklMRVRZUEVfWFRCLCBGT1JNQVRfWE1CfSBmcm9tICcuLi9hcGkvY29uc3RhbnRzJztcclxuaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0RPTVV0aWxpdGllc30gZnJvbSAnLi9kb20tdXRpbGl0aWVzJztcclxuaW1wb3J0IHtBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuL2Fic3RyYWN0LXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUnO1xyXG5pbXBvcnQge1h0YlRyYW5zVW5pdH0gZnJvbSAnLi94dGItdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc1VuaXR9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnMtdW5pdCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAyMy4wNS4yMDE3LlxyXG4gKiB4dGItRmlsZSBhY2Nlc3MuXHJcbiAqIHh0YiBpcyB0aGUgdHJhbnNsYXRlZCBjb3VudGVycGFydCB0byB4bWIuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFh0YkZpbGUgZXh0ZW5kcyBBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIGltcGxlbWVudHMgSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuXHJcbiAgICAvLyBhdHRhY2hlZCBtYXN0ZXIgZmlsZSwgaWYgYW55XHJcbiAgICAvLyB1c2VkIGFzIHNvdXJjZSB0byBkZXRlcm1pbmUgc3RhdGUgLi4uXHJcbiAgICBwcml2YXRlIF9tYXN0ZXJGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGU7IC8vIGFuIHhtYi1maWxlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4geG1iLUZpbGUgZnJvbSBzb3VyY2UuXHJcbiAgICAgKiBAcGFyYW0gX3RyYW5zbGF0aW9uTWVzc2FnZUZpbGVGYWN0b3J5IGZhY3RvcnkgdG8gY3JlYXRlIGEgdHJhbnNsYXRpb24gZmlsZSAoeHRiKSBmb3IgdGhlIHhtYiBmaWxlXHJcbiAgICAgKiBAcGFyYW0geG1sU3RyaW5nIGZpbGUgY29udGVudFxyXG4gICAgICogQHBhcmFtIHBhdGggUGF0aCB0byBmaWxlXHJcbiAgICAgKiBAcGFyYW0gZW5jb2Rpbmcgb3B0aW9uYWwgZW5jb2Rpbmcgb2YgdGhlIHhtbC5cclxuICAgICAqIFRoaXMgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLCBidXQgaWYgeW91IGtub3cgaXQgYmVmb3JlLCB5b3UgY2FuIGF2b2lkIHJlYWRpbmcgdGhlIGZpbGUgdHdpY2UuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXIgaW4gY2FzZSBvZiB4bWIgdGhlIG1hc3RlciBmaWxlLCB0aGF0IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCB0ZXh0cy5cclxuICAgICAqICh0aGlzIGlzIHVzZWQgdG8gc3VwcG9ydCBzdGF0ZSBpbmZvcywgdGhhdCBhcmUgYmFzZWQgb24gY29tcGFyaW5nIG9yaWdpbmFsIHdpdGggdHJhbnNsYXRlZCB2ZXJzaW9uKVxyXG4gICAgICogQHJldHVybiBYbWJGaWxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RyYW5zbGF0aW9uTWVzc2FnZUZpbGVGYWN0b3J5OiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5LFxyXG4gICAgICAgICAgICAgICAgeG1sU3RyaW5nOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgIG9wdGlvbmFsTWFzdGVyPzogeyB4bWxDb250ZW50OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyB9KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl93YXJuaW5ncyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mVHJhbnNVbml0c1dpdGhNaXNzaW5nSWQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZyb21Db250ZW50KHhtbFN0cmluZywgcGF0aCwgZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGluaXRpYWxpemVGcm9tQ29udGVudCh4bWxTdHJpbmc6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXI/OiB7IHhtbENvbnRlbnQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nIH0pOiBYdGJGaWxlIHtcclxuICAgICAgICB0aGlzLnBhcnNlQ29udGVudCh4bWxTdHJpbmcsIHBhdGgsIGVuY29kaW5nKTtcclxuICAgICAgICBpZiAodGhpcy5fcGFyc2VkRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RyYW5zbGF0aW9uYnVuZGxlJykubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0ZpbGUgXCIlc1wiIHNlZW1zIHRvIGJlIG5vIHh0YiBmaWxlIChzaG91bGQgY29udGFpbiBhIHRyYW5zbGF0aW9uYnVuZGxlIGVsZW1lbnQpJywgcGF0aCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9uYWxNYXN0ZXIpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hc3RlckZpbGUgPSB0aGlzLl90cmFuc2xhdGlvbk1lc3NhZ2VGaWxlRmFjdG9yeS5jcmVhdGVGaWxlRnJvbUZpbGVDb250ZW50KFxyXG4gICAgICAgICAgICAgICAgICAgIEZPUk1BVF9YTUIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXIueG1sQ29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3Rlci5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsTWFzdGVyLmVuY29kaW5nKTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrLCB3ZXRoZXIgdGhpcyBjYW4gYmUgdGhlIG1hc3RlciAuLi5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlckluTWFzdGVyID0gdGhpcy5fbWFzdGVyRmlsZS5udW1iZXJPZlRyYW5zVW5pdHMoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG15TnVtYmVyID0gdGhpcy5udW1iZXJPZlRyYW5zVW5pdHMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJJbk1hc3RlciAhPT0gbXlOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXJuaW5ncy5wdXNoKGZvcm1hdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyVzIHRyYW5zIHVuaXRzIGZvdW5kIGluIG1hc3RlciwgYnV0IHRoaXMgZmlsZSBoYXMgJXMuIENoZWNrIGlmIGl0IGlzIHRoZSBjb3JyZWN0IG1hc3RlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlckluTWFzdGVyLCBteU51bWJlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRmlsZSBcIiVzXCIgc2VlbXMgdG8gYmUgbm8geG1iIGZpbGUuIEFuIHh0YiBmaWxlIG5lZWRzIHhtYiBhcyBtYXN0ZXIgZmlsZS4nLCBvcHRpb25hbE1hc3Rlci5wYXRoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVUcmFuc1VuaXRzKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNVbml0cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zVW5pdHNJbkZpbGUgPSB0aGlzLl9wYXJzZWREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHJhbnNsYXRpb24nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zVW5pdHNJbkZpbGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbXNnID0gdHJhbnNVbml0c0luRmlsZS5pdGVtKGkpO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1zZy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICAgICAgICAgIGlmICghaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dhcm5pbmdzLnB1c2goZm9ybWF0KCdvb3BzLCBtc2cgd2l0aG91dCBcImlkXCIgZm91bmQgaW4gbWFzdGVyLCBwbGVhc2UgY2hlY2sgZmlsZSAlcycsIHRoaXMuX2ZpbGVuYW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG1hc3RlclVuaXQ6IElUcmFuc1VuaXQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFzdGVyRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgbWFzdGVyVW5pdCA9IHRoaXMuX21hc3RlckZpbGUudHJhbnNVbml0V2l0aElkKGlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zVW5pdHMucHVzaChuZXcgWHRiVHJhbnNVbml0KG1zZywgaWQsIHRoaXMsIDxBYnN0cmFjdFRyYW5zVW5pdD4gbWFzdGVyVW5pdCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGUgZm9ybWF0IGFzIGl0IGlzIHVzZWQgaW4gY29uZmlnIGZpbGVzLlxyXG4gICAgICogQ3VycmVudGx5ICd4bGYnLCAneGxmMicsICd4bWInLCAneHRiJ1xyXG4gICAgICogUmV0dXJucyBvbmUgb2YgdGhlIGNvbnN0YW50cyBGT1JNQVRfLi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGkxOG5Gb3JtYXQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gRk9STUFUX1hUQjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGUgdHlwZS5cclxuICAgICAqIEhlcmUgJ1hUQidcclxuICAgICAqL1xyXG4gICAgcHVibGljIGZpbGVUeXBlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIEZJTEVUWVBFX1hUQjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiB0YWcgbmFtZXMgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBtaXhlZCBjb250ZW50LlxyXG4gICAgICogVGhlc2UgZWxlbWVudHMgd2lsbCBub3QgYmUgYmVhdXRpZmllZC5cclxuICAgICAqIFR5cGljYWwgY2FuZGlkYXRlcyBhcmUgc291cmNlIGFuZCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBlbGVtZW50c1dpdGhNaXhlZENvbnRlbnQoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiBbJ3RyYW5zbGF0aW9uJ107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICogVW5zdXBwb3J0ZWQgaW4geG1iL3h0Yi5cclxuICAgICAqIFRyeSB0byBndWVzcyBpdCBmcm9tIG1hc3RlciBmaWxlbmFtZSBpZiBhbnkuLlxyXG4gICAgICogQHJldHVybiBzb3VyY2UgbGFuZ3VhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VMYW5ndWFnZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXN0ZXJGaWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXN0ZXJGaWxlLnNvdXJjZUxhbmd1YWdlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdCB0aGUgc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICogVW5zdXBwb3J0ZWQgaW4geG1iL3h0Yi5cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZSBsYW5ndWFnZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U291cmNlTGFuZ3VhZ2UobGFuZ3VhZ2U6IHN0cmluZykge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmcsIHh0YiBoYXMgbm8gbm90YXRpb24gZm9yIHRoaXMuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICogQHJldHVybiB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRMYW5ndWFnZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uYnVuZGxlRWxlbSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fcGFyc2VkRG9jdW1lbnQsICd0cmFuc2xhdGlvbmJ1bmRsZScpO1xyXG4gICAgICAgIGlmICh0cmFuc2xhdGlvbmJ1bmRsZUVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uYnVuZGxlRWxlbS5nZXRBdHRyaWJ1dGUoJ2xhbmcnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFZGl0IHRoZSB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2UgbGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRhcmdldExhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbmJ1bmRsZUVsZW0gPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAndHJhbnNsYXRpb25idW5kbGUnKTtcclxuICAgICAgICBpZiAodHJhbnNsYXRpb25idW5kbGVFbGVtKSB7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uYnVuZGxlRWxlbS5zZXRBdHRyaWJ1dGUoJ2xhbmcnLCBsYW5ndWFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgbmV3IHRyYW5zLXVuaXQgdG8gdGhpcyBmaWxlLlxyXG4gICAgICogVGhlIHRyYW5zIHVuaXQgc3RlbXMgZnJvbSBhbm90aGVyIGZpbGUuXHJcbiAgICAgKiBJdCBjb3BpZXMgdGhlIHNvdXJjZSBjb250ZW50IG9mIHRoZSB0dSB0byB0aGUgdGFyZ2V0IGNvbnRlbnQgdG9vLFxyXG4gICAgICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgaXNEZWZhdWx0TGFuZyBhbmQgY29weUNvbnRlbnQuXHJcbiAgICAgKiBTbyB0aGUgc291cmNlIGNhbiBiZSB1c2VkIGFzIGEgZHVtbXkgdHJhbnNsYXRpb24uXHJcbiAgICAgKiAodXNlZCBieSB4bGlmZm1lcmdlKVxyXG4gICAgICogQHBhcmFtIGZvcmVpZ25UcmFuc1VuaXQgdGhlIHRyYW5zIHVuaXQgdG8gYmUgaW1wb3J0ZWQuXHJcbiAgICAgKiBAcGFyYW0gaXNEZWZhdWx0TGFuZyBGbGFnLCB3ZXRoZXIgZmlsZSBjb250YWlucyB0aGUgZGVmYXVsdCBsYW5ndWFnZS5cclxuICAgICAqIFRoZW4gc291cmNlIGFuZCB0YXJnZXQgYXJlIGp1c3QgZXF1YWwuXHJcbiAgICAgKiBUaGUgY29udGVudCB3aWxsIGJlIGNvcGllZC5cclxuICAgICAqIFN0YXRlIHdpbGwgYmUgZmluYWwuXHJcbiAgICAgKiBAcGFyYW0gY29weUNvbnRlbnQgRmxhZywgd2V0aGVyIHRvIGNvcHkgY29udGVudCBvciBsZWF2ZSBpdCBlbXB0eS5cclxuICAgICAqIFdiZW4gdHJ1ZSwgY29udGVudCB3aWxsIGJlIGNvcGllZCBmcm9tIHNvdXJjZS5cclxuICAgICAqIFdoZW4gZmFsc2UsIGNvbnRlbnQgd2lsbCBiZSBsZWZ0IGVtcHR5IChpZiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UpLlxyXG4gICAgICogQHBhcmFtIGltcG9ydEFmdGVyRWxlbWVudCBvcHRpb25hbCAoc2luY2UgMS4xMCkgb3RoZXIgdHJhbnN1bml0IChwYXJ0IG9mIHRoaXMgZmlsZSksIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgYW5jZXN0b3IuXHJcbiAgICAgKiBOZXdseSBpbXBvcnRlZCB0cmFucyB1bml0IGlzIHRoZW4gaW5zZXJ0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhpcyBlbGVtZW50LlxyXG4gICAgICogSWYgbm90IHNldCBvciBub3QgcGFydCBvZiB0aGlzIGZpbGUsIG5ldyB1bml0IHdpbGwgYmUgaW1wb3J0ZWQgYXQgdGhlIGVuZC5cclxuICAgICAqIElmIGV4cGxpY2l0eSBzZXQgdG8gbnVsbCwgbmV3IHVuaXQgd2lsbCBiZSBpbXBvcnRlZCBhdCB0aGUgc3RhcnQuXHJcbiAgICAgKiBAcmV0dXJuIHRoZSBuZXdseSBpbXBvcnRlZCB0cmFucyB1bml0IChzaW5jZSB2ZXJzaW9uIDEuNy4wKVxyXG4gICAgICogQHRocm93cyBhbiBlcnJvciBpZiB0cmFucy11bml0IHdpdGggc2FtZSBpZCBhbHJlYWR5IGlzIGluIHRoZSBmaWxlLlxyXG4gICAgICovXHJcbiAgICBpbXBvcnROZXdUcmFuc1VuaXQoZm9yZWlnblRyYW5zVW5pdDogSVRyYW5zVW5pdCwgaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4sIGltcG9ydEFmdGVyRWxlbWVudD86IElUcmFuc1VuaXQpXHJcbiAgICAgICAgOiBJVHJhbnNVbml0IHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc1VuaXRXaXRoSWQoZm9yZWlnblRyYW5zVW5pdC5pZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgndHUgd2l0aCBpZCAlcyBhbHJlYWR5IGV4aXN0cyBpbiBmaWxlLCBjYW5ub3QgaW1wb3J0IGl0JywgZm9yZWlnblRyYW5zVW5pdC5pZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdNYXN0ZXJUdSA9ICg8QWJzdHJhY3RUcmFuc1VuaXQ+IGZvcmVpZ25UcmFuc1VuaXQpLmNsb25lV2l0aFNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmcsIGNvcHlDb250ZW50LCB0aGlzKTtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbmJ1bmRsZUVsZW0gPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAndHJhbnNsYXRpb25idW5kbGUnKTtcclxuICAgICAgICBpZiAoIXRyYW5zbGF0aW9uYnVuZGxlRWxlbSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdGaWxlIFwiJXNcIiBzZWVtcyB0byBiZSBubyB4dGIgZmlsZSAoc2hvdWxkIGNvbnRhaW4gYSB0cmFuc2xhdGlvbmJ1bmRsZSBlbGVtZW50KScsIHRoaXMuX2ZpbGVuYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uRWxlbWVudCA9IHRyYW5zbGF0aW9uYnVuZGxlRWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYW5zbGF0aW9uJyk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25FbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBmb3JlaWduVHJhbnNVbml0LmlkKTtcclxuICAgICAgICBsZXQgbmV3Q29udGVudCA9IChjb3B5Q29udGVudCB8fCBpc0RlZmF1bHRMYW5nKSA/IGZvcmVpZ25UcmFuc1VuaXQuc291cmNlQ29udGVudCgpIDogJyc7XHJcbiAgICAgICAgaWYgKCEoPEFic3RyYWN0VHJhbnNVbml0PiBmb3JlaWduVHJhbnNVbml0KS5pc0lDVU1lc3NhZ2UobmV3Q29udGVudCkpIHtcclxuICAgICAgICAgICAgbmV3Q29udGVudCA9IHRoaXMuZ2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCgpICsgbmV3Q29udGVudCArIHRoaXMuZ2V0TmV3VHJhbnNVbml0VGFyZ2V0U3VmZml4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERPTVV0aWxpdGllcy5yZXBsYWNlQ29udGVudFdpdGhYTUxDb250ZW50KHRyYW5zbGF0aW9uRWxlbWVudCwgbmV3Q29udGVudCk7XHJcbiAgICAgICAgY29uc3QgbmV3VHUgPSBuZXcgWHRiVHJhbnNVbml0KHRyYW5zbGF0aW9uRWxlbWVudCwgZm9yZWlnblRyYW5zVW5pdC5pZCwgdGhpcywgbmV3TWFzdGVyVHUpO1xyXG4gICAgICAgIGxldCBpbnNlcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBpc0FmdGVyRWxlbWVudFBhcnRPZkZpbGUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoISFpbXBvcnRBZnRlckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uUG9pbnQgPSB0aGlzLnRyYW5zVW5pdFdpdGhJZChpbXBvcnRBZnRlckVsZW1lbnQuaWQpO1xyXG4gICAgICAgICAgICBpZiAoISFpbnNlcnRpb25Qb2ludCkge1xyXG4gICAgICAgICAgICAgICAgaXNBZnRlckVsZW1lbnRQYXJ0T2ZGaWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW1wb3J0QWZ0ZXJFbGVtZW50ID09PSB1bmRlZmluZWQgfHwgKGltcG9ydEFmdGVyRWxlbWVudCAmJiAhaXNBZnRlckVsZW1lbnRQYXJ0T2ZGaWxlKSkge1xyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbmJ1bmRsZUVsZW0uYXBwZW5kQ2hpbGQobmV3VHUuYXNYbWxFbGVtZW50KCkpO1xyXG4gICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRBZnRlckVsZW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3RUcmFuc2xhdGlvbkVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAndHJhbnNsYXRpb24nKTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0VHJhbnNsYXRpb25FbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMuaW5zZXJ0QmVmb3JlKG5ld1R1LmFzWG1sRWxlbWVudCgpLCBmaXJzdFRyYW5zbGF0aW9uRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyB0cmFucy11bml0LCBlbXB0eSBmaWxlLCBzbyBhZGQgdG8gYnVuZGxlIGF0IGVuZFxyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25idW5kbGVFbGVtLmFwcGVuZENoaWxkKG5ld1R1LmFzWG1sRWxlbWVudCgpKTtcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZlVuaXRFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEVsZW1lbnRCeVRhZ05hbWVBbmRJZCh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3RyYW5zbGF0aW9uJywgaW1wb3J0QWZ0ZXJFbGVtZW50LmlkKTtcclxuICAgICAgICAgICAgaWYgKHJlZlVuaXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMuaW5zZXJ0QWZ0ZXIobmV3VHUuYXNYbWxFbGVtZW50KCksIHJlZlVuaXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zZXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXp5SW5pdGlhbGl6ZVRyYW5zVW5pdHMoKTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc1VuaXRzLnB1c2gobmV3VHUpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50TnVtYmVycygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3VHU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zbGF0aW9uIGZpbGUgZm9yIHRoaXMgZmlsZSBmb3IgYSBnaXZlbiBsYW5ndWFnZS5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGp1c3QgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvbmUuXHJcbiAgICAgKiBCdXQgZm9yIFhNQiB0aGUgdHJhbnNsYXRpb24gZmlsZSBoYXMgZm9ybWF0ICdYVEInLlxyXG4gICAgICogQHBhcmFtIGxhbmcgTGFuZ3VhZ2UgY29kZVxyXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIGV4cGVjdGVkIGZpbGVuYW1lIHRvIHN0b3JlIGZpbGVcclxuICAgICAqIEBwYXJhbSBpc0RlZmF1bHRMYW5nIEZsYWcsIHdldGhlciBmaWxlIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGxhbmd1YWdlLlxyXG4gICAgICogVGhlbiBzb3VyY2UgYW5kIHRhcmdldCBhcmUganVzdCBlcXVhbC5cclxuICAgICAqIFRoZSBjb250ZW50IHdpbGwgYmUgY29waWVkLlxyXG4gICAgICogU3RhdGUgd2lsbCBiZSBmaW5hbC5cclxuICAgICAqIEBwYXJhbSBjb3B5Q29udGVudCBGbGFnLCB3ZXRoZXIgdG8gY29weSBjb250ZW50IG9yIGxlYXZlIGl0IGVtcHR5LlxyXG4gICAgICogV2JlbiB0cnVlLCBjb250ZW50IHdpbGwgYmUgY29waWVkIGZyb20gc291cmNlLlxyXG4gICAgICogV2hlbiBmYWxzZSwgY29udGVudCB3aWxsIGJlIGxlZnQgZW1wdHkgKGlmIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBsYW5ndWFnZSkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nKGxhbmc6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZywgaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4pXHJcbiAgICAgICAgOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0ZpbGUgXCIlc1wiLCB4dGIgZmlsZXMgYXJlIG5vdCB0cmFuc2xhdGFibGUsIHRoZXkgYXJlIGFscmVhZHkgdHJhbnNsYXRpb25zJywgZmlsZW5hbWUpKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAyMS4wMy4yMDE3LlxyXG4gKi9cclxuaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4vaS10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuaW1wb3J0IHtYbGlmZkZpbGV9IGZyb20gJy4uL2ltcGwveGxpZmYtZmlsZSc7XHJcbmltcG9ydCB7WG1iRmlsZX0gZnJvbSAnLi4vaW1wbC94bWItZmlsZSc7XHJcbmltcG9ydCB7Zm9ybWF0fSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtYbGlmZjJGaWxlfSBmcm9tICcuLi9pbXBsL3hsaWZmMi1maWxlJztcclxuaW1wb3J0IHtGT1JNQVRfWExJRkYxMiwgRk9STUFUX1hMSUZGMjAsIEZPUk1BVF9YTUIsIEZPUk1BVF9YVEJ9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHtYdGJGaWxlfSBmcm9tICcuLi9pbXBsL3h0Yi1maWxlJztcclxuaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5fSBmcm9tICcuL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZS1mYWN0b3J5JztcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgdG8gcmVhZCB0cmFuc2xhdGlvbiBmaWxlcyBkZXBlbmRpbmcgb24gZm9ybWF0LlxyXG4gKiBUaGlzIGlzIHBhcnQgb2YgdGhlIHB1YmxpYyBhcGlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZUZhY3RvcnkgaW1wbGVtZW50cyBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgZmlsZSBmdW5jdGlvbiwgcmVzdWx0IGRlcGVuZHMgb24gZm9ybWF0LCBlaXRoZXIgWGxpZmZGaWxlIG9yIFhtYkZpbGUuXHJcbiAgICAgKiBAcGFyYW0gaTE4bkZvcm1hdCBjdXJyZW50bHkgJ3hsZicgb3IgJ3hsZjInIG9yICd4bWInIG9yICd4dGInIGFyZSBzdXBwb3J0ZWRcclxuICAgICAqIEBwYXJhbSB4bWxDb250ZW50IHRoZSBmaWxlIGNvbnRlbnRcclxuICAgICAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBmaWxlIChvbmx5IHVzZWQgdG8gcmVtZW1iZXIgaXQpXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgdXRmLTgsIC4uLiB1c2VkIHRvIHBhcnNlIFhNTC5cclxuICAgICAqIFRoaXMgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLCBidXQgaWYgeW91IGtub3cgaXQgYmVmb3JlLCB5b3UgY2FuIGF2b2lkIHJlYWRpbmcgdGhlIGZpbGUgdHdpY2UuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXIgaW4gY2FzZSBvZiB4bWIgdGhlIG1hc3RlciBmaWxlLCB0aGF0IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCB0ZXh0cy5cclxuICAgICAqICh0aGlzIGlzIHVzZWQgdG8gc3VwcG9ydCBzdGF0ZSBpbmZvcywgdGhhdCBhcmUgYmFzZWQgb24gY29tcGFyaW5nIG9yaWdpbmFsIHdpdGggdHJhbnNsYXRlZCB2ZXJzaW9uKVxyXG4gICAgICogSWdub3JlZCBmb3Igb3RoZXIgZm9ybWF0cy5cclxuICAgICAqIEByZXR1cm4gZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZnJvbUZpbGVDb250ZW50KGkxOG5Gb3JtYXQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbENvbnRlbnQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3Rlcj86IHt4bWxDb250ZW50OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZ30pOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5KCkuY3JlYXRlRmlsZUZyb21GaWxlQ29udGVudChpMThuRm9ybWF0LCB4bWxDb250ZW50LCBwYXRoLCBlbmNvZGluZywgb3B0aW9uYWxNYXN0ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBmaWxlIGZ1bmN0aW9uIGZvciBhbnkgZmlsZSB3aXRoIHVua25vd24gZm9ybWF0LlxyXG4gICAgICogVGhpcyBmdW5jdGlvbnMgdHJpZXMgdG8gZ3Vlc3MgdGhlIGZvcm1hdCBiYXNlZCBvbiB0aGUgZmlsZW5hbWUgYW5kIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlLlxyXG4gICAgICogUmVzdWx0IGRlcGVuZHMgb24gZGV0ZWN0ZWQgZm9ybWF0LCBlaXRoZXIgWGxpZmZGaWxlIG9yIFhtYkZpbGUuXHJcbiAgICAgKiBAcGFyYW0geG1sQ29udGVudCB0aGUgZmlsZSBjb250ZW50XHJcbiAgICAgKiBAcGFyYW0gcGF0aCB0aGUgcGF0aCBvZiB0aGUgZmlsZSAob25seSB1c2VkIHRvIHJlbWVtYmVyIGl0KVxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHV0Zi04LCAuLi4gdXNlZCB0byBwYXJzZSBYTUwuXHJcbiAgICAgKiBUaGlzIGlzIHJlYWQgZnJvbSB0aGUgZmlsZSwgYnV0IGlmIHlvdSBrbm93IGl0IGJlZm9yZSwgeW91IGNhbiBhdm9pZCByZWFkaW5nIHRoZSBmaWxlIHR3aWNlLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbmFsTWFzdGVyIGluIGNhc2Ugb2YgeG1iIHRoZSBtYXN0ZXIgZmlsZSwgdGhhdCBjb250YWlucyB0aGUgb3JpZ2luYWwgdGV4dHMuXHJcbiAgICAgKiAodGhpcyBpcyB1c2VkIHRvIHN1cHBvcnQgc3RhdGUgaW5mb3MsIHRoYXQgYXJlIGJhc2VkIG9uIGNvbXBhcmluZyBvcmlnaW5hbCB3aXRoIHRyYW5zbGF0ZWQgdmVyc2lvbilcclxuICAgICAqIElnbm9yZWQgZm9yIG90aGVyIGZvcm1hdHMuXHJcbiAgICAgKiBAcmV0dXJuIGVpdGhlciBYbGlmZkZpbGUgb3IgWG1iRmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZyb21Vbmtub3duRm9ybWF0RmlsZUNvbnRlbnQoeG1sQ29udGVudDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsTWFzdGVyPzoge3htbENvbnRlbnQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nfSk6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZUZhY3RvcnkoKS5jcmVhdGVGaWxlRnJvbVVua25vd25Gb3JtYXRGaWxlQ29udGVudCh4bWxDb250ZW50LCBwYXRoLCBlbmNvZGluZywgb3B0aW9uYWxNYXN0ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBmaWxlIGZ1bmN0aW9uLCByZXN1bHQgZGVwZW5kcyBvbiBmb3JtYXQsIGVpdGhlciBYbGlmZkZpbGUgb3IgWG1iRmlsZS5cclxuICAgICAqIEBwYXJhbSBpMThuRm9ybWF0IGN1cnJlbnRseSAneGxmJyBvciAneGxmMicgb3IgJ3htYicgb3IgJ3h0YicgYXJlIHN1cHBvcnRlZFxyXG4gICAgICogQHBhcmFtIHhtbENvbnRlbnQgdGhlIGZpbGUgY29udGVudFxyXG4gICAgICogQHBhcmFtIHBhdGggdGhlIHBhdGggb2YgdGhlIGZpbGUgKG9ubHkgdXNlZCB0byByZW1lbWJlciBpdClcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB1dGYtOCwgLi4uIHVzZWQgdG8gcGFyc2UgWE1MLlxyXG4gICAgICogVGhpcyBpcyByZWFkIGZyb20gdGhlIGZpbGUsIGJ1dCBpZiB5b3Uga25vdyBpdCBiZWZvcmUsIHlvdSBjYW4gYXZvaWQgcmVhZGluZyB0aGUgZmlsZSB0d2ljZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25hbE1hc3RlciBpbiBjYXNlIG9mIHhtYiB0aGUgbWFzdGVyIGZpbGUsIHRoYXQgY29udGFpbnMgdGhlIG9yaWdpbmFsIHRleHRzLlxyXG4gICAgICogKHRoaXMgaXMgdXNlZCB0byBzdXBwb3J0IHN0YXRlIGluZm9zLCB0aGF0IGFyZSBiYXNlZCBvbiBjb21wYXJpbmcgb3JpZ2luYWwgd2l0aCB0cmFuc2xhdGVkIHZlcnNpb24pXHJcbiAgICAgKiBJZ25vcmVkIGZvciBvdGhlciBmb3JtYXRzLlxyXG4gICAgICogQHJldHVybiBlaXRoZXIgWGxpZmZGaWxlIG9yIFhtYkZpbGVcclxuICAgICAqL1xyXG4gICAgY3JlYXRlRmlsZUZyb21GaWxlQ29udGVudChpMThuRm9ybWF0OiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbENvbnRlbnQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3Rlcj86IHsgeG1sQ29udGVudDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcgfSk6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgaWYgKGkxOG5Gb3JtYXQgPT09IEZPUk1BVF9YTElGRjEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgWGxpZmZGaWxlKHhtbENvbnRlbnQsIHBhdGgsIGVuY29kaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkxOG5Gb3JtYXQgPT09IEZPUk1BVF9YTElGRjIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgWGxpZmYyRmlsZSh4bWxDb250ZW50LCBwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpMThuRm9ybWF0ID09PSBGT1JNQVRfWE1CKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgWG1iRmlsZSh0aGlzLCB4bWxDb250ZW50LCBwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpMThuRm9ybWF0ID09PSBGT1JNQVRfWFRCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgWHRiRmlsZSh0aGlzLCB4bWxDb250ZW50LCBwYXRoLCBlbmNvZGluZywgb3B0aW9uYWxNYXN0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdvb3BzLCB1bnN1cHBvcnRlZCBmb3JtYXQgXCIlc1wiJywgaTE4bkZvcm1hdCkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgZmlsZSBmdW5jdGlvbiBmb3IgYW55IGZpbGUgd2l0aCB1bmtub3duIGZvcm1hdC5cclxuICAgICAqIFRoaXMgZnVuY3Rpb25zIHRyaWVzIHRvIGd1ZXNzIHRoZSBmb3JtYXQgYmFzZWQgb24gdGhlIGZpbGVuYW1lIGFuZCB0aGUgY29udGVudCBvZiB0aGUgZmlsZS5cclxuICAgICAqIFJlc3VsdCBkZXBlbmRzIG9uIGRldGVjdGVkIGZvcm1hdCwgZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlLlxyXG4gICAgICogQHBhcmFtIHhtbENvbnRlbnQgdGhlIGZpbGUgY29udGVudFxyXG4gICAgICogQHBhcmFtIHBhdGggdGhlIHBhdGggb2YgdGhlIGZpbGUgKG9ubHkgdXNlZCB0byByZW1lbWJlciBpdClcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB1dGYtOCwgLi4uIHVzZWQgdG8gcGFyc2UgWE1MLlxyXG4gICAgICogVGhpcyBpcyByZWFkIGZyb20gdGhlIGZpbGUsIGJ1dCBpZiB5b3Uga25vdyBpdCBiZWZvcmUsIHlvdSBjYW4gYXZvaWQgcmVhZGluZyB0aGUgZmlsZSB0d2ljZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25hbE1hc3RlciBpbiBjYXNlIG9mIHhtYiB0aGUgbWFzdGVyIGZpbGUsIHRoYXQgY29udGFpbnMgdGhlIG9yaWdpbmFsIHRleHRzLlxyXG4gICAgICogKHRoaXMgaXMgdXNlZCB0byBzdXBwb3J0IHN0YXRlIGluZm9zLCB0aGF0IGFyZSBiYXNlZCBvbiBjb21wYXJpbmcgb3JpZ2luYWwgd2l0aCB0cmFuc2xhdGVkIHZlcnNpb24pXHJcbiAgICAgKiBJZ25vcmVkIGZvciBvdGhlciBmb3JtYXRzLlxyXG4gICAgICogQHJldHVybiBlaXRoZXIgWGxpZmZGaWxlIG9yIFhtYkZpbGVcclxuICAgICAqL1xyXG4gICAgY3JlYXRlRmlsZUZyb21Vbmtub3duRm9ybWF0RmlsZUNvbnRlbnQoeG1sQ29udGVudDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsTWFzdGVyPzogeyB4bWxDb250ZW50OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyB9KVxyXG4gICAgICAgIDogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuICAgICAgICBsZXQgZm9ybWF0Q2FuZGlkYXRlcyA9IFtGT1JNQVRfWExJRkYxMiwgRk9STUFUX1hMSUZGMjAsIEZPUk1BVF9YTUIsIEZPUk1BVF9YVEJdO1xyXG4gICAgICAgIGlmIChwYXRoICYmIHBhdGguZW5kc1dpdGgoJ3htYicpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdENhbmRpZGF0ZXMgPSBbRk9STUFUX1hNQiwgRk9STUFUX1hUQiwgRk9STUFUX1hMSUZGMTIsIEZPUk1BVF9YTElGRjIwXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGggJiYgcGF0aC5lbmRzV2l0aCgneHRiJykpIHtcclxuICAgICAgICAgICAgZm9ybWF0Q2FuZGlkYXRlcyA9IFtGT1JNQVRfWFRCLCBGT1JNQVRfWE1CLCBGT1JNQVRfWExJRkYxMiwgRk9STUFUX1hMSUZGMjBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cnkgYWxsIGNhbmRpZGF0ZSBmb3JtYXRzIHRvIGdldCB0aGUgcmlnaHQgb25lXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRDYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdENhbmRpZGF0ZSA9IGZvcm1hdENhbmRpZGF0ZXNbaV07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGlvbkZpbGUgPSBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZUZhY3RvcnkuZnJvbUZpbGVDb250ZW50KFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdENhbmRpZGF0ZSwgeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbkZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25GaWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzZWFtcyB0byBiZSB0aGUgd3JvbmcgZm9ybWF0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnY291bGQgbm90IGlkZW50aWZ5IGZpbGUgZm9ybWF0LCBpdCBpcyBuZWl0ZXIgWExJRkYgKDEuMiBvciAyLjApIG5vciBYTUIvWFRCJykpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuIl0sIm5h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