{"version":3,"file":"ngx-i18nsupport-ngx-i18nsupport-lib.js.map","sources":["ng://@ngx-i18nsupport/ngx-i18nsupport-lib/lib/ngx-i18nsupport-lib.module.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/api/constants.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/dom-utilities.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xml-serializer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-translation-messages-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-text.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-placeholder.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-start-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-end-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/icu-message-tokenizer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/icu-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-icu-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-icu-message-ref.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-empty-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-tokenizer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/tag-mapping.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xtb-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xtb-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/api/translation-messages-file-factory.ts"],"sourcesContent":["import { NgModule } from '@angular/core';\r\n\r\n@NgModule({\r\n  imports: [\r\n  ],\r\n  declarations: [],\r\n  exports: []\r\n})\r\nexport class NgxI18nsupportLibModule { }\r\n","/**\r\n * Created by roobm on 08.05.2017.\r\n * Some constant values used in the API.\r\n */\r\n\r\n/**\r\n * supported file formats\r\n */\r\nexport const FORMAT_XLIFF12 = 'xlf';\r\nexport const FORMAT_XLIFF20 = 'xlf2';\r\nexport const FORMAT_XMB = 'xmb';\r\nexport const FORMAT_XTB = 'xtb';\r\n\r\n/**\r\n * File types\r\n * (returned by fileType() method)\r\n */\r\nexport const FILETYPE_XLIFF12 = 'XLIFF 1.2';\r\nexport const FILETYPE_XLIFF20 = 'XLIFF 2.0';\r\nexport const FILETYPE_XMB = 'XMB';\r\nexport const FILETYPE_XTB = 'XTB';\r\n\r\n/**\r\n * abstract state value.\r\n * There are only 3 supported state values.\r\n */\r\n\r\n/**\r\n * State NEW.\r\n * Signals an untranslated unit.\r\n */\r\nexport const STATE_NEW = 'new';\r\n/**\r\n * State TRANSLATED.\r\n * Signals a translated unit, that is not reviewed until now.\r\n */\r\nexport const STATE_TRANSLATED = 'translated';\r\n/**\r\n * State FINAL.\r\n * Signals a translated unit, that is reviewed and ready for use.\r\n */\r\nexport const STATE_FINAL = 'final';\r\n\r\n/**\r\n * Normalizaton message formats.\r\n */\r\n\r\n/**\r\n * Default format, contains placeholders, html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_DEFAULT = 'default';\r\n\r\n/**\r\n * Format for usage in ngxtranslate messages.\r\n * Placeholder are in the form {{n}}, no html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';\r\n","import {DOMParser, XMLSerializer} from 'xmldom';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\n\r\nexport class DOMUtilities {\r\n\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getFirstElementByTagName(element: Element | Document, tagName: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getElementByTagNameAndId(element: Element | Document, tagName: string, id: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node: Element = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementFollowingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementPrecedingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    public static getXMLContent(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg: RegExp = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg: RegExp = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    public static getPCDATA(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    public static replaceContentWithXMLContent(element: Element, pcdata: string) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment: Document = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    public static getPreviousElementSibling(element: Node): Element {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return <Element> node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    public static createFollowingSibling(elementNameToCreate: string, previousSibling: Node): Element {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return <Element> DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    public static insertAfter(newElement: Node, previousSibling: Node): Node {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        } else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    public static insertBefore(newElement: Node, nextSibling: Node): Node {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\r\n","/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\n\r\ninterface Namespace {\r\n    prefix: string;\r\n    namespace: string;\r\n}\r\n\r\n/**\r\n * Options used to control the formatting\r\n */\r\nexport interface XmlSerializerOptions {\r\n    beautify?: boolean; // set to activate beautify\r\n    indentString?: string; // Sequence uses for indentation, must only contain white space chars, e.g. \"  \" or \"    \" or \"\\t\"\r\n    mixedContentElements?: string[]; // Names of elements containing mixed content (these are not beautified)\r\n}\r\n\r\nconst DEFAULT_INDENT_STRING = '  ';\r\n\r\nexport class XmlSerializer {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document: Document, options?: XmlSerializerOptions): string {\r\n        const buf = [];\r\n        let visibleNamespaces: Namespace[] = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    {namespace: uri, prefix: null}\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    private doSerializeToString(node: Node, options: XmlSerializerOptions, buf: string[],\r\n                                indentLevel: number, partOfMixedContent: boolean, visibleNamespaces: Namespace[]) {\r\n        let child: Node;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode: Element = <Element> node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<' , nodeName);\r\n                } else {\r\n                    this.outputIndented(options, buf, indentLevel, '<' , nodeName);\r\n                }\r\n\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: attr.localName, namespace: attr.value});\r\n                    } else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: '', namespace: attr.value});\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = node.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                }\r\n\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1,\r\n                            partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    } else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                } else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = <Attr> node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = <Text> node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = <CDATASection> node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = <Comment> node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = <DocumentType> node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                } else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                } else {\r\n                    const sub = documenttypeNode.internalSubset;\r\n                    if (sub) {\r\n                        buf.push(' [', sub, ']');\r\n                    }\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = <ProcessingInstruction> node;\r\n                return buf.push( '<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n\r\n    private needNamespaceDefine(node: Element | Attr, visibleNamespaces: Namespace[]): boolean {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _xmlEncoder(c: string): string {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n\r\n    private outputIndented(options: XmlSerializerOptions, buf: string[], indentLevel: number, ...outputParts: string[]) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n\r\n    private indentationString(options: XmlSerializerOptions, indentLevel: number): string {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    private isMixedContentElement(tagName: string, options: XmlSerializerOptions): boolean {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private containsOnlyWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {isNullOrUndefined} from 'util';\r\nimport {DOMParser} from 'xmldom';\r\nimport {XmlSerializer, XmlSerializerOptions} from './xml-serializer';\r\n/**\r\n * Created by roobm on 09.05.2017.\r\n * Abstract superclass for all implementations of ITranslationMessagesFile.\r\n */\r\n\r\nexport abstract class AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    protected _filename: string;\r\n\r\n    protected _encoding: string;\r\n\r\n    protected _parsedDocument: Document;\r\n\r\n    protected _fileEndsWithEOL: boolean;\r\n\r\n    // trans-unit elements and their id from the file\r\n    protected transUnits: ITransUnit[];\r\n\r\n    protected _warnings: string[];\r\n\r\n    protected _numberOfTransUnitsWithMissingId: number;\r\n\r\n    protected _numberOfUntranslatedTransUnits: number;\r\n\r\n    protected _numberOfReviewedTransUnits: number;\r\n\r\n    protected targetPraefix: string;\r\n\r\n    protected targetSuffix: string;\r\n\r\n    protected constructor() {\r\n        this.transUnits = null;\r\n        this._warnings = [];\r\n    }\r\n\r\n    /**\r\n     * Parse file content.\r\n     * Sets _parsedDocument, line ending, encoding, etc.\r\n     * @param xmlString xmlString\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMaster optionalMaster\r\n     */\r\n    protected parseContent(\r\n        xmlString: string,\r\n        path: string, encoding: string,\r\n        optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : void {\r\n        this._filename = path;\r\n        this._encoding = encoding;\r\n        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        this._fileEndsWithEOL = xmlString.endsWith('\\n');\r\n    }\r\n\r\n    abstract i18nFormat(): string;\r\n\r\n    abstract fileType(): string;\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected abstract elementsWithMixedContent(): string[];\r\n\r\n    /**\r\n     * Read all trans units from xml content.\r\n     * Puts the found units into transUnits.\r\n     * Puts warnings for missing ids.\r\n     */\r\n    protected abstract initializeTransUnits();\r\n\r\n    protected lazyInitializeTransUnits() {\r\n        if (isNullOrUndefined(this.transUnits)) {\r\n            this.initializeTransUnits();\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * count units after changes of trans units\r\n     */\r\n    public countNumbers() {\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this._numberOfUntranslatedTransUnits = 0;\r\n        this._numberOfReviewedTransUnits = 0;\r\n        this.forEachTransUnit((tu: ITransUnit) => {\r\n            if (isNullOrUndefined(tu.id) || tu.id === '') {\r\n                this._numberOfTransUnitsWithMissingId++;\r\n            }\r\n            const state = tu.targetState();\r\n            if (isNullOrUndefined(state) || state === STATE_NEW) {\r\n                this._numberOfUntranslatedTransUnits++;\r\n            }\r\n            if (state === STATE_TRANSLATED) {\r\n                this._numberOfReviewedTransUnits++;\r\n            }\r\n        });\r\n    }\r\n\r\n    public warnings(): string[] {\r\n        this.lazyInitializeTransUnits();\r\n        return this._warnings;\r\n    }\r\n\r\n    /**\r\n     * Total number of translation units found in the file.\r\n     */\r\n    public numberOfTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.length;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfUntranslatedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfUntranslatedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units with state 'final'.\r\n     */\r\n    numberOfReviewedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfReviewedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    public numberOfTransUnitsWithMissingId(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfTransUnitsWithMissingId;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    abstract sourceLanguage(): string;\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    abstract targetLanguage(): string;\r\n\r\n    /**\r\n     * Loop over all Translation Units.\r\n     * @param callback callback\r\n     */\r\n    public forEachTransUnit(callback: ((transunit: ITransUnit) => void)) {\r\n        this.lazyInitializeTransUnits();\r\n        this.transUnits.forEach((tu) => callback(tu));\r\n    }\r\n\r\n    /**\r\n     * Get trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    public transUnitWithId(id: string): ITransUnit {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.find((tu) => tu.id === id);\r\n    }\r\n\r\n    /**\r\n     * Edit functions following her\r\n     */\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    abstract setSourceLanguage(language: string);\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    abstract setTargetLanguage(language: string);\r\n\r\n    /**\r\n     * Set the praefix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetPraefix targetPraefix\r\n     */\r\n    public setNewTransUnitTargetPraefix(targetPraefix: string) {\r\n        this.targetPraefix = targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Get the praefix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the praefix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetPraefix(): string {\r\n        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Set the suffix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetSuffix targetSuffix\r\n     */\r\n    public setNewTransUnitTargetSuffix(targetSuffix: string) {\r\n        this.targetSuffix = targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Get the suffix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the suffix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetSuffix(): string {\r\n        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    abstract importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit;\r\n\r\n    /**\r\n     * Remove the trans-unit with the given id.\r\n     * @param id id\r\n     */\r\n    public removeTransUnitWithId(id: string) {\r\n        const tuNode: Node = this._parsedDocument.getElementById(id);\r\n        if (tuNode) {\r\n            tuNode.parentNode.removeChild(tuNode);\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filename where the data is read from.\r\n     */\r\n    public filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    /**\r\n     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)\r\n     */\r\n    public encoding(): string {\r\n        return this._encoding;\r\n    }\r\n\r\n    /**\r\n     * The xml content to be saved after changes are made.\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public editedContent(beautifyOutput?: boolean): string {\r\n        const options: XmlSerializerOptions = {};\r\n        if (beautifyOutput === true) {\r\n           options.beautify = true;\r\n           options.indentString = '  ';\r\n           options.mixedContentElements = this.elementsWithMixedContent();\r\n        }\r\n        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);\r\n        if (this._fileEndsWithEOL) {\r\n            // add eol if there was eol in original source\r\n            return result + '\\n';\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    abstract createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile;\r\n}\r\n","import {STATE_TRANSLATED, ITranslationMessagesFile, INormalizedMessage, ITransUnit, INote} from './internalapi';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {isNullOrUndefined, isString} from 'util';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * Abstract superclass for all implementations of ITransUnit.\r\n */\r\n\r\nexport abstract class AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceContentNormalized: ParsedMessage;\r\n\r\n    protected constructor(protected _element: Element,\r\n                          protected _id: string,\r\n                          protected _translationMessagesFile: ITranslationMessagesFile) {\r\n    }\r\n\r\n    public get id(): string {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * The file the unit belongs to.,\r\n     */\r\n    translationMessagesFile(): ITranslationMessagesFile {\r\n        return this._translationMessagesFile;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract sourceContent(): string;\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    abstract setSourceContent(newContent: string);\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public sourceContentNormalized(): ParsedMessage {\r\n        if (isNullOrUndefined(this._sourceContentNormalized)) {\r\n            this._sourceContentNormalized = this.createSourceContentNormalized();\r\n        }\r\n        return this._sourceContentNormalized;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    abstract createSourceContentNormalized(): ParsedMessage;\r\n\r\n    /**\r\n     * The translated value.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract targetContent(): string;\r\n\r\n    /**\r\n     * The translated value as normalized message.\r\n     * All placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    abstract targetContentNormalized(): INormalizedMessage;\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    abstract nativeTargetState(): string;\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (on of new, translated, final)\r\n     * Return values are defined as Constants STATE_...\r\n     */\r\n    public targetState(): string {\r\n        const nativeState = this.nativeTargetState();\r\n        return this.mapNativeStateToState(nativeState);\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected abstract mapStateToNativeState(state: string): string;\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract mapNativeStateToState(nativeState: string): string;\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract setNativeTargetState(nativeState: string);\r\n\r\n    /**\r\n     * Modify the target state.\r\n     * @param newState one of the 3 allowed target states new, translated, final.\r\n     * Constants STATE_...\r\n     * Invalid states throw an error.\r\n     */\r\n    setTargetState(newState: string) {\r\n        this.setNativeTargetState(this.mapStateToNativeState(newState));\r\n        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {\r\n            (<AbstractTranslationMessagesFile> this.translationMessagesFile()).countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    abstract sourceReferences(): {sourcefile: string, linenumber: number}[];\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    abstract setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]);\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     */\r\n    abstract description(): string;\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     */\r\n    abstract meaning(): string;\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    abstract setDescription(description: string);\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    abstract setMeaning(meaning: string);\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    abstract notes(): INote[];\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    abstract supportsSetNotes(): boolean;\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains descpription or meaning as from attribute.\r\n     */\r\n    abstract setNotes(newNotes: INote[]);\r\n\r\n    /**\r\n     * Check notes\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    protected checkNotes(newNotes: INote[]) {\r\n        // check from values\r\n        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');\r\n        if (!isNullOrUndefined(errorInFromNote)) {\r\n            throw new Error('description or meaning are not allowed as from atttribute');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The real xml element used for the trans unit.\r\n     * (internal usage only, a client should never need this)\r\n     * @return real xml element used for the trans unit.\r\n     */\r\n    public asXmlElement(): Element {\r\n        return this._element;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    abstract cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit;\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    abstract useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean);\r\n\r\n    /**\r\n     * Translate the trans unit.\r\n     * @param translation the translated string or (preferred) a normalized message.\r\n     * The pure string can contain any markup and will not be checked.\r\n     * So it can damage the document.\r\n     * A normalized message prevents this.\r\n     */\r\n    public translate(translation: string | INormalizedMessage) {\r\n        let translationNative: string;\r\n        if (isString(translation)) {\r\n            translationNative = <string> translation;\r\n        } else {\r\n            translationNative = (<INormalizedMessage> translation).asNativeString();\r\n        }\r\n        this.translateNative(translationNative);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected abstract messageParser(): AbstractMessageParser;\r\n\r\n    /**\r\n     * Test, wether message looks like ICU message.\r\n     * @param message message\r\n     * @return wether message looks like ICU message.\r\n     */\r\n    public isICUMessage(message: string): boolean {\r\n        return this.messageParser().isICUMessageStart(message);\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected abstract translateNative(translation: string);\r\n}\r\n","/**\r\n * Created by martin on 05.05.2017.\r\n * A part of a parsed message.\r\n * Can be a text, a placeholder, a tag\r\n */\r\n\r\nexport enum ParsedMessagePartType {\r\n    TEXT,\r\n    PLACEHOLDER,\r\n    START_TAG,\r\n    END_TAG,\r\n    EMPTY_TAG,\r\n    ICU_MESSAGE,\r\n    ICU_MESSAGE_REF\r\n}\r\n\r\nexport abstract class ParsedMessagePart {\r\n\r\n    constructor(public type: ParsedMessagePartType) {\r\n\r\n    }\r\n\r\n    /**\r\n     * String representation of the part.\r\n     * @param format optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public abstract asDisplayString(format?: string): string;\r\n\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of just simple text.\r\n */\r\n\r\nexport class ParsedMessagePartText extends ParsedMessagePart {\r\n\r\n    private text: string;\r\n\r\n    constructor(text: string) {\r\n        super(ParsedMessagePartType.TEXT);\r\n        this.text = text;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return this.text;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a placeholder.\r\n * Placeholders are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartPlaceholder extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.PLACEHOLDER);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {\r\n            return '{{' + this._index + '}}';\r\n        }\r\n        return '{{' + this._index + '}}';\r\n    }\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of an opening tag like <b> or <strange>.\r\n */\r\n\r\nexport class ParsedMessagePartStartTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.START_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a closing tag like </b> or </strange>.\r\n */\r\n\r\nexport class ParsedMessagePartEndTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n\r\n    constructor(tagname: string) {\r\n        super(ParsedMessagePartType.END_TAG);\r\n        this._tagname = tagname;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '</' + this._tagname + '>';\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\n\r\n/**\r\n * Created by martin on 04.06.2017.\r\n * A tokenizer for ICU messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';\r\nexport const CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';\r\nexport const COMMA = 'COMMA';\r\nexport const PLURAL = 'PLURAL';\r\nexport const SELECT = 'SELECT';\r\n\r\nexport interface ICUToken {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\n// states: default normal in_message\r\nconst STATE_DEFAULT = 'default';\r\nconst STATE_NORMAL = 'normal';\r\nconst STATE_IN_MESSAGE = 'in_message';\r\n\r\nexport class ICUMessageTokenizer {\r\n    private lexer: Tokenizr;\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        let openedCurlyBracesInTextCounter = 0;\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT) {\r\n                if (this.containsNonWhiteSpace(plaintext)) {\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                } else {\r\n                    ctx.ignore();\r\n                }\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (this.containsNonWhiteSpace(plaintext)) {\r\n                ctx.accept(TEXT, plaintext);\r\n            }\r\n         });\r\n        // curly brace\r\n        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_NORMAL);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_IN_MESSAGE);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {\r\n            ctx.pop();\r\n            ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n        }, CURLY_BRACE_CLOSE);\r\n        // masked ' { and }\r\n        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {\r\n            if (match[0] === '\\'\\'') {\r\n                plaintext += '\\'';\r\n            } else if (match[0] === '\\'{\\'') {\r\n                plaintext += '{';\r\n            } else if (match[0] === '\\'}\\'') {\r\n                plaintext += '}';\r\n            }\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {\r\n            const char = match[0];\r\n            if (char === '{') {\r\n                openedCurlyBracesInTextCounter++;\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            } else if (char === '}') {\r\n                if (openedCurlyBracesInTextCounter > 0) {\r\n                    openedCurlyBracesInTextCounter--;\r\n                    plaintext += match[0];\r\n                    ctx.ignore();\r\n                } else {\r\n                    ctx.pop();\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n                }\r\n            } else {\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n        }, TEXT);\r\n        // comma\r\n        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {\r\n            ctx.accept(COMMA, match[0]);\r\n        }, COMMA);\r\n        // keywords plural and select\r\n        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {\r\n            ctx.accept(PLURAL, match[0]);\r\n        }, PLURAL);\r\n        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {\r\n            ctx.accept(SELECT, match[0]);\r\n        }, SELECT);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\s]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    private containsNonWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (!/\\s/.test(text.charAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): ICUToken[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n    input(normalizedMessage: string) {\r\n        this.lexer = this.getLexer();\r\n        this.lexer.input(normalizedMessage);\r\n    }\r\n\r\n    next(): ICUToken {\r\n        return this.lexer.token();\r\n    }\r\n\r\n    peek(): ICUToken {\r\n        return this.lexer.peek();\r\n    }\r\n}\r\n","import {IICUMessage, IICUMessageCategory, IICUMessageTranslation, INormalizedMessage} from '../api/index';\r\nimport {format, isNullOrUndefined, isString} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\nclass MessageCategory implements IICUMessageCategory {\r\n\r\n    constructor(private _category: string, private _message: INormalizedMessage) {}\r\n\r\n    public getCategory(): string {\r\n        return this._category;\r\n    }\r\n\r\n    public getMessageNormalized(): INormalizedMessage {\r\n        return this._message;\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nexport class ICUMessage implements IICUMessage {\r\n\r\n    private _isPluralMessage: boolean;\r\n\r\n    private _categories: IICUMessageCategory[];\r\n\r\n    constructor(private _parser: IMessageParser, isPluralMessage: boolean) {\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n\r\n    addCategory(category: string, message: INormalizedMessage) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    public asNativeString(): string {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category: IICUMessageCategory) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage(): boolean {\r\n        return this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage(): boolean {\r\n        return !this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories(): IICUMessageCategory[] {\r\n        return this._categories;\r\n    }\r\n\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation: IICUMessageTranslation): IICUMessage {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories: Set<string> = new Set<string>();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage: INormalizedMessage;\r\n            const translationForCategory: string|IICUMessageTranslation = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            } else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(<string> translationForCategory, null);\r\n            } else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)',\r\n                        categoryName));\r\n                } else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    let translatedMessage = this._parser.parseNormalizedString(<string> translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    private checkValidPluralCategory(categoryName: string) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {IICUMessage, INormalizedMessage} from '../api/index';\r\nimport {\r\n    COMMA, CURLY_BRACE_CLOSE, CURLY_BRACE_OPEN, ICUMessageTokenizer, ICUToken, PLURAL, SELECT,\r\n    TEXT\r\n} from './icu-message-tokenizer';\r\nimport {ICUMessage} from './icu-message';\r\nimport {format} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\n\r\nexport class ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n\r\n    private _message: ICUMessage;\r\n    private _messageText: string;\r\n    private _tokenizer: ICUMessageTokenizer;\r\n\r\n    constructor(icuMessageText: string, private _parser: IMessageParser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText: string): boolean {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n\r\n    public asDisplayString(displayFormat?: string) {\r\n        return '<ICU-Message/>';\r\n    }\r\n\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        return this._message;\r\n    }\r\n\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    private parseICUMessage(text: string) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token: ICUToken = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        } else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    private looksLikeICUMessage(text: string): boolean {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token: ICUToken = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    private expectNext(tokentype: string): ICUToken {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)',\r\n                tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    private parseNativeSubMessage(message: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A reference to an ICU message\r\n * icu references are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartICUMessageRef extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE_REF);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '<ICU-Message-Ref_' + this._index + '/>';\r\n    }\r\n\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 14.06.2017.\r\n * A message part consisting of an empty tag like <br/>.\r\n */\r\n\r\nexport class ParsedMessagePartEmptyTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.EMPTY_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {INormalizedMessage, ValidationErrors} from '../api/i-normalized-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {IICUMessage, IICUMessageTranslation} from '../api/i-icu-message';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ICUMessage} from './icu-message';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message text read from a translation file.\r\n * Can contain placeholders, tags, text.\r\n * This class is a representation independent of the concrete format.\r\n */\r\nexport class ParsedMessage implements INormalizedMessage {\r\n\r\n    /**\r\n     * Parser that created this message (determines the native format).\r\n     */\r\n    private _parser: IMessageParser;\r\n\r\n    /**\r\n     * The message where this one stems from as translation.\r\n     * Optional, set only for messages created by calling translate.\r\n     */\r\n    private sourceMessage: ParsedMessage;\r\n\r\n    /**\r\n     * The parts of the message.\r\n     */\r\n    private _parts: ParsedMessagePart[];\r\n\r\n    /**\r\n     * messages xml representation.\r\n     */\r\n    private _xmlRepresentation: Element;\r\n\r\n    constructor(parser: IMessageParser, sourceMessage: ParsedMessage) {\r\n        this._parser = parser;\r\n        this.sourceMessage = sourceMessage;\r\n        this._parts = [];\r\n    }\r\n\r\n    /**\r\n     * Get the parser (for tests only, not part of API)\r\n     * @return parser\r\n     */\r\n    getParser(): IMessageParser {\r\n        return this._parser;\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message as a translation of this one.\r\n     * @param normalizedString the translation in normalized form.\r\n     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is an ICU message.\r\n     */\r\n    translate(normalizedString: string): INormalizedMessage {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return this._parser.parseNormalizedString(<string> normalizedString, this);\r\n        } else {\r\n            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead (\"%s\", \"%s\")',\r\n                normalizedString, this.asNativeString()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized icu message as a translation of this one.\r\n     * @param icuTranslation the translation, this is the translation of the ICU message,\r\n     * which is not a string, but a collections of the translations of the different categories.\r\n     * The message must be an ICUMessage (getICUMessage returns a value)\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is not an ICU message.\r\n     */\r\n    translateICUMessage(icuTranslation: IICUMessageTranslation): INormalizedMessage {\r\n        const icuMessage: IICUMessage = this.getICUMessage();\r\n        if (isNullOrUndefined(icuMessage)) {\r\n            throw new Error(format('this is not an ICU message, use translate() instead (\"%s\", \"%s\")',\r\n                icuTranslation,  this.asNativeString()));\r\n        } else {\r\n            const translatedICUMessage: IICUMessage = icuMessage.translate(icuTranslation);\r\n            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message from a native xml string as a translation of this one.\r\n     * @param nativeString xml string in the format of the underlying file format.\r\n     * Throws an error if native string is not acceptable.\r\n     */\r\n    translateNativeString(nativeString: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);\r\n    }\r\n\r\n    /**\r\n     * normalized message as string.\r\n     * @param displayFormat optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public asDisplayString(displayFormat?: string) {\r\n        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');\r\n    }\r\n\r\n    /**\r\n     * Returns the message content as format dependent native string.\r\n     * Includes all format specific markup like <ph id=\"INTERPOLATION\" ../> ..\r\n     */\r\n    asNativeString(): string {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return DOMUtilities.getXMLContent(this._xmlRepresentation);\r\n        } else {\r\n            return this.getICUMessage().asNativeString();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate the message.\r\n     * @return null, if ok, error object otherwise.\r\n     */\r\n    public validate(): ValidationErrors | null {\r\n        let hasErrors = false;\r\n        const errors: ValidationErrors = {};\r\n        let e;\r\n        e = this.checkPlaceholderAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.placeholderAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefRemoved();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefRemoved = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        return hasErrors ? errors : null;\r\n    }\r\n\r\n    /**\r\n     * Validate the message, check for warnings only.\r\n     * A warning shows, that the message is acceptable, but misses something.\r\n     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.\r\n     * @return null, if no warning, warnings as error object otherwise.\r\n     */\r\n    validateWarnings(): ValidationErrors | null {\r\n        let hasWarnings = false;\r\n        const warnings: ValidationErrors = {};\r\n        let w;\r\n        w = this.checkPlaceholderRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.placeholderRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagAdded();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagAdded = w;\r\n            hasWarnings = true;\r\n        }\r\n        return hasWarnings ? warnings : null;\r\n    }\r\n\r\n    /**\r\n     * If this message is an ICU message, returns its structure.\r\n     * Otherwise this method returns null.\r\n     * @return ICUMessage or null.\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {\r\n            const icuPart = <ParsedMessagePartICUMessage> this._parts[0];\r\n            return icuPart.getICUMessage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for added placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            myPlaceholders.forEach((index) => {\r\n                if (!sourcePlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderRemoved(): any {\r\n        let w = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            sourcePlaceholders.forEach((index) => {\r\n                if (!myPlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Check for added ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            myICURefs.forEach((index) => {\r\n                if (!sourceICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefRemoved(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            sourceICURefs.forEach((index) => {\r\n                if (!myICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of placeholders used in the message.\r\n     */\r\n    private allPlaceholders(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const index = (<ParsedMessagePartPlaceholder> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of placeholder\r\n     * @param index index of placeholder\r\n     * @return disp or null\r\n     */\r\n    public getPlaceholderDisp(index: number): string {\r\n        let placeHolder: ParsedMessagePartPlaceholder = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const phPart: ParsedMessagePartPlaceholder = <ParsedMessagePartPlaceholder> part;\r\n                if (phPart.index() === index) {\r\n                    placeHolder = phPart;\r\n                }\r\n            }\r\n        });\r\n        return placeHolder ? placeHolder.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of ICU message refs used in the message.\r\n     */\r\n    private allICUMessageRefs(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const index = (<ParsedMessagePartICUMessageRef> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of icu message ref\r\n     * @param index of ref\r\n     * @return disp or null\r\n     */\r\n    public getICUMessageRefDisp(index: number): string {\r\n        let icuMessageRefPart: ParsedMessagePartICUMessageRef = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const refPart: ParsedMessagePartICUMessageRef = <ParsedMessagePartICUMessageRef> part;\r\n                if (refPart.index() === index) {\r\n                    icuMessageRefPart = refPart;\r\n                }\r\n            }\r\n        });\r\n        return icuMessageRefPart ? icuMessageRefPart.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Check for added tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagAdded(): any {\r\n        let e = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            myTags.forEach((tagName) => {\r\n                if (!sourceTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagRemoved(): any {\r\n        let w = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            sourceTags.forEach((tagName) => {\r\n                if (!myTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            w = 'removed tag <' + suspiciousTags[0] + '> from original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            w = 'removed tags ' + allSuspiciousTags + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Get all tag names used in the message.\r\n     */\r\n    private allTags(): Set<string> {\r\n        const result = new Set<string>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {\r\n                const tagName = (<ParsedMessagePartStartTag> part).tagName();\r\n                result.add(tagName);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    public parts(): ParsedMessagePart[] {\r\n        return this._parts;\r\n    }\r\n\r\n    setXmlRepresentation(xmlRepresentation: Element) {\r\n        this._xmlRepresentation = xmlRepresentation;\r\n    }\r\n\r\n    addText(text: string) {\r\n        this._parts.push(new ParsedMessagePartText(text));\r\n    }\r\n\r\n    addPlaceholder(index: number, disp: string) {\r\n        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));\r\n    }\r\n\r\n    addStartTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));\r\n    }\r\n\r\n    addEndTag(tagname: string) {\r\n        // check if well formed\r\n        const openTag = this.calculateOpenTagName();\r\n        if (!openTag || openTag !== tagname) {\r\n            // oops, not well formed\r\n            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                tagname, openTag, this.asNativeString()));\r\n        }\r\n        this._parts.push(new ParsedMessagePartEndTag(tagname));\r\n    }\r\n\r\n    addEmptyTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));\r\n    }\r\n\r\n    addICUMessageRef(index: number, disp) {\r\n        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));\r\n    }\r\n\r\n    addICUMessage(text: string) {\r\n        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));\r\n    }\r\n\r\n    /**\r\n     * Determine, wether there is an open tag, that is not closed.\r\n     * Returns the latest one or null, if there is no open tag.\r\n     */\r\n    private calculateOpenTagName(): string {\r\n        const openTags = [];\r\n        this._parts.forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.START_TAG:\r\n                    openTags.push((<ParsedMessagePartStartTag> part).tagName());\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const tagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {\r\n                        // oops, not well formed\r\n                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];\r\n                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                            tagName, openTag, this.asNativeString()));\r\n                    }\r\n                    openTags.pop();\r\n            }\r\n        });\r\n        return openTags.length === 0 ? null : openTags[openTags.length - 1];\r\n    }\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\nimport {isNullOrUndefined} from 'util';\r\n\r\n/**\r\n * Created by martin on 14.05.2017.\r\n * A tokenizer for normalized messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const START_TAG = 'START_TAG';\r\nexport const END_TAG = 'END_TAG';\r\nexport const EMPTY_TAG = 'EMPTY_TAG';\r\nexport const PLACEHOLDER = 'PLACEHOLDER';\r\nexport const ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';\r\nexport const ICU_MESSAGE = 'ICU_MESSAGE';\r\n\r\nexport interface Token {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\nexport class ParsedMesageTokenizer {\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT && plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n                plaintext = '';\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n            }\r\n         });\r\n        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']\r\n        // format is <name id=\"nr\">, nr ist optional, z.B. <img> oder <img id=\"2\">\r\n        lexer.rule(/<(br|hr|img|area|link|wbr)( id=\"([0-9])*\")?\\>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(EMPTY_TAG, {name: match[1], idcounter: idcount});\r\n        }, EMPTY_TAG);\r\n        // start tag, Format <name id=\"nr\">, nr ist optional, z.B. <mytag> oder <mytag id=\"2\">\r\n        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id=\"([0-9]*)\")?>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(START_TAG, {name: match[1], idcounter: idcount});\r\n        }, START_TAG);\r\n        // end tag\r\n        lexer.rule(/<\\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {\r\n            ctx.accept(END_TAG, {name: match[1]});\r\n        }, END_TAG);\r\n        // placeholder\r\n        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {\r\n            ctx.accept(PLACEHOLDER, {idcounter: parseInt(match[1], 10)});\r\n        }, PLACEHOLDER);\r\n        // icu message ref\r\n        lexer.rule(/<ICU-Message-Ref_([0-9]+)\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE_REF, {idcounter: parseInt(match[1], 10)});\r\n        }, ICU_MESSAGE_REF);\r\n        // icu message\r\n        lexer.rule(/<ICU-Message\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE, {message: match[0]});\r\n        }, ICU_MESSAGE);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\t\\r\\n]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): Token[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.reset();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n}\r\n","import {ParsedMessage} from './parsed-message';\r\nimport {\r\n    EMPTY_TAG,\r\n    END_TAG, ICU_MESSAGE, ICU_MESSAGE_REF, ParsedMesageTokenizer, PLACEHOLDER, START_TAG, TEXT,\r\n    Token\r\n} from './parsed-message-tokenizer';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {DOMParser} from 'xmldom';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser can parse the xml content of a translatable message.\r\n * It generates a ParsedMessage from it.\r\n */\r\nexport abstract class AbstractMessageParser implements IMessageParser {\r\n\r\n    /**\r\n     * Parse XML to ParsedMessage.\r\n     * @param xmlElement the xml representation\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    public createNormalizedMessageFromXML(xmlElement: Element, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        if (xmlElement) {\r\n            message.setXmlRepresentation(xmlElement);\r\n            this.addPartsOfNodeToMessage(xmlElement, message, false);\r\n        }\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse XML string to ParsedMessage.\r\n     * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXMLString(xmlString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const doc: Document = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');\r\n        const xmlElement: Element = <Element> doc.childNodes.item(0);\r\n        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * recursively run through a node and add all identified parts to the message.\r\n     * @param node node\r\n     * @param message message to be generated.\r\n     * @param includeSelf if true, add node by itself, otherwise only children.\r\n     */\r\n    private addPartsOfNodeToMessage(node: Node, message: ParsedMessage, includeSelf: boolean) {\r\n        let processChildren = true;\r\n        if (includeSelf) {\r\n            if (node.nodeType === node.TEXT_NODE) {\r\n                message.addText(node.textContent);\r\n                return;\r\n            }\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                processChildren = this.processStartElement(<Element> node, message);\r\n            }\r\n        }\r\n        if (processChildren) {\r\n            const icuMessageText = this.getICUMessageText(node);\r\n            let isICU = !isNullOrUndefined(icuMessageText);\r\n            if (isICU) {\r\n                try {\r\n                    message.addICUMessage(icuMessageText);\r\n                } catch (error) {\r\n                    // if it is not parsable, handle it as non ICU\r\n                    console.log('non ICU message: ', icuMessageText, error);\r\n                    isICU = false;\r\n                }\r\n            }\r\n            if (!isICU) {\r\n                const children = node.childNodes;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    this.addPartsOfNodeToMessage(children.item(i), message, true);\r\n                }\r\n            }\r\n        }\r\n        if (node.nodeType === node.ELEMENT_NODE) {\r\n            this.processEndElement(<Element> node, message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        const firstChild = children.item(0);\r\n        if (firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                return DOMUtilities.getXMLContent(<Element> node);\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether text is beginning of ICU Message.\r\n     * @param text text\r\n     */\r\n    public isICUMessageStart(text: string): boolean {\r\n        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);\r\n//        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');\r\n    }\r\n\r\n    /**\r\n     * Handle this node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected abstract processStartElement(elementNode: Element, message: ParsedMessage): boolean;\r\n\r\n    /**\r\n     * Handle end of this node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected abstract processEndElement(elementNode: Element, message: ParsedMessage);\r\n\r\n    /**\r\n     * Parse normalized string to ParsedMessage.\r\n     * @param normalizedString normalized string\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if normalized string is not well formed.\r\n     */\r\n    public parseNormalizedString(normalizedString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        const openTags = [];\r\n        let tokens: Token[];\r\n        try {\r\n            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);\r\n        } catch (error) {\r\n            throw new Error(format('unexpected error while parsing message: \"%s\" (parsed \"%\")', error.message, normalizedString));\r\n        }\r\n        tokens.forEach((token: Token) => {\r\n            let disp: string = null;\r\n            switch (token.type) {\r\n                case TEXT:\r\n                    message.addText(token.value.text);\r\n                    break;\r\n                case START_TAG:\r\n                    message.addStartTag(token.value.name, token.value.idcounter);\r\n                    openTags.push(token.value.name);\r\n                    break;\r\n                case END_TAG:\r\n                    message.addEndTag(token.value.name);\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {\r\n                        // oops, not well formed\r\n                        throw new Error(format('unexpected close tag \"%s\" (parsed \"%s\")', token.value.name, normalizedString));\r\n                    }\r\n                    openTags.pop();\r\n                    break;\r\n                case EMPTY_TAG:\r\n                    message.addEmptyTag(token.value.name, token.value.idcounter);\r\n                    break;\r\n                case PLACEHOLDER:\r\n                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;\r\n                    message.addPlaceholder(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE_REF:\r\n                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;\r\n                    message.addICUMessageRef(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE:\r\n                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed \"%\")', normalizedString));\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        if (openTags.length > 0) {\r\n            // oops, not well closed tags\r\n            throw new Error(format('missing close tag \"%s\" (parsed \"%s\")', openTags[openTags.length - 1], normalizedString));\r\n        }\r\n        message.setXmlRepresentation(this.createXmlRepresentation(message));\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse a string, that is an ICU message, to ParsedMessage.\r\n     * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if icuMessageString has not the correct syntax.\r\n     */\r\n    parseICUMessage(icuMessageString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        message.addICUMessage(icuMessageString);\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Helper function: Parse ID from a name.\r\n     * name optionally ends with _<number>. This is the idcount.\r\n     * E.g. name=\"TAG_IMG\" returns 0\r\n     * name = \"TAG_IMG_1\" returns 1\r\n     * @param name name\r\n     * @return id count\r\n     */\r\n    protected parseIdCountFromName(name: string): number {\r\n        const regex = /.*_([0-9]*)/;\r\n        const match = regex.exec(name);\r\n        if (isNullOrUndefined(match) || match[1] === '') {\r\n            return 0;\r\n        } else {\r\n            const num = match[1];\r\n            return parseInt(num, 10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the native xml for a message.\r\n     * Parts are already set here.\r\n     * @param message message\r\n     */\r\n    protected createXmlRepresentation(message: ParsedMessage): Element {\r\n        const root: Document = new DOMParser().parseFromString('<dummy/>', 'text/xml');\r\n        const rootElem: Element = root.getElementsByTagName('dummy').item(0);\r\n        this.addXmlRepresentationToRoot(message, rootElem);\r\n        return rootElem;\r\n    }\r\n\r\n    protected abstract addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element);\r\n\r\n    protected createXmlRepresentationOfTextPart(part: ParsedMessagePartText, rootElem: Element): Node {\r\n        return rootElem.ownerDocument.createTextNode(part.asDisplayString());\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node;\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node;\r\n}\r\n","/**\r\n * Created by roobm on 16.05.2017.\r\n * Mapping from normalized tag names to placeholder names.\r\n */\r\n\r\n/*\r\ncopied from https://github.com/angular/angular/blob/master/packages/compiler/src/i18n/serializers/placeholder.ts\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n\r\n/**\r\n * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.\r\n */\r\nconst VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];\r\n\r\nexport class TagMapping {\r\n\r\n    public getStartTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `START_${baseName}` + this.counterString(id);\r\n    }\r\n\r\n    public getCloseTagPlaceholderName(tag: string): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `CLOSE_${baseName}`;\r\n    }\r\n\r\n    public getEmptyTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName =  TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return baseName + this.counterString(id);\r\n    }\r\n\r\n    public getCtypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n                return 'lb';\r\n            case 'img':\r\n                return 'image';\r\n            default:\r\n                return `x-${tag}`;\r\n        }\r\n    }\r\n\r\n    public getTagnameFromStartTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('START_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('START_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('START_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public getTagnameFromCloseTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('CLOSE_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('CLOSE_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Test, wether placeholder name stands for empty html tag.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public isEmptyTagPlaceholderName(placeholderName: string): boolean {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * tagname of empty tag placeholder.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public getTagnameFromEmptyTagPlaceholderName(placeholderName: string): string {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return matchKey.toLowerCase();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * If placeholder ends with _[0-9]+, strip that number.\r\n     * @param placeholderName placeholderName\r\n     * @return placeholderName without counter at end.\r\n     */\r\n    private stripCounter(placeholderName: string): string {\r\n        if (placeholderName) {\r\n            const re = /(.*)_[0-9]+$/;\r\n            if (placeholderName.match(re)) {\r\n                return placeholderName.replace(re, '$1');\r\n            }\r\n        }\r\n        return placeholderName;\r\n    }\r\n\r\n    /**\r\n     * String suffix for counter.\r\n     * If counter is 0, it is empty, otherwise _<id>.\r\n     * @param id id\r\n     * @return suffix for counter.\r\n     */\r\n    private counterString(id: number) {\r\n        if (id === 0) {\r\n            return '';\r\n        } else {\r\n            return '_' + id.toString(10);\r\n        }\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {isNullOrUndefined} from 'util';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 1.2\r\n */\r\nexport class XliffMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        const tagMapping = new TagMapping();\r\n        if (tagName === 'x') {\r\n            // placeholder are like <x id=\"INTERPOLATION\"/> or <x id=\"INTERPOLATION_1\">\r\n            const id = elementNode.getAttribute('id');\r\n            if (!id) {\r\n                return; // should not happen\r\n            }\r\n            if (id.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromId(id);\r\n                message.addPlaceholder(index, null);\r\n            } else if (id.startsWith('ICU')) {\r\n                const index = this.parseICUMessageRefIndexFromId(id);\r\n                message.addICUMessageRef(index, null);\r\n            } else if (id.startsWith('START_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addStartTag(normalizedTagName, idcount);\r\n                }\r\n            } else if (id.startsWith('CLOSE_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    message.addEndTag(normalizedTagName);\r\n                }\r\n            } else if (tagMapping.isEmptyTagPlaceholderName(id)) {\r\n                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addEmptyTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return index\r\n     */\r\n    private parsePlaceholderIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageRefIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            let child: Node;\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    child = this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    child = this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    child = this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    child = this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    child = this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    child = this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n                    break;\r\n            }\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        const ctypeAttrib = 'x-' + part.tagName();\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '/>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an empty <x/>-Element with attribute id=\"INTERPOLATION\" or id=\"INTERPOLATION_n\"\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        const equivTextAttr = part.disp();\r\n        xElem.setAttribute('id', idAttrib);\r\n        if (equivTextAttr) {\r\n            xElem.setAttribute('equiv-text', equivTextAttr);\r\n        }\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        xElem.setAttribute('id', idAttrib);\r\n        return xElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XliffMessageParser} from './xliff-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XLIFF 1.2 file.\r\n */\r\n\r\nexport class XliffTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XliffMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            return targetElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            targetElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'new';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'new':\r\n                return STATE_NEW;\r\n            case 'needs-translation':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-translation':\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            case 'signed-off':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                const contextElements = elem.getElementsByTagName('context');\r\n                let sourcefile = null;\r\n                let linenumber = 0;\r\n                for (let j = 0; j < contextElements.length; j++) {\r\n                    const contextElem = contextElements.item(j);\r\n                    if (contextElem.getAttribute('context-type') === 'sourcefile') {\r\n                        sourcefile = DOMUtilities.getPCDATA(contextElem);\r\n                    }\r\n                    if (contextElem.getAttribute('context-type') === 'linenumber') {\r\n                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);\r\n                    }\r\n                }\r\n                sourceRefs.push({sourcefile: sourcefile, linenumber: linenumber});\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        sourceRefs.forEach((ref) => {\r\n            const contextGroup = this._element.ownerDocument.createElement('context-group');\r\n            contextGroup.setAttribute('purpose', 'location');\r\n            const contextSource = this._element.ownerDocument.createElement('context');\r\n            contextSource.setAttribute('context-type', 'sourcefile');\r\n            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));\r\n            const contextLine = this._element.ownerDocument.createElement('context');\r\n            contextLine.setAttribute('context-type', 'linenumber');\r\n            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));\r\n            contextGroup.appendChild(contextSource);\r\n            contextGroup.appendChild(contextLine);\r\n            this._element.appendChild(contextGroup);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (description) {\r\n           if (isNullOrUndefined(noteElem)) {\r\n               // create it\r\n               noteElem = this.createNoteElementWithFromAttribute('description', description);\r\n           } else {\r\n               DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n           }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithFromAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('from') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('from');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param fromAttrValue value of \"from\" attribute\r\n     * @param content text value of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithFromAttribute(fromAttrValue: string, content: string): Element {\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (fromAttrValue) {\r\n            noteElement.setAttribute('from', fromAttrValue);\r\n        }\r\n        noteElement.setAttribute('priority', '1');\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        this._element.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithFromAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithFromAttribute(attrValue);\r\n        if (noteElement) {\r\n            this._element.removeChild(noteElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            this._element.removeChild(noteElement);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param  meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('from'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n     }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new XliffTransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        if (isDefaultLang) {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n        } else {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n        }\r\n    }\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF12, FILETYPE_XLIFF12} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {XliffTransUnit} from './xliff-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.02.2017.\r\n * Ab xliff file read from a source file.\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class XliffFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xlf-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XliffFile\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): XliffFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '1.2';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 1.2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 1.2'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XliffTransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('source-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('source-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('target-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('target-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');\r\n        if (!bodyElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 1.2 file (should contain a body element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            bodyElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to body\r\n                bodyElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n         return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XMB\r\n */\r\nexport class XmbMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // There are 4 different usages of ph element:\r\n            // 1. placeholders are like <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>\r\n            // or <ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>\r\n            // 2. start tags:\r\n            // <ph name=\"START_LINK\"><ex>&lt;a&gt;</ex></ph>\r\n            // 3. empty tags:\r\n            // <ph name=\"TAG_IMG\"><ex>&lt;img&gt;</ex></ph>\r\n            // 4. ICU:\r\n            // <ph name=\"ICU\"><ex>ICU</ex></ph>\r\n            const name = elementNode.getAttribute('name');\r\n            if (!name) {\r\n                return true; // should not happen\r\n            }\r\n            if (name.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromName(name);\r\n                message.addPlaceholder(index, null);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('START_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                if (tag) {\r\n                    message.addStartTag(tag, idcounter);\r\n                }\r\n                return false; // ignore children\r\n            } else if (name.startsWith('CLOSE_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                if (tag) {\r\n                    message.addEndTag(tag);\r\n                }\r\n                return false; // ignore children\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(name)) {\r\n                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                message.addEmptyTag(emptyTagName, idcounter);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('ICU')) {\r\n                const index = this.parseICUMessageIndexFromName(name);\r\n                message.addICUMessageRef(index, null);\r\n                return false; // ignore children\r\n            }\r\n        } else if (tagName === 'source') {\r\n            // ignore source\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        let firstChild = null;\r\n        // find first child that is no source element.\r\n        let i;\r\n        for (i = 0; i < children.length; i++) {\r\n            const child = children.item(i);\r\n            if (child.nodeType !== child.ELEMENT_NODE || (<Element> child).tagName !== 'source') {\r\n                firstChild = child;\r\n                break;\r\n            }\r\n        }\r\n        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                const messageText = DOMUtilities.getXMLContent(<Element> node);\r\n                if (i > 0) {\r\n                    // drop <source> elements\r\n                    const reSource: RegExp = new RegExp('<source[^>]*>.*</source>', 'g');\r\n                    return messageText.replace(reSource, '');\r\n                } else {\r\n                    return messageText;\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parsePlaceholderIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as ICU message ref index.\r\n     * id can be \"ICU\" or \"ICU_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse the tag name from a ph element.\r\n     * It contained in the <ex> subelements value and enclosed in <>.\r\n     * Example: <ph name=\"START_BOLD_TEXT\"><ex>&lt;b&gt;</ex></ph>\r\n     * @param phElement phElement\r\n     */\r\n    private parseTagnameFromPhElement(phElement: Element): string {\r\n        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');\r\n        if (exElement) {\r\n            const value = DOMUtilities.getPCDATA(exElement);\r\n            if (!value || !value.startsWith('<') || !value.endsWith('>')) {\r\n                // oops\r\n                return null;\r\n            }\r\n            if (value.charAt(1) === '/') {\r\n                return value.substring(2, value.length - 1);\r\n            } else {\r\n                return value.substring(1, value.length - 1);\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            const child = this.createXmlRepresentationOfPart(part, rootElem);\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected createXmlRepresentationOfPart(part: ParsedMessagePart, rootElem: Element): Node {\r\n        switch (part.type) {\r\n            case ParsedMessagePartType.TEXT:\r\n                return this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n            case ParsedMessagePartType.START_TAG:\r\n                return this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n            case ParsedMessagePartType.END_TAG:\r\n                return this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n            case ParsedMessagePartType.EMPTY_TAG:\r\n                return this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n            case ParsedMessagePartType.PLACEHOLDER:\r\n                return this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n            case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                return this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n}\r\n","import {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XMB file.\r\n */\r\n\r\nexport class XmbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and linenumber\r\n     */\r\n    private static parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private static parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return source content\r\n     */\r\n    public sourceContent(): string {\r\n        let msgContent = DOMUtilities.getXMLContent(this._element);\r\n        const reSourceElem: RegExp = /<source>.*<\\/source>/g;\r\n        msgContent = msgContent.replace(reSourceElem, '');\r\n        return msgContent;\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // not supported\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, null);\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        // in fact, target and source are just the same in xmb\r\n        return this.sourceContent();\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     */\r\n    public nativeTargetState(): string {\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // not supported for xmb\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            const sourceAndPos: string = DOMUtilities.getPCDATA(elem);\r\n            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let insertPosition = this._element.childNodes.item(0);\r\n        for (let i = sourceRefs.length - 1; i >= 0; i--) {\r\n            const ref = sourceRefs[i];\r\n            const source = this._element.ownerDocument.createElement('source');\r\n            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            this._element.insertBefore(source, insertPosition);\r\n            insertPosition = source;\r\n        }\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            toBeRemoved.push(elem);\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xmb this is stored in the attribute \"desc\".\r\n     */\r\n    public description(): string {\r\n        return this._element.getAttribute('desc');\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xmb this is stored in the attribute \"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        return this._element.getAttribute('meaning');\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xmb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * In fact, xmb cannot be translated.\r\n     * So this throws an error.\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        throw new Error('You cannot translate xmb files, use xtb instead.');\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XMB, FILETYPE_XMB, FORMAT_XTB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {XmbTransUnit} from './xmb-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\n\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * xmb-File access.\r\n */\r\n\r\n/**\r\n * Doctype of xtb translation file corresponding with thos xmb file.\r\n */\r\nexport const XTB_DOCTYPE = `<!DOCTYPE translationbundle [\r\n  <!ELEMENT translationbundle (translation)*>\r\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n  <!ELEMENT translation (#PCDATA|ph)*>\r\n  <!ATTLIST translation id CDATA #REQUIRED>\r\n  <!ELEMENT ph EMPTY>\r\n  <!ATTLIST ph name CDATA #REQUIRED>\r\n]>`;\r\n\r\nexport class XmbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XmbFile\r\n     */\r\n    constructor(\r\n        private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n        xmlString: string, path: string, encoding: string) {\r\n\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): XmbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xmb file (should contain a messagebundle element)', path));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XmbTransUnit(msg, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XMB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XMB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XMB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['message'];\r\n    }\r\n\r\n    /**\r\n     * Guess language from filename.\r\n     * If filename is foo.xy.xmb, than language is assumed to be xy.\r\n     * @return Language or null\r\n     */\r\n    private guessLanguageFromFilename(): string {\r\n        if (this._filename) {\r\n            const parts: string[] = this._filename.split('.');\r\n            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {\r\n                return parts[parts.length - 2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        throw Error('xmb file cannot be used to store translations, use xtb file');\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationbundleXMLSource =\r\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + XTB_DOCTYPE + '\\n<translationbundle>\\n</translationbundle>\\n';\r\n        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n            FORMAT_XTB,\r\n            translationbundleXMLSource, filename, this.encoding(),\r\n            {xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding()});\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());\r\n        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());\r\n        this.forEachTransUnit((tu) => {\r\n            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nexport class Xliff2MessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            } else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            } else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            } else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        } else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    private tagNameFromPCElement(pcNode: Element): string {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        const stack = [{element: rootElem, tagName: 'root'}];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfPlaceholderPart(<ParsedMessagePartPlaceholder> part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfICUMessageRefPart(<ParsedMessagePartICUMessageRef> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(<ParsedMessagePartStartTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({element: <Element> newTagElem, tagName: (<ParsedMessagePartStartTag> part).tagName()});\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(<ParsedMessagePartEmptyTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        // not used\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n\r\n    private getTypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id: number): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {Xliff2MessageParser} from './xliff2-message-parser';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\n\r\nexport class Xliff2TransUnit extends AbstractTransUnit  implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new Xliff2MessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos: string = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    private parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithCategoryAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithCategoryAttribute(attrValue: string, content: string): Element {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    private removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithCategoryAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            } else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF20, FILETYPE_XLIFF20} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {Xliff2TransUnit} from './xliff2-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * An XLIFF 2.0 file read from a source file.\r\n * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\n *\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class Xliff2File extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an XLIFF 2.0-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return xliff file\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): Xliff2File {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '2.0';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 2.0'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('srcLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('srcLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('trgLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('trgLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (!fileElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 2.0 file (should contain a file element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            fileElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to first file element\r\n                fileElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {isNullOrUndefined} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\n\r\nexport class XtbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceTransUnitFromMaster: AbstractTransUnit;\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile,\r\n                _sourceTransUnitFromMaster: AbstractTransUnit) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    public sourceContent(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    public nativeTargetState(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            } else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public description(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public meaning(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XTB, FILETYPE_XTB, FORMAT_XMB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {XtbTransUnit} from './xtb-trans-unit';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * xtb-File access.\r\n * xtb is the translated counterpart to xmb.\r\n */\r\n\r\nexport class XtbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    // attached master file, if any\r\n    // used as source to determine state ...\r\n    private _masterFile: ITranslationMessagesFile; // an xmb-file\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * @return XmbFile\r\n     */\r\n    constructor(private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n                xmlString: string, path: string, encoding: string,\r\n                optionalMaster?: { xmlContent: string, path: string, encoding: string }) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string,\r\n                                  optionalMaster?: { xmlContent: string, path: string, encoding: string }): XtbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', path));\r\n        }\r\n        if (optionalMaster) {\r\n            try {\r\n                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n                    FORMAT_XMB,\r\n                    optionalMaster.xmlContent,\r\n                    optionalMaster.path,\r\n                    optionalMaster.encoding);\r\n                // check, wether this can be the master ...\r\n                const numberInMaster = this._masterFile.numberOfTransUnits();\r\n                const myNumber = this.numberOfTransUnits();\r\n                if (numberInMaster !== myNumber) {\r\n                    this._warnings.push(format(\r\n                        '%s trans units found in master, but this file has %s. Check if it is the correct master',\r\n                        numberInMaster, myNumber));\r\n                }\r\n            } catch (error) {\r\n                throw new Error(format('File \"%s\" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            let masterUnit: ITransUnit = null;\r\n            if (this._masterFile) {\r\n                masterUnit = this._masterFile.transUnitWithId(id);\r\n            }\r\n            this.transUnits.push(new XtbTransUnit(msg, id, this, <AbstractTransUnit> masterUnit));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XTB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XTB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XTB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['translation'];\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb/xtb.\r\n     * Try to guess it from master filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        if (this._masterFile) {\r\n            return this._masterFile.sourceLanguage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb/xtb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xtb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            return translationbundleElem.getAttribute('lang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            translationbundleElem.setAttribute('lang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newMasterTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (!translationbundleElem) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', this._filename));\r\n        }\r\n        const translationElement = translationbundleElem.ownerDocument.createElement('translation');\r\n        translationElement.setAttribute('id', foreignTransUnit.id);\r\n        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';\r\n        if (!(<AbstractTransUnit> foreignTransUnit).isICUMessage(newContent)) {\r\n            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);\r\n        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            translationbundleElem.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');\r\n            if (firstTranslationElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to bundle at end\r\n                translationbundleElem.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        throw new Error(format('File \"%s\", xtb files are not translatable, they are already translations', filename));\r\n    }\r\n}\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile} from './i-translation-messages-file';\r\nimport {XliffFile} from '../impl/xliff-file';\r\nimport {XmbFile} from '../impl/xmb-file';\r\nimport {format} from 'util';\r\nimport {Xliff2File} from '../impl/xliff2-file';\r\nimport {FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB} from './constants';\r\nimport {XtbFile} from '../impl/xtb-file';\r\nimport {ITranslationMessagesFileFactory} from './i-translation-messages-file-factory';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nexport class TranslationMessagesFileFactory implements ITranslationMessagesFileFactory {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromFileContent(i18nFormat: string,\r\n                                  xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromUnknownFormatFileContent(xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat: string,\r\n                              xmlContent: string,\r\n                              path: string,\r\n                              encoding: string,\r\n                              optionalMaster?: { xmlContent: string, path: string, encoding: string }): ITranslationMessagesFile {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent: string,\r\n                                           path: string,\r\n                                           encoding: string,\r\n                                           optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : ITranslationMessagesFile {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(\r\n                    formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            } catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n\r\n}\r\n\r\n"],"names":["format","TEXT"],"mappings":";;;;;;;;;AAAA;;;YAEC,QAAQ,SAAC;gBACR,OAAO,EAAE,EACR;gBACD,YAAY,EAAE,EAAE;gBAChB,OAAO,EAAE,EAAE;aACZ;;;;;;;;;;ACCD,MAAa,cAAc,GAAG,KAAK,CAAC;;AACpC,MAAa,cAAc,GAAG,MAAM,CAAC;;AACrC,MAAa,UAAU,GAAG,KAAK,CAAC;;AAChC,MAAa,UAAU,GAAG,KAAK,CAAC;;;;;AAMhC,MAAa,gBAAgB,GAAG,WAAW,CAAC;;AAC5C,MAAa,gBAAgB,GAAG,WAAW,CAAC;;AAC5C,MAAa,YAAY,GAAG,KAAK,CAAC;;AAClC,MAAa,YAAY,GAAG,KAAK,CAAC;;;;;AAWlC,MAAa,SAAS,GAAG,KAAK,CAAC;;;;;AAK/B,MAAa,gBAAgB,GAAG,YAAY,CAAC;;;;;AAK7C,MAAa,WAAW,GAAG,OAAO,CAAC;;;;AASnC,MAAa,4BAA4B,GAAG,SAAS,CAAC;;;;;AAMtD,MAAa,iCAAiC,GAAG,cAAc;;;;;;ACxD/D;;;;AAMA;;;;;;;IAQW,OAAO,wBAAwB,CAAC,OAA2B,EAAE,OAAe;;QAC/E,MAAM,gBAAgB,GAAG,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QAC/D,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE;YACjD,OAAO,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACnC;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;;;IAUE,OAAO,wBAAwB,CAAC,OAA2B,EAAE,OAAe,EAAE,EAAU;;QAC3F,MAAM,gBAAgB,GAAG,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QAC/D,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE;YACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;gBAC9C,MAAM,IAAI,GAAY,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC/C,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE;oBAChC,OAAO,IAAI,CAAC;iBACf;aACJ;SACJ;QACD,OAAO,IAAI,CAAC;;;;;;;IAOT,OAAO,0BAA0B,CAAC,OAAgB;QACrD,IAAI,CAAC,OAAO,EAAE;YACV,OAAO,IAAI,CAAC;SACf;;QACD,IAAI,CAAC,GAAG,OAAO,CAAC,WAAW,CAAC;QAC5B,OAAO,CAAC,EAAE;YACN,IAAI,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,YAAY,EAAE;gBAC/B,yBAAiB,CAAC,EAAC;aACtB;YACD,CAAC,GAAG,CAAC,CAAC,WAAW,CAAC;SACrB;QACD,OAAO,IAAI,CAAC;;;;;;;IAOT,OAAO,0BAA0B,CAAC,OAAgB;QACrD,IAAI,CAAC,OAAO,EAAE;YACV,OAAO,IAAI,CAAC;SACf;;QACD,IAAI,CAAC,GAAG,OAAO,CAAC,eAAe,CAAC;QAChC,OAAO,CAAC,EAAE;YACN,IAAI,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,YAAY,EAAE;gBAC/B,yBAAiB,CAAC,EAAC;aACtB;YACD,CAAC,GAAG,CAAC,CAAC,eAAe,CAAC;SACzB;QACD,OAAO,IAAI,CAAC;;;;;;;IAQT,OAAO,aAAa,CAAC,OAAgB;QACxC,IAAI,CAAC,OAAO,EAAE;YACV,OAAO,IAAI,CAAC;SACf;;QACD,IAAI,MAAM,GAAG,IAAI,aAAa,EAAE,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;;QAC5D,MAAM,OAAO,GAAG,OAAO,CAAC,QAAQ,CAAC;;QACjC,MAAM,UAAU,GAAW,IAAI,MAAM,CAAC,GAAG,GAAG,OAAO,GAAG,QAAQ,EAAE,GAAG,CAAC,CAAC;QACrE,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;;QACxC,MAAM,QAAQ,GAAW,IAAI,MAAM,CAAC,IAAI,GAAG,OAAO,GAAG,GAAG,EAAE,GAAG,CAAC,CAAC;QAC/D,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;QACtC,OAAO,MAAM,CAAC;;;;;;;IAQX,OAAO,SAAS,CAAC,OAAgB;QACpC,IAAI,CAAC,OAAO,EAAE;YACV,OAAO,IAAI,CAAC;SACf;;QACD,IAAI,MAAM,GAAG,EAAE,CAAC;;QAChB,MAAM,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YACxC,MAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACjC,IAAI,KAAK,CAAC,QAAQ,KAAK,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,QAAQ,KAAK,KAAK,CAAC,kBAAkB,EAAE;gBACnF,MAAM,GAAG,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC;aACrC;SACJ;QACD,OAAO,MAAM,CAAC,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,MAAM,CAAC;;;;;;;;IAQxC,OAAO,4BAA4B,CAAC,OAAgB,EAAE,MAAc;;QAEvE,OAAO,OAAO,CAAC,UAAU,EAAE;YACvB,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;SAC3C;;QAED,MAAM,cAAc,GAAa,IAAI,SAAS,EAAE,CAAC,eAAe,CAAC,YAAY,GAAG,MAAM,GAAG,aAAa,EAAE,iBAAiB,CAAC,CAAC;;QAC3H,MAAM,WAAW,GAAG,cAAc,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;QACvF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YACzC,MAAM,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACrC,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;SACzE;;;;;;;IAQE,OAAO,yBAAyB,CAAC,OAAa;;QACjD,IAAI,IAAI,GAAG,OAAO,CAAC,eAAe,CAAC;QACnC,OAAO,IAAI,KAAK,IAAI,EAAE;YAClB,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,YAAY,EAAE;gBACrC,yBAAiB,IAAI,EAAC;aACzB;YACD,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC;SAC/B;QACD,OAAO,IAAI,CAAC;;;;;;;;IAST,OAAO,sBAAsB,CAAC,mBAA2B,EAAE,eAAqB;;QACnF,MAAM,UAAU,GAAG,eAAe,CAAC,aAAa,CAAC,aAAa,CAAC,mBAAmB,CAAC,CAAC;QACpF,yBAAiB,YAAY,CAAC,WAAW,CAAC,UAAU,EAAE,eAAe,CAAC,EAAC;;;;;;;;IAQpE,OAAO,WAAW,CAAC,UAAgB,EAAE,eAAqB;QAC7D,IAAI,eAAe,CAAC,WAAW,KAAK,IAAI,EAAE;YACtC,eAAe,CAAC,UAAU,CAAC,YAAY,CAAC,UAAU,EAAE,eAAe,CAAC,WAAW,CAAC,CAAC;SACpF;aAAM;YACH,eAAe,CAAC,UAAU,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;SACtD;QACD,OAAO,UAAU,CAAC;;;;;;;;IAQf,OAAO,YAAY,CAAC,UAAgB,EAAE,WAAiB;QAC1D,WAAW,CAAC,UAAU,CAAC,YAAY,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;QAC7D,OAAO,UAAU,CAAC;;CAEzB;;;;;;;;;;;;ACvJD,MAAM,qBAAqB,GAAG,IAAI,CAAC;AAEnC;IAEI;KAEC;;;;;;;IAOD,iBAAiB,CAAC,QAAkB,EAAE,OAA8B;;QAChE,MAAM,GAAG,GAAG,EAAE,CAAC;;QACf,IAAI,iBAAiB,GAAgB,EAAE,CAAC;;QACxC,MAAM,OAAO,GAAG,QAAQ,CAAC,eAAe,CAAC;;QACzC,IAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;;QAC5B,MAAM,GAAG,GAAG,OAAO,CAAC,YAAY,CAAC;QAEjC,IAAI,GAAG,IAAI,MAAM,IAAI,IAAI,EAAE;YACvB,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;YACnC,IAAI,MAAM,IAAI,IAAI,EAAE;gBAChB,iBAAiB,GAAG;oBAChB,EAAC,SAAS,EAAE,GAAG,EAAE,MAAM,EAAE,IAAI,EAAC;iBAEjC,CAAC;aACL;SACJ;QACD,IAAI,CAAC,OAAO,EAAE;YACV,OAAO,GAAG,EAAE,CAAC;SAChB;QACD,IAAI,OAAO,CAAC,YAAY,EAAE;YACtB,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;gBACpD,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;aACzE;SACJ;QACD,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,EAAE,KAAK,EAAE,iBAAiB,CAAC,CAAC;QAC9E,OAAO,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACvB;;;;;;;;;;;;IAYO,mBAAmB,CAAC,IAAU,EAAE,OAA6B,EAAE,GAAa,EACxD,WAAmB,EAAE,kBAA2B,EAAE,iBAA8B;;QACxG,IAAI,KAAK,CAAO;QAChB,QAAQ,IAAI,CAAC,QAAQ;YACjB,KAAK,IAAI,CAAC,YAAY;;gBAClB,MAAM,WAAW,qBAAsB,IAAI,EAAC;;gBAC5C,MAAM,KAAK,GAAG,WAAW,CAAC,UAAU,CAAC;;gBACrC,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;gBACzB,KAAK,GAAG,WAAW,CAAC,UAAU,CAAC;;gBAC/B,MAAM,QAAQ,GAAG,WAAW,CAAC,OAAO,CAAC;;gBACrC,MAAM,sBAAsB,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;gBAC7E,IAAI,kBAAkB,EAAE;oBACpB,GAAG,CAAC,IAAI,CAAC,GAAG,EAAG,QAAQ,CAAC,CAAC;iBAC5B;qBAAM;oBACH,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,GAAG,EAAE,WAAW,EAAE,GAAG,EAAG,QAAQ,CAAC,CAAC;iBAClE;gBAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;;oBAE1B,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC3B,IAAI,IAAI,CAAC,MAAM,KAAK,OAAO,EAAE;wBACzB,iBAAiB,CAAC,IAAI,CAAC,EAAC,MAAM,EAAE,IAAI,CAAC,SAAS,EAAE,SAAS,EAAE,IAAI,CAAC,KAAK,EAAC,CAAC,CAAC;qBAC3E;yBAAM,IAAI,IAAI,CAAC,QAAQ,KAAK,OAAO,EAAE;wBAClC,iBAAiB,CAAC,IAAI,CAAC,EAAC,MAAM,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,KAAK,EAAC,CAAC,CAAC;qBAC/D;iBACJ;gBACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;;oBAC1B,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC3B,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,iBAAiB,CAAC,EAAE;;wBACnD,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,IAAI,EAAE,CAAC;;wBACjC,MAAM,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC;;wBAC9B,MAAM,EAAE,GAAG,MAAM,GAAG,SAAS,GAAG,MAAM,GAAG,QAAQ,CAAC;wBAClD,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;wBAC7B,iBAAiB,CAAC,IAAI,CAAC,EAAC,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG,EAAC,CAAC,CAAC;qBAC5D;oBACD,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,OAAO,EAAE,GAAG,EAAE,WAAW,EAAE,KAAK,EAAE,iBAAiB,CAAC,CAAC;iBACvF;;gBAED,IAAI,IAAI,CAAC,mBAAmB,CAAC,WAAW,EAAE,iBAAiB,CAAC,EAAE;;oBAC1D,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,IAAI,EAAE,CAAC;;oBACxC,MAAM,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC;;oBAC9B,MAAM,EAAE,GAAG,MAAM,GAAG,SAAS,GAAG,MAAM,GAAG,QAAQ,CAAC;oBAClD,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;oBAC7B,iBAAiB,CAAC,IAAI,CAAC,EAAC,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG,EAAC,CAAC,CAAC;iBAC5D;gBAED,IAAI,KAAK,EAAE;oBACP,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;;oBAEd,IAAI,iBAAiB,GAAG,KAAK,CAAC;oBAC9B,OAAO,KAAK,EAAE;wBACV,IAAI,KAAK,CAAC,QAAQ,KAAK,KAAK,CAAC,YAAY,EAAE;4BACvC,iBAAiB,GAAG,IAAI,CAAC;yBAC5B;wBACD,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,OAAO,EAAE,GAAG,EAAE,WAAW,GAAG,CAAC,EACzD,kBAAkB,IAAI,sBAAsB,EAAE,iBAAiB,CAAC,CAAC;wBACrE,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC;qBAC7B;oBACD,IAAI,CAAC,kBAAkB,IAAI,CAAC,sBAAsB,IAAI,iBAAiB,EAAE;wBACrE,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,CAAC,CAAC;qBACvE;yBAAM;wBACH,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,GAAG,CAAC,CAAC;qBACjC;iBACJ;qBAAM;oBACH,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAClB;gBACD,OAAO;YACX,KAAK,IAAI,CAAC,aAAa,CAAC;YACxB,KAAK,IAAI,CAAC,sBAAsB;gBAC5B,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;gBACxB,OAAO,KAAK,EAAE;oBACV,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,OAAO,EAAE,GAAG,EAAE,WAAW,EAAE,KAAK,EAAE,iBAAiB,CAAC,CAAC;oBACrF,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC;iBAC7B;gBACD,OAAO;YACX,KAAK,IAAI,CAAC,cAAc;;gBACpB,MAAM,QAAQ,qBAAU,IAAI,EAAC;gBAC7B,OAAO,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,EAAE,GAAG,CAAC,CAAC;YACvG,KAAK,IAAI,CAAC,SAAS;;gBACf,MAAM,QAAQ,qBAAU,IAAI,EAAC;gBAC7B,IAAI,CAAC,OAAO,CAAC,QAAQ,IAAI,kBAAkB,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;oBACxF,OAAO,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;iBACrE;gBACD,OAAO;YACX,KAAK,IAAI,CAAC,kBAAkB;;gBACxB,MAAM,gBAAgB,qBAAkB,IAAI,EAAC;gBAC7C,OAAO,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC/D,KAAK,IAAI,CAAC,YAAY;;gBAClB,MAAM,WAAW,qBAAa,IAAI,EAAC;gBACnC,OAAO,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YACrD,KAAK,IAAI,CAAC,kBAAkB;;gBACxB,MAAM,gBAAgB,qBAAkB,IAAI,EAAC;;gBAC7C,MAAM,KAAK,GAAG,gBAAgB,CAAC,QAAQ,CAAC;;gBACxC,MAAM,KAAK,GAAG,gBAAgB,CAAC,QAAQ,CAAC;gBACxC,GAAG,CAAC,IAAI,CAAC,YAAY,EAAE,gBAAgB,CAAC,IAAI,CAAC,CAAC;gBAC9C,IAAI,KAAK,EAAE;oBACP,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;oBAC7B,IAAI,KAAK,IAAI,KAAK,KAAK,GAAG,EAAE;wBACxB,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;qBAC1B;oBACD,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAClB;qBAAM,IAAI,KAAK,IAAI,KAAK,KAAK,GAAG,EAAE;oBAC/B,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;iBACtC;qBAAM;;oBACH,MAAM,GAAG,GAAG,gBAAgB,CAAC,cAAc,CAAC;oBAC5C,IAAI,GAAG,EAAE;wBACL,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;qBAC5B;oBACD,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBACjB;gBACD,OAAO;YACX,KAAK,IAAI,CAAC,2BAA2B;;gBACjC,MAAM,MAAM,qBAA2B,IAAI,EAAC;gBAC5C,OAAO,GAAG,CAAC,IAAI,CAAE,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YAClE,KAAK,IAAI,CAAC,qBAAqB;gBAC3B,OAAO,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;;;YAG7C;gBACI,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;SACrC;;;;;;;IAGG,mBAAmB,CAAC,IAAoB,EAAE,iBAA8B;;QAC5E,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,IAAI,EAAE,CAAC;;QACjC,MAAM,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC;QAC9B,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE;YACjB,OAAO,KAAK,CAAC;SAChB;QACD,IAAI,MAAM,KAAK,KAAK,IAAI,GAAG,KAAK,sCAAsC;eAC/D,GAAG,KAAK,+BAA+B,EAAE;YAC5C,OAAO,KAAK,CAAC;SAChB;;QAED,IAAI,CAAC,GAAG,iBAAiB,CAAC,MAAM,CAAC;QACjC,OAAO,CAAC,EAAE,EAAE;;YACR,MAAM,EAAE,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;;YAEhC,IAAI,EAAE,CAAC,MAAM,KAAK,MAAM,EAAE;gBACtB,OAAO,EAAE,CAAC,SAAS,KAAK,GAAG,CAAC;aAC/B;SACJ;QACD,OAAO,IAAI,CAAC;;;;;;IAGR,WAAW,CAAC,CAAS;QACzB,OAAO,CAAC,KAAK,GAAG,IAAI,MAAM;YACtB,CAAC,KAAK,GAAG,IAAI,MAAM;YACnB,CAAC,KAAK,GAAG,IAAI,OAAO;YACpB,CAAC,KAAK,GAAG,IAAI,QAAQ;YACrB,IAAI,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;;;;;;;;;IAG7B,cAAc,CAAC,OAA6B,EAAE,GAAa,EAAE,WAAmB,EAAE,GAAG,WAAqB;QAC9G,IAAI,OAAO,CAAC,QAAQ,EAAE;YAClB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACf,IAAI,WAAW,GAAG,CAAC,EAAE;gBACjB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC;aAC1D;SACJ;QACD,GAAG,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,CAAC;;;;;;;IAGrB,iBAAiB,CAAC,OAA6B,EAAE,WAAmB;;QACxE,MAAM,MAAM,GAAG,CAAC,OAAO,CAAC,YAAY,IAAI,OAAO,CAAC,YAAY,GAAG,qBAAqB,CAAC;;QACrF,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;YAClC,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC;SAC5B;QACD,OAAO,MAAM,CAAC;;;;;;;;IAQV,qBAAqB,CAAC,OAAe,EAAE,OAA6B;QACxE,IAAI,OAAO,IAAI,OAAO,CAAC,oBAAoB,EAAE;YACzC,OAAO,CAAC,CAAC,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK,OAAO,CAAC,CAAC;SACxE;aAAM;YACH,OAAO,KAAK,CAAC;SAChB;;;;;;IAGG,sBAAsB,CAAC,IAAY;QACvC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAClC,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YACzB,IAAI,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE;gBACxD,OAAO,KAAK,CAAC;aAChB;SACJ;QACD,OAAO,IAAI,CAAC;;CAEnB;;;;;;ACxRD;;;;;AAYA;IAyBI;QACI,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;KACvB;;;;;;;;;;IAUS,YAAY,CAClB,SAAiB,EACjB,IAAY,EAAE,QAAgB,EAC9B,cAAuE;QAEvE,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,eAAe,GAAG,IAAI,SAAS,EAAE,CAAC,eAAe,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;QAC9E,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;KACpD;;;;IAoBS,wBAAwB;QAC9B,IAAI,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACpC,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAC5B,IAAI,CAAC,YAAY,EAAE,CAAC;SACvB;KACJ;;;;;IAKM,YAAY;QACf,IAAI,CAAC,gCAAgC,GAAG,CAAC,CAAC;QAC1C,IAAI,CAAC,+BAA+B,GAAG,CAAC,CAAC;QACzC,IAAI,CAAC,2BAA2B,GAAG,CAAC,CAAC;QACrC,IAAI,CAAC,gBAAgB,CAAC,CAAC,EAAc;YACjC,IAAI,iBAAiB,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE;gBAC1C,IAAI,CAAC,gCAAgC,EAAE,CAAC;aAC3C;;YACD,MAAM,KAAK,GAAG,EAAE,CAAC,WAAW,EAAE,CAAC;YAC/B,IAAI,iBAAiB,CAAC,KAAK,CAAC,IAAI,KAAK,KAAK,SAAS,EAAE;gBACjD,IAAI,CAAC,+BAA+B,EAAE,CAAC;aAC1C;YACD,IAAI,KAAK,KAAK,gBAAgB,EAAE;gBAC5B,IAAI,CAAC,2BAA2B,EAAE,CAAC;aACtC;SACJ,CAAC,CAAC;;;;;IAGA,QAAQ;QACX,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,OAAO,IAAI,CAAC,SAAS,CAAC;;;;;;IAMnB,kBAAkB;QACrB,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;;;;;;;IAOlC,8BAA8B;QAC1B,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,OAAO,IAAI,CAAC,+BAA+B,CAAC;KAC/C;;;;;IAKD,0BAA0B;QACtB,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,OAAO,IAAI,CAAC,2BAA2B,CAAC;KAC3C;;;;;;IAMM,+BAA+B;QAClC,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,OAAO,IAAI,CAAC,gCAAgC,CAAC;;;;;;;IAmB1C,gBAAgB,CAAC,QAA2C;QAC/D,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;;;;;;;IAQ3C,eAAe,CAAC,EAAU;QAC7B,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;;;;;;;;;IAyB/C,4BAA4B,CAAC,aAAqB;QACrD,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;;;;;;;IAQvC,4BAA4B;QACxB,OAAO,iBAAiB,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC;KAC1E;;;;;;;;IAQM,2BAA2B,CAAC,YAAoB;QACnD,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;;;;;;;IAQrC,2BAA2B;QACvB,OAAO,iBAAiB,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC;KACxE;;;;;;IA+BM,qBAAqB,CAAC,EAAU;;QACnC,MAAM,MAAM,GAAS,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;QAC7D,IAAI,MAAM,EAAE;YACR,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YACtC,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAChC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;YAC/D,IAAI,CAAC,YAAY,EAAE,CAAC;SACvB;;;;;;IAME,QAAQ;QACX,OAAO,IAAI,CAAC,SAAS,CAAC;;;;;;IAMnB,QAAQ;QACX,OAAO,IAAI,CAAC,SAAS,CAAC;;;;;;;;;;IAUnB,aAAa,CAAC,cAAwB;;QACzC,MAAM,OAAO,GAAyB,EAAE,CAAC;QACzC,IAAI,cAAc,KAAK,IAAI,EAAE;YAC1B,OAAO,CAAC,QAAQ,GAAG,IAAI,CAAC;YACxB,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC;YAC5B,OAAO,CAAC,oBAAoB,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;SACjE;;QACD,MAAM,MAAM,GAAG,IAAI,aAAa,EAAE,CAAC,iBAAiB,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;QACpF,IAAI,IAAI,CAAC,gBAAgB,EAAE;;YAEvB,OAAO,MAAM,GAAG,IAAI,CAAC;SACxB;aAAM;YACH,OAAO,MAAM,CAAC;SACjB;;CAmBR;;;;;;ACnUD;;;;;AAUA;;;;;;IAII,YAAgC,QAAiB,EACjB,GAAW,EACX,wBAAkD;QAFlD,aAAQ,GAAR,QAAQ,CAAS;QACjB,QAAG,GAAH,GAAG,CAAQ;QACX,6BAAwB,GAAxB,wBAAwB,CAA0B;KACjF;;;;QAEU,EAAE;QACT,OAAO,IAAI,CAAC,GAAG,CAAC;;;;;;IAMpB,uBAAuB;QACnB,OAAO,IAAI,CAAC,wBAAwB,CAAC;KACxC;;;;;;;IAaD,wBAAwB;QACpB,OAAO,IAAI,CAAC;KACf;;;;;IAaM,uBAAuB;QAC1B,IAAI,iBAAiB,CAAC,IAAI,CAAC,wBAAwB,CAAC,EAAE;YAClD,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,6BAA6B,EAAE,CAAC;SACxE;QACD,OAAO,IAAI,CAAC,wBAAwB,CAAC;;;;;;;;IA+BlC,WAAW;;QACd,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC7C,OAAO,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC;;;;;;;;;IA+BnD,cAAc,CAAC,QAAgB;QAC3B,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC,CAAC;QAChE,IAAI,IAAI,CAAC,uBAAuB,EAAE,YAAY,+BAA+B,EAAE;YAC3E,mBAAmC,IAAI,CAAC,uBAAuB,EAAE,GAAE,YAAY,EAAE,CAAC;SACrF;KACJ;;;;;;;IAiBM,2BAA2B;QAC9B,OAAO,IAAI,CAAC;;;;;;;;IA6BT,gCAAgC;QACnC,OAAO,IAAI,CAAC;;;;;;;;IAyCN,UAAU,CAAC,QAAiB;;QAElC,MAAM,eAAe,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,KAAK,aAAa,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC;QACxG,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,EAAE;YACrC,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;SAChF;KACJ;;;;;;IAOM,YAAY;QACf,OAAO,IAAI,CAAC,QAAQ,CAAC;;;;;;;;;;IAwBlB,SAAS,CAAC,WAAwC;;QACrD,IAAI,iBAAiB,CAAS;QAC9B,IAAI,QAAQ,CAAC,WAAW,CAAC,EAAE;YACvB,iBAAiB,qBAAY,WAAW,CAAA,CAAC;SAC5C;aAAM;YACH,iBAAiB,GAAG,mBAAsB,WAAW,GAAE,cAAc,EAAE,CAAC;SAC3E;QACD,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,CAAC;QACxC,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;;;;;;;IAanC,YAAY,CAAC,OAAe;QAC/B,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;;CAQ9D;;;;;;;;;;;;;ICvRG,OAAI;IACJ,cAAW;IACX,YAAS;IACT,UAAO;IACP,YAAS;IACT,cAAW;IACX,kBAAe;;4CANf,IAAI;4CACJ,WAAW;4CACX,SAAS;4CACT,OAAO;4CACP,SAAS;4CACT,WAAW;4CACX,eAAe;;;;AAGnB;;;;IAEI,YAAmB,IAA2B;QAA3B,SAAI,GAAJ,IAAI,CAAuB;KAE7C;CASJ;;;;;;AC7BD;;;;AAMA,2BAAmC,SAAQ,iBAAiB;;;;IAIxD,YAAY,IAAY;QACpB,KAAK,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;QAClC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;KACpB;;;;;IAEM,eAAe,CAACA,SAAe;QAClC,OAAO,IAAI,CAAC,IAAI,CAAC;;CAExB;;;;;;AClBD;;;;;AAQA,kCAA0C,SAAQ,iBAAiB;;;;;IAO/D,YAAY,KAAa,EAAE,IAAY;QACnC,KAAK,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC;QACzC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;KACrB;;;;;IAEM,eAAe,CAACA,SAAe;QAClC,IAAIA,SAAM,KAAK,iCAAiC,EAAE;YAC9C,OAAO,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;SACpC;QACD,OAAO,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;;;;;IAE9B,KAAK;QACR,OAAO,IAAI,CAAC,MAAM,CAAC;;;;;IAGhB,IAAI;QACP,OAAO,IAAI,CAAC,KAAK,CAAC;;CAEzB;;;;;;AClCD;;;;AAMA,+BAAuC,SAAQ,iBAAiB;;;;;IAK5D,YAAY,OAAe,EAAE,SAAiB;QAC1C,KAAK,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC;QACvC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;KAC/B;;;;;IAEM,eAAe,CAACA,SAAe;QAClC,IAAI,IAAI,CAAC,UAAU,KAAK,CAAC,EAAE;YACvB,OAAO,GAAG,GAAG,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC;SACpC;aAAM;YACH,OAAO,GAAG,GAAG,IAAI,CAAC,QAAQ,GAAG,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC;SAC5E;;;;;IAGE,OAAO;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC;;;;;IAGlB,SAAS;QACZ,OAAO,IAAI,CAAC,UAAU,CAAC;;CAE9B;;;;;;AChCD;;;;AAMA,6BAAqC,SAAQ,iBAAiB;;;;IAI1D,YAAY,OAAe;QACvB,KAAK,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;KAC3B;;;;;IAEM,eAAe,CAACA,SAAe;QAClC,OAAO,IAAI,GAAG,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC;;;;;IAG/B,OAAO;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC;;CAG5B;;;;;;ACvBD;;;;AAQA,MAAa,IAAI,GAAG,MAAM,CAAC;;AAC3B,MAAa,gBAAgB,GAAG,kBAAkB,CAAC;;AACnD,MAAa,iBAAiB,GAAG,mBAAmB,CAAC;;AACrD,MAAa,KAAK,GAAG,OAAO,CAAC;;AAC7B,MAAa,MAAM,GAAG,QAAQ,CAAC;;AAC/B,MAAa,MAAM,GAAG,QAAQ,CAAC;;AAQ/B,MAAM,aAAa,GAAG,SAAS,CAAC;;AAChC,MAAM,YAAY,GAAG,QAAQ,CAAC;;AAC9B,MAAM,gBAAgB,GAAG,YAAY,CAAC;AAEtC;;;;IAGY,QAAQ;;QACZ,MAAM,KAAK,GAAG,IAAI,QAAQ,EAAE,CAAC;;QAC7B,IAAI,SAAS,GAAG,EAAE,CAAC;;QACnB,IAAI,8BAA8B,GAAG,CAAC,CAAC;QACvC,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI;YAC1B,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;gBACpB,IAAI,IAAI,CAAC,qBAAqB,CAAC,SAAS,CAAC,EAAE;oBACvC,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBAC5B,SAAS,GAAG,EAAE,CAAC;iBAClB;qBAAM;oBACH,GAAG,CAAC,MAAM,EAAE,CAAC;iBAChB;aACJ;SACJ,CAAC,CAAC;QACH,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG;YACb,IAAI,IAAI,CAAC,qBAAqB,CAAC,SAAS,CAAC,EAAE;gBACvC,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;aAC/B;SACH,CAAC,CAAC;;QAEJ,KAAK,CAAC,IAAI,CAAC,aAAa,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK;YACtC,GAAG,CAAC,MAAM,CAAC,gBAAgB,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACvC,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;SAC1B,EAAE,gBAAgB,CAAC,CAAC;QACrB,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK;YACrC,GAAG,CAAC,MAAM,CAAC,gBAAgB,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACvC,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;SAC9B,EAAE,gBAAgB,CAAC,CAAC;QACrB,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK;YACrC,GAAG,CAAC,GAAG,EAAE,CAAC;YACV,GAAG,CAAC,MAAM,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SAC3C,EAAE,iBAAiB,CAAC,CAAC;;QAEtB,KAAK,CAAC,IAAI,CAAC,gBAAgB,EAAE,SAAS,EAAE,CAAC,GAAG,EAAE,KAAK;YAC/C,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;gBACrB,SAAS,IAAI,IAAI,CAAC;aACrB;iBAAM,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;gBAC7B,SAAS,IAAI,GAAG,CAAC;aACpB;iBAAM,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;gBAC7B,SAAS,IAAI,GAAG,CAAC;aACpB;YACD,GAAG,CAAC,MAAM,EAAE,CAAC;SAChB,EAAE,IAAI,CAAC,CAAC;QACT,KAAK,CAAC,IAAI,CAAC,gBAAgB,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK;;YACzC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,IAAI,KAAK,GAAG,EAAE;gBACd,8BAA8B,EAAE,CAAC;gBACjC,SAAS,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,GAAG,CAAC,MAAM,EAAE,CAAC;aAChB;iBAAM,IAAI,IAAI,KAAK,GAAG,EAAE;gBACrB,IAAI,8BAA8B,GAAG,CAAC,EAAE;oBACpC,8BAA8B,EAAE,CAAC;oBACjC,SAAS,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;oBACtB,GAAG,CAAC,MAAM,EAAE,CAAC;iBAChB;qBAAM;oBACH,GAAG,CAAC,GAAG,EAAE,CAAC;oBACV,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBAC5B,SAAS,GAAG,EAAE,CAAC;oBACf,GAAG,CAAC,MAAM,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC3C;aACJ;iBAAM;gBACH,SAAS,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,GAAG,CAAC,MAAM,EAAE,CAAC;aAChB;SACJ,EAAE,IAAI,CAAC,CAAC;;QAET,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK;YACrC,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SAC/B,EAAE,KAAK,CAAC,CAAC;;QAEV,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,QAAQ,EAAE,CAAC,GAAG,EAAE,KAAK;YAC1C,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SAChC,EAAE,MAAM,CAAC,CAAC;QACX,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,QAAQ,EAAE,CAAC,GAAG,EAAE,KAAK;YAC1C,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SAChC,EAAE,MAAM,CAAC,CAAC;;QAEX,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK;YACvB,SAAS,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,GAAG,CAAC,MAAM,EAAE,CAAC;SAChB,EAAE,IAAI,CAAC,CAAC;QACT,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,KAAK;YAC3B,SAAS,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,GAAG,CAAC,MAAM,EAAE,CAAC;SAChB,EAAE,IAAI,CAAC,CAAC;QACT,OAAO,KAAK,CAAC;;;;;;IAGT,qBAAqB,CAAC,IAAY;QACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;gBAC5B,OAAO,IAAI,CAAC;aACf;SACJ;QACD,OAAO,KAAK,CAAC;;;;;;IAGjB,QAAQ,CAAC,iBAAyB;;QAC9B,MAAM,KAAK,GAAa,IAAI,CAAC,QAAQ,EAAE,CAAC;QACxC,KAAK,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAC/B,OAAO,KAAK,CAAC,MAAM,EAAE,CAAC;KACzB;;;;;IAED,KAAK,CAAC,iBAAyB;QAC3B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC7B,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;KACvC;;;;IAED,IAAI;QACA,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;KAC7B;;;;IAED,IAAI;QACA,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;KAC5B;CACJ;;;;;;AC9ID,AAGA;;;;;IAEI,YAAoB,SAAiB,EAAU,QAA4B;QAAvD,cAAS,GAAT,SAAS,CAAQ;QAAU,aAAQ,GAAR,QAAQ,CAAoB;KAAI;;;;IAExE,WAAW;QACd,OAAO,IAAI,CAAC,SAAS,CAAC;;;;;IAGnB,oBAAoB;QACvB,OAAO,IAAI,CAAC,QAAQ,CAAC;;CAE5B;;;;;AAMD;;;;;IAMI,YAAoB,OAAuB,EAAE,eAAwB;QAAjD,YAAO,GAAP,OAAO,CAAgB;QACvC,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;QACxC,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;KACzB;;;;;;IAED,WAAW,CAAC,QAAgB,EAAE,OAA2B;QACrD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC;KACjE;;;;;;IAOM,cAAc;;QACjB,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,YAAY,GAAG,YAAY,CAAC;;QACvE,MAAM,IAAI,GAAG,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,QAAQ,GAAG,QAAQ,CAAC;;QAC5D,IAAI,YAAY,GAAG,EAAE,CAAC;QACtB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,QAA6B;YACnD,YAAY,GAAG,YAAY,GAAG,MAAM,CAAC,UAAU,EAAE,QAAQ,CAAC,WAAW,EAAE,EAAE,QAAQ,CAAC,oBAAoB,EAAE,CAAC,cAAc,EAAE,CAAC,CAAC;SAC9H,CAAC,CAAC;QACH,OAAO,MAAM,CAAC,aAAa,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,CAAC,CAAC;;;;;;IAM9D,eAAe;QACX,OAAO,IAAI,CAAC,gBAAgB,CAAC;KAChC;;;;;IAKD,eAAe;QACX,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC;KACjC;;;;;;;IAOD,aAAa;QACT,OAAO,IAAI,CAAC,WAAW,CAAC;KAC3B;;;;;;;;IASD,SAAS,CAAC,WAAmC;;QACzC,MAAM,OAAO,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC;;QACrE,MAAM,oBAAoB,GAAgB,IAAI,GAAG,EAAU,CAAC;QAC5D,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,QAAQ;;YAC9B,IAAI,iBAAiB,CAAqB;;YAC1C,MAAM,sBAAsB,GAAkC,WAAW,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC,CAAC;YAClG,IAAI,iBAAiB,CAAC,sBAAsB,CAAC,EAAE;gBAC3C,iBAAiB,GAAG,QAAQ,CAAC,oBAAoB,EAAE,CAAC;aACvD;iBAAM,IAAI,QAAQ,CAAC,sBAAsB,CAAC,EAAE;gBACzC,oBAAoB,CAAC,GAAG,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC,CAAC;gBACjD,iBAAiB,GAAG,IAAI,CAAC,OAAO,CAAC,qBAAqB,mBAAU,sBAAsB,GAAE,IAAI,CAAC,CAAC;aACjG;iBAAM;;gBAEH,iBAAiB,GAAG,IAAI,CAAC;aAC5B;YACD,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,iBAAiB,CAAC,CAAC;SAClE,CAAC,CAAC;;QAEH,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,CAAC,YAAY;YAC1C,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;gBACzC,IAAI,IAAI,CAAC,eAAe,EAAE,EAAE;oBACxB,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,qFAAqF,EACxG,YAAY,CAAC,CAAC,CAAC;iBACtB;qBAAM;oBACH,IAAI,CAAC,wBAAwB,CAAC,YAAY,CAAC,CAAC;;oBAE5C,IAAI,iBAAiB,GAAG,IAAI,CAAC,OAAO,CAAC,qBAAqB,mBAAU,WAAW,CAAC,YAAY,CAAC,GAAE,IAAI,CAAC,CAAC;oBACrG,OAAO,CAAC,WAAW,CAAC,YAAY,EAAE,iBAAiB,CAAC,CAAC;iBACxD;aACJ;SACJ,CAAC,CAAC;QACH,OAAO,OAAO,CAAC;KAClB;;;;;;;;IAQO,wBAAwB,CAAC,YAAoB;;QACjD,MAAM,eAAe,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;QACvE,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;YAC5B,OAAO;SACV;QACD,IAAI,eAAe,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK,YAAY,CAAC,EAAE;YACrD,OAAO;SACV;QACD,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,uDAAuD,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC,CAAC;;CAEvH;;;;;;ACnID;;;;;;AAiBA,iCAAyC,SAAQ,iBAAiB;;;;;IAM9D,YAAY,cAAsB,EAAU,OAAuB;QAC/D,KAAK,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC;QADD,YAAO,GAAP,OAAO,CAAgB;QAE/D,IAAI,cAAc,EAAE;YAChB,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC;SACxC;KACJ;;;;;;;IAQD,OAAO,mBAAmB,CAAC,cAAsB;;QAC7C,MAAM,IAAI,GAAG,IAAI,2BAA2B,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACzD,OAAO,IAAI,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC;KACnD;;;;;IAEM,eAAe,CAAC,aAAsB;QACzC,OAAO,gBAAgB,CAAC;;;;;;IAOrB,aAAa;QAChB,OAAO,IAAI,CAAC,QAAQ,CAAC;;;;;;;;IAQjB,eAAe,CAAC,IAAY;;;;;;QAMhC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,IAAI,CAAC,UAAU,GAAG,IAAI,mBAAmB,EAAE,CAAC;QAC5C,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC5B,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC;QAClC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;;QACvB,IAAI,KAAK,GAAa,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;QAC7C,IAAI,KAAK,CAAC,IAAI,KAAK,MAAM,EAAE;YACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;SACtD;aAAM,IAAI,KAAK,CAAC,IAAI,KAAK,MAAM,EAAE;YAC9B,IAAI,CAAC,QAAQ,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SACvD;QACD,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QACvB,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;QAC/B,OAAO,KAAK,CAAC,IAAI,KAAK,iBAAiB,EAAE;;YACrC,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;YACpD,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC;;YAClC,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC;YAC5C,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,QAAQ,EAAE,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC,CAAC;YACzE,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC;YACnC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;SAClC;QACD,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC;QACnC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;;;;;;;;IAQnB,mBAAmB,CAAC,IAAY;;;;;;QAMpC,IAAI,CAAC,UAAU,GAAG,IAAI,mBAAmB,EAAE,CAAC;QAC5C,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC5B,IAAI;YACA,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC;YAClC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YACtB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;;YACvB,MAAM,KAAK,GAAa,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;YAC/C,IAAI,KAAK,CAAC,IAAI,KAAK,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,MAAM,EAAE;gBAChD,OAAO,KAAK,CAAC;aAChB;YACD,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACvB,OAAO,IAAI,CAAC;SACf;QAAC,OAAO,KAAK,EAAE;YACZ,OAAO,KAAK,CAAC;SAChB;;;;;;;;IASG,UAAU,CAAC,SAAiB;;QAChC,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;QACrC,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;YAC1B,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,oEAAoE,EACvF,SAAS,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;SAC/D;QACD,OAAO,KAAK,CAAC;;;;;;;IAQT,qBAAqB,CAAC,OAAe;QACzC,OAAO,IAAI,CAAC,OAAO,CAAC,oCAAoC,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;;CAE/E;;;;;;AC7ID;;;;;AAQA,oCAA4C,SAAQ,iBAAiB;;;;;IAOjE,YAAY,KAAa,EAAE,IAAY;QACnC,KAAK,CAAC,qBAAqB,CAAC,eAAe,CAAC,CAAC;QAC7C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;KACrB;;;;;IAEM,eAAe,CAACA,SAAe;QAClC,OAAO,mBAAmB,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;;;;;IAG7C,KAAK;QACR,OAAO,IAAI,CAAC,MAAM,CAAC;;;;;IAGhB,IAAI;QACP,OAAO,IAAI,CAAC,KAAK,CAAC;;CAEzB;;;;;;AChCD;;;;AAMA,+BAAuC,SAAQ,iBAAiB;;;;;IAK5D,YAAY,OAAe,EAAE,SAAiB;QAC1C,KAAK,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC;QACvC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;KAC/B;;;;;IAEM,eAAe,CAACA,SAAe;QAClC,IAAI,IAAI,CAAC,UAAU,KAAK,CAAC,EAAE;YACvB,OAAO,GAAG,GAAG,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC;SACpC;aAAM;YACH,OAAO,GAAG,GAAG,IAAI,CAAC,QAAQ,GAAG,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC;SAC5E;;;;;IAGE,OAAO;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC;;;;;IAGlB,SAAS;QACZ,OAAO,IAAI,CAAC,UAAU,CAAC;;CAE9B;;;;;;AChCD;;;;;;AAoBA;;;;;IAuBI,YAAY,MAAsB,EAAE,aAA4B;QAC5D,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;KACpB;;;;;IAMD,SAAS;QACL,OAAO,IAAI,CAAC,OAAO,CAAC;KACvB;;;;;;;;;IASD,SAAS,CAAC,gBAAwB;QAC9B,IAAI,iBAAiB,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE;YACzC,OAAO,IAAI,CAAC,OAAO,CAAC,qBAAqB,mBAAU,gBAAgB,GAAE,IAAI,CAAC,CAAC;SAC9E;aAAM;YACH,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,iGAAiG,EACpH,gBAAgB,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;SACjD;KACJ;;;;;;;;;;IAUD,mBAAmB,CAAC,cAAsC;;QACtD,MAAM,UAAU,GAAgB,IAAI,CAAC,aAAa,EAAE,CAAC;QACrD,IAAI,iBAAiB,CAAC,UAAU,CAAC,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,kEAAkE,EACrF,cAAc,EAAG,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;SAChD;aAAM;;YACH,MAAM,oBAAoB,GAAgB,UAAU,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;YAC/E,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,oBAAoB,CAAC,cAAc,EAAE,EAAE,IAAI,CAAC,CAAC;SACpF;KACJ;;;;;;;IAOD,qBAAqB,CAAC,YAAoB;QACtC,OAAO,IAAI,CAAC,OAAO,CAAC,oCAAoC,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;KAChF;;;;;;;IAOM,eAAe,CAAC,aAAsB;QACzC,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;;;;;;;IAOnF,cAAc;QACV,IAAI,iBAAiB,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE;YACzC,OAAO,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;SAC9D;aAAM;YACH,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,cAAc,EAAE,CAAC;SAChD;KACJ;;;;;IAMM,QAAQ;;QACX,IAAI,SAAS,GAAG,KAAK,CAAC;;QACtB,MAAM,MAAM,GAAqB,EAAE,CAAC;;QACpC,IAAI,CAAC,CAAC;QACN,CAAC,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAC;QACjC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE;YACvB,MAAM,CAAC,gBAAgB,GAAG,CAAC,CAAC;YAC5B,SAAS,GAAG,IAAI,CAAC;SACpB;QACD,CAAC,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;QACrC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE;YACvB,MAAM,2BAAwB,CAAC,CAAC;YAChC,SAAS,GAAG,IAAI,CAAC;SACpB;QACD,CAAC,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;QACnC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE;YACvB,MAAM,yBAAsB,CAAC,CAAC;YAC9B,SAAS,GAAG,IAAI,CAAC;SACpB;QACD,OAAO,SAAS,GAAG,MAAM,GAAG,IAAI,CAAC;;;;;;;;IASrC,gBAAgB;;QACZ,IAAI,WAAW,GAAG,KAAK,CAAC;;QACxB,MAAM,QAAQ,GAAqB,EAAE,CAAC;;QACtC,IAAI,CAAC,CAAC;QACN,CAAC,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;QACnC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE;YACvB,QAAQ,CAAC,kBAAkB,GAAG,CAAC,CAAC;YAChC,WAAW,GAAG,IAAI,CAAC;SACtB;QACD,CAAC,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QAC3B,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE;YACvB,QAAQ,CAAC,UAAU,GAAG,CAAC,CAAC;YACxB,WAAW,GAAG,IAAI,CAAC;SACtB;QACD,CAAC,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QACzB,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE;YACvB,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC;YACtB,WAAW,GAAG,IAAI,CAAC;SACtB;QACD,OAAO,WAAW,GAAG,QAAQ,GAAG,IAAI,CAAC;KACxC;;;;;;IAOM,aAAa;QAChB,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,qBAAqB,CAAC,WAAW,EAAE;;YACvF,MAAM,OAAO,qBAAiC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAC;YAC7D,OAAO,OAAO,CAAC,aAAa,EAAE,CAAC;SAClC;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;IAQG,qBAAqB;;QACzB,IAAI,CAAC,GAAG,IAAI,CAAC;;QACb,MAAM,iBAAiB,GAAG,EAAE,CAAC;QAC7B,IAAI,IAAI,CAAC,aAAa,EAAE;;YACpB,MAAM,kBAAkB,GAAG,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC;;YAChE,MAAM,cAAc,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;YAC9C,cAAc,CAAC,OAAO,CAAC,CAAC,KAAK;gBACzB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;oBAChC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACjC;aACJ,CAAC,CAAC;SACN;QACD,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,CAAC,GAAG,oBAAoB,GAAG,iBAAiB,CAAC,CAAC,CAAC,GAAG,oCAAoC,CAAC;SAC1F;aAAM,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;;YACrC,IAAI,oBAAoB,GAAG,EAAE,CAAC;;YAC9B,IAAI,KAAK,GAAG,IAAI,CAAC;YACjB,iBAAiB,CAAC,OAAO,CAAC,CAAC,KAAK;gBAC5B,IAAI,CAAC,KAAK,EAAE;oBACR,oBAAoB,GAAG,oBAAoB,GAAG,IAAI,CAAC;iBACtD;gBACD,oBAAoB,GAAG,oBAAoB,GAAG,KAAK,CAAC;gBACpD,KAAK,GAAG,KAAK,CAAC;aACjB,CAAC,CAAC;YACH,CAAC,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,qCAAqC,CAAC;SAC5F;QACD,OAAO,CAAC,CAAC;;;;;;IAOL,uBAAuB;;QAC3B,IAAI,CAAC,GAAG,IAAI,CAAC;;QACb,MAAM,iBAAiB,GAAG,EAAE,CAAC;QAC7B,IAAI,IAAI,CAAC,aAAa,EAAE;;YACpB,MAAM,kBAAkB,GAAG,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC;;YAChE,MAAM,cAAc,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;YAC9C,kBAAkB,CAAC,OAAO,CAAC,CAAC,KAAK;gBAC7B,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;oBAC5B,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACjC;aACJ,CAAC,CAAC;SACN;QACD,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,CAAC,GAAG,sBAAsB,GAAG,iBAAiB,CAAC,CAAC,CAAC,GAAG,wBAAwB,CAAC;SAChF;aAAM,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;;YACrC,IAAI,oBAAoB,GAAG,EAAE,CAAC;;YAC9B,IAAI,KAAK,GAAG,IAAI,CAAC;YACjB,iBAAiB,CAAC,OAAO,CAAC,CAAC,KAAK;gBAC5B,IAAI,CAAC,KAAK,EAAE;oBACR,oBAAoB,GAAG,oBAAoB,GAAG,IAAI,CAAC;iBACtD;gBACD,oBAAoB,GAAG,oBAAoB,GAAG,KAAK,CAAC;gBACpD,KAAK,GAAG,KAAK,CAAC;aACjB,CAAC,CAAC;YACH,CAAC,GAAG,uBAAuB,GAAG,oBAAoB,GAAG,wBAAwB,CAAC;SACjF;QACD,OAAO,CAAC,CAAC;;;;;;IAOL,uBAAuB;;QAC3B,IAAI,CAAC,GAAG,IAAI,CAAC;;QACb,MAAM,iBAAiB,GAAG,EAAE,CAAC;QAC7B,IAAI,IAAI,CAAC,aAAa,EAAE;;YACpB,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,iBAAiB,EAAE,CAAC;;YAC7D,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC3C,SAAS,CAAC,OAAO,CAAC,CAAC,KAAK;gBACpB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;oBAC3B,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACjC;aACJ,CAAC,CAAC;SACN;QACD,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,CAAC,GAAG,8BAA8B,GAAG,iBAAiB,CAAC,CAAC,CAAC,GAAG,oCAAoC,CAAC;SACpG;aAAM,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;;YACrC,IAAI,oBAAoB,GAAG,EAAE,CAAC;;YAC9B,IAAI,KAAK,GAAG,IAAI,CAAC;YACjB,iBAAiB,CAAC,OAAO,CAAC,CAAC,KAAK;gBAC5B,IAAI,CAAC,KAAK,EAAE;oBACR,oBAAoB,GAAG,oBAAoB,GAAG,IAAI,CAAC;iBACtD;gBACD,oBAAoB,GAAG,oBAAoB,GAAG,KAAK,CAAC;gBACpD,KAAK,GAAG,KAAK,CAAC;aACjB,CAAC,CAAC;YACH,CAAC,GAAG,+BAA+B,GAAG,oBAAoB,GAAG,qCAAqC,CAAC;SACtG;QACD,OAAO,CAAC,CAAC;;;;;;IAOL,yBAAyB;;QAC7B,IAAI,CAAC,GAAG,IAAI,CAAC;;QACb,MAAM,iBAAiB,GAAG,EAAE,CAAC;QAC7B,IAAI,IAAI,CAAC,aAAa,EAAE;;YACpB,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,iBAAiB,EAAE,CAAC;;YAC7D,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC3C,aAAa,CAAC,OAAO,CAAC,CAAC,KAAK;gBACxB,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;oBACvB,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACjC;aACJ,CAAC,CAAC;SACN;QACD,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,CAAC,GAAG,gCAAgC,GAAG,iBAAiB,CAAC,CAAC,CAAC,GAAG,wBAAwB,CAAC;SAC1F;aAAM,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;;YACrC,IAAI,oBAAoB,GAAG,EAAE,CAAC;;YAC9B,IAAI,KAAK,GAAG,IAAI,CAAC;YACjB,iBAAiB,CAAC,OAAO,CAAC,CAAC,KAAK;gBAC5B,IAAI,CAAC,KAAK,EAAE;oBACR,oBAAoB,GAAG,oBAAoB,GAAG,IAAI,CAAC;iBACtD;gBACD,oBAAoB,GAAG,oBAAoB,GAAG,KAAK,CAAC;gBACpD,KAAK,GAAG,KAAK,CAAC;aACjB,CAAC,CAAC;YACH,CAAC,GAAG,iCAAiC,GAAG,oBAAoB,GAAG,wBAAwB,CAAC;SAC3F;QACD,OAAO,CAAC,CAAC;;;;;;IAML,eAAe;;QACnB,MAAM,MAAM,GAAG,IAAI,GAAG,EAAU,CAAC;QACjC,IAAI,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI;YACtB,IAAI,IAAI,CAAC,IAAI,KAAK,qBAAqB,CAAC,WAAW,EAAE;;gBACjD,MAAM,KAAK,GAAG,mBAAgC,IAAI,GAAE,KAAK,EAAE,CAAC;gBAC5D,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;aACrB;SACJ,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;;;;;;;IAQX,kBAAkB,CAAC,KAAa;;QACnC,IAAI,WAAW,GAAiC,IAAI,CAAC;QACrD,IAAI,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI;YACtB,IAAI,IAAI,CAAC,IAAI,KAAK,qBAAqB,CAAC,WAAW,EAAE;;gBACjD,MAAM,MAAM,qBAAgE,IAAI,EAAC;gBACjF,IAAI,MAAM,CAAC,KAAK,EAAE,KAAK,KAAK,EAAE;oBAC1B,WAAW,GAAG,MAAM,CAAC;iBACxB;aACJ;SACJ,CAAC,CAAC;QACH,OAAO,WAAW,GAAG,WAAW,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC;;;;;;IAM3C,iBAAiB;;QACrB,MAAM,MAAM,GAAG,IAAI,GAAG,EAAU,CAAC;QACjC,IAAI,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI;YACtB,IAAI,IAAI,CAAC,IAAI,KAAK,qBAAqB,CAAC,eAAe,EAAE;;gBACrD,MAAM,KAAK,GAAG,mBAAkC,IAAI,GAAE,KAAK,EAAE,CAAC;gBAC9D,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;aACrB;SACJ,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;;;;;;;IAQX,oBAAoB,CAAC,KAAa;;QACrC,IAAI,iBAAiB,GAAmC,IAAI,CAAC;QAC7D,IAAI,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI;YACtB,IAAI,IAAI,CAAC,IAAI,KAAK,qBAAqB,CAAC,eAAe,EAAE;;gBACrD,MAAM,OAAO,qBAAoE,IAAI,EAAC;gBACtF,IAAI,OAAO,CAAC,KAAK,EAAE,KAAK,KAAK,EAAE;oBAC3B,iBAAiB,GAAG,OAAO,CAAC;iBAC/B;aACJ;SACJ,CAAC,CAAC;QACH,OAAO,iBAAiB,GAAG,iBAAiB,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC;;;;;;IAOvD,aAAa;;QACjB,IAAI,CAAC,GAAG,IAAI,CAAC;;QACb,MAAM,cAAc,GAAG,EAAE,CAAC;QAC1B,IAAI,IAAI,CAAC,aAAa,EAAE;;YACpB,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC;;YAChD,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAC9B,MAAM,CAAC,OAAO,CAAC,CAAC,OAAO;gBACnB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;oBAC1B,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBAChC;aACJ,CAAC,CAAC;SACN;QACD,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,CAAC,GAAG,aAAa,GAAG,cAAc,CAAC,CAAC,CAAC,GAAG,qCAAqC,CAAC;SACjF;aAAM,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;;YAClC,IAAI,iBAAiB,GAAG,EAAE,CAAC;;YAC3B,IAAI,KAAK,GAAG,IAAI,CAAC;YACjB,cAAc,CAAC,OAAO,CAAC,CAAC,GAAG;gBACvB,IAAI,CAAC,KAAK,EAAE;oBACR,iBAAiB,GAAG,iBAAiB,GAAG,IAAI,CAAC;iBAChD;gBACD,iBAAiB,GAAG,iBAAiB,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;gBACxD,KAAK,GAAG,KAAK,CAAC;aACjB,CAAC,CAAC;YACH,CAAC,GAAG,aAAa,GAAG,iBAAiB,GAAG,qCAAqC,CAAC;SACjF;QACD,OAAO,CAAC,CAAC;;;;;;IAOL,eAAe;;QACnB,IAAI,CAAC,GAAG,IAAI,CAAC;;QACb,MAAM,cAAc,GAAG,EAAE,CAAC;QAC1B,IAAI,IAAI,CAAC,aAAa,EAAE;;YACpB,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC;;YAChD,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAC9B,UAAU,CAAC,OAAO,CAAC,CAAC,OAAO;gBACvB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;oBACtB,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBAChC;aACJ,CAAC,CAAC;SACN;QACD,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,CAAC,GAAG,eAAe,GAAG,cAAc,CAAC,CAAC,CAAC,GAAG,yBAAyB,CAAC;SACvE;aAAM,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;;YAClC,IAAI,iBAAiB,GAAG,EAAE,CAAC;;YAC3B,IAAI,KAAK,GAAG,IAAI,CAAC;YACjB,cAAc,CAAC,OAAO,CAAC,CAAC,GAAG;gBACvB,IAAI,CAAC,KAAK,EAAE;oBACR,iBAAiB,GAAG,iBAAiB,GAAG,IAAI,CAAC;iBAChD;gBACD,iBAAiB,GAAG,iBAAiB,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;gBACxD,KAAK,GAAG,KAAK,CAAC;aACjB,CAAC,CAAC;YACH,CAAC,GAAG,eAAe,GAAG,iBAAiB,GAAG,wBAAwB,CAAC;SACtE;QACD,OAAO,CAAC,CAAC;;;;;;IAML,OAAO;;QACX,MAAM,MAAM,GAAG,IAAI,GAAG,EAAU,CAAC;QACjC,IAAI,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI;YACtB,IAAI,IAAI,CAAC,IAAI,KAAK,qBAAqB,CAAC,SAAS,IAAI,IAAI,CAAC,IAAI,KAAK,qBAAqB,CAAC,SAAS,EAAE;;gBAChG,MAAM,OAAO,GAAG,mBAA6B,IAAI,GAAE,OAAO,EAAE,CAAC;gBAC7D,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;aACvB;SACJ,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;;;;;IAGX,KAAK;QACR,OAAO,IAAI,CAAC,MAAM,CAAC;;;;;;IAGvB,oBAAoB,CAAC,iBAA0B;QAC3C,IAAI,CAAC,kBAAkB,GAAG,iBAAiB,CAAC;KAC/C;;;;;IAED,OAAO,CAAC,IAAY;QAChB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC;KACrD;;;;;;IAED,cAAc,CAAC,KAAa,EAAE,IAAY;QACtC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,4BAA4B,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;KACnE;;;;;;IAED,WAAW,CAAC,OAAe,EAAE,SAAiB;QAC1C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,yBAAyB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC;KACvE;;;;;IAED,SAAS,CAAC,OAAe;;QAErB,MAAM,OAAO,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5C,IAAI,CAAC,OAAO,IAAI,OAAO,KAAK,OAAO,EAAE;;YAEjC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,oEAAoE,EACvF,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;SACjD;QACD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,uBAAuB,CAAC,OAAO,CAAC,CAAC,CAAC;KAC1D;;;;;;IAED,WAAW,CAAC,OAAe,EAAE,SAAiB;QAC1C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,yBAAyB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC;KACvE;;;;;;IAED,gBAAgB,CAAC,KAAa,EAAE,IAAI;QAChC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,8BAA8B,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;KACrE;;;;;IAED,aAAa,CAAC,IAAY;QACtB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,2BAA2B,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;KACzE;;;;;;IAMO,oBAAoB;;QACxB,MAAM,QAAQ,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI;YACrB,QAAQ,IAAI,CAAC,IAAI;gBACb,KAAK,qBAAqB,CAAC,SAAS;oBAChC,QAAQ,CAAC,IAAI,CAAC,mBAA6B,IAAI,GAAE,OAAO,EAAE,CAAC,CAAC;oBAC5D,MAAM;gBACV,KAAK,qBAAqB,CAAC,OAAO;;oBAC9B,MAAM,OAAO,GAAG,mBAA2B,IAAI,GAAE,OAAO,EAAE,CAAC;oBAC3D,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,OAAO,EAAE;;wBAEpE,MAAM,OAAO,GAAG,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,SAAS,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;wBACpF,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,oEAAoE,EACvF,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;qBACjD;oBACD,QAAQ,CAAC,GAAG,EAAE,CAAC;aACtB;SACJ,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;;CAE3E;;;;;;ACthBD;;;;AASA,MAAaC,MAAI,GAAG,MAAM,CAAC;;AAC3B,MAAa,SAAS,GAAG,WAAW,CAAC;;AACrC,MAAa,OAAO,GAAG,SAAS,CAAC;;AACjC,MAAa,SAAS,GAAG,WAAW,CAAC;;AACrC,MAAa,WAAW,GAAG,aAAa,CAAC;;AACzC,MAAa,eAAe,GAAG,iBAAiB,CAAC;;AACjD,MAAa,WAAW,GAAG,aAAa,CAAC;;;;;IAS7B,QAAQ;;QACZ,MAAM,KAAK,GAAG,IAAI,QAAQ,EAAE,CAAC;;QAC7B,IAAI,SAAS,GAAG,EAAE,CAAC;QACnB,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI;YAC1B,IAAI,IAAI,CAAC,IAAI,KAAKA,MAAI,IAAI,SAAS,KAAK,EAAE,EAAE;gBACxC,GAAG,CAAC,MAAM,CAACA,MAAI,EAAE,EAAC,IAAI,EAAE,SAAS,EAAC,CAAC,CAAC;gBACpC,SAAS,GAAG,EAAE,CAAC;aAClB;SACJ,CAAC,CAAC;QACH,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG;YACb,IAAI,SAAS,KAAK,EAAE,EAAE;gBAClB,GAAG,CAAC,MAAM,CAACA,MAAI,EAAE,EAAC,IAAI,EAAE,SAAS,EAAC,CAAC,CAAC;aACvC;SACH,CAAC,CAAC;;;QAGJ,KAAK,CAAC,IAAI,CAAC,+CAA+C,EAAE,CAAC,GAAG,EAAE,KAAK;;YACnE,MAAM,OAAO,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YACzE,GAAG,CAAC,MAAM,CAAC,SAAS,EAAE,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,OAAO,EAAC,CAAC,CAAC;SAC/D,EAAE,SAAS,CAAC,CAAC;;QAEd,KAAK,CAAC,IAAI,CAAC,4CAA4C,EAAE,CAAC,GAAG,EAAE,KAAK;;YAChE,MAAM,OAAO,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YACzE,GAAG,CAAC,MAAM,CAAC,SAAS,EAAE,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,OAAO,EAAC,CAAC,CAAC;SAC/D,EAAE,SAAS,CAAC,CAAC;;QAEd,KAAK,CAAC,IAAI,CAAC,6BAA6B,EAAE,CAAC,GAAG,EAAE,KAAK;YACjD,GAAG,CAAC,MAAM,CAAC,OAAO,EAAE,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC;SACzC,EAAE,OAAO,CAAC,CAAC;;QAEZ,KAAK,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,GAAG,EAAE,KAAK;YAClC,GAAG,CAAC,MAAM,CAAC,WAAW,EAAE,EAAC,SAAS,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EAAC,CAAC,CAAC;SAChE,EAAE,WAAW,CAAC,CAAC;;QAEhB,KAAK,CAAC,IAAI,CAAC,8BAA8B,EAAE,CAAC,GAAG,EAAE,KAAK;YAClD,GAAG,CAAC,MAAM,CAAC,eAAe,EAAE,EAAC,SAAS,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EAAC,CAAC,CAAC;SACpE,EAAE,eAAe,CAAC,CAAC;;QAEpB,KAAK,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,GAAG,EAAE,KAAK;YACrC,GAAG,CAAC,MAAM,CAAC,WAAW,EAAE,EAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC;SAChD,EAAE,WAAW,CAAC,CAAC;;QAEhB,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK;YACvB,SAAS,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,GAAG,CAAC,MAAM,EAAE,CAAC;SAChB,EAAEA,MAAI,CAAC,CAAC;QACT,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,GAAG,EAAE,KAAK;YAC/B,SAAS,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,GAAG,CAAC,MAAM,EAAE,CAAC;SAChB,EAAEA,MAAI,CAAC,CAAC;QACT,OAAO,KAAK,CAAC;;;;;;IAGjB,QAAQ,CAAC,iBAAyB;;QAC9B,MAAM,KAAK,GAAa,IAAI,CAAC,QAAQ,EAAE,CAAC;QACxC,KAAK,CAAC,KAAK,EAAE,CAAC;QACd,KAAK,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAC/B,OAAO,KAAK,CAAC,MAAM,EAAE,CAAC;KACzB;CAEJ;;;;;;ACpFD;;;;;;AAsBA;;;;;;;;IAQW,8BAA8B,CAAC,UAAmB,EAAE,aAA4B;;QACnF,MAAM,OAAO,GAAkB,IAAI,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;QACtE,IAAI,UAAU,EAAE;YACZ,OAAO,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;YACzC,IAAI,CAAC,uBAAuB,CAAC,UAAU,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;SAC5D;QACD,OAAO,OAAO,CAAC;;;;;;;;;IASnB,oCAAoC,CAAC,SAAiB,EAAE,aAA4B;;QAChF,MAAM,GAAG,GAAa,IAAI,SAAS,EAAE,CAAC,eAAe,CAAC,SAAS,GAAG,SAAS,GAAG,UAAU,EAAE,UAAU,CAAC,CAAC;;QACtG,MAAM,UAAU,qBAAsB,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAC;QAC7D,OAAO,IAAI,CAAC,8BAA8B,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC;KACzE;;;;;;;;IAQO,uBAAuB,CAAC,IAAU,EAAE,OAAsB,EAAE,WAAoB;;QACpF,IAAI,eAAe,GAAG,IAAI,CAAC;QAC3B,IAAI,WAAW,EAAE;YACb,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,SAAS,EAAE;gBAClC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAClC,OAAO;aACV;YACD,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,YAAY,EAAE;gBACrC,eAAe,GAAG,IAAI,CAAC,mBAAmB,mBAAW,IAAI,GAAE,OAAO,CAAC,CAAC;aACvE;SACJ;QACD,IAAI,eAAe,EAAE;;YACjB,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;;YACpD,IAAI,KAAK,GAAG,CAAC,iBAAiB,CAAC,cAAc,CAAC,CAAC;YAC/C,IAAI,KAAK,EAAE;gBACP,IAAI;oBACA,OAAO,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC;iBACzC;gBAAC,OAAO,KAAK,EAAE;;oBAEZ,OAAO,CAAC,GAAG,CAAC,mBAAmB,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;oBACxD,KAAK,GAAG,KAAK,CAAC;iBACjB;aACJ;YACD,IAAI,CAAC,KAAK,EAAE;;gBACR,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC;gBACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACtC,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;iBACjE;aACJ;SACJ;QACD,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,YAAY,EAAE;YACrC,IAAI,CAAC,iBAAiB,mBAAW,IAAI,GAAE,OAAO,CAAC,CAAC;SACnD;;;;;;;IAQK,iBAAiB,CAAC,IAAU;;QAClC,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC;QACjC,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YACvB,OAAO,IAAI,CAAC;SACf;;QACD,MAAM,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACpC,IAAI,UAAU,CAAC,QAAQ,KAAK,UAAU,CAAC,SAAS,EAAE;YAC9C,IAAI,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE;gBAChD,OAAO,YAAY,CAAC,aAAa,mBAAW,IAAI,EAAC,CAAC;aACrD;iBAAM;gBACH,OAAO,IAAI,CAAC;aACf;SACJ;aAAM;YACH,OAAO,IAAI,CAAC;SACf;KACJ;;;;;;IAMM,iBAAiB,CAAC,IAAY;QACjC,OAAO,2BAA2B,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;;;;;;;;;;IA4B1D,qBAAqB,CAAC,gBAAwB,EAAE,aAA4B;;QAC/E,MAAM,OAAO,GAAkB,IAAI,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;;QACtE,MAAM,QAAQ,GAAG,EAAE,CAAC;;QACpB,IAAI,MAAM,CAAU;QACpB,IAAI;YACA,MAAM,GAAG,IAAI,qBAAqB,EAAE,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;SACnE;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,2DAA2D,EAAE,KAAK,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC,CAAC;SACzH;QACD,MAAM,CAAC,OAAO,CAAC,CAAC,KAAY;;YACxB,IAAI,IAAI,GAAW,IAAI,CAAC;YACxB,QAAQ,KAAK,CAAC,IAAI;gBACd,KAAKA,MAAI;oBACL,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBAClC,MAAM;gBACV,KAAK,SAAS;oBACV,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;oBAC7D,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBAChC,MAAM;gBACV,KAAK,OAAO;oBACR,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBACpC,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE;;wBAE7E,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,yCAAyC,EAAE,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;qBAC1G;oBACD,QAAQ,CAAC,GAAG,EAAE,CAAC;oBACf,MAAM;gBACV,KAAK,SAAS;oBACV,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;oBAC7D,MAAM;gBACV,KAAK,WAAW;oBACZ,IAAI,GAAG,CAAC,aAAa,IAAI,aAAa,CAAC,kBAAkB,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC;oBACxF,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;oBACpD,MAAM;gBACV,KAAK,eAAe;oBAChB,IAAI,GAAG,CAAC,aAAa,IAAI,aAAa,CAAC,oBAAoB,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC;oBAC1F,OAAO,CAAC,gBAAgB,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;oBACtD,MAAM;gBACV,KAAK,WAAW;oBACZ,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,0EAA0E,EAAE,gBAAgB,CAAC,CAAC,CAAC;gBAC1H;oBACI,MAAM;aACb;SACJ,CAAC,CAAC;QACH,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;;YAErB,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,sCAAsC,EAAE,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC;SACpH;QACD,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC,CAAC;QACpE,OAAO,OAAO,CAAC;;;;;;;;;IAUnB,eAAe,CAAC,gBAAwB,EAAE,aAA4B;;QAClE,MAAM,OAAO,GAAkB,IAAI,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;QACtE,OAAO,CAAC,aAAa,CAAC,gBAAgB,CAAC,CAAC;QACxC,OAAO,OAAO,CAAC;KAClB;;;;;;;;;IAUS,oBAAoB,CAAC,IAAY;;QACvC,MAAM,KAAK,GAAG,aAAa,CAAC;;QAC5B,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC/B,IAAI,iBAAiB,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;YAC7C,OAAO,CAAC,CAAC;SACZ;aAAM;;YACH,MAAM,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACrB,OAAO,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;SAC5B;KACJ;;;;;;;IAOS,uBAAuB,CAAC,OAAsB;;QACpD,MAAM,IAAI,GAAa,IAAI,SAAS,EAAE,CAAC,eAAe,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;;QAC/E,MAAM,QAAQ,GAAY,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACrE,IAAI,CAAC,0BAA0B,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QACnD,OAAO,QAAQ,CAAC;KACnB;;;;;;IAIS,iCAAiC,CAAC,IAA2B,EAAE,QAAiB;QACtF,OAAO,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC;KACxE;CAuCJ;;;;;;;;;;ACtRD,MAAM,wBAAwB,GAA0B;IACpD,GAAG,EAAE,MAAM;IACX,GAAG,EAAE,WAAW;IAChB,IAAI,EAAE,YAAY;IAClB,IAAI,EAAE,iBAAiB;IACvB,IAAI,EAAE,gBAAgB;IACtB,IAAI,EAAE,gBAAgB;IACtB,IAAI,EAAE,gBAAgB;IACtB,IAAI,EAAE,gBAAgB;IACtB,IAAI,EAAE,gBAAgB;IACtB,IAAI,EAAE,gBAAgB;IACtB,IAAI,EAAE,iBAAiB;IACvB,GAAG,EAAE,aAAa;IAClB,IAAI,EAAE,WAAW;IACjB,MAAM,EAAE,YAAY;IACpB,IAAI,EAAE,cAAc;IACpB,GAAG,EAAE,WAAW;IAChB,GAAG,EAAE,WAAW;IAChB,GAAG,EAAE,oBAAoB;IACzB,OAAO,EAAE,YAAY;IACrB,KAAK,EAAE,WAAW;IAClB,KAAK,EAAE,aAAa;IACpB,OAAO,EAAE,YAAY;IACrB,IAAI,EAAE,YAAY;IAClB,OAAO,EAAE,cAAc;IACvB,IAAI,EAAE,mBAAmB;IACzB,OAAO,EAAE,cAAc;IACvB,IAAI,EAAE,WAAW;IACjB,IAAI,EAAE,iBAAiB;IACvB,GAAG,EAAE,iBAAiB;IACtB,IAAI,EAAE,gBAAgB;CACzB,CAAC;;;;AAKF,MAAM,SAAS,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;AAE7D;;;;;;IAEW,0BAA0B,CAAC,GAAW,EAAE,EAAU;;QACrD,MAAM,QAAQ,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;;QACnC,MAAM,QAAQ,GAAG,wBAAwB,CAAC,QAAQ,CAAC,IAAI,OAAO,QAAQ,EAAE,CAAC;QACzE,OAAO,SAAS,QAAQ,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC;;;;;;IAGjD,0BAA0B,CAAC,GAAW;;QACzC,MAAM,QAAQ,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;;QACnC,MAAM,QAAQ,GAAG,wBAAwB,CAAC,QAAQ,CAAC,IAAI,OAAO,QAAQ,EAAE,CAAC;QACzE,OAAO,SAAS,QAAQ,EAAE,CAAC;;;;;;;IAGxB,0BAA0B,CAAC,GAAW,EAAE,EAAU;;QACrD,MAAM,QAAQ,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;;QACnC,MAAM,QAAQ,GAAI,wBAAwB,CAAC,QAAQ,CAAC,IAAI,OAAO,QAAQ,EAAE,CAAC;QAC1E,OAAO,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC;;;;;;IAGtC,cAAc,CAAC,GAAW;QAC7B,QAAQ,GAAG,CAAC,WAAW,EAAE;YACrB,KAAK,IAAI;gBACL,OAAO,IAAI,CAAC;YAChB,KAAK,KAAK;gBACN,OAAO,OAAO,CAAC;YACnB;gBACI,OAAO,KAAK,GAAG,EAAE,CAAC;SACzB;;;;;;IAGE,qCAAqC,CAAC,eAAuB;QAChE,IAAI,eAAe,CAAC,UAAU,CAAC,YAAY,CAAC,EAAE;YAC1C,OAAO,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,SAAS,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;SAC1F;aAAM,IAAI,eAAe,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;;YAC7C,MAAM,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;;YACzE,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,wBAAwB,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC;YAC3G,OAAO,QAAQ,GAAG,QAAQ,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC;SACnD;QACD,OAAO,IAAI,CAAC;;;;;;IAGT,qCAAqC,CAAC,eAAuB;QAChE,IAAI,eAAe,CAAC,UAAU,CAAC,YAAY,CAAC,EAAE;YAC1C,OAAO,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,SAAS,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;SAC1F;aAAM,IAAI,eAAe,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;;YAC7C,MAAM,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;;YACzE,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,wBAAwB,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC;YAC3G,OAAO,QAAQ,GAAG,QAAQ,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC;SACnD;QACD,OAAO,IAAI,CAAC;;;;;;;IAOT,yBAAyB,CAAC,eAAuB;;QACpD,MAAM,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;;QAC9C,IAAI,QAAQ,CAAC;QACb,IAAI,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;YACvB,QAAQ,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;SAC5C;aAAM;YACH,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,wBAAwB,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC;SACxG;QACD,IAAI,QAAQ,EAAE;YACV,IAAI,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBAClC,OAAO,IAAI,CAAC;aACf;SACJ;QACD,OAAO,KAAK,CAAC;;;;;;;IAOV,qCAAqC,CAAC,eAAuB;;QAChE,MAAM,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;;QAC9C,IAAI,QAAQ,CAAC;QACb,IAAI,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;YACvB,QAAQ,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;SAC5C;aAAM;YACH,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,wBAAwB,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC;SACxG;QACD,IAAI,QAAQ,EAAE;YACV,IAAI,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBAClC,OAAO,QAAQ,CAAC,WAAW,EAAE,CAAC;aACjC;iBAAM;gBACH,OAAO,IAAI,CAAC;aACf;SACJ;QACD,OAAO,IAAI,CAAC;;;;;;;IAQR,YAAY,CAAC,eAAuB;QACxC,IAAI,eAAe,EAAE;;YACjB,MAAM,EAAE,GAAG,cAAc,CAAC;YAC1B,IAAI,eAAe,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;gBAC3B,OAAO,eAAe,CAAC,OAAO,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;aAC5C;SACJ;QACD,OAAO,eAAe,CAAC;;;;;;;;IASnB,aAAa,CAAC,EAAU;QAC5B,IAAI,EAAE,KAAK,CAAC,EAAE;YACV,OAAO,EAAE,CAAC;SACb;aAAM;YACH,OAAO,GAAG,GAAG,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;SAChC;;CAER;;;;;;ACzKD;;;;AAeA,wBAAgC,SAAQ,qBAAqB;;;;;;;;IAS/C,mBAAmB,CAAC,WAAoB,EAAE,OAAsB;;QACtE,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC;;QACpC,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;QACpC,IAAI,OAAO,KAAK,GAAG,EAAE;;YAEjB,MAAM,EAAE,GAAG,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAC1C,IAAI,CAAC,EAAE,EAAE;gBACL,OAAO;aACV;YACD,IAAI,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,EAAE;;gBAChC,MAAM,KAAK,GAAG,IAAI,CAAC,2BAA2B,CAAC,EAAE,CAAC,CAAC;gBACnD,OAAO,CAAC,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aACvC;iBAAM,IAAI,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;;gBAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,6BAA6B,CAAC,EAAE,CAAC,CAAC;gBACrD,OAAO,CAAC,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aACzC;iBAAM,IAAI,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;;gBAChC,MAAM,iBAAiB,GAAG,UAAU,CAAC,qCAAqC,CAAC,EAAE,CAAC,CAAC;gBAC/E,IAAI,iBAAiB,EAAE;;oBACnB,MAAM,OAAO,GAAG,IAAI,CAAC,oBAAoB,CAAC,EAAE,CAAC,CAAC;oBAC9C,OAAO,CAAC,WAAW,CAAC,iBAAiB,EAAE,OAAO,CAAC,CAAC;iBACnD;aACJ;iBAAM,IAAI,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;;gBAChC,MAAM,iBAAiB,GAAG,UAAU,CAAC,qCAAqC,CAAC,EAAE,CAAC,CAAC;gBAC/E,IAAI,iBAAiB,EAAE;oBACnB,OAAO,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC;iBACxC;aACJ;iBAAM,IAAI,UAAU,CAAC,yBAAyB,CAAC,EAAE,CAAC,EAAE;;gBACjD,MAAM,iBAAiB,GAAG,UAAU,CAAC,qCAAqC,CAAC,EAAE,CAAC,CAAC;gBAC/E,IAAI,iBAAiB,EAAE;;oBACnB,MAAM,OAAO,GAAG,IAAI,CAAC,oBAAoB,CAAC,EAAE,CAAC,CAAC;oBAC9C,OAAO,CAAC,WAAW,CAAC,iBAAiB,EAAE,OAAO,CAAC,CAAC;iBACnD;aACJ;SACJ;QACD,OAAO,IAAI,CAAC;KACf;;;;;;;;IAQS,iBAAiB,CAAC,WAAoB,EAAE,OAAsB;KACvE;;;;;;;IAQO,2BAA2B,CAAC,EAAU;;QAC1C,IAAI,WAAW,GAAG,EAAE,CAAC;QAErB,IAAI,EAAE,KAAK,eAAe,EAAE;YACxB,WAAW,GAAG,GAAG,CAAC;SACrB;aAAM;YACH,WAAW,GAAG,EAAE,CAAC,SAAS,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;SACvD;QACD,OAAO,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;;;;;;;;IASpC,6BAA6B,CAAC,EAAU;;QAC5C,IAAI,WAAW,GAAG,EAAE,CAAC;QAErB,IAAI,EAAE,KAAK,KAAK,EAAE;YACd,WAAW,GAAG,GAAG,CAAC;SACrB;aAAM;YACH,WAAW,GAAG,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SAC7C;QACD,OAAO,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;;;;;;;IAGlC,0BAA0B,CAAC,OAAsB,EAAE,QAAiB;QAC1E,OAAO,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI;;YACzB,IAAI,KAAK,CAAO;YAChB,QAAQ,IAAI,CAAC,IAAI;gBACb,KAAK,qBAAqB,CAAC,IAAI;oBAC3B,KAAK,GAAG,IAAI,CAAC,iCAAiC,mBAAyB,IAAI,GAAE,QAAQ,CAAC,CAAC;oBACvF,MAAM;gBACV,KAAK,qBAAqB,CAAC,SAAS;oBAChC,KAAK,GAAG,IAAI,CAAC,qCAAqC,oBAA6B,IAAI,IAAG,QAAQ,CAAC,CAAC;oBAChG,MAAM;gBACV,KAAK,qBAAqB,CAAC,OAAO;oBAC9B,KAAK,GAAG,IAAI,CAAC,mCAAmC,oBAA2B,IAAI,IAAG,QAAQ,CAAC,CAAC;oBAC5F,MAAM;gBACV,KAAK,qBAAqB,CAAC,SAAS;oBAChC,KAAK,GAAG,IAAI,CAAC,qCAAqC,oBAA6B,IAAI,IAAG,QAAQ,CAAC,CAAC;oBAChG,MAAM;gBACV,KAAK,qBAAqB,CAAC,WAAW;oBAClC,KAAK,GAAG,IAAI,CAAC,wCAAwC,oBAAgC,IAAI,IAAG,QAAQ,CAAC,CAAC;oBACtG,MAAM;gBACV,KAAK,qBAAqB,CAAC,eAAe;oBACtC,KAAK,GAAG,IAAI,CAAC,0CAA0C,oBAAkC,IAAI,IAAG,QAAQ,CAAC,CAAC;oBAC1G,MAAM;aACb;YACD,IAAI,KAAK,EAAE;gBACP,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aAC/B;SACJ,CAAC,CAAC;KACN;;;;;;;;IAQS,qCAAqC,CAAC,IAA+B,EAAE,QAAiB;;QAC9F,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;;QACxD,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;;QACpC,MAAM,QAAQ,GAAG,UAAU,CAAC,0BAA0B,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;;QACzF,MAAM,WAAW,GAAG,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;;QAC9D,MAAM,aAAa,GAAG,GAAG,GAAG,IAAI,CAAC,OAAO,EAAE,GAAG,GAAG,CAAC;QACjD,KAAK,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACnC,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QACzC,KAAK,CAAC,YAAY,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;QAChD,OAAO,KAAK,CAAC;KAChB;;;;;;;;IAQS,mCAAmC,CAAC,IAA6B,EAAE,QAAiB;;QAC1F,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;;QACxD,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;;QACpC,MAAM,QAAQ,GAAG,UAAU,CAAC,0BAA0B,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;;QACvE,MAAM,WAAW,GAAG,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QAC1C,KAAK,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACnC,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QACzC,OAAO,KAAK,CAAC;KAChB;;;;;;;;IAQS,qCAAqC,CAAC,IAA+B,EAAE,QAAiB;;QAC9F,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;;QACxD,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;;QACpC,MAAM,QAAQ,GAAG,UAAU,CAAC,0BAA0B,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;;QACzF,MAAM,WAAW,GAAG,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;;QAC9D,MAAM,aAAa,GAAG,GAAG,GAAG,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC;QAClD,KAAK,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACnC,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QACzC,KAAK,CAAC,YAAY,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;QAChD,OAAO,KAAK,CAAC;KAChB;;;;;;;;IAQS,wCAAwC,CAAC,IAAkC,EAAE,QAAiB;;QACpG,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;;QACxD,IAAI,QAAQ,GAAG,eAAe,CAAC;QAC/B,IAAI,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;YAClB,QAAQ,GAAG,gBAAgB,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;SAC3D;;QACD,MAAM,aAAa,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAClC,KAAK,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACnC,IAAI,aAAa,EAAE;YACf,KAAK,CAAC,YAAY,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;SACnD;QACD,OAAO,KAAK,CAAC;KAChB;;;;;;;IAOS,0CAA0C,CAAC,IAAoC,EAAE,QAAiB;;QACxG,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;;QACxD,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,IAAI,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;YAClB,QAAQ,GAAG,MAAM,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;SACjD;QACD,KAAK,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACnC,OAAO,KAAK,CAAC;KAChB;CAEJ;;;;;;AC5ND;;;;AAgBA,oBAA4B,SAAQ,iBAAiB;;;;;;IAEjD,YAAY,QAAiB,EAAE,GAAW,EAAE,wBAAkD;QAC1F,KAAK,CAAC,QAAQ,EAAE,GAAG,EAAE,wBAAwB,CAAC,CAAC;KAClD;;;;IAEM,aAAa;;QAChB,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,OAAO,YAAY,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;;;;;;;;;IAS9C,gBAAgB,CAAC,UAAkB;;QACtC,IAAI,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC5E,IAAI,CAAC,MAAM,EAAE;;YAET,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC3F;QACD,YAAY,CAAC,4BAA4B,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;;;;;;IAMxD,aAAa;QACnB,OAAO,IAAI,kBAAkB,EAAE,CAAC;KACnC;;;;;IAKM,6BAA6B;;QAChC,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,IAAI,aAAa,EAAE;YACf,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,8BAA8B,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;SACnF;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;IAME,aAAa;;QAChB,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,OAAO,YAAY,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;;;;;;;IAOrD,uBAAuB;;QACnB,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,OAAO,IAAI,kBAAkB,EAAE,CAAC,8BAA8B,CAAC,aAAa,EAAE,IAAI,CAAC,uBAAuB,EAAE,CAAC,CAAC;KACjH;;;;;IAKM,iBAAiB;;QACpB,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,IAAI,aAAa,EAAE;YACf,OAAO,aAAa,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;SAC9C;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOK,oBAAoB,CAAC,WAAmB;;QAC9C,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,IAAI,aAAa,EAAE;YACf,aAAa,CAAC,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;SACpD;KACJ;;;;;;;;IASS,qBAAqB,CAAC,KAAa;QACzC,QAAS,KAAK;YACV,KAAK,SAAS;gBACV,OAAO,KAAK,CAAC;YACjB,KAAK,gBAAgB;gBACjB,OAAO,YAAY,CAAC;YACxB,KAAK,WAAW;gBACZ,OAAO,OAAO,CAAC;YACnB;gBACI,MAAM,IAAI,KAAK,CAAC,gBAAgB,GAAI,KAAK,CAAC,CAAC;SAClD;KACJ;;;;;;;IAOS,qBAAqB,CAAC,WAAmB;QAC/C,QAAS,WAAW;YAChB,KAAK,KAAK;gBACN,OAAO,SAAS,CAAC;YACrB,KAAK,mBAAmB;gBACpB,OAAO,SAAS,CAAC;YACrB,KAAK,YAAY;gBACb,OAAO,gBAAgB,CAAC;YAC5B,KAAK,kBAAkB;gBACnB,OAAO,gBAAgB,CAAC;YAC5B,KAAK,YAAY;gBACb,OAAO,gBAAgB,CAAC;YAC5B,KAAK,yBAAyB;gBAC1B,OAAO,gBAAgB,CAAC;YAC5B,KAAK,mBAAmB;gBACpB,OAAO,gBAAgB,CAAC;YAC5B,KAAK,0BAA0B;gBAC3B,OAAO,gBAAgB,CAAC;YAC5B,KAAK,OAAO;gBACR,OAAO,WAAW,CAAC;YACvB,KAAK,YAAY;gBACb,OAAO,WAAW,CAAC;YACvB;gBACI,OAAO,SAAS,CAAC;SACxB;KACJ;;;;;;;;;;IAUM,gBAAgB;;QACnB,MAAM,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAC;;QAC3E,MAAM,UAAU,GAAiD,EAAE,CAAC;QACpE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC5C,MAAM,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACpC,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,KAAK,UAAU,EAAE;;gBAC7C,MAAM,eAAe,GAAG,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;;gBAC7D,IAAI,UAAU,GAAG,IAAI,CAAC;;gBACtB,IAAI,UAAU,GAAG,CAAC,CAAC;gBACnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;oBAC7C,MAAM,WAAW,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC5C,IAAI,WAAW,CAAC,YAAY,CAAC,cAAc,CAAC,KAAK,YAAY,EAAE;wBAC3D,UAAU,GAAG,YAAY,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;qBACpD;oBACD,IAAI,WAAW,CAAC,YAAY,CAAC,cAAc,CAAC,KAAK,YAAY,EAAE;wBAC3D,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC,CAAC;qBACzE;iBACJ;gBACD,UAAU,CAAC,IAAI,CAAC,EAAC,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAC,CAAC,CAAC;aACrE;SACJ;QACD,OAAO,UAAU,CAAC;;;;;;;;;IASf,mBAAmB,CAAC,UAAsD;QAC7E,IAAI,CAAC,yBAAyB,EAAE,CAAC;QACjC,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG;;YACnB,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;YAChF,YAAY,CAAC,YAAY,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;;YACjD,MAAM,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;YAC3E,aAAa,CAAC,YAAY,CAAC,cAAc,EAAE,YAAY,CAAC,CAAC;YACzD,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;;YACtF,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;YACzE,WAAW,CAAC,YAAY,CAAC,cAAc,EAAE,YAAY,CAAC,CAAC;YACvD,WAAW,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACjG,YAAY,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;YACxC,YAAY,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;YACtC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;SAC3C,CAAC,CAAC;;;;;IAGC,yBAAyB;;QAC7B,MAAM,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAC;;QAC3E,MAAM,WAAW,GAAG,EAAE,CAAC;QACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC5C,MAAM,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACpC,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,KAAK,UAAU,EAAE;gBAC7C,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAC1B;SACJ;QACD,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,OAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;;;;;;;;IAQlE,WAAW;;QACd,MAAM,QAAQ,GAAG,IAAI,CAAC,gCAAgC,CAAC,aAAa,CAAC,CAAC;QACtE,IAAI,QAAQ,EAAE;YACV,OAAO,YAAY,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;SAC3C;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOE,cAAc,CAAC,WAAmB;;QACrC,IAAI,QAAQ,GAAG,IAAI,CAAC,gCAAgC,CAAC,aAAa,CAAC,CAAC;QACpE,IAAI,WAAW,EAAE;YACd,IAAI,iBAAiB,CAAC,QAAQ,CAAC,EAAE;;gBAE7B,QAAQ,GAAG,IAAI,CAAC,kCAAkC,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;aAClF;iBAAM;gBACH,YAAY,CAAC,4BAA4B,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;aACpE;SACH;aAAM;YACH,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE;;gBAE9B,IAAI,CAAC,kCAAkC,CAAC,aAAa,CAAC,CAAC;aAC1D;SACJ;;;;;;;IAQG,gCAAgC,CAAC,SAAiB;;QACtD,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;QAChE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC1C,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtC,IAAI,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,KAAK,SAAS,EAAE;gBAC7C,OAAO,QAAQ,CAAC;aACnB;SACJ;QACD,OAAO,IAAI,CAAC;;;;;;IAOR,6BAA6B;;QACjC,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;;QAChE,MAAM,MAAM,GAAc,EAAE,CAAC;QAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC1C,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;YACtC,MAAM,aAAa,GAAG,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;YACpD,IAAI,aAAa,KAAK,aAAa,IAAI,aAAa,KAAK,SAAS,EAAE;gBAChE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aACzB;SACJ;QACD,OAAO,MAAM,CAAC;;;;;;;;IASV,kCAAkC,CAAC,aAAqB,EAAE,OAAe;;QAC7E,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;QACtE,IAAI,aAAa,EAAE;YACf,WAAW,CAAC,YAAY,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;SACnD;QACD,WAAW,CAAC,YAAY,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;QAC1C,IAAI,OAAO,EAAE;YACT,YAAY,CAAC,4BAA4B,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;SACnE;QACD,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QACvC,OAAO,WAAW,CAAC;;;;;;;IAOf,kCAAkC,CAAC,SAAiB;;QACxD,MAAM,WAAW,GAAG,IAAI,CAAC,gCAAgC,CAAC,SAAS,CAAC,CAAC;QACrE,IAAI,WAAW,EAAE;YACb,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;SAC1C;;;;;;IAMG,+BAA+B;;QACnC,MAAM,YAAY,GAAG,IAAI,CAAC,6BAA6B,EAAE,CAAC;QAC1D,YAAY,CAAC,OAAO,CAAC,CAAC,WAAW;YAC7B,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;SAC1C,CAAC,CAAC;;;;;;;;;IASA,OAAO;;QACV,MAAM,QAAQ,GAAG,IAAI,CAAC,gCAAgC,CAAC,SAAS,CAAC,CAAC;QAClE,IAAI,QAAQ,EAAE;YACV,OAAO,YAAY,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;SAC3C;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOE,UAAU,CAAC,OAAe;;QAC7B,IAAI,QAAQ,GAAG,IAAI,CAAC,gCAAgC,CAAC,SAAS,CAAC,CAAC;QAChE,IAAI,OAAO,EAAE;YACT,IAAI,iBAAiB,CAAC,QAAQ,CAAC,EAAE;;gBAE7B,QAAQ,GAAG,IAAI,CAAC,kCAAkC,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;aAC1E;iBAAM;gBACH,YAAY,CAAC,4BAA4B,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;aAChE;SACJ;aAAM;YACH,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE;;gBAE9B,IAAI,CAAC,kCAAkC,CAAC,SAAS,CAAC,CAAC;aACtD;SACJ;;;;;;;;IAQE,KAAK;;QACR,MAAM,YAAY,GAAc,IAAI,CAAC,6BAA6B,EAAE,CAAC;QACrE,OAAO,YAAY,CAAC,GAAG,CAAC,IAAI;YACxB,OAAO;gBACH,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC;gBAC/B,IAAI,EAAE,YAAY,CAAC,SAAS,CAAC,IAAI,CAAC;aACrC,CAAC;SACL,CAAC,CAAC;;;;;;;;IAQA,gBAAgB;QACnB,OAAO,IAAI,CAAC;;;;;;;;IAQT,QAAQ,CAAC,QAAiB;QAC7B,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE;YAC9B,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;SAC7B;QACD,IAAI,CAAC,+BAA+B,EAAE,CAAC;QACvC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE;YAC9B,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI;;gBAClB,MAAM,QAAQ,GAAG,IAAI,CAAC,kCAAkC,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;aAClF,CAAC,CAAC;SACN;;;;;;;IAOK,eAAe,CAAC,WAAmB;;QACzC,IAAI,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC5E,IAAI,CAAC,MAAM,EAAE;;YACT,MAAM,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YAC9E,MAAM,GAAG,YAAY,CAAC,sBAAsB,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;SAClE;QACD,YAAY,CAAC,4BAA4B,CAAC,MAAM,oBAAW,WAAW,EAAC,CAAC;QACxE,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;KACzC;;;;;;;;;;;IAQM,uBAAuB,CAAC,aAAsB,EAAE,WAAoB,EAAE,UAAoC;;QAC7G,MAAM,OAAO,qBAAa,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,EAAC;;QACxD,MAAM,KAAK,GAAG,IAAI,cAAc,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;QAChE,KAAK,CAAC,iBAAiB,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;QACpD,OAAO,KAAK,CAAC;;;;;;;;;IAOV,iBAAiB,CAAC,aAAsB,EAAE,WAAoB;;QACjE,MAAM,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;;QAC9E,IAAI,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC5E,IAAI,CAAC,MAAM,EAAE;YACT,MAAM,GAAG,YAAY,CAAC,sBAAsB,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;SAClE;QACD,IAAI,aAAa,IAAI,WAAW,EAAE;;YAC9B,MAAM,YAAY,GAAG,YAAY,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;;YACxD,IAAI,eAAe,GAAG,YAAY,CAAC;YACnC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,EAAE;gBAClC,eAAe,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC,4BAA4B,EAAE;sBACzE,YAAY;sBACZ,IAAI,CAAC,uBAAuB,EAAE,CAAC,2BAA2B,EAAE,CAAC;aACtE;YACD,YAAY,CAAC,4BAA4B,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;SACtE;aAAM;YACH,YAAY,CAAC,4BAA4B,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;SACzD;QACD,IAAI,aAAa,EAAE;YACf,MAAM,CAAC,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC,CAAC;SACzE;aAAM;YACH,MAAM,CAAC,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC,CAAC;SACvE;;CAER;;;;;;AC5cD;;;;;AAcA,eAAuB,SAAQ,+BAA+B;;;;;;;;IAU1D,YAAY,SAAiB,EAAE,IAAY,EAAE,QAAgB;QACzD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,gCAAgC,GAAG,CAAC,CAAC;QAC1C,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;KACzD;;;;;;;IAEO,qBAAqB,CAAC,SAAiB,EAAE,IAAY,EAAE,QAAgB;QAC3E,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;;QAC7C,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QACrE,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,uEAAuE,EAAE,IAAI,CAAC,CAAC,CAAC;SAC1G;aAAM;;YACH,MAAM,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;;YAC1D,MAAM,eAAe,GAAG,KAAK,CAAC;YAC9B,IAAI,OAAO,KAAK,eAAe,EAAE;gBAC7B,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,yEAAyE,EAC5F,IAAI,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC,CAAC;aACxC;SACJ;QACD,OAAO,IAAI,CAAC;;;;;;;;IAQT,UAAU;QACb,OAAO,cAAc,CAAC;;;;;;;IAOnB,QAAQ;QACX,OAAO,gBAAgB,CAAC;;;;;;;;IAQlB,wBAAwB;QAC9B,OAAO,CAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,YAAY,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;KAClG;;;;IAES,oBAAoB;QAC1B,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;;QACrB,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,YAAY,CAAC,CAAC;QACjF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC9C,MAAM,SAAS,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;YAC3C,MAAM,EAAE,GAAG,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YACxC,IAAI,CAAC,EAAE,EAAE;gBACL,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,qEAAqE,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;aACtH;YACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,SAAS,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC;SACjE;KACJ;;;;;IAMM,cAAc;;QACjB,MAAM,QAAQ,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;QACrF,IAAI,QAAQ,EAAE;YACV,OAAO,QAAQ,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAC;SACnD;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOE,iBAAiB,CAAC,QAAgB;;QACrC,MAAM,QAAQ,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;QACrF,IAAI,QAAQ,EAAE;YACV,QAAQ,CAAC,YAAY,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;SACtD;;;;;;IAOE,cAAc;;QACjB,MAAM,QAAQ,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;QACrF,IAAI,QAAQ,EAAE;YACV,OAAO,QAAQ,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAC;SACnD;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOE,iBAAiB,CAAC,QAAgB;;QACrC,MAAM,QAAQ,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;QACrF,IAAI,QAAQ,EAAE;YACV,QAAQ,CAAC,YAAY,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;SACtD;;;;;;;;;;;;;;;;;;;;;;;;IAyBL,kBAAkB,CAAC,gBAA4B,EAAE,aAAsB,EAAE,WAAoB,EAAE,kBAA+B;QAE1H,IAAI,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,EAAE,CAAC,EAAE;YAC3C,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,wDAAwD,EAAE,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC;SAC1G;;QACD,MAAM,KAAK,GAAG,mBAAqB,gBAAgB,GAAE,uBAAuB,CAAC,aAAa,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;;QAC/G,MAAM,WAAW,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;QACxF,IAAI,CAAC,WAAW,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,yEAAyE,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;SACtH;;QACD,IAAI,QAAQ,GAAG,KAAK,CAAC;;QACrB,IAAI,wBAAwB,GAAG,KAAK,CAAC;QACrC,IAAI,CAAC,CAAC,kBAAkB,EAAE;;YACtB,MAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;YACnE,IAAI,CAAC,CAAC,cAAc,EAAE;gBAClB,wBAAwB,GAAG,IAAI,CAAC;aACnC;SACJ;QACD,IAAI,kBAAkB,KAAK,SAAS,KAAK,kBAAkB,IAAI,CAAC,wBAAwB,CAAC,EAAE;YACvF,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;YAC9C,QAAQ,GAAG,IAAI,CAAC;SACnB;aAAM,IAAI,kBAAkB,KAAK,IAAI,EAAE;;YACpC,MAAM,gBAAgB,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;YACnG,IAAI,gBAAgB,EAAE;gBAClB,YAAY,CAAC,YAAY,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,gBAAgB,CAAC,CAAC;gBAClE,QAAQ,GAAG,IAAI,CAAC;aACnB;iBAAM;;gBAEH,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;gBAC9C,QAAQ,GAAG,IAAI,CAAC;aACnB;SACJ;aAAM;;YACH,MAAM,cAAc,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,YAAY,EAAE,kBAAkB,CAAC,EAAE,CAAC,CAAC;YACxH,IAAI,cAAc,EAAE;gBAChB,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,cAAc,CAAC,CAAC;gBAC/D,QAAQ,GAAG,IAAI,CAAC;aACnB;SACJ;QACD,IAAI,QAAQ,EAAE;YACV,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAChC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC5B,IAAI,CAAC,YAAY,EAAE,CAAC;YACpB,OAAO,KAAK,CAAC;SAChB;aAAM;YACN,OAAO,IAAI,CAAC;SACZ;KACJ;;;;;;;;;;;;;;;;IAgBM,4BAA4B,CAAC,IAAY,EAAE,QAAgB,EAAE,aAAsB,EAAE,WAAoB;;QAE5G,MAAM,eAAe,GAAG,IAAI,SAAS,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QACvF,eAAe,CAAC,4BAA4B,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACjE,eAAe,CAAC,2BAA2B,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC/D,eAAe,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACxC,eAAe,CAAC,gBAAgB,CAAC,CAAC,SAAqB;YACnD,mBAAqB,SAAS,GAAE,iBAAiB,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;SACjF,CAAC,CAAC;QACH,OAAO,eAAe,CAAC;;CAE9B;;;;;;ACrOD;;;;AAeA,sBAA8B,SAAQ,qBAAqB;;;;;;;;IAS7C,mBAAmB,CAAC,WAAoB,EAAE,OAAsB;;QACtE,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC;QACpC,IAAI,OAAO,KAAK,IAAI,EAAE;;YAUlB,MAAM,IAAI,GAAG,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;YAC9C,IAAI,CAAC,IAAI,EAAE;gBACP,OAAO,IAAI,CAAC;aACf;YACD,IAAI,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,EAAE;;gBAClC,MAAM,KAAK,GAAG,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC;gBACvD,OAAO,CAAC,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;gBACpC,OAAO,KAAK,CAAC;aAChB;iBAAM,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;;gBAClC,MAAM,GAAG,GAAG,IAAI,CAAC,yBAAyB,CAAC,WAAW,CAAC,CAAC;;gBACxD,MAAM,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;gBAClD,IAAI,GAAG,EAAE;oBACL,OAAO,CAAC,WAAW,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;iBACvC;gBACD,OAAO,KAAK,CAAC;aAChB;iBAAM,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;;gBAClC,MAAM,GAAG,GAAG,IAAI,CAAC,yBAAyB,CAAC,WAAW,CAAC,CAAC;gBACxD,IAAI,GAAG,EAAE;oBACL,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;iBAC1B;gBACD,OAAO,KAAK,CAAC;aAChB;iBAAM,IAAI,IAAI,UAAU,EAAE,CAAC,yBAAyB,CAAC,IAAI,CAAC,EAAE;;gBACzD,MAAM,YAAY,GAAG,IAAI,UAAU,EAAE,CAAC,qCAAqC,CAAC,IAAI,CAAC,CAAC;;gBAClF,MAAM,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;gBAClD,OAAO,CAAC,WAAW,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;gBAC7C,OAAO,KAAK,CAAC;aAChB;iBAAM,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;;gBAC/B,MAAM,KAAK,GAAG,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,CAAC;gBACtD,OAAO,CAAC,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;gBACtC,OAAO,KAAK,CAAC;aAChB;SACJ;aAAM,IAAI,OAAO,KAAK,QAAQ,EAAE;;YAE7B,OAAO,KAAK,CAAC;SAChB;QACD,OAAO,IAAI,CAAC;KACf;;;;;;IAOS,iBAAiB,CAAC,IAAU;;QAClC,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC;QACjC,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YACvB,OAAO,IAAI,CAAC;SACf;;QACD,IAAI,UAAU,GAAG,IAAI,CAAC;;QAEtB,IAAI,CAAC,CAAC;QACN,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAClC,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC/B,IAAI,KAAK,CAAC,QAAQ,KAAK,KAAK,CAAC,YAAY,IAAI,mBAAW,KAAK,GAAE,OAAO,KAAK,QAAQ,EAAE;gBACjF,UAAU,GAAG,KAAK,CAAC;gBACnB,MAAM;aACT;SACJ;QACD,IAAI,UAAU,IAAI,UAAU,CAAC,QAAQ,KAAK,UAAU,CAAC,SAAS,EAAE;YAC5D,IAAI,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE;;gBAChD,MAAM,WAAW,GAAG,YAAY,CAAC,aAAa,mBAAW,IAAI,EAAC,CAAC;gBAC/D,IAAI,CAAC,GAAG,CAAC,EAAE;;oBAEP,MAAM,QAAQ,GAAW,IAAI,MAAM,CAAC,0BAA0B,EAAE,GAAG,CAAC,CAAC;oBACrE,OAAO,WAAW,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;iBAC5C;qBAAM;oBACH,OAAO,WAAW,CAAC;iBACtB;aACJ;iBAAM;gBACH,OAAO,IAAI,CAAC;aACf;SACJ;aAAM;YACH,OAAO,IAAI,CAAC;SACf;KACJ;;;;;;;;IAQS,iBAAiB,CAAC,WAAoB,EAAE,OAAsB;KACvE;;;;;;;IAQO,6BAA6B,CAAC,IAAY;;QAC9C,IAAI,WAAW,GAAG,EAAE,CAAC;QAErB,IAAI,IAAI,KAAK,eAAe,EAAE;YAC1B,WAAW,GAAG,GAAG,CAAC;SACrB;aAAM;YACH,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;SACzD;QACD,OAAO,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;;;;;;;;IASpC,4BAA4B,CAAC,IAAY;;QAC7C,IAAI,WAAW,GAAG,EAAE,CAAC;QAErB,IAAI,IAAI,KAAK,KAAK,EAAE;YAChB,WAAW,GAAG,GAAG,CAAC;SACrB;aAAM;YACH,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SAC/C;QACD,OAAO,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;;;;;;;;;IASpC,yBAAyB,CAAC,SAAkB;;QAChD,MAAM,SAAS,GAAG,YAAY,CAAC,wBAAwB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QACzE,IAAI,SAAS,EAAE;;YACX,MAAM,KAAK,GAAG,YAAY,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;YAChD,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;;gBAE1D,OAAO,IAAI,CAAC;aACf;YACD,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;gBACzB,OAAO,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;aAC/C;iBAAM;gBACH,OAAO,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;aAC/C;SACJ;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAGK,0BAA0B,CAAC,OAAsB,EAAE,QAAiB;QAC1E,OAAO,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI;;YACzB,MAAM,KAAK,GAAG,IAAI,CAAC,6BAA6B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;YACjE,IAAI,KAAK,EAAE;gBACP,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aAC/B;SACJ,CAAC,CAAC;KACN;;;;;;IAES,6BAA6B,CAAC,IAAuB,EAAE,QAAiB;QAC9E,QAAQ,IAAI,CAAC,IAAI;YACb,KAAK,qBAAqB,CAAC,IAAI;gBAC3B,OAAO,IAAI,CAAC,iCAAiC,mBAAyB,IAAI,GAAE,QAAQ,CAAC,CAAC;YAC1F,KAAK,qBAAqB,CAAC,SAAS;gBAChC,OAAO,IAAI,CAAC,qCAAqC,oBAA6B,IAAI,IAAG,QAAQ,CAAC,CAAC;YACnG,KAAK,qBAAqB,CAAC,OAAO;gBAC9B,OAAO,IAAI,CAAC,mCAAmC,oBAA2B,IAAI,IAAG,QAAQ,CAAC,CAAC;YAC/F,KAAK,qBAAqB,CAAC,SAAS;gBAChC,OAAO,IAAI,CAAC,qCAAqC,oBAA6B,IAAI,IAAG,QAAQ,CAAC,CAAC;YACnG,KAAK,qBAAqB,CAAC,WAAW;gBAClC,OAAO,IAAI,CAAC,wCAAwC,oBAAgC,IAAI,IAAG,QAAQ,CAAC,CAAC;YACzG,KAAK,qBAAqB,CAAC,eAAe;gBACtC,OAAO,IAAI,CAAC,0CAA0C,oBAAkC,IAAI,IAAG,QAAQ,CAAC,CAAC;SAChH;KACJ;;;;;;;;IAQS,qCAAqC,CAAC,IAA+B,EAAE,QAAiB;;QAC9F,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;QAC1D,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;;QACpC,MAAM,UAAU,GAAG,UAAU,CAAC,0BAA0B,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;QAC3F,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;;QACxC,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC1D,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;QACtF,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAC3B,OAAO,MAAM,CAAC;KACjB;;;;;;;;IAQS,mCAAmC,CAAC,IAA6B,EAAE,QAAiB;;QAC1F,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;QAC1D,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;;QACpC,MAAM,UAAU,GAAG,UAAU,CAAC,0BAA0B,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;QACzE,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;;QACxC,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC1D,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;QACvF,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAC3B,OAAO,MAAM,CAAC;KACjB;;;;;;;;IAQS,qCAAqC,CAAC,IAA+B,EAAE,QAAiB;;QAC9F,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;QAC1D,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;;QACpC,MAAM,UAAU,GAAG,UAAU,CAAC,0BAA0B,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;QAC3F,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;;QACxC,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC1D,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;QACtF,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAC3B,OAAO,MAAM,CAAC;KACjB;;;;;;;;IAQS,wCAAwC,CAAC,IAAkC,EAAE,QAAiB;;QACpG,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;QAC1D,IAAI,UAAU,GAAG,eAAe,CAAC;QACjC,IAAI,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;YAClB,UAAU,GAAG,gBAAgB,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;SAC7D;QACD,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;;QACxC,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC1D,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC;QACtE,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAC3B,OAAO,MAAM,CAAC;KACjB;;;;;;;IAOS,0CAA0C,CAAC,IAAoC,EAAE,QAAiB;;QACxG,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;QAC1D,IAAI,UAAU,GAAG,KAAK,CAAC;QACvB,IAAI,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;YAClB,UAAU,GAAG,MAAM,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;SACnD;QACD,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;;QACxC,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC1D,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC;QACtE,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAC3B,OAAO,MAAM,CAAC;KACjB;CACJ;;;;;;AChSD;;;;AAUA,kBAA0B,SAAQ,iBAAiB;;;;;;IAE/C,YAAY,QAAiB,EAAE,GAAW,EAAE,wBAAkD;QAC1F,KAAK,CAAC,QAAQ,EAAE,GAAG,EAAE,wBAAwB,CAAC,CAAC;KAClD;;;;;;IAOO,OAAO,iBAAiB,CAAC,YAAoB;;QACjD,MAAM,KAAK,GAAG,YAAY,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QAC5C,IAAI,KAAK,GAAG,CAAC,EAAE;YACX,OAAO;gBACH,UAAU,EAAE,YAAY;gBACxB,UAAU,EAAE,CAAC;aAChB,CAAC;SACL;aAAM;YACH,OAAO;gBACH,UAAU,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;gBAC5C,UAAU,EAAE,YAAY,CAAC,eAAe,CAAC,YAAY,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;aAC9E,CAAC;SACL;;;;;;IAGG,OAAO,eAAe,CAAC,gBAAwB;QACnD,OAAO,MAAM,CAAC,QAAQ,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC;;;;;;;IAQ1C,aAAa;;QAChB,IAAI,UAAU,GAAG,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;;QAC3D,MAAM,YAAY,GAAW,uBAAuB,CAAC;QACrD,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;QAClD,OAAO,UAAU,CAAC;;;;;;;;IAQtB,wBAAwB;QACpB,OAAO,KAAK,CAAC;KAChB;;;;;;;;IAQM,gBAAgB,CAAC,UAAkB;;;;;;;IAOhC,aAAa;QACnB,OAAO,IAAI,gBAAgB,EAAE,CAAC;KACjC;;;;;IAKM,6BAA6B;QAChC,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,8BAA8B,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;;;;;;IAM7E,aAAa;;QAEhB,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC;;;;;;;IAOhC,uBAAuB;QACnB,OAAO,IAAI,gBAAgB,EAAE,CAAC,8BAA8B,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,uBAAuB,EAAE,CAAC,CAAC;KAC/G;;;;;;IAMM,iBAAiB;QACpB,OAAO,IAAI,CAAC;;;;;;;;;IAUN,qBAAqB,CAAC,KAAa;QACzC,OAAO,KAAK,CAAC;KAChB;;;;;;;IAOS,qBAAqB,CAAC,WAAmB;QAC/C,OAAO,WAAW,CAAC;KACtB;;;;;;;IAOS,oBAAoB,CAAC,WAAmB;;KAEjD;;;;;;;;;;IAUM,gBAAgB;;QACnB,MAAM,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;;QACpE,MAAM,UAAU,GAAiD,EAAE,CAAC;QACpE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC5C,MAAM,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;YACpC,MAAM,YAAY,GAAW,YAAY,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YAC1D,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC,CAAC;SACjE;QACD,OAAO,UAAU,CAAC;;;;;;;;;IASf,mBAAmB,CAAC,UAAsD;QAC7E,IAAI,CAAC,yBAAyB,EAAE,CAAC;;QACjC,IAAI,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACtD,KAAK,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;;YAC7C,MAAM,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;;YAC1B,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;YACnE,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,GAAG,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACnH,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;YACnD,cAAc,GAAG,MAAM,CAAC;SAC3B;;;;;IAGG,yBAAyB;;QAC7B,MAAM,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;;QACpE,MAAM,WAAW,GAAG,EAAE,CAAC;QACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC5C,MAAM,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACpC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC1B;QACD,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,OAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;;;;;;;;IAQlE,WAAW;QACd,OAAO,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;;;;;;;;;IASvC,OAAO;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;;;;;;;;IAQ1C,gCAAgC;QACnC,OAAO,KAAK,CAAC;;;;;;;IAOV,cAAc,CAAC,WAAmB;;;;;;;;IAQlC,UAAU,CAAC,OAAe;;;;;;;;IAQ1B,KAAK;QACR,OAAO,EAAE,CAAC;;;;;;;;IAQP,gBAAgB;QACnB,OAAO,KAAK,CAAC;;;;;;;;IAQV,QAAQ,CAAC,QAAiB;;;;;;;;;;;;;;IAW1B,uBAAuB,CAAC,aAAsB,EAAE,WAAoB,EAAE,UAAoC;QAC7G,OAAO,IAAI,CAAC;;;;;;;;;IAOT,iBAAiB,CAAC,aAAsB,EAAE,WAAoB;;;;;;;;;;IAU3D,eAAe,CAAC,WAAmB;QACzC,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;KACvE;CAEJ;;;;;;AC7RD;;;AAaA,MAAa,WAAW,GAAG;;;;;;;GAOxB,CAAC;AAEJ,aAAqB,SAAQ,+BAA+B;;;;;;;;;IAWxD,YACY,gCACR,SAAiB,EAAE,IAAY,EAAE,QAAgB;QAEjD,KAAK,EAAE,CAAC;QAHA,mCAA8B,GAA9B,8BAA8B;QAItC,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,gCAAgC,GAAG,CAAC,CAAC;QAC1C,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;KACzD;;;;;;;IAEO,qBAAqB,CAAC,SAAiB,EAAE,IAAY,EAAE,QAAgB;QAC3E,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;QAC7C,IAAI,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;YACzE,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,4EAA4E,EAAE,IAAI,CAAC,CAAC,CAAC;SAC/G;QACD,OAAO,IAAI,CAAC;;;;;IAGN,oBAAoB;QAC1B,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;;QACrB,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;QAC1E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC9C,MAAM,GAAG,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;YACrC,MAAM,EAAE,GAAG,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAClC,IAAI,CAAC,EAAE,EAAE;gBACL,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,8DAA8D,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;aAC/G;YACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,YAAY,CAAC,GAAG,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC;SACzD;KACJ;;;;;;;IAOM,UAAU;QACb,OAAO,UAAU,CAAC;;;;;;;IAOf,QAAQ;QACX,OAAO,YAAY,CAAC;;;;;;;;IAQd,wBAAwB;QAC9B,OAAO,CAAC,SAAS,CAAC,CAAC;KACtB;;;;;;IAOO,yBAAyB;QAC7B,IAAI,IAAI,CAAC,SAAS,EAAE;;YAChB,MAAM,KAAK,GAAa,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAClD,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,WAAW,EAAE,KAAK,KAAK,EAAE;gBACrE,OAAO,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;aAClC;SACJ;QACD,OAAO,IAAI,CAAC;;;;;;;;IAST,cAAc;QACjB,OAAO,IAAI,CAAC,yBAAyB,EAAE,CAAC;;;;;;;;IAQrC,iBAAiB,CAAC,QAAgB;;;;;;;;;IAUlC,cAAc;QACjB,OAAO,IAAI,CAAC,yBAAyB,EAAE,CAAC;;;;;;;;IAQrC,iBAAiB,CAAC,QAAgB;;;;;;;;;;;;;;;;;;;;;;;;;IA0BzC,kBAAkB,CAAC,gBAA4B,EAAE,aAAsB,EAAE,WAAoB,EAAE,kBAA+B;QAE1H,MAAM,KAAK,CAAC,6DAA6D,CAAC,CAAC;KAC9E;;;;;;;;;;;;;;;;IAgBM,4BAA4B,CAAC,IAAY,EAAE,QAAgB,EAAE,aAAsB,EAAE,WAAoB;;QAE5G,MAAM,0BAA0B,GAC5B,0CAA0C,GAAG,WAAW,GAAG,+CAA+C,CAAC;;QAC/G,MAAM,eAAe,GAAG,IAAI,CAAC,8BAA8B,CAAC,yBAAyB,CACjF,UAAU,EACV,0BAA0B,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,EACrD,EAAC,UAAU,EAAE,IAAI,CAAC,aAAa,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAC,CAAC,CAAC;QAC1F,eAAe,CAAC,4BAA4B,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACjE,eAAe,CAAC,2BAA2B,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC/D,eAAe,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACxC,eAAe,CAAC,4BAA4B,CAAC,IAAI,CAAC,4BAA4B,EAAE,CAAC,CAAC;QAClF,eAAe,CAAC,2BAA2B,CAAC,IAAI,CAAC,2BAA2B,EAAE,CAAC,CAAC;QAChF,IAAI,CAAC,gBAAgB,CAAC,CAAC,EAAE;YACrB,eAAe,CAAC,kBAAkB,CAAC,EAAE,EAAE,aAAa,EAAE,WAAW,CAAC,CAAC;SACtE,CAAC,CAAC;QACH,OAAO,eAAe,CAAC;;CAG9B;;;;;;AC9MD;;;;AAcA,yBAAiC,SAAQ,qBAAqB;;;;;;;;IAShD,mBAAmB,CAAC,WAAoB,EAAE,OAAsB;;QACtE,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC;QACpC,IAAI,OAAO,KAAK,IAAI,EAAE;;YAYlB,IAAI,eAAe,GAAG,KAAK,CAAC;;YAC5B,IAAI,KAAK,GAAG,KAAK,CAAC;;YAClB,IAAI,UAAU,GAAG,KAAK,CAAC;;YACvB,MAAM,KAAK,GAAG,WAAW,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;;YAChD,MAAM,IAAI,GAAG,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;;YAC9C,IAAI,WAAW,GAAG,IAAI,CAAC;;YACvB,IAAI,KAAK,GAAG,CAAC,CAAC;;YACd,IAAI,YAAY,GAAG,IAAI,CAAC;YACxB,IAAI,CAAC,KAAK,EAAE;;gBAER,KAAK,GAAG,IAAI,CAAC;gBACb,WAAW,GAAG,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;gBAC7C,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;aAC5C;iBAAM,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;;gBAEhC,KAAK,GAAG,IAAI,CAAC;gBACb,IAAI,KAAK,KAAK,KAAK,EAAE;oBACjB,WAAW,GAAG,GAAG,CAAC;iBACrB;qBAAM;oBACH,WAAW,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;iBAChD;gBACD,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;aAC5C;iBAAM,IAAI,KAAK,CAAC,UAAU,CAAC,eAAe,CAAC,EAAE;gBAC1C,eAAe,GAAG,IAAI,CAAC;gBACvB,IAAI,KAAK,KAAK,eAAe,EAAE;oBAC3B,WAAW,GAAG,GAAG,CAAC;iBACrB;qBAAM;oBACH,WAAW,GAAG,KAAK,CAAC,SAAS,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;iBAC1D;gBACD,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;aAC5C;iBAAM,IAAI,IAAI,UAAU,EAAE,CAAC,yBAAyB,CAAC,KAAK,CAAC,EAAE;gBAC1D,UAAU,GAAG,IAAI,CAAC;gBAClB,YAAY,GAAG,IAAI,UAAU,EAAE,CAAC,qCAAqC,CAAC,KAAK,CAAC,CAAC;aAChF;iBAAM;gBACH,OAAO,IAAI,CAAC;aACf;YACD,IAAI,eAAe,EAAE;gBACjB,OAAO,CAAC,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aACvC;iBAAM,IAAI,KAAK,EAAE;gBACd,OAAO,CAAC,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aACzC;iBAAM,IAAI,UAAU,EAAE;gBACnB,OAAO,CAAC,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC;aACvE;SACJ;aAAM,IAAI,OAAO,KAAK,IAAI,EAAE;;YAGzB,MAAM,eAAe,GAAG,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC;YAC/D,IAAI,eAAe,EAAE;gBACjB,OAAO,CAAC,WAAW,CAAC,eAAe,EAAE,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;aAC3G;SACJ;QACD,OAAO,IAAI,CAAC;KACf;;;;;;;;IAQS,iBAAiB,CAAC,WAAoB,EAAE,OAAsB;;QACpE,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC;QACpC,IAAI,OAAO,KAAK,IAAI,EAAE;;YAGlB,MAAM,eAAe,GAAG,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC;YAC/D,IAAI,eAAe,EAAE;gBACjB,OAAO,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;aACtC;YACD,OAAO;SACV;KACJ;;;;;IAEO,oBAAoB,CAAC,MAAe;;QACxC,IAAI,SAAS,GAAG,MAAM,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QACjD,IAAI,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YAC3B,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;SACtC;QACD,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YACzB,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;SAC5D;QACD,OAAO,SAAS,CAAC;;;;;;;;;IASX,0BAA0B,CAAC,OAAsB,EAAE,QAAiB;;QAC1E,MAAM,KAAK,GAAG,CAAC,EAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAC,CAAC,CAAC;;QACrD,IAAI,EAAE,GAAG,CAAC,CAAC;QACX,OAAO,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI;YACzB,QAAQ,IAAI,CAAC,IAAI;gBACb,KAAK,qBAAqB,CAAC,IAAI;oBAC3B,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,CACvC,IAAI,CAAC,iCAAiC,mBAAyB,IAAI,GAAE,QAAQ,CAAC,CAAC,CAAC;oBACpF,MAAM;gBACV,KAAK,qBAAqB,CAAC,WAAW;oBAClC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,CACvC,IAAI,CAAC,wCAAwC,mBAAgC,IAAI,GAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;oBACxG,MAAM;gBACV,KAAK,qBAAqB,CAAC,eAAe;oBACtC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,CACvC,IAAI,CAAC,0CAA0C,mBAAkC,IAAI,GAAE,QAAQ,CAAC,CAAC,CAAC;oBACtG,MAAM;gBACV,KAAK,qBAAqB,CAAC,SAAS;;oBAChC,MAAM,UAAU,GAAG,IAAI,CAAC,qCAAqC,mBAA6B,IAAI,GAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC;oBAChH,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;oBACxD,KAAK,CAAC,IAAI,CAAC,EAAC,OAAO,oBAAY,UAAU,CAAA,EAAE,OAAO,EAAE,mBAA6B,IAAI,GAAE,OAAO,EAAE,EAAC,CAAC,CAAC;oBACnG,MAAM;gBACV,KAAK,qBAAqB,CAAC,OAAO;;oBAC9B,MAAM,YAAY,GAAG,mBAA2B,IAAI,GAAE,OAAO,EAAE,CAAC;oBAChE,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,OAAO,KAAK,YAAY,EAAE;;wBAEvE,MAAM,IAAI,KAAK,CAAC,uBAAuB,GAAG,YAAY,CAAC,CAAC;qBAC3D;oBACD,KAAK,CAAC,GAAG,EAAE,CAAC;oBACZ,MAAM;gBACV,KAAK,qBAAqB,CAAC,SAAS;;oBAChC,MAAM,YAAY,GAAG,IAAI,CAAC,qCAAqC,mBAA6B,IAAI,GAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC;oBAClH,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;oBAC1D,MAAM;aACb;SACJ,CAAC,CAAC;QACH,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;;YAEpB,MAAM,IAAI,KAAK,CAAC,oBAAoB,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;SAC3E;KACJ;;;;;;;;;;;IAWS,qCAAqC,CAAC,IAA+B,EAAE,QAAiB,EAAE,EAAU;;QAC1G,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;;QACpC,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;QAC1D,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;;QAC/B,MAAM,UAAU,GAAG,UAAU,CAAC,0BAA0B,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;;QACpF,MAAM,QAAQ,GAAG,UAAU,CAAC,0BAA0B,CAAC,OAAO,CAAC,CAAC;;QAChE,MAAM,SAAS,GAAG,GAAG,GAAG,OAAO,GAAG,GAAG,CAAC;;QACtC,MAAM,OAAO,GAAG,IAAI,GAAG,OAAO,GAAG,GAAG,CAAC;QACrC,MAAM,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3C,MAAM,CAAC,YAAY,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;QAC9C,MAAM,CAAC,YAAY,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QAC1C,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC;QACzD,MAAM,CAAC,YAAY,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;QAC5C,MAAM,CAAC,YAAY,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QACxC,OAAO,MAAM,CAAC;KACjB;;;;;;;;IAQS,mCAAmC,CAAC,IAA6B,EAAE,QAAiB;;QAE1F,OAAO,IAAI,CAAC;KACf;;;;;;;;;;IAUS,qCAAqC,CAAC,IAA+B,EAAE,QAAiB,EAAE,EAAU;;QAC1G,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;;QACpC,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;QAC1D,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;;QAC/B,MAAM,KAAK,GAAG,UAAU,CAAC,0BAA0B,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;;QAC/E,MAAM,IAAI,GAAG,GAAG,GAAG,OAAO,GAAG,IAAI,CAAC;QAClC,MAAM,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3C,MAAM,CAAC,YAAY,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACpC,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC;QACzD,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAClC,OAAO,MAAM,CAAC;KACjB;;;;;IAEO,aAAa,CAAC,GAAW;QAC7B,QAAQ,GAAG,CAAC,WAAW,EAAE;YACrB,KAAK,IAAI,CAAC;YACV,KAAK,GAAG,CAAC;YACT,KAAK,GAAG,CAAC;YACT,KAAK,GAAG;gBACJ,OAAO,KAAK,CAAC;YACjB,KAAK,KAAK;gBACN,OAAO,OAAO,CAAC;YACnB,KAAK,GAAG;gBACJ,OAAO,MAAM,CAAC;YAClB;gBACI,OAAO,OAAO,CAAC;SACtB;;;;;;;;;;IAUK,wCAAwC,CAAC,IAAkC,EAAE,QAAiB,EAAE,EAAU;;QAChH,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;QAC1D,IAAI,WAAW,GAAG,eAAe,CAAC;QAClC,IAAI,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;YAClB,WAAW,GAAG,gBAAgB,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;SAC9D;QACD,MAAM,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3C,MAAM,CAAC,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;;QAC1C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QACzB,IAAI,IAAI,EAAE;YACN,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SACrC;QACD,OAAO,MAAM,CAAC;KACjB;;;;;;;IAOS,0CAA0C,CAAC,IAAoC,EAAE,QAAiB;;QACxG,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;QAC1D,IAAI,WAAW,GAAG,KAAK,CAAC;QACxB,IAAI,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;YAClB,WAAW,GAAG,MAAM,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;SACpD;QACD,MAAM,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;QACrD,MAAM,CAAC,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;;QAC1C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QACzB,IAAI,IAAI,EAAE;YACN,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SACrC;QACD,OAAO,MAAM,CAAC;KACjB;CAEJ;;;;;;AC7RD;;;;AAgBA,qBAA6B,SAAQ,iBAAiB;;;;;;IAElD,YAAY,QAAiB,EAAE,GAAW,EAAE,wBAAkD;QAC1F,KAAK,CAAC,QAAQ,EAAE,GAAG,EAAE,wBAAwB,CAAC,CAAC;KAClD;;;;IAEM,aAAa;;QAChB,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,OAAO,YAAY,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;;;;;;;;;IAS9C,gBAAgB,CAAC,UAAkB;;QACtC,IAAI,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC5E,IAAI,CAAC,MAAM,EAAE;;YAET,MAAM,OAAO,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;YAChF,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC;SAChG;QACD,YAAY,CAAC,4BAA4B,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;;;;;;IAMxD,aAAa;QACnB,OAAO,IAAI,mBAAmB,EAAE,CAAC;KACpC;;;;;IAKM,6BAA6B;;QAChC,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,IAAI,aAAa,EAAE;YACf,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,8BAA8B,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;SACnF;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;IAME,aAAa;;QAChB,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,OAAO,YAAY,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;;;;;;;IAOrD,uBAAuB;;QACnB,MAAM,aAAa,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACrF,OAAO,IAAI,mBAAmB,EAAE,CAAC,8BAA8B,CAAC,aAAa,EAAE,IAAI,CAAC,uBAAuB,EAAE,CAAC,CAAC;KAClH;;;;;IAKM,iBAAiB;;QACpB,MAAM,cAAc,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;QACvF,IAAI,cAAc,EAAE;YAChB,OAAO,cAAc,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;SAC/C;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOK,oBAAoB,CAAC,WAAmB;;QAC9C,MAAM,cAAc,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;QACvF,IAAI,cAAc,EAAE;YAChB,cAAc,CAAC,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;SACrD;KACJ;;;;;;;;IASS,qBAAqB,CAAC,KAAa;QACzC,QAAS,KAAK;YACV,KAAK,SAAS;gBACV,OAAO,SAAS,CAAC;YACrB,KAAK,gBAAgB;gBACjB,OAAO,YAAY,CAAC;YACxB,KAAK,WAAW;gBACZ,OAAO,OAAO,CAAC;YACnB;gBACI,MAAM,IAAI,KAAK,CAAC,gBAAgB,GAAI,KAAK,CAAC,CAAC;SAClD;KACJ;;;;;;;IAOS,qBAAqB,CAAC,WAAmB;QAC/C,QAAS,WAAW;YAChB,KAAK,SAAS;gBACV,OAAO,SAAS,CAAC;YACrB,KAAK,YAAY;gBACb,OAAO,gBAAgB,CAAC;YAC5B,KAAK,UAAU;;gBACX,OAAO,gBAAgB,CAAC;YAC5B,KAAK,OAAO;gBACR,OAAO,WAAW,CAAC;YACvB;gBACI,OAAO,SAAS,CAAC;SACxB;KACJ;;;;;;;;;;IAUM,gBAAgB;;QAEnB,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;;QAChE,MAAM,UAAU,GAAiD,EAAE,CAAC;QACpE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC1C,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtC,IAAI,QAAQ,CAAC,YAAY,CAAC,UAAU,CAAC,KAAK,UAAU,EAAE;;gBAClD,MAAM,YAAY,GAAW,YAAY,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;gBAC9D,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC,CAAC;aACzD;SACJ;QACD,OAAO,UAAU,CAAC;;;;;;;IAQd,iBAAiB,CAAC,YAAoB;;QAC1C,MAAM,KAAK,GAAG,YAAY,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QAC5C,IAAI,KAAK,GAAG,CAAC,EAAE;YACX,OAAO;gBACH,UAAU,EAAE,YAAY;gBACxB,UAAU,EAAE,CAAC;aAChB,CAAC;SACL;aAAM;YACH,OAAO;gBACH,UAAU,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;gBAC5C,UAAU,EAAE,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;aACtE,CAAC;SACL;;;;;;IAGG,eAAe,CAAC,gBAAwB;QAC5C,OAAO,MAAM,CAAC,QAAQ,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC;;;;;;;;;IAS1C,mBAAmB,CAAC,UAAsD;QAC7E,IAAI,CAAC,yBAAyB,EAAE,CAAC;;QACjC,IAAI,YAAY,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACjF,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,IAAI,YAAY,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;;YAErG,YAAY,CAAC,UAAU,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;YAClD,OAAO;SACV;QACD,IAAI,iBAAiB,CAAC,YAAY,CAAC,EAAE;YACjC,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YAClE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;SAC9E;QACD,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG;;YACnB,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;YAC/D,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;YAC1C,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,GAAG,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACjH,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;SAClC,CAAC,CAAC;;;;;IAGC,yBAAyB;;QAC7B,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;;QAChE,MAAM,WAAW,GAAG,EAAE,CAAC;QACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC1C,MAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAClC,IAAI,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,KAAK,UAAU,EAAE;gBAC9C,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAC1B;SACJ;QACD,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,OAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;;;;;;;;IAQlE,WAAW;;QACd,MAAM,QAAQ,GAAG,IAAI,CAAC,oCAAoC,CAAC,aAAa,CAAC,CAAC;QAC1E,IAAI,QAAQ,EAAE;YACV,OAAO,YAAY,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;SAC3C;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOE,cAAc,CAAC,WAAmB;;QACrC,MAAM,QAAQ,GAAG,IAAI,CAAC,oCAAoC,CAAC,aAAa,CAAC,CAAC;QAC1E,IAAI,WAAW,EAAE;YACb,IAAI,iBAAiB,CAAC,QAAQ,CAAC,EAAE;;gBAE7B,IAAI,CAAC,sCAAsC,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;aAC3E;iBAAM;gBACH,YAAY,CAAC,4BAA4B,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;aACpE;SACJ;aAAM;YACH,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE;;gBAE9B,IAAI,CAAC,sCAAsC,CAAC,aAAa,CAAC,CAAC;aAC9D;SACJ;;;;;;;IAQG,oCAAoC,CAAC,SAAiB;;QAC1D,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;QAChE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC1C,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtC,IAAI,QAAQ,CAAC,YAAY,CAAC,UAAU,CAAC,KAAK,SAAS,EAAE;gBACjD,OAAO,QAAQ,CAAC;aACnB;SACJ;QACD,OAAO,IAAI,CAAC;;;;;;IAOR,6BAA6B;;QACjC,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;;QAChE,MAAM,MAAM,GAAc,EAAE,CAAC;QAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC1C,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;YACtC,MAAM,aAAa,GAAG,QAAQ,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;YACxD,IAAI,aAAa,KAAK,aAAa,IAAI,aAAa,KAAK,SAAS,EAAE;gBAChE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aACzB;SACJ;QACD,OAAO,MAAM,CAAC;;;;;;;;IASV,sCAAsC,CAAC,SAAiB,EAAE,OAAe;;QAC7E,IAAI,YAAY,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACjF,IAAI,iBAAiB,CAAC,YAAY,CAAC,EAAE;;YAEjC,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YAClE,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;SAC3C;;QACD,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;QACtE,IAAI,SAAS,EAAE;YACX,WAAW,CAAC,YAAY,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;SACnD;QACD,IAAI,OAAO,EAAE;YACT,YAAY,CAAC,4BAA4B,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;SACnE;QACD,YAAY,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QACtC,OAAO,WAAW,CAAC;;;;;IAGf,yBAAyB;;QAC7B,MAAM,YAAY,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACnF,IAAI,YAAY,EAAE;;YACd,MAAM,SAAS,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;YAC/E,IAAI,CAAC,SAAS,EAAE;;gBAEZ,YAAY,CAAC,UAAU,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;aACrD;SACJ;;;;;;;IAOG,sCAAsC,CAAC,SAAiB;;QAC5D,MAAM,WAAW,GAAG,IAAI,CAAC,oCAAoC,CAAC,SAAS,CAAC,CAAC;QACzE,IAAI,WAAW,EAAE;YACb,WAAW,CAAC,UAAU,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;SACnD;QACD,IAAI,CAAC,yBAAyB,EAAE,CAAC;;;;;;IAM7B,+BAA+B;;QACnC,MAAM,YAAY,GAAG,IAAI,CAAC,6BAA6B,EAAE,CAAC;QAC1D,YAAY,CAAC,OAAO,CAAC,CAAC,WAAW;YAC7B,WAAW,CAAC,UAAU,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;SACnD,CAAC,CAAC;QACH,IAAI,CAAC,yBAAyB,EAAE,CAAC;;;;;;;;;IAS9B,OAAO;;QACV,MAAM,QAAQ,GAAG,IAAI,CAAC,oCAAoC,CAAC,SAAS,CAAC,CAAC;QACtE,IAAI,QAAQ,EAAE;YACV,OAAO,YAAY,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;SAC3C;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOE,UAAU,CAAC,OAAe;;QAC7B,MAAM,QAAQ,GAAG,IAAI,CAAC,oCAAoC,CAAC,SAAS,CAAC,CAAC;QACtE,IAAI,OAAO,EAAE;YACT,IAAI,iBAAiB,CAAC,QAAQ,CAAC,EAAE;;gBAE7B,IAAI,CAAC,sCAAsC,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;aACnE;iBAAM;gBACH,YAAY,CAAC,4BAA4B,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;aAChE;SACJ;aAAM;YACH,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE;;gBAE9B,IAAI,CAAC,sCAAsC,CAAC,SAAS,CAAC,CAAC;aAC1D;SACJ;;;;;;;;IAQE,KAAK;;QACR,MAAM,YAAY,GAAc,IAAI,CAAC,6BAA6B,EAAE,CAAC;QACrE,OAAO,YAAY,CAAC,GAAG,CAAC,IAAI;YACxB,OAAO;gBACH,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;gBACnC,IAAI,EAAE,YAAY,CAAC,SAAS,CAAC,IAAI,CAAC;aACrC,CAAC;SACL,CAAC,CAAC;;;;;;;;IAQA,gBAAgB;QACnB,OAAO,IAAI,CAAC;;;;;;;IAOT,QAAQ,CAAC,QAAiB;QAC7B,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE;YAC9B,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;SAC7B;QACD,IAAI,CAAC,+BAA+B,EAAE,CAAC;QACvC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE;YAC9B,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI;gBAClB,IAAI,CAAC,sCAAsC,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;aACrE,CAAC,CAAC;SACN;;;;;;;IAOK,eAAe,CAAC,WAAmB;;QACzC,IAAI,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC5E,IAAI,CAAC,MAAM,EAAE;;YACT,MAAM,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YAC9E,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC/F;QACD,YAAY,CAAC,4BAA4B,CAAC,MAAM,oBAAW,WAAW,EAAC,CAAC;QACxE,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;KACzC;;;;;;;;;;;IAQM,uBAAuB,CAAC,aAAsB,EAAE,WAAoB,EAAE,UAAoC;;QAC7G,MAAM,OAAO,qBAAa,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,EAAC;;QACxD,MAAM,KAAK,GAAG,IAAI,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;QACjE,KAAK,CAAC,iBAAiB,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;QACpD,OAAO,KAAK,CAAC;;;;;;;;;IAOV,iBAAiB,CAAC,aAAsB,EAAE,WAAoB;;QACjE,MAAM,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;;QAC9E,IAAI,MAAM,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC5E,IAAI,CAAC,MAAM,EAAE;YACT,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC/F;QACD,IAAI,aAAa,IAAI,WAAW,EAAE;;YAC9B,MAAM,YAAY,GAAG,YAAY,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;;YACxD,IAAI,eAAe,GAAG,YAAY,CAAC;YACnC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,EAAE;gBAClC,eAAe,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC,4BAA4B,EAAE;sBACzE,YAAY;sBACZ,IAAI,CAAC,uBAAuB,EAAE,CAAC,2BAA2B,EAAE,CAAC;aACtE;YACD,YAAY,CAAC,4BAA4B,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;SACtE;aAAM;YACH,YAAY,CAAC,4BAA4B,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;SACzD;;QACD,MAAM,OAAO,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;QAChF,IAAI,OAAO,EAAE;YACT,IAAI,aAAa,EAAE;gBACf,OAAO,CAAC,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC,CAAC;aAC1E;iBAAM;gBACH,OAAO,CAAC,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC,CAAC;aACxE;SACJ;;CAGR;;;;;;ACveD;;;;;;;AAgBA,gBAAwB,SAAQ,+BAA+B;;;;;;;;IAU3D,YAAY,SAAiB,EAAE,IAAY,EAAE,QAAgB;QACzD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,gCAAgC,GAAG,CAAC,CAAC;QAC1C,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;KACzD;;;;;;;IAEO,qBAAqB,CAAC,SAAiB,EAAE,IAAY,EAAE,QAAgB;QAC3E,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;;QAC7C,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QACrE,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,uEAAuE,EAAE,IAAI,CAAC,CAAC,CAAC;SAC1G;aAAM;;YACH,MAAM,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;;YAC1D,MAAM,eAAe,GAAG,KAAK,CAAC;YAC9B,IAAI,OAAO,KAAK,eAAe,EAAE;gBAC7B,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,uEAAuE,EAC1F,IAAI,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC,CAAC;aACxC;SACJ;QACD,OAAO,IAAI,CAAC;;;;;;;;IAQT,UAAU;QACb,OAAO,cAAc,CAAC;;;;;;;IAOnB,QAAQ;QACX,OAAO,gBAAgB,CAAC;;;;;;;;IAQlB,wBAAwB;QAC9B,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;KACxE;;;;IAES,oBAAoB;QAC1B,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;;QACrB,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;QAC3E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC9C,MAAM,SAAS,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;YAC3C,MAAM,EAAE,GAAG,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YACxC,IAAI,CAAC,EAAE,EAAE;gBACL,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,qEAAqE,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;aACtH;YACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,SAAS,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC;SAClE;KACJ;;;;;IAMM,cAAc;;QACjB,MAAM,SAAS,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;QACvF,IAAI,SAAS,EAAE;YACX,OAAO,SAAS,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;SAC5C;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOE,iBAAiB,CAAC,QAAgB;;QACrC,MAAM,SAAS,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;QACvF,IAAI,SAAS,EAAE;YACX,SAAS,CAAC,YAAY,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;SAC/C;;;;;;IAOE,cAAc;;QACjB,MAAM,SAAS,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;QACvF,IAAI,SAAS,EAAE;YACX,OAAO,SAAS,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;SAC5C;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOE,iBAAiB,CAAC,QAAgB;;QACrC,MAAM,SAAS,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;QACvF,IAAI,SAAS,EAAE;YACX,SAAS,CAAC,YAAY,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;SAC/C;;;;;;;;;;;;;;;;;;;;;;;;IAyBL,kBAAkB,CAAC,gBAA4B,EAAE,aAAsB,EAAE,WAAoB,EAAE,kBAA+B;QAE1H,IAAI,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,EAAE,CAAC,EAAE;YAC3C,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,wDAAwD,EAAE,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC;SAC1G;;QACD,MAAM,KAAK,GAAG,mBAAqB,gBAAgB,GAAE,uBAAuB,CAAC,aAAa,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;;QAC/G,MAAM,WAAW,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;QACxF,IAAI,CAAC,WAAW,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,yEAAyE,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;SACtH;;QACD,IAAI,QAAQ,GAAG,KAAK,CAAC;;QACrB,IAAI,wBAAwB,GAAG,KAAK,CAAC;QACrC,IAAI,CAAC,CAAC,kBAAkB,EAAE;;YACtB,MAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;YACnE,IAAI,CAAC,CAAC,cAAc,EAAE;gBAClB,wBAAwB,GAAG,IAAI,CAAC;aACnC;SACJ;QACD,IAAI,kBAAkB,KAAK,SAAS,KAAK,kBAAkB,IAAI,CAAC,wBAAwB,CAAC,EAAE;YACvF,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;YAC9C,QAAQ,GAAG,IAAI,CAAC;SACnB;aAAM,IAAI,kBAAkB,KAAK,IAAI,EAAE;;YACpC,MAAM,gBAAgB,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;YAC7F,IAAI,gBAAgB,EAAE;gBAClB,YAAY,CAAC,YAAY,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,gBAAgB,CAAC,CAAC;gBAClE,QAAQ,GAAG,IAAI,CAAC;aACnB;iBAAM;;gBAEH,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;gBAC9C,QAAQ,GAAG,IAAI,CAAC;aACnB;SACJ;aAAM;;YACH,MAAM,cAAc,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,EAAE,kBAAkB,CAAC,EAAE,CAAC,CAAC;YAClH,IAAI,cAAc,EAAE;gBAChB,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,cAAc,CAAC,CAAC;gBAC/D,QAAQ,GAAG,IAAI,CAAC;aACnB;SACJ;QACD,IAAI,QAAQ,EAAE;YACV,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAChC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC5B,IAAI,CAAC,YAAY,EAAE,CAAC;YACpB,OAAO,KAAK,CAAC;SAChB;aAAM;YACH,OAAO,IAAI,CAAC;SACf;KACJ;;;;;;;;;;;;;;;;IAgBM,4BAA4B,CAAC,IAAY,EAAE,QAAgB,EAAE,aAAsB,EAAE,WAAoB;;QAE5G,MAAM,eAAe,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QACxF,eAAe,CAAC,4BAA4B,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACjE,eAAe,CAAC,2BAA2B,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC/D,eAAe,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACxC,eAAe,CAAC,gBAAgB,CAAC,CAAC,SAAqB;YACnD,mBAAqB,SAAS,GAAE,iBAAiB,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;SACjF,CAAC,CAAC;QACH,OAAO,eAAe,CAAC;;CAE9B;;;;;;ACvOD;;;;AAeA,kBAA0B,SAAQ,iBAAiB;;;;;;;IAI/C,YAAY,QAAiB,EAAE,GAAW,EAAE,wBAAkD,EAClF,0BAA6C;QACrD,KAAK,CAAC,QAAQ,EAAE,GAAG,EAAE,wBAAwB,CAAC,CAAC;QAC/C,IAAI,CAAC,0BAA0B,GAAG,0BAA0B,CAAC;KAChE;;;;;;IAOM,aAAa;QAChB,IAAI,IAAI,CAAC,0BAA0B,EAAE;YACjC,OAAO,IAAI,CAAC,0BAA0B,CAAC,aAAa,EAAE,CAAC;SAC1D;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;;IAQL,wBAAwB;QACpB,OAAO,KAAK,CAAC;KAChB;;;;;;;;IAQM,gBAAgB,CAAC,UAAkB;;;;;;;IAOhC,aAAa;QACnB,OAAO,IAAI,gBAAgB,EAAE,CAAC;KACjC;;;;;IAKM,6BAA6B;QAChC,IAAI,IAAI,CAAC,0BAA0B,EAAE;YACjC,OAAO,IAAI,CAAC,0BAA0B,CAAC,6BAA6B,EAAE,CAAC;SAC1E;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;IAME,aAAa;QAChB,OAAO,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;;;;;;;IAOrD,uBAAuB;QACnB,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,8BAA8B,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,uBAAuB,EAAE,CAAC,CAAC;KAC7G;;;;;;;IAOM,iBAAiB;QACpB,IAAI,IAAI,CAAC,0BAA0B,EAAE;;YACjC,MAAM,aAAa,GAAG,IAAI,CAAC,0BAA0B,CAAC,aAAa,EAAE,CAAC;YACtE,IAAI,CAAC,aAAa,IAAI,aAAa,KAAK,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE;gBACnF,OAAO,KAAK,CAAC;aAChB;iBAAM;gBACH,OAAO,OAAO,CAAC;aAClB;SACJ;QACD,OAAO,IAAI,CAAC;;;;;;;;;IAUN,qBAAqB,CAAC,KAAa;QACzC,OAAO,KAAK,CAAC;KAChB;;;;;;;IAOS,qBAAqB,CAAC,WAAmB;QAC/C,OAAO,WAAW,CAAC;KACtB;;;;;;;IAOS,oBAAoB,CAAC,WAAmB;;KAEjD;;;;;;;;;;IAUM,gBAAgB;QACnB,IAAI,IAAI,CAAC,0BAA0B,EAAE;YACjC,OAAO,IAAI,CAAC,0BAA0B,CAAC,gBAAgB,EAAE,CAAC;SAC7D;aAAM;YACH,OAAO,EAAE,CAAC;SACb;;;;;;;;IAQE,2BAA2B;QAC9B,OAAO,KAAK,CAAC;;;;;;;;;IASV,mBAAmB,CAAC,UAAsD;;;;;;;;;IAS1E,WAAW;QACd,IAAI,IAAI,CAAC,0BAA0B,EAAE;YACjC,OAAO,IAAI,CAAC,0BAA0B,CAAC,WAAW,EAAE,CAAC;SACxD;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;;;IASE,OAAO;QACV,IAAI,IAAI,CAAC,0BAA0B,EAAE;YACjC,OAAO,IAAI,CAAC,0BAA0B,CAAC,OAAO,EAAE,CAAC;SACpD;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;;IAQE,gCAAgC;QACnC,OAAO,KAAK,CAAC;;;;;;;IAOV,cAAc,CAAC,WAAmB;;;;;;;;IAQlC,UAAU,CAAC,OAAe;;;;;;;;IAQ1B,KAAK;QACR,OAAO,EAAE,CAAC;;;;;;;;IAQP,gBAAgB;QACnB,OAAO,KAAK,CAAC;;;;;;;;IAQV,QAAQ,CAAC,QAAiB;;;;;;;;;;;;;;IAW1B,uBAAuB,CAAC,aAAsB,EAAE,WAAoB,EAAE,UAAoC;QAC7G,OAAO,IAAI,CAAC;;;;;;;;;IAOT,iBAAiB,CAAC,aAAsB,EAAE,WAAoB;;;;;;;;IAQ3D,eAAe,CAAC,WAAmB;;QACzC,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC7B,IAAI,iBAAiB,CAAC,WAAW,CAAC,EAAE;YAChC,WAAW,GAAG,EAAE,CAAC;SACpB;QACD,YAAY,CAAC,4BAA4B,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;KAClE;CAEJ;;;;;;ACrRD;;;;;AAYA,aAAqB,SAAQ,+BAA+B;;;;;;;;;;;IAiBxD,YAAoB,8BAA+D,EACvE,SAAiB,EAAE,IAAY,EAAE,QAAgB,EACjD,cAAuE;QAC/E,KAAK,EAAE,CAAC;QAHQ,mCAA8B,GAA9B,8BAA8B,CAAiC;QAI/E,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,gCAAgC,GAAG,CAAC,CAAC;QAC1C,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;KACzE;;;;;;;;IAEO,qBAAqB,CAAC,SAAiB,EAAE,IAAY,EAAE,QAAgB,EACjD,cAAuE;QACjG,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;QAC7C,IAAI,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,mBAAmB,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7E,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,gFAAgF,EAAE,IAAI,CAAC,CAAC,CAAC;SACnH;QACD,IAAI,cAAc,EAAE;YAChB,IAAI;gBACA,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,8BAA8B,CAAC,yBAAyB,CAC5E,UAAU,EACV,cAAc,CAAC,UAAU,EACzB,cAAc,CAAC,IAAI,EACnB,cAAc,CAAC,QAAQ,CAAC,CAAC;;gBAE7B,MAAM,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,kBAAkB,EAAE,CAAC;;gBAC7D,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBAC3C,IAAI,cAAc,KAAK,QAAQ,EAAE;oBAC7B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CACtB,yFAAyF,EACzF,cAAc,EAAE,QAAQ,CAAC,CAAC,CAAC;iBAClC;aACJ;YAAC,OAAO,KAAK,EAAE;gBACZ,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,0EAA0E,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;aAC5H;SACJ;QACD,OAAO,IAAI,CAAC;;;;;IAGN,oBAAoB;QAC1B,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;;QACrB,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,aAAa,CAAC,CAAC;QAClF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC9C,MAAM,GAAG,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;YACrC,MAAM,EAAE,GAAG,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAClC,IAAI,CAAC,EAAE,EAAE;gBACL,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,8DAA8D,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;aAC/G;;YACD,IAAI,UAAU,GAAe,IAAI,CAAC;YAClC,IAAI,IAAI,CAAC,WAAW,EAAE;gBAClB,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;aACrD;YACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,YAAY,CAAC,GAAG,EAAE,EAAE,EAAE,IAAI,oBAAsB,UAAU,EAAC,CAAC,CAAC;SACzF;KACJ;;;;;;;IAOM,UAAU;QACb,OAAO,UAAU,CAAC;;;;;;;IAOf,QAAQ;QACX,OAAO,YAAY,CAAC;;;;;;;;IAQd,wBAAwB;QAC9B,OAAO,CAAC,aAAa,CAAC,CAAC;KAC1B;;;;;;;IAQM,cAAc;QACjB,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,OAAO,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,CAAC;SAC5C;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;;IAQE,iBAAiB,CAAC,QAAgB;;;;;;;IAQlC,cAAc;;QACjB,MAAM,qBAAqB,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,mBAAmB,CAAC,CAAC;QAC/G,IAAI,qBAAqB,EAAE;YACvB,OAAO,qBAAqB,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;SACrD;aAAM;YACH,OAAO,IAAI,CAAC;SACf;;;;;;;IAOE,iBAAiB,CAAC,QAAgB;;QACrC,MAAM,qBAAqB,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,mBAAmB,CAAC,CAAC;QAC/G,IAAI,qBAAqB,EAAE;YACvB,qBAAqB,CAAC,YAAY,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;SACxD;;;;;;;;;;;;;;;;;;;;;;;;IAyBL,kBAAkB,CAAC,gBAA4B,EAAE,aAAsB,EAAE,WAAoB,EAAE,kBAA+B;QAE1H,IAAI,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,EAAE,CAAC,EAAE;YAC3C,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,wDAAwD,EAAE,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC;SAC1G;;QACD,MAAM,WAAW,GAAG,mBAAqB,gBAAgB,GAAE,uBAAuB,CAAC,aAAa,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;;QACrH,MAAM,qBAAqB,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,mBAAmB,CAAC,CAAC;QAC/G,IAAI,CAAC,qBAAqB,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,gFAAgF,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;SAC7H;;QACD,MAAM,kBAAkB,GAAG,qBAAqB,CAAC,aAAa,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QAC5F,kBAAkB,CAAC,YAAY,CAAC,IAAI,EAAE,gBAAgB,CAAC,EAAE,CAAC,CAAC;;QAC3D,IAAI,UAAU,GAAG,CAAC,WAAW,IAAI,aAAa,IAAI,gBAAgB,CAAC,aAAa,EAAE,GAAG,EAAE,CAAC;QACxF,IAAI,CAAC,mBAAqB,gBAAgB,GAAE,YAAY,CAAC,UAAU,CAAC,EAAE;YAClE,UAAU,GAAG,IAAI,CAAC,4BAA4B,EAAE,GAAG,UAAU,GAAG,IAAI,CAAC,2BAA2B,EAAE,CAAC;SACtG;QACD,YAAY,CAAC,4BAA4B,CAAC,kBAAkB,EAAE,UAAU,CAAC,CAAC;;QAC1E,MAAM,KAAK,GAAG,IAAI,YAAY,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,EAAE,EAAE,IAAI,EAAE,WAAW,CAAC,CAAC;;QAC3F,IAAI,QAAQ,GAAG,KAAK,CAAC;;QACrB,IAAI,wBAAwB,GAAG,KAAK,CAAC;QACrC,IAAI,CAAC,CAAC,kBAAkB,EAAE;;YACtB,MAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;YACnE,IAAI,CAAC,CAAC,cAAc,EAAE;gBAClB,wBAAwB,GAAG,IAAI,CAAC;aACnC;SACJ;QACD,IAAI,kBAAkB,KAAK,SAAS,KAAK,kBAAkB,IAAI,CAAC,wBAAwB,CAAC,EAAE;YACvF,qBAAqB,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;YACxD,QAAQ,GAAG,IAAI,CAAC;SACnB;aAAM,IAAI,kBAAkB,KAAK,IAAI,EAAE;;YACpC,MAAM,uBAAuB,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,aAAa,CAAC,CAAC;YAC3G,IAAI,uBAAuB,EAAE;gBACzB,YAAY,CAAC,YAAY,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,uBAAuB,CAAC,CAAC;gBACzE,QAAQ,GAAG,IAAI,CAAC;aACnB;iBAAM;;gBAEH,qBAAqB,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;gBACxD,QAAQ,GAAG,IAAI,CAAC;aACnB;SACJ;aAAM;;YACH,MAAM,cAAc,GAAG,YAAY,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,EAAE,aAAa,EAAE,kBAAkB,CAAC,EAAE,CAAC,CAAC;YACzH,IAAI,cAAc,EAAE;gBAChB,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,cAAc,CAAC,CAAC;gBAC/D,QAAQ,GAAG,IAAI,CAAC;aACnB;SACJ;QACD,IAAI,QAAQ,EAAE;YACV,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAChC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC5B,IAAI,CAAC,YAAY,EAAE,CAAC;YACpB,OAAO,KAAK,CAAC;SAChB;aAAM;YACH,OAAO,IAAI,CAAC;SACf;KACJ;;;;;;;;;;;;;;;;IAgBM,4BAA4B,CAAC,IAAY,EAAE,QAAgB,EAAE,aAAsB,EAAE,WAAoB;QAE5G,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,0EAA0E,EAAE,QAAQ,CAAC,CAAC,CAAC;;CAErH;;;;;;AC3PD;;;;AAYA;;;;;;;;;;;;;IAcW,OAAO,eAAe,CAAC,UAAkB,EAClB,UAAkB,EAClB,IAAY,EACZ,QAAgB,EAChB,cAAqE;QAC/F,OAAO,IAAI,8BAA8B,EAAE,CAAC,yBAAyB,CAAC,UAAU,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;;;;;;;;;;;;;;;IAgB3H,OAAO,4BAA4B,CAAC,UAAkB,EAC/B,IAAY,EACZ,QAAgB,EAChB,cAAqE;QAC/F,OAAO,IAAI,8BAA8B,EAAE,CAAC,sCAAsC,CAAC,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;;;;;;;;;;;;;;IAenI,yBAAyB,CAAC,UAAkB,EAClB,UAAkB,EAClB,IAAY,EACZ,QAAgB,EAChB,cAAuE;QAC7F,IAAI,UAAU,KAAK,cAAc,EAAE;YAC/B,OAAO,IAAI,SAAS,CAAC,UAAU,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;SACpD;QACD,IAAI,UAAU,KAAK,cAAc,EAAE;YAC/B,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;SACrD;QACD,IAAI,UAAU,KAAK,UAAU,EAAE;YAC3B,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;SACxD;QACD,IAAI,UAAU,KAAK,UAAU,EAAE;YAC3B,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;SACxE;QACD,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,+BAA+B,EAAE,UAAU,CAAC,CAAC,CAAC;KAExE;;;;;;;;;;;;;;IAeD,sCAAsC,CAAC,UAAkB,EAClB,IAAY,EACZ,QAAgB,EAChB,cAAuE;;QAE1G,IAAI,gBAAgB,GAAG,CAAC,cAAc,EAAE,cAAc,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;QAChF,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YAC9B,gBAAgB,GAAG,CAAC,UAAU,EAAE,UAAU,EAAE,cAAc,EAAE,cAAc,CAAC,CAAC;SAC/E;QACD,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YAC9B,gBAAgB,GAAG,CAAC,UAAU,EAAE,UAAU,EAAE,cAAc,EAAE,cAAc,CAAC,CAAC;SAC/E;;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAC9C,MAAM,eAAe,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;YAC5C,IAAI;;gBACA,MAAM,eAAe,GAAG,8BAA8B,CAAC,eAAe,CAClE,eAAe,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;gBACjE,IAAI,eAAe,EAAE;oBACjB,OAAO,eAAe,CAAC;iBAC1B;aACJ;YAAC,OAAO,CAAC,EAAE;;aAEX;SACJ;QACD,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,6EAA6E,CAAC,CAAC,CAAC;KAC1G;CAEJ;;;;;;;;;;;;;;;;;;;"}
