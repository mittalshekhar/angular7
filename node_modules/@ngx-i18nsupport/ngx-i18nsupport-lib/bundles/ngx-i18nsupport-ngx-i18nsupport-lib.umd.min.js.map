{"version":3,"sources":["ng://@ngx-i18nsupport/ngx-i18nsupport-lib/lib/ngx-i18nsupport-lib.module.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/api/constants.ts","../../node_modules/tslib/tslib.es6.js","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/dom-utilities.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xml-serializer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-translation-messages-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-text.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-placeholder.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-start-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-end-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/icu-message-tokenizer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/icu-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-icu-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-icu-message-ref.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-empty-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-tokenizer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/tag-mapping.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xtb-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xtb-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/api/translation-messages-file-factory.ts"],"names":["NgxI18nsupportLibModule","NgModule","args","imports","declarations","exports","FORMAT_XLIFF12","FORMAT_XLIFF20","FORMAT_XMB","FORMAT_XTB","FILETYPE_XLIFF12","FILETYPE_XLIFF20","STATE_NEW","STATE_TRANSLATED","STATE_FINAL","NORMALIZATION_FORMAT_NGXTRANSLATE","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","DOMUtilities","getFirstElementByTagName","element","tagName","matchingElements","getElementsByTagName","length","item","getElementByTagNameAndId","id","node","getAttribute","getElementFollowingSibling","nextSibling","nodeType","ELEMENT_NODE","getElementPrecedingSibling","previousSibling","getXMLContent","result","XMLSerializer","serializeToString","nodeName","reStartMsg","RegExp","replace","reEndMsg","getPCDATA","childNodes","child","TEXT_NODE","CDATA_SECTION_NODE","nodeValue","replaceContentWithXMLContent","pcdata","firstChild","removeChild","newChildren","DOMParser","parseFromString","j","newChild","appendChild","ownerDocument","importNode","getPreviousElementSibling","createFollowingSibling","elementNameToCreate","newElement","createElement","insertAfter","parentNode","insertBefore","XmlSerializer","document","options","buf","visibleNamespaces","refNode","documentElement","prefix","uri","namespaceURI","lookupPrefix","namespace","indentString","containsOnlyWhiteSpace","Error","doSerializeToString","join","indentLevel","partOfMixedContent","elementNode","attrs","attributes","len","elementHasMixedContent","isMixedContentElement","outputIndented","attr","localName","needNamespaceDefine","ns","hasComplexContent","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","ATTRIBUTE_NODE","attrNode","name","_xmlEncoder","textNode","beautify","data","cdatasectionNode","COMMENT_NODE","commentNode","DOCUMENT_TYPE_NODE","documenttypeNode","pubid","publicId","sysid","systemId","sub","internalSubset","PROCESSING_INSTRUCTION_NODE","piNode","target","ENTITY_REFERENCE_NODE","c","charCodeAt","outputParts","_i","arguments","indentationString","apply","__spread","concat","indent","mixedContentElements","find","tag","text","charAt","AbstractTranslationMessagesFile","transUnits","_warnings","parseContent","xmlString","path","encoding","optionalMaster","_filename","_encoding","_parsedDocument","_fileEndsWithEOL","endsWith","lazyInitializeTransUnits","isNullOrUndefined","initializeTransUnits","countNumbers","_numberOfTransUnitsWithMissingId","_numberOfUntranslatedTransUnits","_numberOfReviewedTransUnits","forEachTransUnit","tu","_this","state","targetState","warnings","numberOfTransUnits","numberOfUntranslatedTransUnits","numberOfReviewedTransUnits","numberOfTransUnitsWithMissingId","callback","forEach","transUnitWithId","setNewTransUnitTargetPraefix","targetPraefix","getNewTransUnitTargetPraefix","setNewTransUnitTargetSuffix","targetSuffix","getNewTransUnitTargetSuffix","removeTransUnitWithId","tuNode","getElementById","filter","filename","editedContent","beautifyOutput","elementsWithMixedContent","AbstractTransUnit","_element","_id","_translationMessagesFile","translationMessagesFile","supportsSetSourceContent","sourceContentNormalized","_sourceContentNormalized","createSourceContentNormalized","nativeState","nativeTargetState","mapNativeStateToState","setTargetState","newState","setNativeTargetState","mapStateToNativeState","supportsSetSourceReferences","supportsSetDescriptionAndMeaning","checkNotes","newNotes","errorInFromNote","note","from","asXmlElement","translate","translation","translationNative","isString","asNativeString","translateNative","isICUMessage","message","messageParser","isICUMessageStart","TEXT","PLACEHOLDER","START_TAG","END_TAG","EMPTY_TAG","ICU_MESSAGE","ICU_MESSAGE_REF","ParsedMessagePart","type","ParsedMessagePartText","_super","ParsedMessagePartType","tslib_1.__extends","asDisplayString","format","ParsedMessagePartPlaceholder","index","disp","_index","_disp","ParsedMessagePartStartTag","tagname","idcounter","_tagname","_idcounter","toString","idCounter","ParsedMessagePartEndTag","CURLY_BRACE_OPEN","CURLY_BRACE_CLOSE","COMMA","PLURAL","SELECT","STATE_NORMAL","STATE_IN_MESSAGE","ICUMessageTokenizer","getLexer","lexer","Tokenizr","plaintext","openedCurlyBracesInTextCounter","before","ctx","match","rule","containsNonWhiteSpace","accept","ignore","finish","pop","char","test","tokenize","normalizedMessage","input","tokens","token","peek","MessageCategory","_category","_message","getCategory","getMessageNormalized","ICUMessage","_parser","isPluralMessage","_isPluralMessage","_categories","addCategory","category","varname","choiceString","isSelectMessage","getCategories","translatedCategories","Set","translatedMessage","translationForCategory","add","parseNormalizedString","keys","categoryName","has","checkValidPluralCategory","allowedKeywords","key","ParsedMessagePartICUMessage","icuMessageText","parseICUMessage","looksLikeICUMessage","displayFormat","getICUMessage","_messageText","_tokenizer","expectNext","trim","parseNativeSubMessage","tokentype","createNormalizedMessageFromXMLString","ParsedMessagePartICUMessageRef","ParsedMessagePartEmptyTag","ParsedMessage","parser","sourceMessage","_parts","getParser","normalizedString","translateICUMessage","icuTranslation","icuMessage","translatedICUMessage","translateNativeString","nativeString","map","part","_xmlRepresentation","validate","hasErrors","errors","checkPlaceholderAdded","placeholderAdded","checkICUMessageRefRemoved","checkICUMessageRefAdded","validateWarnings","w","hasWarnings","checkPlaceholderRemoved","placeholderRemoved","checkTagRemoved","tagRemoved","checkTagAdded","tagAdded","suspiciousIndexes","sourcePlaceholders_1","allPlaceholders","allSuspiciousIndexes_1","first_1","sourcePlaceholders","myPlaceholders_1","allSuspiciousIndexes_2","first_2","sourceICURefs_1","allICUMessageRefs","allSuspiciousIndexes_3","first_3","sourceICURefs","myICURefs_1","allSuspiciousIndexes_4","first_4","parts","getPlaceholderDisp","placeHolder","phPart","getICUMessageRefDisp","icuMessageRefPart","refPart","suspiciousTags","sourceTags_1","allTags","allSuspiciousTags_1","first_5","sourceTags","myTags_1","allSuspiciousTags_2","first_6","setXmlRepresentation","xmlRepresentation","addText","addPlaceholder","addStartTag","addEndTag","openTag","calculateOpenTagName","addEmptyTag","addICUMessageRef","addICUMessage","openTags","ParsedMesageTokenizer","idcount","parseInt","reset","AbstractMessageParser","createNormalizedMessageFromXML","xmlElement","addPartsOfNodeToMessage","includeSelf","processChildren","textContent","processStartElement","getICUMessageText","isICU","console","log","children","processEndElement","createXmlRepresentation","icuMessageString","parseIdCountFromName","exec","num","rootElem","addXmlRepresentationToRoot","createXmlRepresentationOfTextPart","createTextNode","TAG_TO_PLACEHOLDER_NAMES","A","B","BR","EM","H1","H2","H3","H4","H5","H6","HR","I","LI","LINK","OL","P","Q","S","SMALL","SUB","SUP","TBODY","TD","TFOOT","TH","THEAD","TR","TT","U","UL","VOID_TAGS","TagMapping","getStartTagPlaceholderName","upperTag","toUpperCase","counterString","getCloseTagPlaceholderName","getEmptyTagPlaceholderName","getCtypeForTag","toLowerCase","getTagnameFromStartTagPlaceholderName","placeholderName","startsWith","stripCounter","substring","ph_1","matchKey","getTagnameFromCloseTagPlaceholderName","ph_2","isEmptyTagPlaceholderName","ph","indexOf","getTagnameFromEmptyTagPlaceholderName","re","XliffMessageParser","tagMapping","parsePlaceholderIndexFromId","parseICUMessageRefIndexFromId","normalizedTagName","indexString","Number","createXmlRepresentationOfStartTagPart","createXmlRepresentationOfEndTagPart","createXmlRepresentationOfEmptyTagPart","createXmlRepresentationOfPlaceholderPart","createXmlRepresentationOfICUMessageRefPart","xElem","idAttrib","ctypeAttrib","equivTextAttr","setAttribute","XliffTransUnit","sourceContent","sourceElement","setSourceContent","newContent","source","targetContent","targetElement","targetContentNormalized","sourceReferences","sourceElements","sourceRefs","elem","contextElements","sourcefile","linenumber","contextElem","setSourceReferences","removeAllSourceReferences","ref","contextGroup","contextSource","contextLine","toBeRemoved","description","noteElem","findNoteElementWithFromAttribute","setDescription","createNoteElementWithFromAttribute","removeNoteElementWithFromAttribute","attrValue","noteElements","findAllAdditionalNoteElements","fromAttribute","fromAttrValue","content","noteElement","removeAllAdditionalNoteElements","meaning","setMeaning","notes","supportsSetNotes","setNotes","cloneWithSourceAsTarget","isDefaultLang","copyContent","targetFile","clone","cloneNode","useSourceAsTarget","sourceString","newTargetString","XliffFile","initializeFromContent","xliffList","version","i18nFormat","fileType","transUnitsInFile","transunit","sourceLanguage","fileElem","setSourceLanguage","language","targetLanguage","setTargetLanguage","importNewTransUnit","foreignTransUnit","importAfterElement","newTu","bodyElement","inserted","isAfterElementPartOfFile","undefined","firstUnitElement","refUnitElement","createTranslationFileForLang","lang","translationFile","transUnit","XmbMessageParser","name_1","parsePlaceholderIndexFromName","parseTagnameFromPhElement","emptyTagName","parseICUMessageIndexFromName","messageText","reSource","phElement","exElement","createXmlRepresentationOfPart","phElem","nameAttrib","exElem","XmbTransUnit","parseSourceAndPos","sourceAndPos","lastIndexOf","parseLineNumber","lineNumberString","msgContent","insertPosition","XmbFile","_translationMessageFileFactory","msg","guessLanguageFromFilename","split","createFileFromFileContent","xmlContent","Xliff2MessageParser","isInterpolation","isEmptyTag","equiv","embeddedTagName","tagNameFromPCElement","pcNode","dispStart","stack","newTagElem","closeTagName","emptyTagElem","pcElem","equivStart","equivEnd","dispEnd","getTypeForTag","equivAttrib","Xliff2TransUnit","segmentElement","notesElement","findNoteElementWithCategoryAttribute","createNoteElementWithCategoryAttribute","removeNoteElementWithCategoryAttribute","removeNotesElementIfEmpty","segment","Xliff2File","xliffElem","fileElement","XtbTransUnit","_sourceTransUnitFromMaster","XtbFile","_masterFile","numberInMaster","myNumber","masterUnit","translationbundleElem","newMasterTu","translationElement","firstTranslationElement","TranslationMessagesFileFactory","fromFileContent","fromUnknownFormatFileContent","createFileFromUnknownFormatFileContent","formatCandidates","formatCandidate"],"mappings":"0dAAA,IAAAA,EAAA,oDAECC,EAAAA,SAAQC,KAAA,CAAC,CACRC,QAAS,GAETC,aAAc,GACdC,QAAS,SANX,GCQaC,EAAiB,MACjBC,EAAiB,OACjBC,EAAa,MACbC,EAAa,MAMbC,EAAmB,YACnBC,EAAmB,YAanBC,EAAY,MAKZC,EAAmB,aAKnBC,EAAc,QAedC,EAAoC,eCxC7CC,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAG5B,SAAAO,EAA0BR,EAAGC,GAEzB,SAAAQ,IAAgBC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GAGnF,SAAAK,EAwFuBC,EAAGC,GACtB,IAAIC,EAAsB,mBAAXC,QAAyBH,EAAEG,OAAOC,UACjD,IAAKF,EAAG,OAAOF,EACf,IAAmBK,EAAYC,EAA3BC,EAAIL,EAAEM,KAAKR,GAAOS,EAAK,GAC3B,IACI,WAAc,IAANR,GAAsB,EAANA,QAAcI,EAAIE,EAAEG,QAAQC,MAAMF,EAAGG,KAAKP,EAAEQ,OAExE,MAAOC,GAASR,EAAI,CAAEQ,MAAOA,WAEzB,IACQT,IAAMA,EAAEM,OAAST,EAAIK,EAAU,YAAIL,EAAEM,KAAKD,WAExC,GAAID,EAAG,MAAMA,EAAEQ,OAE7B,OAAOL,EC7HX,IAAAM,EAAA,gCAQkBA,EAAAC,kCAAyBC,EAA6BC,GAChE,IAAMC,EAAmBF,EAAQG,qBAAqBF,GACtD,OAAIC,GAA8C,EAA1BA,EAAiBE,OAC9BF,EAAiBG,KAAK,GAEtB,MAWDP,EAAAQ,kCAAyBN,EAA6BC,EAAiBM,GACjF,IAAML,EAAmBF,EAAQG,qBAAqBF,GACtD,GAAIC,GAA8C,EAA1BA,EAAiBE,OACrC,IAAK,IAAId,EAAI,EAAGA,EAAIY,EAAiBE,OAAQd,IAAK,CAC9C,IAAMkB,EAAgBN,EAAiBG,KAAKf,GAC5C,GAAIkB,EAAKC,aAAa,QAAUF,EAC5B,OAAOC,EAInB,OAAO,MAOGV,EAAAY,oCAA2BV,GACrC,IAAKA,EACD,OAAO,KAGX,IADA,IAAIX,EAAIW,EAAQW,YACTtB,GAAG,CACN,GAAIA,EAAEuB,WAAavB,EAAEwB,aACjB,OAAA,EAEJxB,EAAIA,EAAEsB,YAEV,OAAO,MAOGb,EAAAgB,oCAA2Bd,GACrC,IAAKA,EACD,OAAO,KAGX,IADA,IAAIX,EAAIW,EAAQe,gBACT1B,GAAG,CACN,GAAIA,EAAEuB,WAAavB,EAAEwB,aACjB,OAAA,EAEJxB,EAAIA,EAAE0B,gBAEV,OAAO,MAQGjB,EAAAkB,uBAAchB,GACxB,IAAKA,EACD,OAAO,KAEX,IAAIiB,GAAS,IAAIC,EAAAA,eAAgBC,kBAAkBnB,GAC7CC,EAAUD,EAAQoB,SAClBC,EAAqB,IAAIC,OAAO,IAAMrB,EAAU,SAAU,KAChEgB,EAASA,EAAOM,QAAQF,EAAY,IACpC,IAAMG,EAAmB,IAAIF,OAAO,KAAOrB,EAAU,IAAK,KAE1D,OADAgB,EAASA,EAAOM,QAAQC,EAAU,KASxB1B,EAAA2B,mBAAUzB,GACpB,IAAKA,EACD,OAAO,KAIX,IAFA,IAAIiB,EAAS,GACPS,EAAa1B,EAAQ0B,WAClBpC,EAAI,EAAGA,EAAIoC,EAAWtB,OAAQd,IAAK,CACxC,IAAMqC,EAAQD,EAAWrB,KAAKf,GAC1BqC,EAAMf,WAAae,EAAMC,WAAaD,EAAMf,WAAae,EAAME,qBAC/DZ,GAAkBU,EAAMG,WAGhC,OAAyB,IAAlBb,EAAOb,OAAe,KAAOa,GAQ1BnB,EAAAiC,sCAA6B/B,EAAkBgC,GAEzD,KAAOhC,EAAQiC,YACXjC,EAAQkC,YAAYlC,EAAQiC,YAKhC,IAFA,IACME,GAD2B,IAAIC,EAAAA,WAAYC,gBAAgB,aAAeL,EAAS,cAAe,mBACrE7B,qBAAqB,YAAYE,KAAK,GAAGqB,WACnEY,EAAI,EAAGA,EAAIH,EAAY/B,OAAQkC,IAAK,CACzC,IAAMC,EAAWJ,EAAY9B,KAAKiC,GAClCtC,EAAQwC,YAAYxC,EAAQyC,cAAcC,WAAWH,GAAU,MASzDzC,EAAA6C,mCAA0B3C,GAEpC,IADA,IAAIQ,EAAOR,EAAQe,gBACH,OAATP,GAAe,CAClB,GAAIA,EAAKI,WAAaJ,EAAKK,aACvB,OAAA,EAEJL,EAAOA,EAAKO,gBAEhB,OAAO,MASGjB,EAAA8C,gCAAuBC,EAA6B9B,GAC9D,IAAM+B,EAAa/B,EAAgB0B,cAAcM,cAAcF,GAC/D,OAAiB/C,EAAakD,YAAYF,EAAY/B,IAQ5CjB,EAAAkD,qBAAYF,EAAkB/B,GAMxC,OALoC,OAAhCA,EAAgBJ,YAChBI,EAAgBkC,WAAWC,aAAaJ,EAAY/B,EAAgBJ,aAEpEI,EAAgBkC,WAAWT,YAAYM,GAEpCA,GAQGhD,EAAAoD,sBAAaJ,EAAkBnC,GAEzC,OADAA,EAAYsC,WAAWC,aAAaJ,EAAYnC,GACzCmC,KAlLf,GC+BAK,EAAA,WAEI,SAAAA,YASAA,EAAAvE,UAAAuC,kBAAA,SAAkBiC,EAAoBC,GAClC,IAAMC,EAAM,GACRC,EAAiC,GAC/BC,EAAUJ,EAASK,gBACrBC,EAASF,EAAQE,OACfC,EAAMH,EAAQI,aAcpB,GAZID,GAAiB,MAAVD,GAEO,OADdA,EAASF,EAAQK,aAAaF,MAE1BJ,EAAoB,CAChB,CAACO,UAAWH,EAAKD,OAAQ,QAKhCL,IACDA,EAAU,IAEVA,EAAQU,eACHrF,KAAKsF,uBAAuBX,EAAQU,cACrC,MAAM,IAAIE,MAAM,sDAIxB,OADAvF,KAAKwF,oBAAoBd,EAAUC,EAASC,EAAK,GAAG,EAAOC,GACpDD,EAAIa,KAAK,KAaZhB,EAAAvE,UAAAsF,6BAAoB1D,EAAY6C,EAA+BC,EAC3Cc,EAAqBC,EAA6Bd,GAC1E,IAAI5B,EACJ,OAAQnB,EAAKI,UACT,KAAKJ,EAAKK,aACN,IAAMyD,EAAW,EACXC,EAAQD,EAAYE,WACpBC,EAAMF,EAAMnE,OAClBuB,EAAQ2C,EAAYrC,WACpB,IAAMb,EAAWkD,EAAYrE,QACvByE,EAAyBhG,KAAKiG,sBAAsBvD,EAAUiC,GAChEgB,EACAf,EAAI3D,KAAK,IAAMyB,GAEf1C,KAAKkG,eAAevB,EAASC,EAAKc,EAAa,IAAMhD,GAGzD,IAAK,IAAI9B,EAAI,EAAGA,EAAImF,EAAKnF,IAAK,CAGN,WADduF,EAAON,EAAMlE,KAAKf,IACfoE,OACLH,EAAkB5D,KAAK,CAAC+D,OAAQmB,EAAKC,UAAWhB,UAAWe,EAAKjF,QACvC,UAAlBiF,EAAKzD,UACZmC,EAAkB5D,KAAK,CAAC+D,OAAQ,GAAII,UAAWe,EAAKjF,QAG5D,IAASN,EAAI,EAAGA,EAAImF,EAAKnF,IAAK,CAC1B,IAAMuF,EAAON,EAAMlE,KAAKf,GACxB,GAAIZ,KAAKqG,oBAAoBF,EAAMtB,GAAoB,CACnD,IAAMG,EAASmB,EAAKnB,QAAU,GACxBC,EAAMkB,EAAKjB,aACXoB,EAAKtB,EAAS,UAAYA,EAAS,SACzCJ,EAAI3D,KAAKqF,EAAI,KAAMrB,EAAK,KACxBJ,EAAkB5D,KAAK,CAAC+D,OAAQA,EAAQI,UAAWH,IAEvDjF,KAAKwF,oBAAoBW,EAAMxB,EAASC,EAAKc,GAAa,EAAOb,GAGrE,GAAI7E,KAAKqG,oBAAoBT,EAAaf,GAAoB,CACpDG,EAASY,EAAYZ,QAAU,GAC/BC,EAAMnD,EAAKoD,aACXoB,EAAKtB,EAAS,UAAYA,EAAS,SACzCJ,EAAI3D,KAAKqF,EAAI,KAAMrB,EAAK,KACxBJ,EAAkB5D,KAAK,CAAC+D,OAAQA,EAAQI,UAAWH,IAGvD,GAAIhC,EAAO,CACP2B,EAAI3D,KAAK,KAGT,IADA,IAAIsF,GAAoB,EACjBtD,GACCA,EAAMf,WAAae,EAAMd,eACzBoE,GAAoB,GAExBvG,KAAKwF,oBAAoBvC,EAAO0B,EAASC,EAAKc,EAAc,EACxDC,GAAsBK,EAAwBnB,GAClD5B,EAAQA,EAAMhB,YAEb0D,GAAuBK,IAA0BO,EAGlD3B,EAAI3D,KAAK,KAAMyB,EAAU,KAFzB1C,KAAKkG,eAAevB,EAASC,EAAKc,EAAa,KAAMhD,EAAU,UAKnEkC,EAAI3D,KAAK,MAEb,OACJ,KAAKa,EAAK0E,cACV,KAAK1E,EAAK2E,uBAEN,IADAxD,EAAQnB,EAAKyB,WACNN,GACHjD,KAAKwF,oBAAoBvC,EAAO0B,EAASC,EAAKc,GAAa,EAAOb,GAClE5B,EAAQA,EAAMhB,YAElB,OACJ,KAAKH,EAAK4E,eACN,IAAMC,EAAQ,EACd,OAAO/B,EAAI3D,KAAK,IAAK0F,EAASC,KAAM,KAAMD,EAASzF,MAAM2B,QAAQ,SAAU7C,KAAK6G,aAAc,KAClG,KAAK/E,EAAKoB,UACN,IAAM4D,EAAQ,EACd,OAAKnC,EAAQoC,WAAYpB,GAAuB3F,KAAKsF,uBAAuBwB,EAASE,WAGrF,EAFWpC,EAAI3D,KAAK6F,EAASE,KAAKnE,QAAQ,QAAS7C,KAAK6G,cAG5D,KAAK/E,EAAKqB,mBACN,IAAM8D,EAAgB,EACtB,OAAOrC,EAAI3D,KAAK,YAAagG,EAAiBD,KAAM,OACxD,KAAKlF,EAAKoF,aACN,IAAMC,EAAW,EACjB,OAAOvC,EAAI3D,KAAK,UAAQkG,EAAYH,KAAM,UAC9C,KAAKlF,EAAKsF,mBACN,IAAMC,EAAgB,EAChBC,EAAQD,EAAiBE,SACzBC,EAAQH,EAAiBI,SAE/B,GADA7C,EAAI3D,KAAK,aAAcoG,EAAiBT,MACpCU,EACA1C,EAAI3D,KAAK,YAAaqG,GAClBE,GAAmB,MAAVA,GACT5C,EAAI3D,KAAK,MAAOuG,GAEpB5C,EAAI3D,KAAK,WACN,GAAIuG,GAAmB,MAAVA,EAChB5C,EAAI3D,KAAK,YAAauG,EAAO,UAC1B,CACH,IAAME,EAAML,EAAiBM,eACzBD,GACA9C,EAAI3D,KAAK,KAAMyG,EAAK,KAExB9C,EAAI3D,KAAK,KAEb,OACJ,KAAKa,EAAK8F,4BACN,IAAMC,EAAM,EACZ,OAAOjD,EAAI3D,KAAM,KAAM4G,EAAOC,OAAQ,IAAKD,EAAOb,KAAM,MAC5D,KAAKlF,EAAKiG,sBACN,OAAOnD,EAAI3D,KAAK,IAAKa,EAAKY,SAAU,KAGxC,QACIkC,EAAI3D,KAAK,KAAMa,EAAKY,YAIxB+B,EAAAvE,UAAAmG,6BAAoBvE,EAAsB+C,GAC9C,IAAMG,EAASlD,EAAKkD,QAAU,GACxBC,EAAMnD,EAAKoD,aACjB,IAAKF,IAAWC,EACZ,OAAO,EAEX,GAAe,QAAXD,GAA4B,yCAARC,GACT,kCAARA,EACH,OAAO,EAIX,IADA,IAAIrE,EAAIiE,EAAkBnD,OACnBd,KAAK,CACR,IAAM0F,EAAKzB,EAAkBjE,GAE7B,GAAI0F,EAAGtB,SAAWA,EACd,OAAOsB,EAAGlB,YAAcH,EAGhC,OAAO,GAGHR,EAAAvE,UAAA2G,qBAAYmB,GAChB,OAAa,MAANA,EAAa,OACV,MAANA,GAAa,SACP,MAANA,GAAa,SACP,MAANA,GAAa,UACb,KAAOA,EAAEC,WAAW,GAAK,KAGzBxD,EAAAvE,UAAAgG,wBAAevB,EAA+BC,EAAec,OAAqB,IAAAwC,EAAA,GAAAC,EAAA,EAAAA,EAAAC,UAAA1G,OAAAyG,IAAAD,EAAAC,EAAA,GAAAC,UAAAD,GAClFxD,EAAQoC,WACRnC,EAAI3D,KAAK,MACS,EAAdyE,GACAd,EAAI3D,KAAKjB,KAAKqI,kBAAkB1D,EAASe,KAGjDd,EAAI3D,KAAIqH,MAAR1D,EFhHR,SAAA2D,IACI,IAAK,IAAIzH,EAAK,GAAIF,EAAI,EAAGA,EAAIwH,UAAU1G,OAAQd,IAC3CE,EAAKA,EAAG0H,OAAOpI,EAAOgI,UAAUxH,KACpC,OAAOE,EE6GAyH,CAASL,KAGRzD,EAAAvE,UAAAmI,2BAAkB1D,EAA+Be,GAGrD,IAFA,IAAM+C,EAAU9D,EAAoB,aAAIA,EAAQU,aAvN1B,KAwNlB9C,EAAS,GACJ3B,EAAI,EAAGA,EAAI8E,EAAa9E,IAC7B2B,GAAkBkG,EAEtB,OAAOlG,GAQHkC,EAAAvE,UAAA+F,+BAAsB1E,EAAiBoD,GAC3C,SAAIA,IAAWA,EAAQ+D,yBACV/D,EAAQ+D,qBAAqBC,KAAK,SAACC,GAAQ,OAAAA,IAAQrH,KAM5DkD,EAAAvE,UAAAoF,gCAAuBuD,GAC3B,IAAK,IAAIjI,EAAI,EAAGA,EAAIiI,EAAKnH,OAAQd,IAAK,CAClC,IAAMoH,EAAIa,EAAKC,OAAOlI,GACtB,GAAY,MAANoH,GAAmB,OAANA,GAAoB,OAANA,GAAoB,OAANA,EAC3C,OAAO,EAGf,OAAO,KAjPf,GCzBAe,EAAA,WAyBI,SAAAA,IACI/I,KAAKgJ,WAAa,KAClBhJ,KAAKiJ,UAAY,UAWXF,EAAA7I,UAAAgJ,aAAV,SACIC,EACAC,EAAcC,EACdC,GAEAtJ,KAAKuJ,UAAYH,EACjBpJ,KAAKwJ,UAAYH,EACjBrJ,KAAKyJ,iBAAkB,IAAI/F,EAAAA,WAAYC,gBAAgBwF,EAAW,YAClEnJ,KAAK0J,iBAAmBP,EAAUQ,SAAS,OAqBrCZ,EAAA7I,UAAA0J,yBAAV,WACQC,EAAAA,kBAAkB7J,KAAKgJ,cACvBhJ,KAAK8J,uBACL9J,KAAK+J,iBAONhB,EAAA7I,UAAA6J,mCACH/J,KAAKgK,iCAAmC,EACxChK,KAAKiK,gCAAkC,EACvCjK,KAAKkK,4BAA8B,EACnClK,KAAKmK,iBAAiB,SAACC,IACfP,EAAAA,kBAAkBO,EAAGvI,KAAiB,KAAVuI,EAAGvI,KAC/BwI,EAAKL,mCAET,IAAMM,EAAQF,EAAGG,eACbV,EAAAA,kBAAkBS,IAAUA,IAAUrL,IACtCoL,EAAKJ,kCAELK,IAAUpL,GACVmL,EAAKH,iCAKVnB,EAAA7I,UAAAsK,oBAEH,OADAxK,KAAK4J,2BACE5J,KAAKiJ,WAMTF,EAAA7I,UAAAuK,8BAEH,OADAzK,KAAK4J,2BACE5J,KAAKgJ,WAAWtH,QAO3BqH,EAAA7I,UAAAwK,+BAAA,WAEI,OADA1K,KAAK4J,2BACE5J,KAAKiK,iCAMhBlB,EAAA7I,UAAAyK,2BAAA,WAEI,OADA3K,KAAK4J,2BACE5J,KAAKkK,6BAOTnB,EAAA7I,UAAA0K,2CAEH,OADA5K,KAAK4J,2BACE5J,KAAKgK,kCAmBTjB,EAAA7I,UAAAiK,0BAAiBU,GACpB7K,KAAK4J,2BACL5J,KAAKgJ,WAAW8B,QAAQ,SAACV,GAAO,OAAAS,EAAST,MAQtCrB,EAAA7I,UAAA6K,yBAAgBlJ,GAEnB,OADA7B,KAAK4J,2BACE5J,KAAKgJ,WAAWL,KAAK,SAACyB,GAAO,OAAAA,EAAGvI,KAAOA,KAyB3CkH,EAAA7I,UAAA8K,sCAA6BC,GAChCjL,KAAKiL,cAAgBA,GAQzBlC,EAAA7I,UAAAgL,6BAAA,WACI,OAAOrB,EAAAA,kBAAkB7J,KAAKiL,eAAiB,GAAKjL,KAAKiL,eAStDlC,EAAA7I,UAAAiL,qCAA4BC,GAC/BpL,KAAKoL,aAAeA,GAQxBrC,EAAA7I,UAAAmL,4BAAA,WACI,OAAOxB,EAAAA,kBAAkB7J,KAAKoL,cAAgB,GAAKpL,KAAKoL,cAgCrDrC,EAAA7I,UAAAoL,+BAAsBzJ,GACzB,IAAM0J,EAAevL,KAAKyJ,gBAAgB+B,eAAe3J,GACrD0J,IACAA,EAAOhH,WAAWf,YAAY+H,GAC9BvL,KAAK4J,2BACL5J,KAAKgJ,WAAahJ,KAAKgJ,WAAWyC,OAAO,SAACrB,GAAO,OAAAA,EAAGvI,KAAOA,IAC3D7B,KAAK+J,iBAONhB,EAAA7I,UAAAwL,oBACH,OAAO1L,KAAKuJ,WAMTR,EAAA7I,UAAAmJ,oBACH,OAAOrJ,KAAKwJ,WAUTT,EAAA7I,UAAAyL,uBAAcC,GACjB,IAAMjH,EAAgC,IACf,IAAnBiH,IACDjH,EAAQoC,UAAW,EACnBpC,EAAQU,aAAe,KACvBV,EAAQ+D,qBAAuB1I,KAAK6L,4BAEvC,IAAMtJ,GAAS,IAAIkC,GAAgBhC,kBAAkBzC,KAAKyJ,gBAAiB9E,GAC3E,OAAI3E,KAAK0J,iBAEEnH,EAAS,KAETA,KAnSnB,GCFAuJ,EAAA,WAII,SAAAA,EAAgCC,EACAC,EACAC,GAFAjM,KAAA+L,SAAAA,EACA/L,KAAAgM,IAAAA,EACAhM,KAAAiM,yBAAAA,+BAGrBH,EAAA5L,UAAA,KAAE,gBACT,OAAOF,KAAKgM,qCAMhBF,EAAA5L,UAAAgM,wBAAA,WACI,OAAOlM,KAAKiM,0BAchBH,EAAA5L,UAAAiM,yBAAA,WACI,OAAO,GAcJL,EAAA5L,UAAAkM,mCAIH,OAHIvC,EAAAA,kBAAkB7J,KAAKqM,4BACvBrM,KAAKqM,yBAA2BrM,KAAKsM,iCAElCtM,KAAKqM,0BA+BTP,EAAA5L,UAAAqK,uBACH,IAAMgC,EAAcvM,KAAKwM,oBACzB,OAAOxM,KAAKyM,sBAAsBF,IA+BtCT,EAAA5L,UAAAwM,eAAA,SAAeC,GACX3M,KAAK4M,qBAAqB5M,KAAK6M,sBAAsBF,IACjD3M,KAAKkM,oCAAqCnD,GACP/I,KAAKkM,0BAA2BnC,gBAmBpE+B,EAAA5L,UAAA4M,uCACH,OAAO,GA6BJhB,EAAA5L,UAAA6M,4CACH,OAAO,GAyCDjB,EAAA5L,UAAA8M,WAAV,SAAqBC,GAEjB,IAAMC,EAAkBD,EAAStE,KAAK,SAACwE,GAAS,MAAc,gBAAdA,EAAKC,MAAwC,YAAdD,EAAKC,OACpF,IAAKvD,EAAAA,kBAAkBqD,GACnB,MAAM,IAAI3H,MAAM,8DASjBuG,EAAA5L,UAAAmN,wBACH,OAAOrN,KAAK+L,UAwBTD,EAAA5L,UAAAoN,mBAAUC,GACb,IAAIC,EAEAA,EADAC,EAAAA,SAASF,GACQ,EAEG,EAAmCG,iBAE3D1N,KAAK2N,gBAAgBH,GACrBxN,KAAK0M,eAAexN,IAajB4M,EAAA5L,UAAA0N,sBAAaC,GAChB,OAAO7N,KAAK8N,gBAAgBC,kBAAkBF,MA5QtD,MCHIG,KAAA,EACAC,YAAA,EACAC,UAAA,EACAC,QAAA,EACAC,UAAA,EACAC,YAAA,EACAC,gBAAA,OANAN,MAAI,WACJC,aAAW,kBACXC,WAAS,gBACTC,SAAO,cACPC,WAAS,gBACTC,aAAW,kBACXC,iBAAe,kBAGnB,IAAAC,EAEI,SAAAA,GAAmBC,GAAAxO,KAAAwO,KAAAA,GCZvBC,EAAA,SAAAC,GAII,SAAAD,EAAY5F,GAAZ,IAAAwB,EACIqE,EAAA7N,KAAAb,KAAM2O,EAAsBX,OAAKhO,YACjCqK,EAAKxB,KAAOA,WANuB+F,EAAAA,EAAAA,GAShCH,EAAAvO,UAAA2O,yBAAgBC,GACnB,OAAO9O,KAAK6I,QAVpB,CAA2C0F,GCE3CQ,EAAA,SAAAL,GAOI,SAAAK,EAAYC,EAAeC,GAA3B,IAAA5E,EACIqE,EAAA7N,KAAAb,KAAM2O,EAAsBV,cAAYjO,YACxCqK,EAAK6E,OAASF,EACd3E,EAAK8E,MAAQF,WAV6BL,EAAAA,EAAAA,GAavCG,EAAA7O,UAAA2O,yBAAgBC,GACnB,MACW,KAAO9O,KAAKkP,OAAS,MAI7BH,EAAA7O,UAAA8O,iBACH,OAAOhP,KAAKkP,QAGTH,EAAA7O,UAAA+O,gBACH,OAAOjP,KAAKmP,SAxBpB,CAAkDZ,GCFlDa,EAAA,SAAAV,GAKI,SAAAU,EAAYC,EAAiBC,GAA7B,IAAAjF,EACIqE,EAAA7N,KAAAb,KAAM2O,EAAsBT,YAAUlO,YACtCqK,EAAKkF,SAAWF,EAChBhF,EAAKmF,WAAaF,WARqBV,EAAAA,EAAAA,GAWpCQ,EAAAlP,UAAA2O,yBAAgBC,GACnB,OAAwB,IAApB9O,KAAKwP,WACE,IAAMxP,KAAKuP,SAAW,IAEtB,IAAMvP,KAAKuP,SAAW,QAAUvP,KAAKwP,WAAWC,WAAa,MAIrEL,EAAAlP,UAAAqB,mBACH,OAAOvB,KAAKuP,UAGTH,EAAAlP,UAAAwP,qBACH,OAAO1P,KAAKwP,cAxBpB,CAA+CjB,GCA/CoB,EAAA,SAAAjB,GAII,SAAAiB,EAAYN,GAAZ,IAAAhF,EACIqE,EAAA7N,KAAAb,KAAM2O,EAAsBR,UAAQnO,YACpCqK,EAAKkF,SAAWF,WANqBT,EAAAA,EAAAA,GASlCe,EAAAzP,UAAA2O,yBAAgBC,GACnB,MAAO,KAAO9O,KAAKuP,SAAW,KAG3BI,EAAAzP,UAAAqB,mBACH,OAAOvB,KAAKuP,YAdpB,CAA6ChB,GCEhCP,EAAO,OACP4B,EAAmB,mBACnBC,EAAoB,oBACpBC,EAAQ,QACRC,EAAS,SACTC,EAAS,SAShBC,EAAe,SACfC,EAAmB,aAEzBC,EAAA,gCAGYA,EAAAjQ,UAAAkQ,+BACEC,EAAQ,IAAIC,EACdC,EAAY,GACZC,EAAiC,EAkFrC,OAjFAH,EAAMI,OAAO,SAACC,EAAKC,EAAOC,GAClBA,EAAKhK,OAASoH,IACV3D,EAAKwG,sBAAsBN,IAC3BG,EAAII,OAAO9C,EAAMuC,GACjBA,EAAY,IAEZG,EAAIK,YAIhBV,EAAMW,OAAO,SAACN,GACNrG,EAAKwG,sBAAsBN,IAC3BG,EAAII,OAAO9C,EAAMuC,KAIzBF,EAAMO,KA3BQ,UA2BY,IAAK,SAACF,EAAKC,GACjCD,EAAII,OAAOlB,EAAkBe,EAAM,IACnCD,EAAIzP,KAAKgP,IACVL,GACHS,EAAMO,KAAKX,EAAc,IAAK,SAACS,EAAKC,GAChCD,EAAII,OAAOlB,EAAkBe,EAAM,IACnCD,EAAIzP,KAAKiP,IACVN,GACHS,EAAMO,KAAKX,EAAc,IAAK,SAACS,EAAKC,GAChCD,EAAIO,MACJP,EAAII,OAAOjB,EAAmBc,EAAM,KACrCd,GAEHQ,EAAMO,KAAKV,EAAkB,UAAW,SAACQ,EAAKC,GACzB,OAAbA,EAAM,GACNJ,GAAa,IACO,QAAbI,EAAM,GACbJ,GAAa,IACO,QAAbI,EAAM,KACbJ,GAAa,KAEjBG,EAAIK,UACL/C,GACHqC,EAAMO,KAAKV,EAAkB,IAAK,SAACQ,EAAKC,GACpC,IAAMO,EAAOP,EAAM,GACN,MAATO,GACAV,IACAD,GAAaI,EAAM,GACnBD,EAAIK,UACY,MAATG,EAC8B,EAAjCV,GACAA,IACAD,GAAaI,EAAM,GACnBD,EAAIK,WAEJL,EAAIO,MACJP,EAAII,OAAO9C,EAAMuC,GACjBA,EAAY,GACZG,EAAII,OAAOjB,EAAmBc,EAAM,MAGxCJ,GAAaI,EAAM,GACnBD,EAAIK,WAET/C,GAEHqC,EAAMO,KAAKX,EAAc,IAAK,SAACS,EAAKC,GAChCD,EAAII,OAAOhB,EAAOa,EAAM,KACzBb,GAEHO,EAAMO,KAAKX,EAAc,SAAU,SAACS,EAAKC,GACrCD,EAAII,OAAOf,EAAQY,EAAM,KAC1BZ,GACHM,EAAMO,KAAKX,EAAc,SAAU,SAACS,EAAKC,GACrCD,EAAII,OAAOd,EAAQW,EAAM,KAC1BX,GAEHK,EAAMO,KAAK,IAAK,SAACF,EAAKC,GAClBJ,GAAaI,EAAM,GACnBD,EAAIK,UACL/C,GACHqC,EAAMO,KAAK,QAAS,SAACF,EAAKC,GACtBJ,GAAaI,EAAM,GACnBD,EAAIK,UACL/C,GACIqC,GAGHF,EAAAjQ,UAAA2Q,+BAAsBhI,GAC1B,IAAK,IAAIjI,EAAI,EAAGA,EAAIiI,EAAKnH,OAAQd,IAC7B,IAAK,KAAKuQ,KAAKtI,EAAKC,OAAOlI,IACvB,OAAO,EAGf,OAAO,GAGXuP,EAAAjQ,UAAAkR,SAAA,SAASC,GACL,IAAMhB,EAAkBrQ,KAAKoQ,WAE7B,OADAC,EAAMiB,MAAMD,GACLhB,EAAMkB,UAGjBpB,EAAAjQ,UAAAoR,MAAA,SAAMD,GACFrR,KAAKqQ,MAAQrQ,KAAKoQ,WAClBpQ,KAAKqQ,MAAMiB,MAAMD,IAGrBlB,EAAAjQ,UAAAa,KAAA,WACI,OAAOf,KAAKqQ,MAAMmB,SAGtBrB,EAAAjQ,UAAAuR,KAAA,WACI,OAAOzR,KAAKqQ,MAAMoB,UApH1B,GCrBAC,EAAA,WAEI,SAAAA,EAAoBC,EAA2BC,GAA3B5R,KAAA2R,UAAAA,EAA2B3R,KAAA4R,SAAAA,SAExCF,EAAAxR,UAAA2R,uBACH,OAAO7R,KAAK2R,WAGTD,EAAAxR,UAAA4R,gCACH,OAAO9R,KAAK4R,YATpB,GAiBAG,EAAA,WAMI,SAAAA,EAAoBC,EAAyBC,GAAzBjS,KAAAgS,QAAAA,EAChBhS,KAAKkS,iBAAmBD,EACxBjS,KAAKmS,YAAc,UAGvBJ,EAAA7R,UAAAkS,YAAA,SAAYC,EAAkBxE,GAC1B7N,KAAKmS,YAAYlR,KAAK,IAAIyQ,EAAgBW,EAAUxE,KAQjDkE,EAAA7R,UAAAwN,0BACH,IAAM4E,EAAWtS,KAAKiS,kBAAqB,aAAe,aACpDzD,EAAQxO,KAAKiS,kBAAqB,SAAW,SAC/CM,EAAe,GAInB,OAHAvS,KAAKmS,YAAYrH,QAAQ,SAACuH,GACtBE,GAA8BzD,EAAAA,OAAO,WAAYuD,EAASR,cAAeQ,EAASP,uBAAuBpE,oBAEtGoB,EAAAA,OAAO,cAAewD,EAAS9D,EAAM+D,IAMhDR,EAAA7R,UAAA+R,gBAAA,WACI,OAAOjS,KAAKkS,kBAMhBH,EAAA7R,UAAAsS,gBAAA,WACI,OAAQxS,KAAKkS,kBAQjBH,EAAA7R,UAAAuS,cAAA,WACI,OAAOzS,KAAKmS,aAUhBJ,EAAA7R,UAAAoN,UAAA,SAAUC,GAAV,IAAAlD,EAAArK,KACU6N,EAAU,IAAIkE,EAAW/R,KAAKgS,QAAShS,KAAKiS,mBAC5CS,EAAoC,IAAIC,IA6B9C,OA5BA3S,KAAKmS,YAAYrH,QAAQ,SAACuH,GACtB,IAAIO,EACEC,EAAwDtF,EAAY8E,EAASR,eAE/Ee,EADA/I,EAAAA,kBAAkBgJ,GACER,EAASP,uBACtBrE,EAAAA,SAASoF,IAChBH,EAAqBI,IAAIT,EAASR,eACdxH,EAAK2H,QAAQe,sBAAqB,EAAkC,OAGpE,KAExBlF,EAAQuE,YAAYC,EAASR,cAAee,KAGhDpT,OAAOwT,KAAKzF,GAAazC,QAAQ,SAACmI,GAC9B,IAAKP,EAAqBQ,IAAID,GAAe,CACzC,GAAI5I,EAAKmI,kBACL,MAAM,IAAIjN,MAAMuJ,EAAAA,OAAO,sFACnBmE,IAEJ5I,EAAK8I,yBAAyBF,GAE9B,IAAIL,EAAoBvI,EAAK2H,QAAQe,sBAA+BxF,EAAY0F,GAAe,MAC/FpF,EAAQuE,YAAYa,EAAcL,MAIvC/E,GASHkE,EAAA7R,UAAAiT,kCAAyBF,GAC7B,IAAMG,EAAkB,CAAC,OAAQ,MAAO,MAAO,MAAO,OAAQ,SAC9D,IAAIH,EAAatC,MAAM,UAGnByC,EAAgBzK,KAAK,SAAC0K,GAAQ,OAAAA,IAAQJ,IAG1C,MAAM,IAAI1N,MAAMuJ,EAAAA,OAAO,wDAAyDmE,EAAcG,OA5GtG,GCJAE,EAAA,SAAA5E,GAMI,SAAA4E,EAAYC,EAAgCvB,GAA5C,IAAA3H,EACIqE,EAAA7N,KAAAb,KAAM2O,EAAsBN,cAAYrO,YADAqK,EAAA2H,QAAAA,EAEpCuB,GACAlJ,EAAKmJ,gBAAgBD,YATgB3E,EAAAA,EAAAA,GAmBtC0E,EAAAG,oBAAP,SAA2BF,GAEvB,OADa,IAAID,EAA4B,KAAM,MACvCG,oBAAoBF,IAG7BD,EAAApT,UAAA2O,yBAAgB6E,GACnB,MAAO,kBAOJJ,EAAApT,UAAAyT,yBACH,OAAO3T,KAAK4R,UAQR0B,EAAApT,UAAAsT,yBAAgB3K,GAMpB7I,KAAK4T,aAAe/K,EACpB7I,KAAK6T,WAAa,IAAI1D,EACtBnQ,KAAK6T,WAAWvC,MAAMzI,GACtB7I,KAAK8T,WAAWlE,GAChB5P,KAAK8T,WAAW9F,GAChBhO,KAAK8T,WAAWhE,GAChB,IAAI0B,EAAkBxR,KAAK6T,WAAW9S,OAQtC,IAPIyQ,EAAMhD,OAASuB,EACf/P,KAAK4R,SAAW,IAAIG,EAAW/R,KAAKgS,SAAS,GACtCR,EAAMhD,OAASwB,IACtBhQ,KAAK4R,SAAW,IAAIG,EAAW/R,KAAKgS,SAAS,IAEjDhS,KAAK8T,WAAWhE,GAChB0B,EAAQxR,KAAK6T,WAAWpC,OACjBD,EAAMhD,OAASqB,GAAmB,CACrC,IAAMwC,EAAWrS,KAAK8T,WAAW9F,GAAM9M,MAAM6S,OAC7C/T,KAAK8T,WAAWlE,GAChB,IAAM/B,EAAU7N,KAAK8T,WAAW9F,GAAM9M,MACtClB,KAAK4R,SAASQ,YAAYC,EAAUrS,KAAKgU,sBAAsBnG,IAC/D7N,KAAK8T,WAAWjE,GAChB2B,EAAQxR,KAAK6T,WAAWpC,OAE5BzR,KAAK8T,WAAWjE,GAChB7P,KAAK8T,WAAW,QAQZR,EAAApT,UAAAuT,6BAAoB5K,GAMxB7I,KAAK6T,WAAa,IAAI1D,EACtBnQ,KAAK6T,WAAWvC,MAAMzI,GACtB,IACI7I,KAAK8T,WAAWlE,GAChB5P,KAAK8T,WAAW9F,GAChBhO,KAAK8T,WAAWhE,GAChB,IAAM0B,EAAkBxR,KAAK6T,WAAW9S,OACxC,OAAIyQ,EAAMhD,OAASuB,GAAUyB,EAAMhD,OAASwB,KAG5ChQ,KAAK8T,WAAWhE,IACT,GACT,MAAO3O,GACL,OAAO,IAUPmS,EAAApT,UAAA4T,oBAAWG,GACf,IAAMzC,EAAQxR,KAAK6T,WAAW9S,OAC9B,GAAIyQ,EAAMhD,OAASyF,EACf,MAAM,IAAI1O,MAAMuJ,EAAAA,OAAO,qEACnBmF,EAAWzC,EAAMhD,KAAMgD,EAAMtQ,MAAOlB,KAAK4T,eAEjD,OAAOpC,GAQH8B,EAAApT,UAAA8T,+BAAsBnG,GAC1B,OAAO7N,KAAKgS,QAAQkC,qCAAqCrG,EAAS,SA1H1E,CAAiDU,GCTjD4F,EAAA,SAAAzF,GAOI,SAAAyF,EAAYnF,EAAeC,GAA3B,IAAA5E,EACIqE,EAAA7N,KAAAb,KAAM2O,EAAsBL,kBAAgBtO,YAC5CqK,EAAK6E,OAASF,EACd3E,EAAK8E,MAAQF,WAV+BL,EAAAA,EAAAA,GAazCuF,EAAAjU,UAAA2O,yBAAgBC,GACnB,MAAO,oBAAsB9O,KAAKkP,OAAS,MAGxCiF,EAAAjU,UAAA8O,iBACH,OAAOhP,KAAKkP,QAGTiF,EAAAjU,UAAA+O,gBACH,OAAOjP,KAAKmP,SAtBpB,CAAoDZ,GCFpD6F,EAAA,SAAA1F,GAKI,SAAA0F,EAAY/E,EAAiBC,GAA7B,IAAAjF,EACIqE,EAAA7N,KAAAb,KAAM2O,EAAsBP,YAAUpO,YACtCqK,EAAKkF,SAAWF,EAChBhF,EAAKmF,WAAaF,WARqBV,EAAAA,EAAAA,GAWpCwF,EAAAlU,UAAA2O,yBAAgBC,GACnB,OAAwB,IAApB9O,KAAKwP,WACE,IAAMxP,KAAKuP,SAAW,IAEtB,IAAMvP,KAAKuP,SAAW,QAAUvP,KAAKwP,WAAWC,WAAa,MAIrE2E,EAAAlU,UAAAqB,mBACH,OAAOvB,KAAKuP,UAGT6E,EAAAlU,UAAAwP,qBACH,OAAO1P,KAAKwP,cAxBpB,CAA+CjB,GCc/C8F,EAAA,WAuBI,SAAAA,EAAYC,EAAwBC,GAChCvU,KAAKgS,QAAUsC,EACftU,KAAKuU,cAAgBA,EACrBvU,KAAKwU,OAAS,UAOlBH,EAAAnU,UAAAuU,UAAA,WACI,OAAOzU,KAAKgS,SAUhBqC,EAAAnU,UAAAoN,UAAA,SAAUoH,GACN,GAAI7K,EAAAA,kBAAkB7J,KAAK2T,iBACvB,OAAO3T,KAAKgS,QAAQe,sBAAqB,EAA4B/S,MAErE,MAAM,IAAIuF,MAAMuJ,EAAAA,OAAO,kGACnB4F,EAAkB1U,KAAK0N,oBAYnC2G,EAAAnU,UAAAyU,oBAAA,SAAoBC,GAChB,IAAMC,EAA0B7U,KAAK2T,gBACrC,GAAI9J,EAAAA,kBAAkBgL,GAClB,MAAM,IAAItP,MAAMuJ,EAAAA,OAAO,mEACnB8F,EAAiB5U,KAAK0N,mBAE1B,IAAMoH,EAAoCD,EAAWvH,UAAUsH,GAC/D,OAAO5U,KAAKgS,QAAQwB,gBAAgBsB,EAAqBpH,iBAAkB1N,OASnFqU,EAAAnU,UAAA6U,sBAAA,SAAsBC,GAClB,OAAOhV,KAAKgS,QAAQkC,qCAAqCc,EAAchV,OAQpEqU,EAAAnU,UAAA2O,yBAAgB6E,GACnB,OAAO1T,KAAKwU,OAAOS,IAAI,SAACC,GAAS,OAAAA,EAAKrG,gBAAgB6E,KAAgBjO,KAAK,KAO/E4O,EAAAnU,UAAAwN,eAAA,WACI,OAAI7D,EAAAA,kBAAkB7J,KAAK2T,iBAChBvS,EAAakB,cAActC,KAAKmV,oBAEhCnV,KAAK2T,gBAAgBjG,kBAQ7B2G,EAAAnU,UAAAkV,oBACH,IAEIzU,EAFA0U,GAAY,EACVC,EAA2B,GAiBjC,OAfA3U,EAAIX,KAAKuV,wBACJ1L,EAAAA,kBAAkBlJ,KACnB2U,EAAOE,iBAAmB7U,EAC1B0U,GAAY,GAEhB1U,EAAIX,KAAKyV,4BACJ5L,EAAAA,kBAAkBlJ,KACnB2U,EAAM,qBAAwB3U,EAC9B0U,GAAY,GAEhB1U,EAAIX,KAAK0V,0BACJ7L,EAAAA,kBAAkBlJ,KACnB2U,EAAM,mBAAsB3U,EAC5B0U,GAAY,GAETA,EAAYC,EAAS,MAShCjB,EAAAnU,UAAAyV,iBAAA,WACI,IAEIC,EAFAC,GAAc,EACZrL,EAA6B,GAiBnC,OAfAoL,EAAI5V,KAAK8V,0BACJjM,EAAAA,kBAAkB+L,KACnBpL,EAASuL,mBAAqBH,EAC9BC,GAAc,GAElBD,EAAI5V,KAAKgW,kBACJnM,EAAAA,kBAAkB+L,KACnBpL,EAASyL,WAAaL,EACtBC,GAAc,GAElBD,EAAI5V,KAAKkW,gBACJrM,EAAAA,kBAAkB+L,KACnBpL,EAAS2L,SAAWP,EACpBC,GAAc,GAEXA,EAAcrL,EAAW,MAQ7B6J,EAAAnU,UAAAyT,yBACH,OAA2B,IAAvB3T,KAAKwU,OAAO9S,QAAgB1B,KAAKwU,OAAO,GAAGhG,OAASG,EAAsBN,YAInE,KAHuCrO,KAAKwU,OAAO,GAC3Cb,iBAWfU,EAAAnU,UAAAqV,iCACJ,IAAI5U,EAAI,KACFyV,EAAoB,GAC1B,GAAIpW,KAAKuU,cAAe,CACpB,IAAM8B,EAAqBrW,KAAKuU,cAAc+B,kBACvBtW,KAAKsW,kBACbxL,QAAQ,SAACkE,GACfqH,EAAmBnD,IAAIlE,IACxBoH,EAAkBnV,KAAK+N,KAInC,GAAiC,IAA7BoH,EAAkB1U,OAClBf,EAAI,qBAAuByV,EAAkB,GAAK,0CAC/C,GAA+B,EAA3BA,EAAkB1U,OAAY,CACrC,IAAI6U,EAAuB,GACvBC,GAAQ,EACZJ,EAAkBtL,QAAQ,SAACkE,GAClBwH,IACDD,GAA8C,MAElDA,GAA8CvH,EAC9CwH,GAAQ,IAEZ7V,EAAI,sBAAwB4V,EAAuB,sCAEvD,OAAO5V,GAOH0T,EAAAnU,UAAA4V,mCACJ,IAAIF,EAAI,KACFQ,EAAoB,GAC1B,GAAIpW,KAAKuU,cAAe,CACpB,IAAMkC,EAAqBzW,KAAKuU,cAAc+B,kBACxCI,EAAiB1W,KAAKsW,kBAC5BG,EAAmB3L,QAAQ,SAACkE,GACnB0H,EAAexD,IAAIlE,IACpBoH,EAAkBnV,KAAK+N,KAInC,GAAiC,IAA7BoH,EAAkB1U,OAClBkU,EAAI,uBAAyBQ,EAAkB,GAAK,8BACjD,GAA+B,EAA3BA,EAAkB1U,OAAY,CACrC,IAAIiV,EAAuB,GACvBC,GAAQ,EACZR,EAAkBtL,QAAQ,SAACkE,GAClB4H,IACDD,GAA8C,MAElDA,GAA8C3H,EAC9C4H,GAAQ,IAEZhB,EAAI,wBAA0Be,EAAuB,yBAEzD,OAAOf,GAOHvB,EAAAnU,UAAAwV,mCACJ,IAAI/U,EAAI,KACFyV,EAAoB,GAC1B,GAAIpW,KAAKuU,cAAe,CACpB,IAAMsC,EAAgB7W,KAAKuU,cAAcuC,oBACvB9W,KAAK8W,oBACbhM,QAAQ,SAACkE,GACV6H,EAAc3D,IAAIlE,IACnBoH,EAAkBnV,KAAK+N,KAInC,GAAiC,IAA7BoH,EAAkB1U,OAClBf,EAAI,+BAAiCyV,EAAkB,GAAK,0CACzD,GAA+B,EAA3BA,EAAkB1U,OAAY,CACrC,IAAIqV,EAAuB,GACvBC,GAAQ,EACZZ,EAAkBtL,QAAQ,SAACkE,GAClBgI,IACDD,GAA8C,MAElDA,GAA8C/H,EAC9CgI,GAAQ,IAEZrW,EAAI,gCAAkCoW,EAAuB,sCAEjE,OAAOpW,GAOH0T,EAAAnU,UAAAuV,qCACJ,IAAI9U,EAAI,KACFyV,EAAoB,GAC1B,GAAIpW,KAAKuU,cAAe,CACpB,IAAM0C,EAAgBjX,KAAKuU,cAAcuC,oBACnCI,EAAYlX,KAAK8W,oBACvBG,EAAcnM,QAAQ,SAACkE,GACdkI,EAAUhE,IAAIlE,IACfoH,EAAkBnV,KAAK+N,KAInC,GAAiC,IAA7BoH,EAAkB1U,OAClBf,EAAI,iCAAmCyV,EAAkB,GAAK,8BAC3D,GAA+B,EAA3BA,EAAkB1U,OAAY,CACrC,IAAIyV,EAAuB,GACvBC,GAAQ,EACZhB,EAAkBtL,QAAQ,SAACkE,GAClBoI,IACDD,GAA8C,MAElDA,GAA8CnI,EAC9CoI,GAAQ,IAEZzW,EAAI,kCAAoCwW,EAAuB,yBAEnE,OAAOxW,GAMH0T,EAAAnU,UAAAoW,2BACJ,IAAM/T,EAAS,IAAIoQ,IAOnB,OANA3S,KAAKqX,QAAQvM,QAAQ,SAACoK,GAClB,GAAIA,EAAK1G,OAASG,EAAsBV,YAAa,CACjD,IAAMe,EAAQ,EAAsCA,QACpDzM,EAAOuQ,IAAI9D,MAGZzM,GAQJ8R,EAAAnU,UAAAoX,4BAAmBtI,GACtB,IAAIuI,EAA4C,KAShD,OARAvX,KAAKqX,QAAQvM,QAAQ,SAACoK,GAClB,GAAIA,EAAK1G,OAASG,EAAsBV,YAAa,CACjD,IAAMuJ,EAAM,EACRA,EAAOxI,UAAYA,IACnBuI,EAAcC,MAInBD,EAAcA,EAAYtI,OAAS,MAMtCoF,EAAAnU,UAAA4W,6BACJ,IAAMvU,EAAS,IAAIoQ,IAOnB,OANA3S,KAAKqX,QAAQvM,QAAQ,SAACoK,GAClB,GAAIA,EAAK1G,OAASG,EAAsBL,gBAAiB,CACrD,IAAMU,EAAQ,EAAwCA,QACtDzM,EAAOuQ,IAAI9D,MAGZzM,GAQJ8R,EAAAnU,UAAAuX,8BAAqBzI,GACxB,IAAI0I,EAAoD,KASxD,OARA1X,KAAKqX,QAAQvM,QAAQ,SAACoK,GAClB,GAAIA,EAAK1G,OAASG,EAAsBL,gBAAiB,CACrD,IAAMqJ,EAAO,EACTA,EAAQ3I,UAAYA,IACpB0I,EAAoBC,MAIzBD,EAAoBA,EAAkBzI,OAAS,MAOlDoF,EAAAnU,UAAAgW,yBACJ,IAAIvV,EAAI,KACFiX,EAAiB,GACvB,GAAI5X,KAAKuU,cAAe,CACpB,IAAMsD,EAAa7X,KAAKuU,cAAcuD,UACvB9X,KAAK8X,UACbhN,QAAQ,SAACvJ,GACPsW,EAAW3E,IAAI3R,IAChBqW,EAAe3W,KAAKM,KAIhC,GAA8B,IAA1BqW,EAAelW,OACff,EAAI,cAAgBiX,EAAe,GAAK,2CACrC,GAA4B,EAAxBA,EAAelW,OAAY,CAClC,IAAIqW,EAAoB,GACpBC,GAAQ,EACZJ,EAAe9M,QAAQ,SAAClC,GACfoP,IACDD,GAAwC,MAE5CA,EAAoBA,EAAoB,IAAMnP,EAAM,IACpDoP,GAAQ,IAEZrX,EAAI,cAAgBoX,EAAoB,sCAE5C,OAAOpX,GAOH0T,EAAAnU,UAAA8V,2BACJ,IAAIJ,EAAI,KACFgC,EAAiB,GACvB,GAAI5X,KAAKuU,cAAe,CACpB,IAAM0D,EAAajY,KAAKuU,cAAcuD,UAChCI,EAASlY,KAAK8X,UACpBG,EAAWnN,QAAQ,SAACvJ,GACX2W,EAAOhF,IAAI3R,IACZqW,EAAe3W,KAAKM,KAIhC,GAA8B,IAA1BqW,EAAelW,OACfkU,EAAI,gBAAkBgC,EAAe,GAAK,+BACvC,GAA4B,EAAxBA,EAAelW,OAAY,CAClC,IAAIyW,EAAoB,GACpBC,GAAQ,EACZR,EAAe9M,QAAQ,SAAClC,GACfwP,IACDD,GAAwC,MAE5CA,EAAoBA,EAAoB,IAAMvP,EAAM,IACpDwP,GAAQ,IAEZxC,EAAI,gBAAkBuC,EAAoB,yBAE9C,OAAOvC,GAMHvB,EAAAnU,UAAA4X,mBACJ,IAAMvV,EAAS,IAAIoQ,IAOnB,OANA3S,KAAKqX,QAAQvM,QAAQ,SAACoK,GAClB,GAAIA,EAAK1G,OAASG,EAAsBT,WAAagH,EAAK1G,OAASG,EAAsBP,UAAW,CAChG,IAAM7M,EAAU,EAAmCA,UACnDgB,EAAOuQ,IAAIvR,MAGZgB,GAGJ8R,EAAAnU,UAAAmX,iBACH,OAAOrX,KAAKwU,QAGhBH,EAAAnU,UAAAmY,qBAAA,SAAqBC,GACjBtY,KAAKmV,mBAAqBmD,GAG9BjE,EAAAnU,UAAAqY,QAAA,SAAQ1P,GACJ7I,KAAKwU,OAAOvT,KAAK,IAAIwN,EAAsB5F,KAG/CwL,EAAAnU,UAAAsY,eAAA,SAAexJ,EAAeC,GAC1BjP,KAAKwU,OAAOvT,KAAK,IAAI8N,EAA6BC,EAAOC,KAG7DoF,EAAAnU,UAAAuY,YAAA,SAAYpJ,EAAiBC,GACzBtP,KAAKwU,OAAOvT,KAAK,IAAImO,EAA0BC,EAASC,KAG5D+E,EAAAnU,UAAAwY,UAAA,SAAUrJ,GAEN,IAAMsJ,EAAU3Y,KAAK4Y,uBACrB,IAAKD,GAAWA,IAAYtJ,EAExB,MAAM,IAAI9J,MAAMuJ,EAAAA,OAAO,qEACnBO,EAASsJ,EAAS3Y,KAAK0N,mBAE/B1N,KAAKwU,OAAOvT,KAAK,IAAI0O,EAAwBN,KAGjDgF,EAAAnU,UAAA2Y,YAAA,SAAYxJ,EAAiBC,GACzBtP,KAAKwU,OAAOvT,KAAK,IAAImT,EAA0B/E,EAASC,KAG5D+E,EAAAnU,UAAA4Y,iBAAA,SAAiB9J,EAAeC,GAC5BjP,KAAKwU,OAAOvT,KAAK,IAAIkT,EAA+BnF,EAAOC,KAG/DoF,EAAAnU,UAAA6Y,cAAA,SAAclQ,GACV7I,KAAKwU,OAAOvT,KAAK,IAAIqS,EAA4BzK,EAAM7I,KAAKgS,WAOxDqC,EAAAnU,UAAA0Y,2CACEI,EAAW,GAiBjB,OAhBAhZ,KAAKwU,OAAO1J,QAAQ,SAACoK,GACjB,OAAQA,EAAK1G,MACT,KAAKG,EAAsBT,UACvB8K,EAAS/X,KAAK,EAAmCM,WACjD,MACJ,KAAKoN,EAAsBR,QACvB,IAAM5M,EAAU,EAAiCA,UACjD,GAAwB,IAApByX,EAAStX,QAAgBsX,EAASA,EAAStX,OAAS,KAAOH,EAAS,CAEpE,IAAMoX,EAA+B,IAApBK,EAAStX,OAAgB,UAAYsX,EAASA,EAAStX,OAAS,GACjF,MAAM,IAAI6D,MAAMuJ,EAAAA,OAAO,qEACnBvN,EAASoX,EAAStO,EAAKqD,mBAE/BsL,EAAS/H,SAGM,IAApB+H,EAAStX,OAAe,KAAOsX,EAASA,EAAStX,OAAS,MAhgBzE,GCXasM,EAAO,OACPE,EAAY,YACZC,EAAU,UACVC,EAAY,YACZH,EAAc,cACdK,EAAkB,kBAClBD,EAAc,cAO3B4K,EAAA,gCAEYA,EAAA/Y,UAAAkQ,oBACJ,IAAMC,EAAQ,IAAIC,EACdC,EAAY,GAgDhB,OA/CAF,EAAMI,OAAO,SAACC,EAAKC,EAAOC,GAClBA,EAAKhK,OAASoH,GAAsB,KAAduC,IACtBG,EAAII,OAAO9C,EAAM,CAACnF,KAAM0H,IACxBA,EAAY,MAGpBF,EAAMW,OAAO,SAACN,GACQ,KAAdH,GACAG,EAAII,OAAO9C,EAAM,CAACnF,KAAM0H,MAKhCF,EAAMO,KAAK,gDAAiD,SAACF,EAAKC,GAC9D,IAAMuI,EAAUrP,EAAAA,kBAAkB8G,EAAM,IAAM,EAAIwI,SAASxI,EAAM,GAAI,IACrED,EAAII,OAAO1C,EAAW,CAACxH,KAAM+J,EAAM,GAAIrB,UAAW4J,KACnD9K,GAEHiC,EAAMO,KAAK,6CAA8C,SAACF,EAAKC,GAC3D,IAAMuI,EAAUrP,EAAAA,kBAAkB8G,EAAM,IAAM,EAAIwI,SAASxI,EAAM,GAAI,IACrED,EAAII,OAAO5C,EAAW,CAACtH,KAAM+J,EAAM,GAAIrB,UAAW4J,KACnDhL,GAEHmC,EAAMO,KAAK,8BAA+B,SAACF,EAAKC,GAC5CD,EAAII,OAAO3C,EAAS,CAACvH,KAAM+J,EAAM,MAClCxC,GAEHkC,EAAMO,KAAK,eAAgB,SAACF,EAAKC,GAC7BD,EAAII,OAAO7C,EAAa,CAACqB,UAAW6J,SAASxI,EAAM,GAAI,OACxD1C,GAEHoC,EAAMO,KAAK,+BAAgC,SAACF,EAAKC,GAC7CD,EAAII,OAAOxC,EAAiB,CAACgB,UAAW6J,SAASxI,EAAM,GAAI,OAC5DrC,GAEH+B,EAAMO,KAAK,kBAAmB,SAACF,EAAKC,GAChCD,EAAII,OAAOzC,EAAa,CAACR,QAAS8C,EAAM,MACzCtC,GAEHgC,EAAMO,KAAK,IAAK,SAACF,EAAKC,GAClBJ,GAAaI,EAAM,GACnBD,EAAIK,UACL/C,GACHqC,EAAMO,KAAK,YAAa,SAACF,EAAKC,GAC1BJ,GAAaI,EAAM,GACnBD,EAAIK,UACL/C,GACIqC,GAGX4I,EAAA/Y,UAAAkR,SAAA,SAASC,GACL,IAAMhB,EAAkBrQ,KAAKoQ,WAG7B,OAFAC,EAAM+I,QACN/I,EAAMiB,MAAMD,GACLhB,EAAMkB,YA3DrB,GCAA8H,EAAA,gCAQWA,EAAAnZ,UAAAoZ,wCAA+BC,EAAqBhF,GACvD,IAAM1G,EAAyB,IAAIwG,EAAcrU,KAAMuU,GAKvD,OAJIgF,IACA1L,EAAQwK,qBAAqBkB,GAC7BvZ,KAAKwZ,wBAAwBD,EAAY1L,GAAS,IAE/CA,GASXwL,EAAAnZ,UAAAgU,qCAAA,SAAqC/K,EAAmBoL,GACpD,IACMgF,GADgB,IAAI7V,EAAAA,WAAYC,gBAAgB,UAAYwF,EAAY,WAAY,YAChDnG,WAAWrB,KAAK,GAC1D,OAAO3B,KAAKsZ,+BAA+BC,EAAYhF,IASnD8E,EAAAnZ,UAAAsZ,iCAAwB1X,EAAY+L,EAAwB4L,GAChE,IAAIC,GAAkB,EACtB,GAAID,EAAa,CACb,GAAI3X,EAAKI,WAAaJ,EAAKoB,UAEvB,YADA2K,EAAQ0K,QAAQzW,EAAK6X,aAGrB7X,EAAKI,WAAaJ,EAAKK,eACvBuX,EAAkB1Z,KAAK4Z,oBAAmB,EAAiB/L,IAGnE,GAAI6L,EAAiB,CACjB,IAAMnG,EAAiBvT,KAAK6Z,kBAAkB/X,GAC1CgY,GAASjQ,EAAAA,kBAAkB0J,GAC/B,GAAIuG,EACA,IACIjM,EAAQkL,cAAcxF,GACxB,MAAOpS,GAEL4Y,QAAQC,IAAI,oBAAqBzG,EAAgBpS,GACjD2Y,GAAQ,EAGhB,IAAKA,EAED,IADA,IAAMG,EAAWnY,EAAKkB,WACbpC,EAAI,EAAGA,EAAIqZ,EAASvY,OAAQd,IACjCZ,KAAKwZ,wBAAwBS,EAAStY,KAAKf,GAAIiN,GAAS,GAIhE/L,EAAKI,WAAaJ,EAAKK,cACvBnC,KAAKka,kBAAiB,EAAiBrM,IASrCwL,EAAAnZ,UAAA2Z,kBAAV,SAA4B/X,GACxB,IAAMmY,EAAWnY,EAAKkB,WACtB,GAAwB,IAApBiX,EAASvY,OACT,OAAO,KAEX,IAAM6B,EAAa0W,EAAStY,KAAK,GACjC,OAAI4B,EAAWrB,WAAaqB,EAAWL,WAC/BlD,KAAK+N,kBAAkBxK,EAAWoW,aAC3BvY,EAAakB,cAAa,GAK9B,MAQR+W,EAAAnZ,UAAA6N,2BAAkBlF,GACrB,OAAOyK,EAA4BG,oBAAoB5K,IA4BpDwQ,EAAAnZ,UAAA6S,+BAAsB2B,EAA0BH,GACnD,IAEIhD,EAFE1D,EAAyB,IAAIwG,EAAcrU,KAAMuU,GACjDyE,EAAW,GAEjB,IACIzH,GAAS,IAAI0H,GAAwB7H,SAASsD,GAChD,MAAOvT,GACL,MAAM,IAAIoE,MAAMuJ,EAAAA,OAAO,4DAA6D3N,EAAM0M,QAAS6G,IAqCvG,GAnCAnD,EAAOzG,QAAQ,SAAC0G,GACZ,IAAIvC,EAAe,KACnB,OAAQuC,EAAMhD,MACV,KAAKR,EACDH,EAAQ0K,QAAQ/G,EAAMtQ,MAAM2H,MAC5B,MACJ,KAAKqF,EACDL,EAAQ4K,YAAYjH,EAAMtQ,MAAM0F,KAAM4K,EAAMtQ,MAAMoO,WAClD0J,EAAS/X,KAAKuQ,EAAMtQ,MAAM0F,MAC1B,MACJ,KAAKuH,EAED,GADAN,EAAQ6K,UAAUlH,EAAMtQ,MAAM0F,MACN,IAApBoS,EAAStX,QAAgBsX,EAASA,EAAStX,OAAS,KAAO8P,EAAMtQ,MAAM0F,KAEvE,MAAM,IAAIrB,MAAMuJ,EAAAA,OAAO,0CAA2C0C,EAAMtQ,MAAM0F,KAAM8N,IAExFsE,EAAS/H,MACT,MACJ,KAAK7C,EACDP,EAAQgL,YAAYrH,EAAMtQ,MAAM0F,KAAM4K,EAAMtQ,MAAMoO,WAClD,MACJ,KAAKrB,EACDgB,EAAO,EAAkBsF,EAAc+C,mBAAmB9F,EAAMtQ,MAAMoO,WAAa,KACnFzB,EAAQ2K,eAAehH,EAAMtQ,MAAMoO,UAAWL,GAC9C,MACJ,KAAKX,EACDW,EAAO,EAAkBsF,EAAckD,qBAAqBjG,EAAMtQ,MAAMoO,WAAa,KACrFzB,EAAQiL,iBAAiBtH,EAAMtQ,MAAMoO,UAAWL,GAChD,MACJ,KAAKZ,EACD,MAAM,IAAI9I,MAAMuJ,EAAAA,OAAO,2EAA4E4F,OAKzF,EAAlBsE,EAAStX,OAET,MAAM,IAAI6D,MAAMuJ,EAAAA,OAAO,uCAAwCkK,EAASA,EAAStX,OAAS,GAAIgT,IAGlG,OADA7G,EAAQwK,qBAAqBrY,KAAKma,wBAAwBtM,IACnDA,GAUXwL,EAAAnZ,UAAAsT,gBAAA,SAAgB4G,EAA0B7F,GACtC,IAAM1G,EAAyB,IAAIwG,EAAcrU,KAAMuU,GAEvD,OADA1G,EAAQkL,cAAcqB,GACfvM,GAWDwL,EAAAnZ,UAAAma,qBAAV,SAA+BzT,GAC3B,IACM+J,EADQ,cACM2J,KAAK1T,GACzB,GAAIiD,EAAAA,kBAAkB8G,IAAuB,KAAbA,EAAM,GAClC,OAAO,EAEP,IAAM4J,EAAM5J,EAAM,GAClB,OAAOwI,SAASoB,EAAK,KASnBlB,EAAAnZ,UAAAia,wBAAV,SAAkCtM,GAC9B,IACM2M,GADiB,IAAI9W,EAAAA,WAAYC,gBAAgB,WAAY,YACpClC,qBAAqB,SAASE,KAAK,GAElE,OADA3B,KAAKya,2BAA2B5M,EAAS2M,GAClCA,GAKDnB,EAAAnZ,UAAAwa,kCAAV,SAA4CxF,EAA6BsF,GACrE,OAAOA,EAASzW,cAAc4W,eAAezF,EAAKrG,sBAhO1D,GCdM+L,EAAkD,CACpDC,EAAK,OACLC,EAAK,YACLC,GAAM,aACNC,GAAM,kBACNC,GAAM,iBACNC,GAAM,iBACNC,GAAM,iBACNC,GAAM,iBACNC,GAAM,iBACNC,GAAM,iBACNC,GAAM,kBACNC,EAAK,cACLC,GAAM,YACNC,KAAQ,aACRC,GAAM,eACNC,EAAK,YACLC,EAAK,YACLC,EAAK,qBACLC,MAAS,aACTC,IAAO,YACPC,IAAO,cACPC,MAAS,aACTC,GAAM,aACNC,MAAS,eACTC,GAAM,oBACNC,MAAS,eACTC,GAAM,YACNC,GAAM,kBACNC,EAAK,kBACLC,GAAM,kBAMJC,GAAY,CAAC,KAAM,KAAM,MAAO,OAAQ,OAAQ,OAEtDC,GAAA,gCAEWA,EAAA1c,UAAA2c,oCAA2BjU,EAAa/G,GAC3C,IAAMib,EAAWlU,EAAImU,cAErB,MAAO,UADUnC,EAAyBkC,IAAa,OAAOA,GACjC9c,KAAKgd,cAAcnb,IAG7C+a,EAAA1c,UAAA+c,oCAA2BrU,GAC9B,IAAMkU,EAAWlU,EAAImU,cAErB,MAAO,UADUnC,EAAyBkC,IAAa,OAAOA,IAI3DF,EAAA1c,UAAAgd,oCAA2BtU,EAAa/G,GAC3C,IAAMib,EAAWlU,EAAImU,cAErB,OADkBnC,EAAyBkC,IAAa,OAAOA,GAC7C9c,KAAKgd,cAAcnb,IAGlC+a,EAAA1c,UAAAid,wBAAevU,GAClB,OAAQA,EAAIwU,eACR,IAAK,KACD,MAAO,KACX,IAAK,MACD,MAAO,QACX,QACI,MAAO,KAAKxU,IAIjBgU,EAAA1c,UAAAmd,+CAAsCC,GACzC,GAAIA,EAAgBC,WAAW,cAC3B,OAAOvd,KAAKwd,aAAaF,EAAgBG,UAAU,aAAa/b,SAAS0b,cACtE,GAAIE,EAAgBC,WAAW,UAAW,CAC7C,IAAMG,EAAK1d,KAAKwd,aAAaF,EAAgBG,UAAU,SAAS/b,SAC1Dic,EAAWne,OAAOwT,KAAK4H,GAA0BjS,KAAK,SAAC0K,GAAQ,OAAAuH,EAAyBvH,KAASqK,IACvG,OAAOC,EAAWA,EAASP,cAAgB,KAE/C,OAAO,MAGJR,EAAA1c,UAAA0d,+CAAsCN,GACzC,GAAIA,EAAgBC,WAAW,cAC3B,OAAOvd,KAAKwd,aAAaF,EAAgBG,UAAU,aAAa/b,SAAS0b,cACtE,GAAIE,EAAgBC,WAAW,UAAW,CAC7C,IAAMM,EAAK7d,KAAKwd,aAAaF,EAAgBG,UAAU,SAAS/b,SAC1Dic,EAAWne,OAAOwT,KAAK4H,GAA0BjS,KAAK,SAAC0K,GAAQ,OAAAuH,EAAyBvH,KAASwK,IACvG,OAAOF,EAAWA,EAASP,cAAgB,KAE/C,OAAO,MAOJR,EAAA1c,UAAA4d,mCAA0BR,GAC7B,IACIK,EADEI,EAAK/d,KAAKwd,aAAaF,GAO7B,UAJIK,EADAI,EAAGR,WAAW,QACHQ,EAAGN,UAAU,GAAGV,cAEhBvd,OAAOwT,KAAK4H,GAA0BjS,KAAK,SAAC0K,GAAQ,OAAAuH,EAAyBvH,KAAS0K,MAG9D,GAA/BpB,GAAUqB,QAAQL,KAWvBf,EAAA1c,UAAA+d,+CAAsCX,GACzC,IACIK,EADEI,EAAK/d,KAAKwd,aAAaF,GAO7B,OAJIK,EADAI,EAAGR,WAAW,QACHQ,EAAGN,UAAU,GAAGV,cAEhBvd,OAAOwT,KAAK4H,GAA0BjS,KAAK,SAAC0K,GAAQ,OAAAuH,EAAyBvH,KAAS0K,MAG9D,GAA/BpB,GAAUqB,QAAQL,GACXA,EAASP,cAKjB,MAQHR,EAAA1c,UAAAsd,sBAAaF,GACjB,GAAIA,EAAiB,CACjB,IAAMY,EAAK,eACX,GAAIZ,EAAgB3M,MAAMuN,GACtB,OAAOZ,EAAgBza,QAAQqb,EAAI,MAG3C,OAAOZ,GASHV,EAAA1c,UAAA8c,uBAAcnb,GAClB,OAAW,IAAPA,EACO,GAEA,IAAMA,EAAG4N,SAAS,OAxHrC,GC/BA0O,GAAA,SAAAzP,sEAAwCE,EAAAA,EAAAA,GAS1BuP,EAAAje,UAAA0Z,oBAAV,SAA8BhU,EAAsBiI,GAChD,IAAMtM,EAAUqE,EAAYrE,QACtB6c,EAAa,IAAIxB,GACvB,GAAgB,MAAZrb,EAAiB,CAEjB,IAAMM,EAAK+D,EAAY7D,aAAa,MACpC,IAAKF,EACD,OAEJ,GAAIA,EAAG0b,WAAW,iBAAkB,CAChC,IAAMvO,EAAQhP,KAAKqe,4BAA4Bxc,GAC/CgM,EAAQ2K,eAAexJ,EAAO,WAC3B,GAAInN,EAAG0b,WAAW,OAAQ,CACvBvO,EAAQhP,KAAKse,8BAA8Bzc,GACjDgM,EAAQiL,iBAAiB9J,EAAO,WAC7B,GAAInN,EAAG0b,WAAW,UAAW,CAEhC,GADMgB,EAAoBH,EAAWf,sCAAsCxb,GACpD,CACnB,IAAMqX,EAAUlZ,KAAKqa,qBAAqBxY,GAC1CgM,EAAQ4K,YAAY8F,EAAmBrF,SAExC,GAAIrX,EAAG0b,WAAW,UAAW,EAC1BgB,EAAoBH,EAAWR,sCAAsC/b,KAEvEgM,EAAQ6K,UAAU6F,QAEnB,GAAIH,EAAWN,0BAA0Bjc,GAAK,CACjD,IAAM0c,EACN,GADMA,EAAoBH,EAAWH,sCAAsCpc,GACpD,CACbqX,EAAUlZ,KAAKqa,qBAAqBxY,GAC1CgM,EAAQgL,YAAY0F,EAAmBrF,KAInD,OAAO,GASDiF,EAAAje,UAAAga,kBAAV,SAA4BtU,EAAsBiI,KAS1CsQ,EAAAje,UAAAme,qCAA4Bxc,GAChC,IAAI2c,EAAc,GAOlB,OAJIA,EADO,kBAAP3c,EACc,IAEAA,EAAG4b,UAAU,iBAAiB/b,QAEzC+c,OAAOtF,SAASqF,EAAa,KAShCL,EAAAje,UAAAoe,uCAA8Bzc,GAClC,IAAI2c,EAAc,GAOlB,OAJIA,EADO,QAAP3c,EACc,IAEAA,EAAG4b,UAAU,OAAO/b,QAE/B+c,OAAOtF,SAASqF,EAAa,KAG9BL,EAAAje,UAAAua,2BAAV,SAAqC5M,EAAwB2M,GAA7D,IAAAnQ,EAAArK,KACI6N,EAAQwJ,QAAQvM,QAAQ,SAACoK,GACrB,IAAIjS,EACJ,OAAQiS,EAAK1G,MACT,KAAKG,EAAsBX,KACvB/K,EAAQoH,EAAKqQ,kCAAiC,EAA+BF,GAC7E,MACJ,KAAK7L,EAAsBT,UACvBjL,EAAQoH,EAAKqU,sCAAqC,EAAoClE,GACtF,MACJ,KAAK7L,EAAsBR,QACvBlL,EAAQoH,EAAKsU,oCAAmC,EAAkCnE,GAClF,MACJ,KAAK7L,EAAsBP,UACvBnL,EAAQoH,EAAKuU,sCAAqC,EAAoCpE,GACtF,MACJ,KAAK7L,EAAsBV,YACvBhL,EAAQoH,EAAKwU,yCAAwC,EAAuCrE,GAC5F,MACJ,KAAK7L,EAAsBL,gBACvBrL,EAAQoH,EAAKyU,2CAA0C,EAAyCtE,GAGpGvX,GACAuX,EAAS1W,YAAYb,MAWvBkb,EAAAje,UAAAwe,sCAAV,SAAgDxJ,EAAiCsF,GAC7E,IAAMuE,EAAQvE,EAASzW,cAAcM,cAAc,KAC7C+Z,EAAa,IAAIxB,GACjBoC,EAAWZ,EAAWvB,2BAA2B3H,EAAK3T,UAAW2T,EAAKxF,aACtEuP,EAAcb,EAAWjB,eAAejI,EAAK3T,WAC7C2d,EAAgB,IAAMhK,EAAK3T,UAAY,IAI7C,OAHAwd,EAAMI,aAAa,KAAMH,GACzBD,EAAMI,aAAa,QAASF,GAC5BF,EAAMI,aAAa,aAAcD,GAC1BH,GASDZ,EAAAje,UAAAye,oCAAV,SAA8CzJ,EAA+BsF,GACzE,IAAMuE,EAAQvE,EAASzW,cAAcM,cAAc,KAE7C2a,GADa,IAAIpC,IACKK,2BAA2B/H,EAAK3T,WACtD0d,EAAc,KAAO/J,EAAK3T,UAGhC,OAFAwd,EAAMI,aAAa,KAAMH,GACzBD,EAAMI,aAAa,QAASF,GACrBF,GASDZ,EAAAje,UAAA0e,sCAAV,SAAgD1J,EAAiCsF,GAC7E,IAAMuE,EAAQvE,EAASzW,cAAcM,cAAc,KAC7C+Z,EAAa,IAAIxB,GACjBoC,EAAWZ,EAAWlB,2BAA2BhI,EAAK3T,UAAW2T,EAAKxF,aACtEuP,EAAcb,EAAWjB,eAAejI,EAAK3T,WAC7C2d,EAAgB,IAAMhK,EAAK3T,UAAY,KAI7C,OAHAwd,EAAMI,aAAa,KAAMH,GACzBD,EAAMI,aAAa,QAASF,GAC5BF,EAAMI,aAAa,aAAcD,GAC1BH,GASDZ,EAAAje,UAAA2e,yCAAV,SAAmD3J,EAAoCsF,GACnF,IAAMuE,EAAQvE,EAASzW,cAAcM,cAAc,KAC/C2a,EAAW,gBACI,EAAf9J,EAAKlG,UACLgQ,EAAW,iBAAmB9J,EAAKlG,QAAQS,SAAS,KAExD,IAAMyP,EAAgBhK,EAAKjG,OAK3B,OAJA8P,EAAMI,aAAa,KAAMH,GACrBE,GACAH,EAAMI,aAAa,aAAcD,GAE9BH,GAQDZ,EAAAje,UAAA4e,2CAAV,SAAqD5J,EAAsCsF,GACvF,IAAMuE,EAAQvE,EAASzW,cAAcM,cAAc,KAC/C2a,EAAW,MAKf,OAJmB,EAAf9J,EAAKlG,UACLgQ,EAAW,OAAS9J,EAAKlG,QAAQS,SAAS,KAE9CsP,EAAMI,aAAa,KAAMH,GAClBD,KA1Mf,CAAwC1F,GCCxC+F,GAAA,SAAA1Q,GAEI,SAAA0Q,EAAYrT,EAAmBC,EAAaC,UACxCyC,EAAA7N,KAAAb,KAAM+L,EAAUC,EAAKC,IAAyBjM,YAHlB4O,EAAAA,EAAAA,GAMzBwQ,EAAAlf,UAAAmf,yBACH,IAAMC,EAAgBle,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC3E,OAAO3K,EAAakB,cAAcgd,IAS/BF,EAAAlf,UAAAqf,0BAAiBC,GACpB,IAAIC,EAASre,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC7D0T,IAEDA,EAASzf,KAAK+L,SAASjI,YAAY9D,KAAK+L,SAAShI,cAAcM,cAAc,YAEjFjD,EAAaiC,6BAA6Boc,EAAQD,IAM5CJ,EAAAlf,UAAA4N,cAAV,WACI,OAAO,IAAIqQ,IAMRiB,EAAAlf,UAAAoM,yCACH,IAAMgT,EAAgBle,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC3E,OAAIuT,EACOtf,KAAK8N,gBAAgBwL,+BAA+BgG,EAAe,MAEnE,MAORF,EAAAlf,UAAAwf,yBACH,IAAMC,EAAgBve,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC3E,OAAO3K,EAAakB,cAAcqd,IAOtCP,EAAAlf,UAAA0f,wBAAA,WACI,IAAMD,EAAgBve,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC3E,OAAO,IAAIoS,IAAqB7E,+BAA+BqG,EAAe3f,KAAKoM,4BAMhFgT,EAAAlf,UAAAsM,6BACH,IAAMmT,EAAgBve,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC3E,OAAI4T,EACOA,EAAc5d,aAAa,SAE3B,MAQLqd,EAAAlf,UAAA0M,qBAAV,SAA+BL,GAC3B,IAAMoT,EAAgBve,EAAaC,yBAAyBrB,KAAK+L,SAAU,UACvE4T,GACAA,EAAcR,aAAa,QAAS5S,IAWlC6S,EAAAlf,UAAA2M,sBAAV,SAAgCvC,GAC5B,OAASA,GACL,KAAKrL,EACD,MAAO,MACX,KAAKC,EACD,MAAO,aACX,KAAKC,EACD,MAAO,QACX,QACI,MAAM,IAAIoG,MAAM,iBAAoB+E,KAStC8U,EAAAlf,UAAAuM,sBAAV,SAAgCF,GAC5B,OAASA,GACL,IAAK,MAEL,IAAK,oBACD,OAAOtN,EACX,IAAK,aAEL,IAAK,mBAEL,IAAK,aAEL,IAAK,0BAEL,IAAK,oBAEL,IAAK,2BACD,OAAOC,EACX,IAAK,QAEL,IAAK,aACD,OAAOC,EACX,QACI,OAAOF,IAYZmgB,EAAAlf,UAAA2f,4BAGH,IAFA,IAAMC,EAAiB9f,KAAK+L,SAAStK,qBAAqB,iBACpDse,EAA2D,GACxDnf,EAAI,EAAGA,EAAIkf,EAAepe,OAAQd,IAAK,CAC5C,IAAMof,EAAOF,EAAene,KAAKf,GACjC,GAAqC,aAAjCof,EAAKje,aAAa,WAA2B,CAI7C,IAHA,IAAMke,EAAkBD,EAAKve,qBAAqB,WAC9Cye,EAAa,KACbC,EAAa,EACRvc,EAAI,EAAGA,EAAIqc,EAAgBve,OAAQkC,IAAK,CAC7C,IAAMwc,EAAcH,EAAgBte,KAAKiC,GACQ,eAA7Cwc,EAAYre,aAAa,kBACzBme,EAAa9e,EAAa2B,UAAUqd,IAES,eAA7CA,EAAYre,aAAa,kBACzBoe,EAAa1B,OAAOtF,SAAS/X,EAAa2B,UAAUqd,GAAc,KAG1EL,EAAW9e,KAAK,CAACif,WAAYA,EAAYC,WAAYA,KAG7D,OAAOJ,GASJX,EAAAlf,UAAAmgB,6BAAoBN,cACvB/f,KAAKsgB,4BACLP,EAAWjV,QAAQ,SAACyV,GAChB,IAAMC,EAAenW,EAAK0B,SAAShI,cAAcM,cAAc,iBAC/Dmc,EAAarB,aAAa,UAAW,YACrC,IAAMsB,EAAgBpW,EAAK0B,SAAShI,cAAcM,cAAc,WAChEoc,EAActB,aAAa,eAAgB,cAC3CsB,EAAc3c,YAAYuG,EAAK0B,SAAShI,cAAc4W,eAAe4F,EAAIL,aACzE,IAAMQ,EAAcrW,EAAK0B,SAAShI,cAAcM,cAAc,WAC9Dqc,EAAYvB,aAAa,eAAgB,cACzCuB,EAAY5c,YAAYuG,EAAK0B,SAAShI,cAAc4W,eAAe4F,EAAIJ,WAAW1Q,SAAS,MAC3F+Q,EAAa1c,YAAY2c,GACzBD,EAAa1c,YAAY4c,GACzBrW,EAAK0B,SAASjI,YAAY0c,MAI1BpB,EAAAlf,UAAAogB,qCAGJ,IAFA,IAAMR,EAAiB9f,KAAK+L,SAAStK,qBAAqB,iBACpDkf,EAAc,GACX/f,EAAI,EAAGA,EAAIkf,EAAepe,OAAQd,IAAK,CAC5C,IAAMof,EAAOF,EAAene,KAAKf,GACI,aAAjCof,EAAKje,aAAa,YAClB4e,EAAY1f,KAAK+e,GAGzBW,EAAY7V,QAAQ,SAACkV,GAAUA,EAAKzb,WAAWf,YAAYwc,MAQxDZ,EAAAlf,UAAA0gB,uBACH,IAAMC,EAAW7gB,KAAK8gB,iCAAiC,eACvD,OAAID,EACOzf,EAAa2B,UAAU8d,GAEvB,MAQRzB,EAAAlf,UAAA6gB,wBAAeH,GAClB,IAAIC,EAAW7gB,KAAK8gB,iCAAiC,eACjDF,EACG/W,EAAAA,kBAAkBgX,GAElBA,EAAW7gB,KAAKghB,mCAAmC,cAAeJ,GAElExf,EAAaiC,6BAA6Bwd,EAAUD,GAGlD/W,EAAAA,kBAAkBgX,IAEnB7gB,KAAKihB,mCAAmC,gBAU5C7B,EAAAlf,UAAA4gB,0CAAiCI,GAErC,IADA,IAAMC,EAAenhB,KAAK+L,SAAStK,qBAAqB,QAC/Cb,EAAI,EAAGA,EAAIugB,EAAazf,OAAQd,IAAK,CAC1C,IAAMigB,EAAWM,EAAaxf,KAAKf,GACnC,GAAIigB,EAAS9e,aAAa,UAAYmf,EAClC,OAAOL,EAGf,OAAO,MAOHzB,EAAAlf,UAAAkhB,yCAGJ,IAFA,IAAMD,EAAenhB,KAAK+L,SAAStK,qBAAqB,QAClDc,EAAoB,GACjB3B,EAAI,EAAGA,EAAIugB,EAAazf,OAAQd,IAAK,CAC1C,IAAMigB,EAAWM,EAAaxf,KAAKf,GAC7BygB,EAAgBR,EAAS9e,aAAa,QACtB,gBAAlBsf,GAAqD,YAAlBA,GACnC9e,EAAOtB,KAAK4f,GAGpB,OAAOte,GASH6c,EAAAlf,UAAA8gB,4CAAmCM,EAAuBC,GAC9D,IAAMC,EAAcxhB,KAAK+L,SAAShI,cAAcM,cAAc,QAS9D,OARIid,GACAE,EAAYrC,aAAa,OAAQmC,GAErCE,EAAYrC,aAAa,WAAY,KACjCoC,GACAngB,EAAaiC,6BAA6Bme,EAAaD,GAE3DvhB,KAAK+L,SAASjI,YAAY0d,GACnBA,GAOHpC,EAAAlf,UAAA+gB,4CAAmCC,GACvC,IAAMM,EAAcxhB,KAAK8gB,iCAAiCI,GACtDM,GACAxhB,KAAK+L,SAASvI,YAAYge,IAO1BpC,EAAAlf,UAAAuhB,sDACiBzhB,KAAKohB,gCACbtW,QAAQ,SAAC0W,GAClBnX,EAAK0B,SAASvI,YAAYge,MAU3BpC,EAAAlf,UAAAwhB,mBACH,IAAMb,EAAW7gB,KAAK8gB,iCAAiC,WACvD,OAAID,EACOzf,EAAa2B,UAAU8d,GAEvB,MAQRzB,EAAAlf,UAAAyhB,oBAAWD,GACd,IAAIb,EAAW7gB,KAAK8gB,iCAAiC,WACjDY,EACI7X,EAAAA,kBAAkBgX,GAElBA,EAAW7gB,KAAKghB,mCAAmC,UAAWU,GAE9DtgB,EAAaiC,6BAA6Bwd,EAAUa,GAGnD7X,EAAAA,kBAAkBgX,IAEnB7gB,KAAKihB,mCAAmC,YAU7C7B,EAAAlf,UAAA0hB,iBAEH,OADgC5hB,KAAKohB,gCACjBnM,IAAI,SAAA+K,GACpB,MAAO,CACH5S,KAAM4S,EAAKje,aAAa,QACxB8G,KAAMzH,EAAa2B,UAAUid,OAUlCZ,EAAAlf,UAAA2hB,4BACH,OAAO,GAQJzC,EAAAlf,UAAA4hB,kBAAS7U,cACPpD,EAAAA,kBAAkBoD,IACnBjN,KAAKgN,WAAWC,GAEpBjN,KAAKyhB,kCACA5X,EAAAA,kBAAkBoD,IACnBA,EAASnC,QAAQ,SAACqC,GACG9C,EAAK2W,mCAAmC7T,EAAKC,KAAMD,EAAKtE,SAS3EuW,EAAAlf,UAAAyN,gBAAV,SAA0BJ,GACtB,IAAIzF,EAAS1G,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAClE,IAAKjE,EAAQ,CACT,IAAM2X,EAASre,EAAaC,yBAAyBrB,KAAK+L,SAAU,UACpEjE,EAAS1G,EAAa8C,uBAAuB,SAAUub,GAE3Dre,EAAaiC,6BAA6ByE,EAAM,GAChD9H,KAAK0M,eAAexN,IASjBkgB,EAAAlf,UAAA6hB,iCAAwBC,EAAwBC,EAAsBC,GACzE,IACMC,EAAQ,IAAI/C,EADQpf,KAAK+L,SAASqW,WAAU,GACRpiB,KAAKgM,IAAKkW,GAEpD,OADAC,EAAME,kBAAkBL,EAAeC,GAChCE,GAOJ/C,EAAAlf,UAAAmiB,2BAAkBL,EAAwBC,GAC7C,IAAMxC,EAASre,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAChEjE,EAAS1G,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAIlE,GAHKjE,IACDA,EAAS1G,EAAa8C,uBAAuB,SAAUub,IAEvDuC,GAAiBC,EAAa,CAC9B,IAAMK,EAAelhB,EAAakB,cAAcmd,GAC5C8C,EAAkBD,EACjBtiB,KAAK4N,aAAa0U,KACnBC,EAAkBviB,KAAKkM,0BAA0BhB,+BAC3CoX,EACAtiB,KAAKkM,0BAA0Bb,+BAEzCjK,EAAaiC,6BAA6ByE,EAAQya,QAElDnhB,EAAaiC,6BAA6ByE,EAAQ,IAElDka,EACAla,EAAOqX,aAAa,QAASnf,KAAK6M,sBAAsB1N,IAExD2I,EAAOqX,aAAa,QAASnf,KAAK6M,sBAAsB5N,OAzbpE,CAAoC6M,GCFpC0W,GAAA,SAAA9T,GAUI,SAAA8T,EAAYrZ,EAAmBC,EAAcC,GAA7C,IAAAgB,EACIqE,EAAA7N,KAAAb,OAAOA,YACPqK,EAAKpB,UAAY,GACjBoB,EAAKL,iCAAmC,EACxCK,EAAKoY,sBAAsBtZ,EAAWC,EAAMC,YAdrBuF,EAAAA,EAAAA,GAiBnB4T,EAAAtiB,UAAAuiB,+BAAsBtZ,EAAmBC,EAAcC,GAC3DrJ,KAAKkJ,aAAaC,EAAWC,EAAMC,GACnC,IAAMqZ,EAAY1iB,KAAKyJ,gBAAgBhI,qBAAqB,SAC5D,GAAyB,IAArBihB,EAAUhhB,OACV,MAAM,IAAI6D,MAAMuJ,EAAAA,OAAO,wEAAyE1F,IAEhG,IAAMuZ,EAAUD,EAAU/gB,KAAK,GAAGI,aAAa,WAE/C,GADwB,QACpB4gB,EACA,MAAM,IAAIpd,MAAMuJ,EAAAA,OAAO,0EACnB1F,EAHgB,MAGOuZ,IAGnC,OAAO3iB,MAQJwiB,EAAAtiB,UAAA0iB,sBACH,OAAOjkB,GAOJ6jB,EAAAtiB,UAAA2iB,oBACH,OAAO9jB,GAQDyjB,EAAAtiB,UAAA2L,yBAAV,WACI,MAAO,CAAC,SAAU,SAAU,OAAQ,aAAc,IAAK,KAAM,MAAO,MAAO,KAAM,MAAO,QAGlF2W,EAAAtiB,UAAA4J,qBAAV,WACI9J,KAAKgJ,WAAa,GAElB,IADA,IAAM8Z,EAAmB9iB,KAAKyJ,gBAAgBhI,qBAAqB,cAC1Db,EAAI,EAAGA,EAAIkiB,EAAiBphB,OAAQd,IAAK,CAC9C,IAAMmiB,EAAYD,EAAiBnhB,KAAKf,GAClCiB,EAAKkhB,EAAUhhB,aAAa,MAC7BF,GACD7B,KAAKiJ,UAAUhI,KAAK6N,EAAAA,OAAO,sEAAuE9O,KAAKuJ,YAE3GvJ,KAAKgJ,WAAW/H,KAAK,IAAIme,GAAe2D,EAAWlhB,EAAI7B,SAQxDwiB,EAAAtiB,UAAA8iB,0BACH,IAAMC,EAAW7hB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,QAC7E,OAAIwZ,EACOA,EAASlhB,aAAa,mBAEtB,MAQRygB,EAAAtiB,UAAAgjB,2BAAkBC,GACrB,IAAMF,EAAW7hB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,QACzEwZ,GACAA,EAAS9D,aAAa,kBAAmBgE,IAQ1CX,EAAAtiB,UAAAkjB,0BACH,IAAMH,EAAW7hB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,QAC7E,OAAIwZ,EACOA,EAASlhB,aAAa,mBAEtB,MAQRygB,EAAAtiB,UAAAmjB,2BAAkBF,GACrB,IAAMF,EAAW7hB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,QACzEwZ,GACAA,EAAS9D,aAAa,kBAAmBgE,IA0BjDX,EAAAtiB,UAAAojB,mBAAA,SAAmBC,EAA8BvB,EAAwBC,EAAsBuB,GAE3F,GAAIxjB,KAAK+K,gBAAgBwY,EAAiB1hB,IACtC,MAAM,IAAI0D,MAAMuJ,EAAAA,OAAO,yDAA0DyU,EAAiB1hB,KAEtG,IAAM4hB,EAAQ,EAAuC1B,wBAAwBC,EAAeC,EAAajiB,MACnG0jB,EAActiB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,QAChF,IAAKia,EACD,MAAM,IAAIne,MAAMuJ,EAAAA,OAAO,0EAA2E9O,KAAKuJ,YAE3G,IAAIoa,GAAW,EACXC,GAA2B,EACzBJ,IACqBxjB,KAAK+K,gBAAgByY,EAAmB3hB,MAE3D+hB,GAA2B,IAGnC,GAAIJ,IAAuBK,WAAcL,IAAuBI,EAC5DF,EAAY5f,YAAY2f,EAAMpW,gBAC9BsW,GAAW,OACR,GAA2B,OAAvBH,EAA6B,CACpC,IAAMM,EAAmB1iB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,cAGjFka,GAFAG,EACA1iB,EAAaoD,aAAaif,EAAMpW,eAAgByW,GAIhDJ,EAAY5f,YAAY2f,EAAMpW,iBAHnB,OAMZ,CACH,IAAM0W,EAAiB3iB,EAAaQ,yBAAyB5B,KAAKyJ,gBAAiB,aAAc+Z,EAAmB3hB,IAChHkiB,IACA3iB,EAAakD,YAAYmf,EAAMpW,eAAgB0W,GAC/CJ,GAAW,GAGnB,OAAIA,GACA3jB,KAAK4J,2BACL5J,KAAKgJ,WAAW/H,KAAKwiB,GACrBzjB,KAAK+J,eACE0Z,GAEH,MAkBLjB,EAAAtiB,UAAA8jB,sCAA6BC,EAAcvY,EAAkBsW,EAAwBC,GAExF,IAAMiC,EAAkB,IAAI1B,EAAUxiB,KAAK2L,gBAAiBD,EAAU1L,KAAKqJ,YAO3E,OANA6a,EAAgBlZ,6BAA6BhL,KAAKiL,eAClDiZ,EAAgB/Y,4BAA4BnL,KAAKoL,cACjD8Y,EAAgBb,kBAAkBY,GAClCC,EAAgB/Z,iBAAiB,SAACga,GAC9B,EAAgC9B,kBAAkBL,EAAeC,KAE9DiC,KArNf,CAA+Bnb,GCC/Bqb,GAAA,SAAA1V,sEAAsCE,EAAAA,EAAAA,GASxBwV,EAAAlkB,UAAA0Z,oBAAV,SAA8BhU,EAAsBiI,GAChD,IAAMtM,EAAUqE,EAAYrE,QAC5B,GAAgB,OAAZA,EAAkB,CAUlB,IAAM8iB,EAAOze,EAAY7D,aAAa,QACtC,IAAKsiB,EACD,OAAO,EAEX,GAAIA,EAAK9G,WAAW,iBAAkB,CAClC,IAAMvO,EAAQhP,KAAKskB,8BAA8BD,GAEjD,OADAxW,EAAQ2K,eAAexJ,EAAO,OACvB,EACJ,GAAIqV,EAAK9G,WAAW,UAAW,CAClC,IAAM3U,EAAM5I,KAAKukB,0BAA0B3e,GACrC0J,EAAYtP,KAAKqa,qBAAqBgK,GAI5C,OAHIzb,GACAiF,EAAQ4K,YAAY7P,EAAK0G,IAEtB,EACJ,GAAI+U,EAAK9G,WAAW,UAKvB,OAJM3U,EAAM5I,KAAKukB,0BAA0B3e,KAEvCiI,EAAQ6K,UAAU9P,IAEf,EACJ,IAAI,IAAIgU,IAAakB,0BAA0BuG,GAAO,CACzD,IAAMG,GAAe,IAAI5H,IAAaqB,sCAAsCoG,GACtE/U,EAAYtP,KAAKqa,qBAAqBgK,GAE5C,OADAxW,EAAQgL,YAAY2L,EAAclV,IAC3B,EACJ,GAAI+U,EAAK9G,WAAW,OAAQ,CACzBvO,EAAQhP,KAAKykB,6BAA6BJ,GAEhD,OADAxW,EAAQiL,iBAAiB9J,EAAO,OACzB,QAER,GAAgB,WAAZzN,EAEP,OAAO,EAEX,OAAO,GAQD6iB,EAAAlkB,UAAA2Z,kBAAV,SAA4B/X,GACxB,IAAMmY,EAAWnY,EAAKkB,WACtB,GAAwB,IAApBiX,EAASvY,OACT,OAAO,KAEX,IAEId,EAFA2C,EAAa,KAGjB,IAAK3C,EAAI,EAAGA,EAAIqZ,EAASvY,OAAQd,IAAK,CAClC,IAAMqC,EAAQgX,EAAStY,KAAKf,GAC5B,GAAIqC,EAAMf,WAAae,EAAMd,cAA8C,WAA9B,EAAkBZ,QAAsB,CACjFgC,EAAaN,EACb,OAGR,GAAIM,GAAcA,EAAWrB,WAAaqB,EAAWL,UAAW,CAC5D,GAAIlD,KAAK+N,kBAAkBxK,EAAWoW,aAAc,CAChD,IAAM+K,EAActjB,EAAakB,cAAa,GAC9C,GAAQ,EAAJ1B,EAAO,CAEP,IAAM+jB,EAAmB,IAAI/hB,OAAO,2BAA4B,KAChE,OAAO8hB,EAAY7hB,QAAQ8hB,EAAU,IAErC,OAAOD,EAGX,OAAO,KAGX,OAAO,MAULN,EAAAlkB,UAAAga,kBAAV,SAA4BtU,EAAsBiI,KAS1CuW,EAAAlkB,UAAAokB,uCAA8B1d,GAClC,IAAI4X,EAAc,GAOlB,OAJIA,EADS,kBAAT5X,EACc,IAEAA,EAAK6W,UAAU,iBAAiB/b,QAE3C+c,OAAOtF,SAASqF,EAAa,KAShC4F,EAAAlkB,UAAAukB,sCAA6B7d,GACjC,IAAI4X,EAAc,GAOlB,OAJIA,EADS,QAAT5X,EACc,IAEAA,EAAK6W,UAAU,OAAO/b,QAEjC+c,OAAOtF,SAASqF,EAAa,KAShC4F,EAAAlkB,UAAAqkB,mCAA0BK,GAC9B,IAAMC,EAAYzjB,EAAaC,yBAAyBujB,EAAW,MACnE,GAAIC,EAAW,CACX,IAAM3jB,EAAQE,EAAa2B,UAAU8hB,GACrC,OAAK3jB,GAAUA,EAAMqc,WAAW,MAASrc,EAAMyI,SAAS,KAIhC,MAApBzI,EAAM4H,OAAO,GACN5H,EAAMuc,UAAU,EAAGvc,EAAMQ,OAAS,GAElCR,EAAMuc,UAAU,EAAGvc,EAAMQ,OAAS,GALlC,KAQX,OAAO,MAIL0iB,EAAAlkB,UAAAua,2BAAV,SAAqC5M,EAAwB2M,GAA7D,IAAAnQ,EAAArK,KACI6N,EAAQwJ,QAAQvM,QAAQ,SAACoK,GACrB,IAAMjS,EAAQoH,EAAKya,8BAA8B5P,EAAMsF,GACnDvX,GACAuX,EAAS1W,YAAYb,MAKvBmhB,EAAAlkB,UAAA4kB,8BAAV,SAAwC5P,EAAyBsF,GAC7D,OAAQtF,EAAK1G,MACT,KAAKG,EAAsBX,KACvB,OAAOhO,KAAK0a,kCAAiC,EAA+BF,GAChF,KAAK7L,EAAsBT,UACvB,OAAOlO,KAAK0e,sCAAqC,EAAoClE,GACzF,KAAK7L,EAAsBR,QACvB,OAAOnO,KAAK2e,oCAAmC,EAAkCnE,GACrF,KAAK7L,EAAsBP,UACvB,OAAOpO,KAAK4e,sCAAqC,EAAoCpE,GACzF,KAAK7L,EAAsBV,YACvB,OAAOjO,KAAK6e,yCAAwC,EAAuCrE,GAC/F,KAAK7L,EAAsBL,gBACvB,OAAOtO,KAAK8e,2CAA0C,EAAyCtE,KAUjG4J,EAAAlkB,UAAAwe,sCAAV,SAAgDxJ,EAAiCsF,GAC7E,IAAMuK,EAASvK,EAASzW,cAAcM,cAAc,MAE9C2gB,GADa,IAAIpI,IACOC,2BAA2B3H,EAAK3T,UAAW2T,EAAKxF,aAC9EqV,EAAO5F,aAAa,OAAQ6F,GAC5B,IAAMC,EAASzK,EAASzW,cAAcM,cAAc,MAGpD,OAFA4gB,EAAOnhB,YAAY0W,EAASzW,cAAc4W,eAAe,IAAMzF,EAAK3T,UAAY,MAChFwjB,EAAOjhB,YAAYmhB,GACZF,GASDX,EAAAlkB,UAAAye,oCAAV,SAA8CzJ,EAA+BsF,GACzE,IAAMuK,EAASvK,EAASzW,cAAcM,cAAc,MAE9C2gB,GADa,IAAIpI,IACOK,2BAA2B/H,EAAK3T,WAC9DwjB,EAAO5F,aAAa,OAAQ6F,GAC5B,IAAMC,EAASzK,EAASzW,cAAcM,cAAc,MAGpD,OAFA4gB,EAAOnhB,YAAY0W,EAASzW,cAAc4W,eAAe,KAAOzF,EAAK3T,UAAY,MACjFwjB,EAAOjhB,YAAYmhB,GACZF,GASDX,EAAAlkB,UAAA0e,sCAAV,SAAgD1J,EAAiCsF,GAC7E,IAAMuK,EAASvK,EAASzW,cAAcM,cAAc,MAE9C2gB,GADa,IAAIpI,IACOM,2BAA2BhI,EAAK3T,UAAW2T,EAAKxF,aAC9EqV,EAAO5F,aAAa,OAAQ6F,GAC5B,IAAMC,EAASzK,EAASzW,cAAcM,cAAc,MAGpD,OAFA4gB,EAAOnhB,YAAY0W,EAASzW,cAAc4W,eAAe,IAAMzF,EAAK3T,UAAY,MAChFwjB,EAAOjhB,YAAYmhB,GACZF,GASDX,EAAAlkB,UAAA2e,yCAAV,SAAmD3J,EAAoCsF,GACnF,IAAMuK,EAASvK,EAASzW,cAAcM,cAAc,MAChD2gB,EAAa,gBACE,EAAf9P,EAAKlG,UACLgW,EAAa,iBAAmB9P,EAAKlG,QAAQS,SAAS,KAE1DsV,EAAO5F,aAAa,OAAQ6F,GAC5B,IAAMC,EAASzK,EAASzW,cAAcM,cAAc,MAGpD,OAFA4gB,EAAOnhB,YAAY0W,EAASzW,cAAc4W,eAAeqK,IACzDD,EAAOjhB,YAAYmhB,GACZF,GAQDX,EAAAlkB,UAAA4e,2CAAV,SAAqD5J,EAAsCsF,GACvF,IAAMuK,EAASvK,EAASzW,cAAcM,cAAc,MAChD2gB,EAAa,MACE,EAAf9P,EAAKlG,UACLgW,EAAa,OAAS9P,EAAKlG,QAAQS,SAAS,KAEhDsV,EAAO5F,aAAa,OAAQ6F,GAC5B,IAAMC,EAASzK,EAASzW,cAAcM,cAAc,MAGpD,OAFA4gB,EAAOnhB,YAAY0W,EAASzW,cAAc4W,eAAeqK,IACzDD,EAAOjhB,YAAYmhB,GACZF,KAnRf,CAAsC1L,GCDtC6L,GAAA,SAAAxW,GAEI,SAAAwW,EAAYnZ,EAAmBC,EAAaC,UACxCyC,EAAA7N,KAAAb,KAAM+L,EAAUC,EAAKC,IAAyBjM,YAHpB4O,EAAAA,EAAAA,GAWfsW,EAAAC,2BAAkBC,GAC7B,IAAMpW,EAAQoW,EAAaC,YAAY,KACvC,OAAIrW,EAAQ,EACD,CACHkR,WAAYkF,EACZjF,WAAY,GAGT,CACHD,WAAYkF,EAAa3H,UAAU,EAAGzO,GACtCmR,WAAY+E,EAAaI,gBAAgBF,EAAa3H,UAAUzO,EAAQ,MAKrEkW,EAAAI,yBAAgBC,GAC3B,OAAO9G,OAAOtF,SAASoM,EAAkB,KAQtCL,EAAAhlB,UAAAmf,yBACH,IAAImG,EAAapkB,EAAakB,cAActC,KAAK+L,UAGjD,OADAyZ,EAAaA,EAAW3iB,QADK,wBACiB,KASlDqiB,EAAAhlB,UAAAiM,yBAAA,WACI,OAAO,GASJ+Y,EAAAhlB,UAAAqf,0BAAiBC,KAOd0F,EAAAhlB,UAAA4N,cAAV,WACI,OAAO,IAAIsW,IAMRc,EAAAhlB,UAAAoM,yCACH,OAAOtM,KAAK8N,gBAAgBwL,+BAA+BtZ,KAAK+L,SAAU,OAMvEmZ,EAAAhlB,UAAAwf,yBAEH,OAAO1f,KAAKqf,iBAOhB6F,EAAAhlB,UAAA0f,wBAAA,WACI,OAAO,IAAIwE,IAAmB9K,+BAA+BtZ,KAAK+L,SAAU/L,KAAKoM,4BAO9E8Y,EAAAhlB,UAAAsM,6BACH,OAAO,MAUD0Y,EAAAhlB,UAAA2M,sBAAV,SAAgCvC,GAC5B,OAAOA,GAQD4a,EAAAhlB,UAAAuM,sBAAV,SAAgCF,GAC5B,OAAOA,GAQD2Y,EAAAhlB,UAAA0M,qBAAV,SAA+BL,KAYxB2Y,EAAAhlB,UAAA2f,4BAGH,IAFA,IAAMC,EAAiB9f,KAAK+L,SAAStK,qBAAqB,UACpDse,EAA2D,GACxDnf,EAAI,EAAGA,EAAIkf,EAAepe,OAAQd,IAAK,CAC5C,IAAMof,EAAOF,EAAene,KAAKf,GAC3BwkB,EAAuBhkB,EAAa2B,UAAUid,GACpDD,EAAW9e,KAAKikB,EAAaC,kBAAkBC,IAEnD,OAAOrF,GASJmF,EAAAhlB,UAAAmgB,6BAAoBN,GACvB/f,KAAKsgB,4BAEL,IADA,IAAImF,EAAiBzlB,KAAK+L,SAAS/I,WAAWrB,KAAK,GAC1Cf,EAAImf,EAAWre,OAAS,EAAQ,GAALd,EAAQA,IAAK,CAC7C,IAAM2f,EAAMR,EAAWnf,GACjB6e,EAASzf,KAAK+L,SAAShI,cAAcM,cAAc,UACzDob,EAAO3b,YAAY9D,KAAK+L,SAAShI,cAAc4W,eAAe4F,EAAIL,WAAa,IAAMK,EAAIJ,WAAW1Q,SAAS,MAC7GzP,KAAK+L,SAASvH,aAAaib,EAAQgG,GACnCA,EAAiBhG,IAIjByF,EAAAhlB,UAAAogB,qCAGJ,IAFA,IAAMR,EAAiB9f,KAAK+L,SAAStK,qBAAqB,UACpDkf,EAAc,GACX/f,EAAI,EAAGA,EAAIkf,EAAepe,OAAQd,IAAK,CAC5C,IAAMof,EAAOF,EAAene,KAAKf,GACjC+f,EAAY1f,KAAK+e,GAErBW,EAAY7V,QAAQ,SAACkV,GAAUA,EAAKzb,WAAWf,YAAYwc,MAQxDkF,EAAAhlB,UAAA0gB,uBACH,OAAO5gB,KAAK+L,SAAShK,aAAa,SAS/BmjB,EAAAhlB,UAAAwhB,mBACH,OAAO1hB,KAAK+L,SAAShK,aAAa,YAQ/BmjB,EAAAhlB,UAAA6M,4CACH,OAAO,GAOJmY,EAAAhlB,UAAA6gB,wBAAeH,KAQfsE,EAAAhlB,UAAAyhB,oBAAWD,KAQXwD,EAAAhlB,UAAA0hB,iBACH,MAAO,IAQJsD,EAAAhlB,UAAA2hB,4BACH,OAAO,GAQJqD,EAAAhlB,UAAA4hB,kBAAS7U,KAWTiY,EAAAhlB,UAAA6hB,iCAAwBC,EAAwBC,EAAsBC,GACzE,OAAOliB,MAOJklB,EAAAhlB,UAAAmiB,2BAAkBL,EAAwBC,KAUvCiD,EAAAhlB,UAAAyN,gBAAV,SAA0BJ,GACtB,MAAM,IAAIhI,MAAM,uDA/QxB,CAAkCuG,GCWlC4Z,GAAA,SAAAhX,GAWI,SAAAgX,EACYC,EACRxc,EAAmBC,EAAcC,GAFrC,IAAAgB,EAIIqE,EAAA7N,KAAAb,OAAOA,YAHCqK,EAAAsb,+BAAAA,EAIRtb,EAAKpB,UAAY,GACjBoB,EAAKL,iCAAmC,EACxCK,EAAKoY,sBAAsBtZ,EAAWC,EAAMC,YAlBvBuF,EAAAA,EAAAA,GAqBjB8W,EAAAxlB,UAAAuiB,+BAAsBtZ,EAAmBC,EAAcC,GAE3D,GADArJ,KAAKkJ,aAAaC,EAAWC,EAAMC,GACuC,IAAtErJ,KAAKyJ,gBAAgBhI,qBAAqB,iBAAiBC,OAC3D,MAAM,IAAI6D,MAAMuJ,EAAAA,OAAO,6EAA8E1F,IAEzG,OAAOpJ,MAGD0lB,EAAAxlB,UAAA4J,qBAAV,WACI9J,KAAKgJ,WAAa,GAElB,IADA,IAAM8Z,EAAmB9iB,KAAKyJ,gBAAgBhI,qBAAqB,OAC1Db,EAAI,EAAGA,EAAIkiB,EAAiBphB,OAAQd,IAAK,CAC9C,IAAMglB,EAAM9C,EAAiBnhB,KAAKf,GAC5BiB,EAAK+jB,EAAI7jB,aAAa,MACvBF,GACD7B,KAAKiJ,UAAUhI,KAAK6N,EAAAA,OAAO,+DAAgE9O,KAAKuJ,YAEpGvJ,KAAKgJ,WAAW/H,KAAK,IAAIikB,GAAaU,EAAK/jB,EAAI7B,SAShD0lB,EAAAxlB,UAAA0iB,sBACH,OAAO/jB,GAOJ6mB,EAAAxlB,UAAA2iB,oBACH,MzB9DoB,OyBsEd6C,EAAAxlB,UAAA2L,yBAAV,WACI,MAAO,CAAC,YAQJ6Z,EAAAxlB,UAAA2lB,qCACJ,GAAI7lB,KAAKuJ,UAAW,CAChB,IAAM8N,EAAkBrX,KAAKuJ,UAAUuc,MAAM,KAC7C,GAAmB,EAAfzO,EAAM3V,QAAwD,QAA1C2V,EAAMA,EAAM3V,OAAS,GAAG0b,cAC5C,OAAO/F,EAAMA,EAAM3V,OAAS,GAGpC,OAAO,MASJgkB,EAAAxlB,UAAA8iB,0BACH,OAAOhjB,KAAK6lB,6BAQTH,EAAAxlB,UAAAgjB,2BAAkBC,KAUlBuC,EAAAxlB,UAAAkjB,0BACH,OAAOpjB,KAAK6lB,6BAQTH,EAAAxlB,UAAAmjB,2BAAkBF,KA0BzBuC,EAAAxlB,UAAAojB,mBAAA,SAAmBC,EAA8BvB,EAAwBC,EAAsBuB,GAE3F,MAAMje,MAAM,gEAiBTmgB,EAAAxlB,UAAA8jB,sCAA6BC,EAAcvY,EAAkBsW,EAAwBC,GAExF,IAEMiC,EAAkBlkB,KAAK2lB,+BAA+BI,0BACxDjnB,EAFA,+WAG4B4M,EAAU1L,KAAKqJ,WAC3C,CAAC2c,WAAYhmB,KAAK2L,gBAAiBvC,KAAMpJ,KAAK0L,WAAYrC,SAAUrJ,KAAKqJ,aAS7E,OARA6a,EAAgBlZ,6BAA6BhL,KAAKiL,eAClDiZ,EAAgB/Y,4BAA4BnL,KAAKoL,cACjD8Y,EAAgBb,kBAAkBY,GAClCC,EAAgBlZ,6BAA6BhL,KAAKkL,gCAClDgZ,EAAgB/Y,4BAA4BnL,KAAKqL,+BACjDrL,KAAKmK,iBAAiB,SAACC,GACnB8Z,EAAgBZ,mBAAmBlZ,EAAI4X,EAAeC,KAEnDiC,KAlLf,CAA6Bnb,GCX7Bkd,GAAA,SAAAvX,sEAAyCE,EAAAA,EAAAA,GAS3BqX,EAAA/lB,UAAA0Z,oBAAV,SAA8BhU,EAAsBiI,GAChD,IAAMtM,EAAUqE,EAAYrE,QAC5B,GAAgB,OAAZA,EAAkB,CAYlB,IAAI2kB,GAAkB,EAClBpM,GAAQ,EACRqM,GAAa,EACXC,EAAQxgB,EAAY7D,aAAa,SACjCkN,EAAOrJ,EAAY7D,aAAa,QAClCyc,EAAc,KACdxP,EAAQ,EACRwV,EAAe,KACnB,GAAK4B,EAKE,GAAIA,EAAM7I,WAAW,OAExBzD,GAAQ,EAEJ0E,EADU,QAAV4H,EACc,IAEAA,EAAM3I,UAAU,OAAO/b,QAEzCsN,EAAQyP,OAAOtF,SAASqF,EAAa,SAClC,GAAI4H,EAAM7I,WAAW,iBACxB2I,GAAkB,EAEd1H,EADU,kBAAV4H,EACc,IAEAA,EAAM3I,UAAU,iBAAiB/b,QAEnDsN,EAAQyP,OAAOtF,SAASqF,EAAa,QAClC,CAAA,KAAI,IAAI5B,IAAakB,0BAA0BsI,GAIlD,OAAO,EAHPD,GAAa,EACb3B,GAAe,IAAI5H,IAAaqB,sCAAsCmI,QAtBtEtM,GAAQ,EACR0E,EAAc5Y,EAAY7D,aAAa,MACvCiN,EAAQyP,OAAOtF,SAASqF,EAAa,IAwBrC0H,EACArY,EAAQ2K,eAAexJ,EAAOC,GACvB6K,EACPjM,EAAQiL,iBAAiB9J,EAAOC,GACzBkX,GACPtY,EAAQgL,YAAY2L,EAAcxkB,KAAKqa,qBAAqB+L,SAE7D,GAAgB,OAAZ7kB,EAAkB,CAGzB,IAAM8kB,EAAkBrmB,KAAKsmB,qBAAqB1gB,GAC9CygB,GACAxY,EAAQ4K,YAAY4N,EAAiBrmB,KAAKqa,qBAAqBzU,EAAY7D,aAAa,gBAGhG,OAAO,GASDkkB,EAAA/lB,UAAAga,kBAAV,SAA4BtU,EAAsBiI,GAE9C,GAAgB,OADAjI,EAAYrE,aAC5B,CAGI,IAAM8kB,EAAkBrmB,KAAKsmB,qBAAqB1gB,GAC9CygB,GACAxY,EAAQ6K,UAAU2N,KAMtBJ,EAAA/lB,UAAAomB,8BAAqBC,GACzB,IAAIC,EAAYD,EAAOxkB,aAAa,aAOpC,OANIykB,EAAUjJ,WAAW,OACrBiJ,EAAYA,EAAU/I,UAAU,IAEhC+I,EAAU7c,SAAS,OACnB6c,EAAYA,EAAU/I,UAAU,EAAG+I,EAAU9kB,OAAS,IAEnD8kB,GASDP,EAAA/lB,UAAAua,2BAAV,SAAqC5M,EAAwB2M,GAA7D,IAAAnQ,EAAArK,KACUymB,EAAQ,CAAC,CAACnlB,QAASkZ,EAAUjZ,QAAS,SACxCM,EAAK,EAkCT,GAjCAgM,EAAQwJ,QAAQvM,QAAQ,SAACoK,GACrB,OAAQA,EAAK1G,MACT,KAAKG,EAAsBX,KACvByY,EAAMA,EAAM/kB,OAAS,GAAGJ,QAAQwC,YAC5BuG,EAAKqQ,kCAAiC,EAA+BF,IACzE,MACJ,KAAK7L,EAAsBV,YACvBwY,EAAMA,EAAM/kB,OAAS,GAAGJ,QAAQwC,YAC5BuG,EAAKwU,yCAAwC,EAAsCrE,EAAU3Y,MACjG,MACJ,KAAK8M,EAAsBL,gBACvBmY,EAAMA,EAAM/kB,OAAS,GAAGJ,QAAQwC,YAC5BuG,EAAKyU,2CAA0C,EAAwCtE,IAC3F,MACJ,KAAK7L,EAAsBT,UACvB,IAAMwY,EAAarc,EAAKqU,sCAAqC,EAAmClE,EAAU3Y,KAC1G4kB,EAAMA,EAAM/kB,OAAS,GAAGJ,QAAQwC,YAAY4iB,GAC5CD,EAAMxlB,KAAK,CAACK,QAAO,EAAwBC,QAAS,EAAmCA,YACvF,MACJ,KAAKoN,EAAsBR,QACvB,IAAMwY,EAAe,EAAiCplB,UACtD,GAAIklB,EAAM/kB,QAAU,GAAK+kB,EAAMA,EAAM/kB,OAAS,GAAGH,UAAYolB,EAEzD,MAAM,IAAIphB,MAAM,wBAA0BohB,GAE9CF,EAAMxV,MACN,MACJ,KAAKtC,EAAsBP,UACvB,IAAMwY,EAAevc,EAAKuU,sCAAqC,EAAmCpE,EAAU3Y,KAC5G4kB,EAAMA,EAAM/kB,OAAS,GAAGJ,QAAQwC,YAAY8iB,MAInC,IAAjBH,EAAM/kB,OAEN,MAAM,IAAI6D,MAAM,qBAAuBkhB,EAAMA,EAAM/kB,OAAS,GAAGH,UAa7D0kB,EAAA/lB,UAAAwe,sCAAV,SAAgDxJ,EAAiCsF,EAAmB3Y,GAChG,IAAMuc,EAAa,IAAIxB,GACjBiK,EAASrM,EAASzW,cAAcM,cAAc,MAC9C9C,EAAU2T,EAAK3T,UACfulB,EAAa1I,EAAWvB,2BAA2Btb,EAAS2T,EAAKxF,aACjEqX,EAAW3I,EAAWnB,2BAA2B1b,GACjDilB,EAAY,IAAMjlB,EAAU,IAC5BylB,EAAU,KAAOzlB,EAAU,IAOjC,OANAslB,EAAO1H,aAAa,KAAMtd,EAAG4N,SAAS,KACtCoX,EAAO1H,aAAa,aAAc2H,GAClCD,EAAO1H,aAAa,WAAY4H,GAChCF,EAAO1H,aAAa,OAAQnf,KAAKinB,cAAc1lB,IAC/CslB,EAAO1H,aAAa,YAAaqH,GACjCK,EAAO1H,aAAa,UAAW6H,GACxBH,GASDZ,EAAA/lB,UAAAye,oCAAV,SAA8CzJ,EAA+BsF,GAEzE,OAAO,MAWDyL,EAAA/lB,UAAA0e,sCAAV,SAAgD1J,EAAiCsF,EAAmB3Y,GAChG,IAAMuc,EAAa,IAAIxB,GACjBmI,EAASvK,EAASzW,cAAcM,cAAc,MAC9C9C,EAAU2T,EAAK3T,UACf6kB,EAAQhI,EAAWlB,2BAA2B3b,EAAS2T,EAAKxF,aAC5DT,EAAO,IAAM1N,EAAU,KAK7B,OAJAwjB,EAAO5F,aAAa,KAAMtd,EAAG4N,SAAS,KACtCsV,EAAO5F,aAAa,QAASiH,GAC7BrB,EAAO5F,aAAa,OAAQnf,KAAKinB,cAAc1lB,IAC/CwjB,EAAO5F,aAAa,OAAQlQ,GACrB8V,GAGHkB,EAAA/lB,UAAA+mB,uBAAcre,GAClB,OAAQA,EAAIwU,eACR,IAAK,KACL,IAAK,IACL,IAAK,IACL,IAAK,IACD,MAAO,MACX,IAAK,MACD,MAAO,QACX,IAAK,IACD,MAAO,OACX,QACI,MAAO,UAWT6I,EAAA/lB,UAAA2e,yCAAV,SAAmD3J,EAAoCsF,EAAmB3Y,GACtG,IAAMkjB,EAASvK,EAASzW,cAAcM,cAAc,MAChD6iB,EAAc,gBACC,EAAfhS,EAAKlG,UACLkY,EAAc,iBAAmBhS,EAAKlG,QAAQS,SAAS,KAE3DsV,EAAO5F,aAAa,KAAMtd,EAAG4N,SAAS,KACtCsV,EAAO5F,aAAa,QAAS+H,GAC7B,IAAMjY,EAAOiG,EAAKjG,OAIlB,OAHIA,GACA8V,EAAO5F,aAAa,OAAQlQ,GAEzB8V,GAQDkB,EAAA/lB,UAAA4e,2CAAV,SAAqD5J,EAAsCsF,GACvF,IAAMuK,EAASvK,EAASzW,cAAcM,cAAc,MAChD6iB,EAAc,MACC,EAAfhS,EAAKlG,UACLkY,EAAc,OAAShS,EAAKlG,QAAQS,SAAS,KAEjDsV,EAAO5F,aAAa,KAAMjK,EAAKlG,QAAQS,SAAS,KAChDsV,EAAO5F,aAAa,QAAS+H,GAC7B,IAAMjY,EAAOiG,EAAKjG,OAIlB,OAHIA,GACA8V,EAAO5F,aAAa,OAAQlQ,GAEzB8V,KA5Qf,CAAyC1L,GCEzC8N,GAAA,SAAAzY,GAEI,SAAAyY,EAAYpb,EAAmBC,EAAaC,UACxCyC,EAAA7N,KAAAb,KAAM+L,EAAUC,EAAKC,IAAyBjM,YAHjB4O,EAAAA,EAAAA,GAM1BuY,EAAAjnB,UAAAmf,yBACH,IAAMC,EAAgBle,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC3E,OAAO3K,EAAakB,cAAcgd,IAS/B6H,EAAAjnB,UAAAqf,0BAAiBC,GACpB,IAAIC,EAASre,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC7D0T,IAGDA,EADgBre,EAAaC,yBAAyBrB,KAAK+L,SAAU,WACpDxH,WAAWT,YAAY9D,KAAK+L,SAAShI,cAAcM,cAAc,YAEtFjD,EAAaiC,6BAA6Boc,EAAQD,IAM5C2H,EAAAjnB,UAAA4N,cAAV,WACI,OAAO,IAAImY,IAMRkB,EAAAjnB,UAAAoM,yCACH,IAAMgT,EAAgBle,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC3E,OAAIuT,EACOtf,KAAK8N,gBAAgBwL,+BAA+BgG,EAAe,MAEnE,MAOR6H,EAAAjnB,UAAAwf,yBACH,IAAMC,EAAgBve,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC3E,OAAO3K,EAAakB,cAAcqd,IAOtCwH,EAAAjnB,UAAA0f,wBAAA,WACI,IAAMD,EAAgBve,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC3E,OAAO,IAAIka,IAAsB3M,+BAA+BqG,EAAe3f,KAAKoM,4BAMjF+a,EAAAjnB,UAAAsM,6BACH,IAAM4a,EAAiBhmB,EAAaC,yBAAyBrB,KAAK+L,SAAU,WAC5E,OAAIqb,EACOA,EAAerlB,aAAa,SAE5B,MAQLolB,EAAAjnB,UAAA0M,qBAAV,SAA+BL,GAC3B,IAAM6a,EAAiBhmB,EAAaC,yBAAyBrB,KAAK+L,SAAU,WACxEqb,GACAA,EAAejI,aAAa,QAAS5S,IAWnC4a,EAAAjnB,UAAA2M,sBAAV,SAAgCvC,GAC5B,OAASA,GACL,KAAKrL,EACD,MAAO,UACX,KAAKC,EACD,MAAO,aACX,KAAKC,EACD,MAAO,QACX,QACI,MAAM,IAAIoG,MAAM,iBAAoB+E,KAStC6c,EAAAjnB,UAAAuM,sBAAV,SAAgCF,GAC5B,OAASA,GACL,IAAK,UACD,OAAOtN,EACX,IAAK,aAEL,IAAK,WACD,OAAOC,EACX,IAAK,QACD,OAAOC,EACX,QACI,OAAOF,IAYZkoB,EAAAjnB,UAAA2f,4BAIH,IAFA,IAAMsB,EAAenhB,KAAK+L,SAAStK,qBAAqB,QAClDse,EAA2D,GACxDnf,EAAI,EAAGA,EAAIugB,EAAazf,OAAQd,IAAK,CAC1C,IAAMigB,EAAWM,EAAaxf,KAAKf,GACnC,GAA0C,aAAtCigB,EAAS9e,aAAa,YAA4B,CAClD,IAAMqjB,EAAuBhkB,EAAa2B,UAAU8d,GACpDd,EAAW9e,KAAKjB,KAAKmlB,kBAAkBC,KAG/C,OAAOrF,GAQHoH,EAAAjnB,UAAAilB,2BAAkBC,GACtB,IAAMpW,EAAQoW,EAAaC,YAAY,KACvC,OAAIrW,EAAQ,EACD,CACHkR,WAAYkF,EACZjF,WAAY,GAGT,CACHD,WAAYkF,EAAa3H,UAAU,EAAGzO,GACtCmR,WAAYngB,KAAKslB,gBAAgBF,EAAa3H,UAAUzO,EAAQ,MAKpEmY,EAAAjnB,UAAAolB,yBAAgBC,GACpB,OAAO9G,OAAOtF,SAASoM,EAAkB,KAStC4B,EAAAjnB,UAAAmgB,6BAAoBN,cACvB/f,KAAKsgB,4BACL,IAAI+G,EAAejmB,EAAaC,yBAAyBrB,KAAK+L,SAAU,SAC9C,IAAtBgU,EAAWre,QAAiBmI,EAAAA,kBAAkBwd,IAAoD,IAAnCA,EAAarkB,WAAWtB,QAKvFmI,EAAAA,kBAAkBwd,KAClBA,EAAernB,KAAK+L,SAAShI,cAAcM,cAAc,SACzDrE,KAAK+L,SAASvH,aAAa6iB,EAAcrnB,KAAK+L,SAAS/I,WAAWrB,KAAK,KAE3Eoe,EAAWjV,QAAQ,SAACyV,GAChB,IAAMpT,EAAO9C,EAAK0B,SAAShI,cAAcM,cAAc,QACvD8I,EAAKgS,aAAa,WAAY,YAC9BhS,EAAKrJ,YAAYuG,EAAK0B,SAAShI,cAAc4W,eAAe4F,EAAIL,WAAa,IAAMK,EAAIJ,WAAW1Q,SAAS,MAC3G4X,EAAavjB,YAAYqJ,MAXzBka,EAAa9iB,WAAWf,YAAY6jB,IAepCF,EAAAjnB,UAAAogB,qCAGJ,IAFA,IAAMa,EAAenhB,KAAK+L,SAAStK,qBAAqB,QAClDkf,EAAc,GACX/f,EAAI,EAAGA,EAAIugB,EAAazf,OAAQd,IAAK,CAC1C,IAAMof,EAAOmB,EAAaxf,KAAKf,GACO,aAAlCof,EAAKje,aAAa,aAClB4e,EAAY1f,KAAK+e,GAGzBW,EAAY7V,QAAQ,SAACkV,GAAUA,EAAKzb,WAAWf,YAAYwc,MAQxDmH,EAAAjnB,UAAA0gB,uBACH,IAAMC,EAAW7gB,KAAKsnB,qCAAqC,eAC3D,OAAIzG,EACOzf,EAAa2B,UAAU8d,GAEvB,MAQRsG,EAAAjnB,UAAA6gB,wBAAeH,GAClB,IAAMC,EAAW7gB,KAAKsnB,qCAAqC,eACvD1G,EACI/W,EAAAA,kBAAkBgX,GAElB7gB,KAAKunB,uCAAuC,cAAe3G,GAE3Dxf,EAAaiC,6BAA6Bwd,EAAUD,GAGnD/W,EAAAA,kBAAkBgX,IAEnB7gB,KAAKwnB,uCAAuC,gBAUhDL,EAAAjnB,UAAAonB,8CAAqCpG,GAEzC,IADA,IAAMC,EAAenhB,KAAK+L,SAAStK,qBAAqB,QAC/Cb,EAAI,EAAGA,EAAIugB,EAAazf,OAAQd,IAAK,CAC1C,IAAMigB,EAAWM,EAAaxf,KAAKf,GACnC,GAAIigB,EAAS9e,aAAa,cAAgBmf,EACtC,OAAOL,EAGf,OAAO,MAOHsG,EAAAjnB,UAAAkhB,yCAGJ,IAFA,IAAMD,EAAenhB,KAAK+L,SAAStK,qBAAqB,QAClDc,EAAoB,GACjB3B,EAAI,EAAGA,EAAIugB,EAAazf,OAAQd,IAAK,CAC1C,IAAMigB,EAAWM,EAAaxf,KAAKf,GAC7BygB,EAAgBR,EAAS9e,aAAa,YACtB,gBAAlBsf,GAAqD,YAAlBA,GACnC9e,EAAOtB,KAAK4f,GAGpB,OAAOte,GASH4kB,EAAAjnB,UAAAqnB,gDAAuCrG,EAAmBK,GAC9D,IAAI8F,EAAejmB,EAAaC,yBAAyBrB,KAAK+L,SAAU,SACpElC,EAAAA,kBAAkBwd,KAElBA,EAAernB,KAAK+L,SAAShI,cAAcM,cAAc,SACzDrE,KAAK+L,SAASjI,YAAYujB,IAE9B,IAAM7F,EAAcxhB,KAAK+L,SAAShI,cAAcM,cAAc,QAQ9D,OAPI6c,GACAM,EAAYrC,aAAa,WAAY+B,GAErCK,GACAngB,EAAaiC,6BAA6Bme,EAAaD,GAE3D8F,EAAavjB,YAAY0d,GAClBA,GAGH2F,EAAAjnB,UAAAunB,qCACJ,IAAMJ,EAAejmB,EAAaC,yBAAyBrB,KAAK+L,SAAU,SACtEsb,IACkBjmB,EAAaC,yBAAyBrB,KAAK+L,SAAU,SAGnEsb,EAAa9iB,WAAWf,YAAY6jB,KASxCF,EAAAjnB,UAAAsnB,gDAAuCtG,GAC3C,IAAMM,EAAcxhB,KAAKsnB,qCAAqCpG,GAC1DM,GACAA,EAAYjd,WAAWf,YAAYge,GAEvCxhB,KAAKynB,6BAMDN,EAAAjnB,UAAAuhB,2CACiBzhB,KAAKohB,gCACbtW,QAAQ,SAAC0W,GAClBA,EAAYjd,WAAWf,YAAYge,KAEvCxhB,KAAKynB,6BASFN,EAAAjnB,UAAAwhB,mBACH,IAAMb,EAAW7gB,KAAKsnB,qCAAqC,WAC3D,OAAIzG,EACOzf,EAAa2B,UAAU8d,GAEvB,MAQRsG,EAAAjnB,UAAAyhB,oBAAWD,GACd,IAAMb,EAAW7gB,KAAKsnB,qCAAqC,WACvD5F,EACI7X,EAAAA,kBAAkBgX,GAElB7gB,KAAKunB,uCAAuC,UAAW7F,GAEvDtgB,EAAaiC,6BAA6Bwd,EAAUa,GAGnD7X,EAAAA,kBAAkBgX,IAEnB7gB,KAAKwnB,uCAAuC,YAUjDL,EAAAjnB,UAAA0hB,iBAEH,OADgC5hB,KAAKohB,gCACjBnM,IAAI,SAAA+K,GACpB,MAAO,CACH5S,KAAM4S,EAAKje,aAAa,YACxB8G,KAAMzH,EAAa2B,UAAUid,OAUlCmH,EAAAjnB,UAAA2hB,4BACH,OAAO,GAOJsF,EAAAjnB,UAAA4hB,kBAAS7U,cACPpD,EAAAA,kBAAkBoD,IACnBjN,KAAKgN,WAAWC,GAEpBjN,KAAKyhB,kCACA5X,EAAAA,kBAAkBoD,IACnBA,EAASnC,QAAQ,SAACqC,GACd9C,EAAKkd,uCAAuCpa,EAAKC,KAAMD,EAAKtE,SAS9Dse,EAAAjnB,UAAAyN,gBAAV,SAA0BJ,GACtB,IAAIzF,EAAS1G,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAC7DjE,IAEDA,EADe1G,EAAaC,yBAAyBrB,KAAK+L,SAAU,UACpDxH,WAAWT,YAAY9D,KAAK+L,SAAShI,cAAcM,cAAc,YAErFjD,EAAaiC,6BAA6ByE,EAAM,GAChD9H,KAAK0M,eAAexN,IASjBioB,EAAAjnB,UAAA6hB,iCAAwBC,EAAwBC,EAAsBC,GACzE,IACMC,EAAQ,IAAIgF,EADQnnB,KAAK+L,SAASqW,WAAU,GACPpiB,KAAKgM,IAAKkW,GAErD,OADAC,EAAME,kBAAkBL,EAAeC,GAChCE,GAOJgF,EAAAjnB,UAAAmiB,2BAAkBL,EAAwBC,GAC7C,IAAMxC,EAASre,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAChEjE,EAAS1G,EAAaC,yBAAyBrB,KAAK+L,SAAU,UAIlE,GAHKjE,IACDA,EAAS2X,EAAOlb,WAAWT,YAAY9D,KAAK+L,SAAShI,cAAcM,cAAc,YAEjF2d,GAAiBC,EAAa,CAC9B,IAAMK,EAAelhB,EAAakB,cAAcmd,GAC5C8C,EAAkBD,EACjBtiB,KAAK4N,aAAa0U,KACnBC,EAAkBviB,KAAKkM,0BAA0BhB,+BAC3CoX,EACAtiB,KAAKkM,0BAA0Bb,+BAEzCjK,EAAaiC,6BAA6ByE,EAAQya,QAElDnhB,EAAaiC,6BAA6ByE,EAAQ,IAEtD,IAAM4f,EAAUtmB,EAAaC,yBAAyBrB,KAAK+L,SAAU,WACjE2b,IACI1F,EACA0F,EAAQvI,aAAa,QAASnf,KAAK6M,sBAAsB1N,IAEzDuoB,EAAQvI,aAAa,QAASnf,KAAK6M,sBAAsB5N,QAldzE,CAAqC6M,GCArC6b,GAAA,SAAAjZ,GAUI,SAAAiZ,EAAYxe,EAAmBC,EAAcC,GAA7C,IAAAgB,EACIqE,EAAA7N,KAAAb,OAAOA,YACPqK,EAAKpB,UAAY,GACjBoB,EAAKL,iCAAmC,EACxCK,EAAKoY,sBAAsBtZ,EAAWC,EAAMC,YAdpBuF,EAAAA,EAAAA,GAiBpB+Y,EAAAznB,UAAAuiB,+BAAsBtZ,EAAmBC,EAAcC,GAC3DrJ,KAAKkJ,aAAaC,EAAWC,EAAMC,GACnC,IAAMqZ,EAAY1iB,KAAKyJ,gBAAgBhI,qBAAqB,SAC5D,GAAyB,IAArBihB,EAAUhhB,OACV,MAAM,IAAI6D,MAAMuJ,EAAAA,OAAO,wEAAyE1F,IAEhG,IAAMuZ,EAAUD,EAAU/gB,KAAK,GAAGI,aAAa,WAE/C,GADwB,QACpB4gB,EACA,MAAM,IAAIpd,MAAMuJ,EAAAA,OAAO,wEACnB1F,EAHgB,MAGOuZ,IAGnC,OAAO3iB,MAQJ2nB,EAAAznB,UAAA0iB,sBACH,OAAOhkB,GAOJ+oB,EAAAznB,UAAA2iB,oBACH,OAAO7jB,GAQD2oB,EAAAznB,UAAA2L,yBAAV,WACI,MAAO,CAAC,WAAY,OAAQ,OAAQ,SAAU,SAAU,KAAM,QAGxD8b,EAAAznB,UAAA4J,qBAAV,WACI9J,KAAKgJ,WAAa,GAElB,IADA,IAAM8Z,EAAmB9iB,KAAKyJ,gBAAgBhI,qBAAqB,QAC1Db,EAAI,EAAGA,EAAIkiB,EAAiBphB,OAAQd,IAAK,CAC9C,IAAMmiB,EAAYD,EAAiBnhB,KAAKf,GAClCiB,EAAKkhB,EAAUhhB,aAAa,MAC7BF,GACD7B,KAAKiJ,UAAUhI,KAAK6N,EAAAA,OAAO,sEAAuE9O,KAAKuJ,YAE3GvJ,KAAKgJ,WAAW/H,KAAK,IAAIkmB,GAAgBpE,EAAWlhB,EAAI7B,SAQzD2nB,EAAAznB,UAAA8iB,0BACH,IAAM4E,EAAYxmB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,SAC9E,OAAIme,EACOA,EAAU7lB,aAAa,WAEvB,MAQR4lB,EAAAznB,UAAAgjB,2BAAkBC,GACrB,IAAMyE,EAAYxmB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,SAC1Eme,GACAA,EAAUzI,aAAa,UAAWgE,IAQnCwE,EAAAznB,UAAAkjB,0BACH,IAAMwE,EAAYxmB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,SAC9E,OAAIme,EACOA,EAAU7lB,aAAa,WAEvB,MAQR4lB,EAAAznB,UAAAmjB,2BAAkBF,GACrB,IAAMyE,EAAYxmB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,SAC1Eme,GACAA,EAAUzI,aAAa,UAAWgE,IA0B1CwE,EAAAznB,UAAAojB,mBAAA,SAAmBC,EAA8BvB,EAAwBC,EAAsBuB,GAE3F,GAAIxjB,KAAK+K,gBAAgBwY,EAAiB1hB,IACtC,MAAM,IAAI0D,MAAMuJ,EAAAA,OAAO,yDAA0DyU,EAAiB1hB,KAEtG,IAAM4hB,EAAQ,EAAuC1B,wBAAwBC,EAAeC,EAAajiB,MACnG6nB,EAAczmB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,QAChF,IAAKoe,EACD,MAAM,IAAItiB,MAAMuJ,EAAAA,OAAO,0EAA2E9O,KAAKuJ,YAE3G,IAAIoa,GAAW,EACXC,GAA2B,EACzBJ,IACqBxjB,KAAK+K,gBAAgByY,EAAmB3hB,MAE3D+hB,GAA2B,IAGnC,GAAIJ,IAAuBK,WAAcL,IAAuBI,EAC5DiE,EAAY/jB,YAAY2f,EAAMpW,gBAC9BsW,GAAW,OACR,GAA2B,OAAvBH,EAA6B,CACpC,IAAMM,EAAmB1iB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,QAGjFka,GAFAG,EACA1iB,EAAaoD,aAAaif,EAAMpW,eAAgByW,GAIhD+D,EAAY/jB,YAAY2f,EAAMpW,iBAHnB,OAMZ,CACH,IAAM0W,EAAiB3iB,EAAaQ,yBAAyB5B,KAAKyJ,gBAAiB,OAAQ+Z,EAAmB3hB,IAC1GkiB,IACA3iB,EAAakD,YAAYmf,EAAMpW,eAAgB0W,GAC/CJ,GAAW,GAGnB,OAAIA,GACA3jB,KAAK4J,2BACL5J,KAAKgJ,WAAW/H,KAAKwiB,GACrBzjB,KAAK+J,eACE0Z,GAEA,MAkBRkE,EAAAznB,UAAA8jB,sCAA6BC,EAAcvY,EAAkBsW,EAAwBC,GAExF,IAAMiC,EAAkB,IAAIyD,EAAW3nB,KAAK2L,gBAAiBD,EAAU1L,KAAKqJ,YAO5E,OANA6a,EAAgBlZ,6BAA6BhL,KAAKiL,eAClDiZ,EAAgB/Y,4BAA4BnL,KAAKoL,cACjD8Y,EAAgBb,kBAAkBY,GAClCC,EAAgB/Z,iBAAiB,SAACga,GAC9B,EAAgC9B,kBAAkBL,EAAeC,KAE9DiC,KArNf,CAAgCnb,GCDhC+e,GAAA,SAAApZ,GAII,SAAAoZ,EAAY/b,EAAmBC,EAAaC,EAChC8b,GADZ,IAAA1d,EAEIqE,EAAA7N,KAAAb,KAAM+L,EAAUC,EAAKC,IAAyBjM,YAC9CqK,EAAK0d,2BAA6BA,WAPRnZ,EAAAA,EAAAA,GAevBkZ,EAAA5nB,UAAAmf,yBACH,OAAIrf,KAAK+nB,2BACE/nB,KAAK+nB,2BAA2B1I,gBAEhC,MASfyI,EAAA5nB,UAAAiM,yBAAA,WACI,OAAO,GASJ2b,EAAA5nB,UAAAqf,0BAAiBC,KAOdsI,EAAA5nB,UAAA4N,cAAV,WACI,OAAO,IAAIsW,IAMR0D,EAAA5nB,UAAAoM,yCACH,OAAItM,KAAK+nB,2BACE/nB,KAAK+nB,2BAA2Bzb,gCAEhC,MAORwb,EAAA5nB,UAAAwf,yBACH,OAAOte,EAAakB,cAActC,KAAK+L,WAO3C+b,EAAA5nB,UAAA0f,wBAAA,WACI,OAAO5f,KAAK8N,gBAAgBwL,+BAA+BtZ,KAAK+L,SAAU/L,KAAKoM,4BAQ5E0b,EAAA5nB,UAAAsM,6BACH,GAAIxM,KAAK+nB,2BAA4B,CACjC,IAAM1I,EAAgBrf,KAAK+nB,2BAA2B1I,gBACtD,OAAKA,GAAiBA,IAAkBrf,KAAK0f,iBAAoB1f,KAAK0f,gBAG3D,QAFA,MAKf,OAAO,MAUDoI,EAAA5nB,UAAA2M,sBAAV,SAAgCvC,GAC5B,OAAOA,GAQDwd,EAAA5nB,UAAAuM,sBAAV,SAAgCF,GAC5B,OAAOA,GAQDub,EAAA5nB,UAAA0M,qBAAV,SAA+BL,KAYxBub,EAAA5nB,UAAA2f,4BACH,OAAI7f,KAAK+nB,2BACE/nB,KAAK+nB,2BAA2BlI,mBAEhC,IASRiI,EAAA5nB,UAAA4M,uCACH,OAAO,GASJgb,EAAA5nB,UAAAmgB,6BAAoBN,KASpB+H,EAAA5nB,UAAA0gB,uBACH,OAAI5gB,KAAK+nB,2BACE/nB,KAAK+nB,2BAA2BnH,cAEhC,MAURkH,EAAA5nB,UAAAwhB,mBACH,OAAI1hB,KAAK+nB,2BACE/nB,KAAK+nB,2BAA2BrG,UAEhC,MASRoG,EAAA5nB,UAAA6M,4CACH,OAAO,GAOJ+a,EAAA5nB,UAAA6gB,wBAAeH,KAQfkH,EAAA5nB,UAAAyhB,oBAAWD,KAQXoG,EAAA5nB,UAAA0hB,iBACH,MAAO,IAQJkG,EAAA5nB,UAAA2hB,4BACH,OAAO,GAQJiG,EAAA5nB,UAAA4hB,kBAAS7U,KAWT6a,EAAA5nB,UAAA6hB,iCAAwBC,EAAwBC,EAAsBC,GACzE,OAAOliB,MAOJ8nB,EAAA5nB,UAAAmiB,2BAAkBL,EAAwBC,KAQvC6F,EAAA5nB,UAAAyN,gBAAV,SAA0BJ,GACtB,IAAMzF,EAAS9H,KAAK+L,SAChBlC,EAAAA,kBAAkB0D,KAClBA,EAAc,IAElBnM,EAAaiC,6BAA6ByE,EAAQyF,MAtQ1D,CAAkCzB,GCAlCkc,GAAA,SAAAtZ,GAiBI,SAAAsZ,EAAoBrC,EACRxc,EAAmBC,EAAcC,EACjCC,GAFZ,IAAAe,EAGIqE,EAAA7N,KAAAb,OAAOA,YAHSqK,EAAAsb,+BAAAA,EAIhBtb,EAAKpB,UAAY,GACjBoB,EAAKL,iCAAmC,EACxCK,EAAKoY,sBAAsBtZ,EAAWC,EAAMC,EAAUC,YAvBjCsF,EAAAA,EAAAA,GA0BjBoZ,EAAA9nB,UAAAuiB,+BAAsBtZ,EAAmBC,EAAcC,EACjCC,GAE1B,GADAtJ,KAAKkJ,aAAaC,EAAWC,EAAMC,GAC2C,IAA1ErJ,KAAKyJ,gBAAgBhI,qBAAqB,qBAAqBC,OAC/D,MAAM,IAAI6D,MAAMuJ,EAAAA,OAAO,iFAAkF1F,IAE7G,GAAIE,EACA,IACItJ,KAAKioB,YAAcjoB,KAAK2lB,+BAA+BI,0BACnDlnB,EACAyK,EAAe0c,WACf1c,EAAeF,KACfE,EAAeD,UAEnB,IAAM6e,EAAiBloB,KAAKioB,YAAYxd,qBAClC0d,EAAWnoB,KAAKyK,qBAClByd,IAAmBC,GACnBnoB,KAAKiJ,UAAUhI,KAAK6N,EAAAA,OAChB,0FACAoZ,EAAgBC,IAE1B,MAAOhnB,GACL,MAAM,IAAIoE,MAAMuJ,EAAAA,OAAO,2EAA4ExF,EAAeF,OAG1H,OAAOpJ,MAGDgoB,EAAA9nB,UAAA4J,qBAAV,WACI9J,KAAKgJ,WAAa,GAElB,IADA,IAAM8Z,EAAmB9iB,KAAKyJ,gBAAgBhI,qBAAqB,eAC1Db,EAAI,EAAGA,EAAIkiB,EAAiBphB,OAAQd,IAAK,CAC9C,IAAMglB,EAAM9C,EAAiBnhB,KAAKf,GAC5BiB,EAAK+jB,EAAI7jB,aAAa,MACvBF,GACD7B,KAAKiJ,UAAUhI,KAAK6N,EAAAA,OAAO,+DAAgE9O,KAAKuJ,YAEpG,IAAI6e,EAAyB,KACzBpoB,KAAKioB,cACLG,EAAapoB,KAAKioB,YAAYld,gBAAgBlJ,IAElD7B,KAAKgJ,WAAW/H,KAAK,IAAI6mB,GAAalC,EAAK/jB,EAAI7B,KAAI,MASpDgoB,EAAA9nB,UAAA0iB,sBACH,OAAO9jB,GAOJkpB,EAAA9nB,UAAA2iB,oBACH,M9BhFoB,O8BwFdmF,EAAA9nB,UAAA2L,yBAAV,WACI,MAAO,CAAC,gBASLmc,EAAA9nB,UAAA8iB,0BACH,OAAIhjB,KAAKioB,YACEjoB,KAAKioB,YAAYjF,iBAEjB,MASRgF,EAAA9nB,UAAAgjB,2BAAkBC,KAQlB6E,EAAA9nB,UAAAkjB,0BACH,IAAMiF,EAAwBjnB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,qBAC1F,OAAI4e,EACOA,EAAsBtmB,aAAa,QAEnC,MAQRimB,EAAA9nB,UAAAmjB,2BAAkBF,GACrB,IAAMkF,EAAwBjnB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,qBACtF4e,GACAA,EAAsBlJ,aAAa,OAAQgE,IA0BnD6E,EAAA9nB,UAAAojB,mBAAA,SAAmBC,EAA8BvB,EAAwBC,EAAsBuB,GAE3F,GAAIxjB,KAAK+K,gBAAgBwY,EAAiB1hB,IACtC,MAAM,IAAI0D,MAAMuJ,EAAAA,OAAO,yDAA0DyU,EAAiB1hB,KAEtG,IAAMymB,EAAc,EAAuCvG,wBAAwBC,EAAeC,EAAajiB,MACzGqoB,EAAwBjnB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,qBAC1F,IAAK4e,EACD,MAAM,IAAI9iB,MAAMuJ,EAAAA,OAAO,iFAAkF9O,KAAKuJ,YAElH,IAAMgf,EAAqBF,EAAsBtkB,cAAcM,cAAc,eAC7EkkB,EAAmBpJ,aAAa,KAAMoE,EAAiB1hB,IACvD,IAAI2d,EAAcyC,GAAeD,EAAiBuB,EAAiBlE,gBAAkB,GAChF,EAAuCzR,aAAa4R,KACrDA,EAAaxf,KAAKkL,+BAAiCsU,EAAaxf,KAAKqL,+BAEzEjK,EAAaiC,6BAA6BklB,EAAoB/I,GAC9D,IAAMiE,EAAQ,IAAIqE,GAAaS,EAAoBhF,EAAiB1hB,GAAI7B,KAAMsoB,GAC1E3E,GAAW,EACXC,GAA2B,EACzBJ,IACqBxjB,KAAK+K,gBAAgByY,EAAmB3hB,MAE3D+hB,GAA2B,IAGnC,GAAIJ,IAAuBK,WAAcL,IAAuBI,EAC5DyE,EAAsBvkB,YAAY2f,EAAMpW,gBACxCsW,GAAW,OACR,GAA2B,OAAvBH,EAA6B,CACpC,IAAMgF,EAA0BpnB,EAAaC,yBAAyBrB,KAAKyJ,gBAAiB,eAGxFka,GAFA6E,EACApnB,EAAaoD,aAAaif,EAAMpW,eAAgBmb,GAIhDH,EAAsBvkB,YAAY2f,EAAMpW,iBAH7B,OAMZ,CACH,IAAM0W,EAAiB3iB,EAAaQ,yBAAyB5B,KAAKyJ,gBAAiB,cAAe+Z,EAAmB3hB,IACjHkiB,IACA3iB,EAAakD,YAAYmf,EAAMpW,eAAgB0W,GAC/CJ,GAAW,GAGnB,OAAIA,GACA3jB,KAAK4J,2BACL5J,KAAKgJ,WAAW/H,KAAKwiB,GACrBzjB,KAAK+J,eACE0Z,GAEA,MAkBRuE,EAAA9nB,UAAA8jB,sCAA6BC,EAAcvY,EAAkBsW,EAAwBC,GAExF,MAAM,IAAI1c,MAAMuJ,EAAAA,OAAO,2EAA4EpD,OA9O3G,CAA6B3C,GCC7B0f,GAAA,gCAckBA,EAAAC,yBAAgB9F,EACAoD,EACA5c,EACAC,EACAC,GAC1B,OAAO,IAAImf,GAAiC1C,0BAA0BnD,EAAYoD,EAAY5c,EAAMC,EAAUC,IAgBpGmf,EAAAE,sCAA6B3C,EACb5c,EACAC,EACAC,GAC1B,OAAO,IAAImf,GAAiCG,uCAAuC5C,EAAY5c,EAAMC,EAAUC,IAenHmf,EAAAvoB,UAAA6lB,0BAAA,SAA0BnD,EACAoD,EACA5c,EACAC,EACAC,GACtB,GAAIsZ,IAAejkB,EACf,OAAO,IAAI6jB,GAAUwD,EAAY5c,EAAMC,GAE3C,GAAIuZ,IAAehkB,EACf,OAAO,IAAI+oB,GAAW3B,EAAY5c,EAAMC,GAE5C,GAAIuZ,IAAe/jB,EACf,OAAO,IAAI6mB,GAAQ1lB,KAAMgmB,EAAY5c,EAAMC,GAE/C,GAAIuZ,IAAe9jB,EACf,OAAO,IAAIkpB,GAAQhoB,KAAMgmB,EAAY5c,EAAMC,EAAUC,GAEzD,MAAM,IAAI/D,MAAMuJ,EAAAA,OAAO,gCAAiC8T,KAiB5D6F,EAAAvoB,UAAA0oB,uCAAA,SAAuC5C,EACA5c,EACAC,EACAC,GAEnC,IAAIuf,EAAmB,CAAClqB,EAAgBC,EAAgBC,EAAYC,GAChEsK,GAAQA,EAAKO,SAAS,SACtBkf,EAAmB,CAAChqB,EAAYC,EAAYH,EAAgBC,IAE5DwK,GAAQA,EAAKO,SAAS,SACtBkf,EAAmB,CAAC/pB,EAAYD,EAAYF,EAAgBC,IAGhE,IAAK,IAAIgC,EAAI,EAAGA,EAAIioB,EAAiBnnB,OAAQd,IAAK,CAC9C,IAAMkoB,EAAkBD,EAAiBjoB,GACzC,IACI,IAAMsjB,EAAkBuE,EAA+BC,gBACnDI,EAAiB9C,EAAY5c,EAAMC,EAAUC,GACjD,GAAI4a,EACA,OAAOA,EAEb,MAAOvjB,KAIb,MAAM,IAAI4E,MAAMuJ,EAAAA,OAAO,mFAjH/B,gM/BG4B,qBACA,wFA8BgB","sourcesContent":["import { NgModule } from '@angular/core';\r\n\r\n@NgModule({\r\n  imports: [\r\n  ],\r\n  declarations: [],\r\n  exports: []\r\n})\r\nexport class NgxI18nsupportLibModule { }\r\n","/**\r\n * Created by roobm on 08.05.2017.\r\n * Some constant values used in the API.\r\n */\r\n\r\n/**\r\n * supported file formats\r\n */\r\nexport const FORMAT_XLIFF12 = 'xlf';\r\nexport const FORMAT_XLIFF20 = 'xlf2';\r\nexport const FORMAT_XMB = 'xmb';\r\nexport const FORMAT_XTB = 'xtb';\r\n\r\n/**\r\n * File types\r\n * (returned by fileType() method)\r\n */\r\nexport const FILETYPE_XLIFF12 = 'XLIFF 1.2';\r\nexport const FILETYPE_XLIFF20 = 'XLIFF 2.0';\r\nexport const FILETYPE_XMB = 'XMB';\r\nexport const FILETYPE_XTB = 'XTB';\r\n\r\n/**\r\n * abstract state value.\r\n * There are only 3 supported state values.\r\n */\r\n\r\n/**\r\n * State NEW.\r\n * Signals an untranslated unit.\r\n */\r\nexport const STATE_NEW = 'new';\r\n/**\r\n * State TRANSLATED.\r\n * Signals a translated unit, that is not reviewed until now.\r\n */\r\nexport const STATE_TRANSLATED = 'translated';\r\n/**\r\n * State FINAL.\r\n * Signals a translated unit, that is reviewed and ready for use.\r\n */\r\nexport const STATE_FINAL = 'final';\r\n\r\n/**\r\n * Normalizaton message formats.\r\n */\r\n\r\n/**\r\n * Default format, contains placeholders, html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_DEFAULT = 'default';\r\n\r\n/**\r\n * Format for usage in ngxtranslate messages.\r\n * Placeholder are in the form {{n}}, no html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {DOMParser, XMLSerializer} from 'xmldom';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\n\r\nexport class DOMUtilities {\r\n\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getFirstElementByTagName(element: Element | Document, tagName: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getElementByTagNameAndId(element: Element | Document, tagName: string, id: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node: Element = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementFollowingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementPrecedingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    public static getXMLContent(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg: RegExp = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg: RegExp = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    public static getPCDATA(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    public static replaceContentWithXMLContent(element: Element, pcdata: string) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment: Document = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    public static getPreviousElementSibling(element: Node): Element {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return <Element> node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    public static createFollowingSibling(elementNameToCreate: string, previousSibling: Node): Element {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return <Element> DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    public static insertAfter(newElement: Node, previousSibling: Node): Node {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        } else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    public static insertBefore(newElement: Node, nextSibling: Node): Node {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\r\n","/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\n\r\ninterface Namespace {\r\n    prefix: string;\r\n    namespace: string;\r\n}\r\n\r\n/**\r\n * Options used to control the formatting\r\n */\r\nexport interface XmlSerializerOptions {\r\n    beautify?: boolean; // set to activate beautify\r\n    indentString?: string; // Sequence uses for indentation, must only contain white space chars, e.g. \"  \" or \"    \" or \"\\t\"\r\n    mixedContentElements?: string[]; // Names of elements containing mixed content (these are not beautified)\r\n}\r\n\r\nconst DEFAULT_INDENT_STRING = '  ';\r\n\r\nexport class XmlSerializer {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document: Document, options?: XmlSerializerOptions): string {\r\n        const buf = [];\r\n        let visibleNamespaces: Namespace[] = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    {namespace: uri, prefix: null}\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    private doSerializeToString(node: Node, options: XmlSerializerOptions, buf: string[],\r\n                                indentLevel: number, partOfMixedContent: boolean, visibleNamespaces: Namespace[]) {\r\n        let child: Node;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode: Element = <Element> node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<' , nodeName);\r\n                } else {\r\n                    this.outputIndented(options, buf, indentLevel, '<' , nodeName);\r\n                }\r\n\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: attr.localName, namespace: attr.value});\r\n                    } else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: '', namespace: attr.value});\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = node.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                }\r\n\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1,\r\n                            partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    } else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                } else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = <Attr> node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = <Text> node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = <CDATASection> node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = <Comment> node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = <DocumentType> node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                } else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                } else {\r\n                    const sub = documenttypeNode.internalSubset;\r\n                    if (sub) {\r\n                        buf.push(' [', sub, ']');\r\n                    }\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = <ProcessingInstruction> node;\r\n                return buf.push( '<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n\r\n    private needNamespaceDefine(node: Element | Attr, visibleNamespaces: Namespace[]): boolean {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _xmlEncoder(c: string): string {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n\r\n    private outputIndented(options: XmlSerializerOptions, buf: string[], indentLevel: number, ...outputParts: string[]) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n\r\n    private indentationString(options: XmlSerializerOptions, indentLevel: number): string {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    private isMixedContentElement(tagName: string, options: XmlSerializerOptions): boolean {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private containsOnlyWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {isNullOrUndefined} from 'util';\r\nimport {DOMParser} from 'xmldom';\r\nimport {XmlSerializer, XmlSerializerOptions} from './xml-serializer';\r\n/**\r\n * Created by roobm on 09.05.2017.\r\n * Abstract superclass for all implementations of ITranslationMessagesFile.\r\n */\r\n\r\nexport abstract class AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    protected _filename: string;\r\n\r\n    protected _encoding: string;\r\n\r\n    protected _parsedDocument: Document;\r\n\r\n    protected _fileEndsWithEOL: boolean;\r\n\r\n    // trans-unit elements and their id from the file\r\n    protected transUnits: ITransUnit[];\r\n\r\n    protected _warnings: string[];\r\n\r\n    protected _numberOfTransUnitsWithMissingId: number;\r\n\r\n    protected _numberOfUntranslatedTransUnits: number;\r\n\r\n    protected _numberOfReviewedTransUnits: number;\r\n\r\n    protected targetPraefix: string;\r\n\r\n    protected targetSuffix: string;\r\n\r\n    protected constructor() {\r\n        this.transUnits = null;\r\n        this._warnings = [];\r\n    }\r\n\r\n    /**\r\n     * Parse file content.\r\n     * Sets _parsedDocument, line ending, encoding, etc.\r\n     * @param xmlString xmlString\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMaster optionalMaster\r\n     */\r\n    protected parseContent(\r\n        xmlString: string,\r\n        path: string, encoding: string,\r\n        optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : void {\r\n        this._filename = path;\r\n        this._encoding = encoding;\r\n        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        this._fileEndsWithEOL = xmlString.endsWith('\\n');\r\n    }\r\n\r\n    abstract i18nFormat(): string;\r\n\r\n    abstract fileType(): string;\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected abstract elementsWithMixedContent(): string[];\r\n\r\n    /**\r\n     * Read all trans units from xml content.\r\n     * Puts the found units into transUnits.\r\n     * Puts warnings for missing ids.\r\n     */\r\n    protected abstract initializeTransUnits();\r\n\r\n    protected lazyInitializeTransUnits() {\r\n        if (isNullOrUndefined(this.transUnits)) {\r\n            this.initializeTransUnits();\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * count units after changes of trans units\r\n     */\r\n    public countNumbers() {\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this._numberOfUntranslatedTransUnits = 0;\r\n        this._numberOfReviewedTransUnits = 0;\r\n        this.forEachTransUnit((tu: ITransUnit) => {\r\n            if (isNullOrUndefined(tu.id) || tu.id === '') {\r\n                this._numberOfTransUnitsWithMissingId++;\r\n            }\r\n            const state = tu.targetState();\r\n            if (isNullOrUndefined(state) || state === STATE_NEW) {\r\n                this._numberOfUntranslatedTransUnits++;\r\n            }\r\n            if (state === STATE_TRANSLATED) {\r\n                this._numberOfReviewedTransUnits++;\r\n            }\r\n        });\r\n    }\r\n\r\n    public warnings(): string[] {\r\n        this.lazyInitializeTransUnits();\r\n        return this._warnings;\r\n    }\r\n\r\n    /**\r\n     * Total number of translation units found in the file.\r\n     */\r\n    public numberOfTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.length;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfUntranslatedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfUntranslatedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units with state 'final'.\r\n     */\r\n    numberOfReviewedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfReviewedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    public numberOfTransUnitsWithMissingId(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfTransUnitsWithMissingId;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    abstract sourceLanguage(): string;\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    abstract targetLanguage(): string;\r\n\r\n    /**\r\n     * Loop over all Translation Units.\r\n     * @param callback callback\r\n     */\r\n    public forEachTransUnit(callback: ((transunit: ITransUnit) => void)) {\r\n        this.lazyInitializeTransUnits();\r\n        this.transUnits.forEach((tu) => callback(tu));\r\n    }\r\n\r\n    /**\r\n     * Get trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    public transUnitWithId(id: string): ITransUnit {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.find((tu) => tu.id === id);\r\n    }\r\n\r\n    /**\r\n     * Edit functions following her\r\n     */\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    abstract setSourceLanguage(language: string);\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    abstract setTargetLanguage(language: string);\r\n\r\n    /**\r\n     * Set the praefix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetPraefix targetPraefix\r\n     */\r\n    public setNewTransUnitTargetPraefix(targetPraefix: string) {\r\n        this.targetPraefix = targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Get the praefix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the praefix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetPraefix(): string {\r\n        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Set the suffix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetSuffix targetSuffix\r\n     */\r\n    public setNewTransUnitTargetSuffix(targetSuffix: string) {\r\n        this.targetSuffix = targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Get the suffix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the suffix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetSuffix(): string {\r\n        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    abstract importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit;\r\n\r\n    /**\r\n     * Remove the trans-unit with the given id.\r\n     * @param id id\r\n     */\r\n    public removeTransUnitWithId(id: string) {\r\n        const tuNode: Node = this._parsedDocument.getElementById(id);\r\n        if (tuNode) {\r\n            tuNode.parentNode.removeChild(tuNode);\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filename where the data is read from.\r\n     */\r\n    public filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    /**\r\n     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)\r\n     */\r\n    public encoding(): string {\r\n        return this._encoding;\r\n    }\r\n\r\n    /**\r\n     * The xml content to be saved after changes are made.\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public editedContent(beautifyOutput?: boolean): string {\r\n        const options: XmlSerializerOptions = {};\r\n        if (beautifyOutput === true) {\r\n           options.beautify = true;\r\n           options.indentString = '  ';\r\n           options.mixedContentElements = this.elementsWithMixedContent();\r\n        }\r\n        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);\r\n        if (this._fileEndsWithEOL) {\r\n            // add eol if there was eol in original source\r\n            return result + '\\n';\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    abstract createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile;\r\n}\r\n","import {STATE_TRANSLATED, ITranslationMessagesFile, INormalizedMessage, ITransUnit, INote} from './internalapi';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {isNullOrUndefined, isString} from 'util';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * Abstract superclass for all implementations of ITransUnit.\r\n */\r\n\r\nexport abstract class AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceContentNormalized: ParsedMessage;\r\n\r\n    protected constructor(protected _element: Element,\r\n                          protected _id: string,\r\n                          protected _translationMessagesFile: ITranslationMessagesFile) {\r\n    }\r\n\r\n    public get id(): string {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * The file the unit belongs to.,\r\n     */\r\n    translationMessagesFile(): ITranslationMessagesFile {\r\n        return this._translationMessagesFile;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract sourceContent(): string;\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    abstract setSourceContent(newContent: string);\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public sourceContentNormalized(): ParsedMessage {\r\n        if (isNullOrUndefined(this._sourceContentNormalized)) {\r\n            this._sourceContentNormalized = this.createSourceContentNormalized();\r\n        }\r\n        return this._sourceContentNormalized;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    abstract createSourceContentNormalized(): ParsedMessage;\r\n\r\n    /**\r\n     * The translated value.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract targetContent(): string;\r\n\r\n    /**\r\n     * The translated value as normalized message.\r\n     * All placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    abstract targetContentNormalized(): INormalizedMessage;\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    abstract nativeTargetState(): string;\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (on of new, translated, final)\r\n     * Return values are defined as Constants STATE_...\r\n     */\r\n    public targetState(): string {\r\n        const nativeState = this.nativeTargetState();\r\n        return this.mapNativeStateToState(nativeState);\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected abstract mapStateToNativeState(state: string): string;\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract mapNativeStateToState(nativeState: string): string;\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract setNativeTargetState(nativeState: string);\r\n\r\n    /**\r\n     * Modify the target state.\r\n     * @param newState one of the 3 allowed target states new, translated, final.\r\n     * Constants STATE_...\r\n     * Invalid states throw an error.\r\n     */\r\n    setTargetState(newState: string) {\r\n        this.setNativeTargetState(this.mapStateToNativeState(newState));\r\n        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {\r\n            (<AbstractTranslationMessagesFile> this.translationMessagesFile()).countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    abstract sourceReferences(): {sourcefile: string, linenumber: number}[];\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    abstract setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]);\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     */\r\n    abstract description(): string;\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     */\r\n    abstract meaning(): string;\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    abstract setDescription(description: string);\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    abstract setMeaning(meaning: string);\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    abstract notes(): INote[];\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    abstract supportsSetNotes(): boolean;\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains descpription or meaning as from attribute.\r\n     */\r\n    abstract setNotes(newNotes: INote[]);\r\n\r\n    /**\r\n     * Check notes\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    protected checkNotes(newNotes: INote[]) {\r\n        // check from values\r\n        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');\r\n        if (!isNullOrUndefined(errorInFromNote)) {\r\n            throw new Error('description or meaning are not allowed as from atttribute');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The real xml element used for the trans unit.\r\n     * (internal usage only, a client should never need this)\r\n     * @return real xml element used for the trans unit.\r\n     */\r\n    public asXmlElement(): Element {\r\n        return this._element;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    abstract cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit;\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    abstract useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean);\r\n\r\n    /**\r\n     * Translate the trans unit.\r\n     * @param translation the translated string or (preferred) a normalized message.\r\n     * The pure string can contain any markup and will not be checked.\r\n     * So it can damage the document.\r\n     * A normalized message prevents this.\r\n     */\r\n    public translate(translation: string | INormalizedMessage) {\r\n        let translationNative: string;\r\n        if (isString(translation)) {\r\n            translationNative = <string> translation;\r\n        } else {\r\n            translationNative = (<INormalizedMessage> translation).asNativeString();\r\n        }\r\n        this.translateNative(translationNative);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected abstract messageParser(): AbstractMessageParser;\r\n\r\n    /**\r\n     * Test, wether message looks like ICU message.\r\n     * @param message message\r\n     * @return wether message looks like ICU message.\r\n     */\r\n    public isICUMessage(message: string): boolean {\r\n        return this.messageParser().isICUMessageStart(message);\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected abstract translateNative(translation: string);\r\n}\r\n","/**\r\n * Created by martin on 05.05.2017.\r\n * A part of a parsed message.\r\n * Can be a text, a placeholder, a tag\r\n */\r\n\r\nexport enum ParsedMessagePartType {\r\n    TEXT,\r\n    PLACEHOLDER,\r\n    START_TAG,\r\n    END_TAG,\r\n    EMPTY_TAG,\r\n    ICU_MESSAGE,\r\n    ICU_MESSAGE_REF\r\n}\r\n\r\nexport abstract class ParsedMessagePart {\r\n\r\n    constructor(public type: ParsedMessagePartType) {\r\n\r\n    }\r\n\r\n    /**\r\n     * String representation of the part.\r\n     * @param format optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public abstract asDisplayString(format?: string): string;\r\n\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of just simple text.\r\n */\r\n\r\nexport class ParsedMessagePartText extends ParsedMessagePart {\r\n\r\n    private text: string;\r\n\r\n    constructor(text: string) {\r\n        super(ParsedMessagePartType.TEXT);\r\n        this.text = text;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return this.text;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a placeholder.\r\n * Placeholders are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartPlaceholder extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.PLACEHOLDER);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {\r\n            return '{{' + this._index + '}}';\r\n        }\r\n        return '{{' + this._index + '}}';\r\n    }\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of an opening tag like <b> or <strange>.\r\n */\r\n\r\nexport class ParsedMessagePartStartTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.START_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a closing tag like </b> or </strange>.\r\n */\r\n\r\nexport class ParsedMessagePartEndTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n\r\n    constructor(tagname: string) {\r\n        super(ParsedMessagePartType.END_TAG);\r\n        this._tagname = tagname;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '</' + this._tagname + '>';\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\n\r\n/**\r\n * Created by martin on 04.06.2017.\r\n * A tokenizer for ICU messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';\r\nexport const CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';\r\nexport const COMMA = 'COMMA';\r\nexport const PLURAL = 'PLURAL';\r\nexport const SELECT = 'SELECT';\r\n\r\nexport interface ICUToken {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\n// states: default normal in_message\r\nconst STATE_DEFAULT = 'default';\r\nconst STATE_NORMAL = 'normal';\r\nconst STATE_IN_MESSAGE = 'in_message';\r\n\r\nexport class ICUMessageTokenizer {\r\n    private lexer: Tokenizr;\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        let openedCurlyBracesInTextCounter = 0;\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT) {\r\n                if (this.containsNonWhiteSpace(plaintext)) {\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                } else {\r\n                    ctx.ignore();\r\n                }\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (this.containsNonWhiteSpace(plaintext)) {\r\n                ctx.accept(TEXT, plaintext);\r\n            }\r\n         });\r\n        // curly brace\r\n        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_NORMAL);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_IN_MESSAGE);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {\r\n            ctx.pop();\r\n            ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n        }, CURLY_BRACE_CLOSE);\r\n        // masked ' { and }\r\n        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {\r\n            if (match[0] === '\\'\\'') {\r\n                plaintext += '\\'';\r\n            } else if (match[0] === '\\'{\\'') {\r\n                plaintext += '{';\r\n            } else if (match[0] === '\\'}\\'') {\r\n                plaintext += '}';\r\n            }\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {\r\n            const char = match[0];\r\n            if (char === '{') {\r\n                openedCurlyBracesInTextCounter++;\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            } else if (char === '}') {\r\n                if (openedCurlyBracesInTextCounter > 0) {\r\n                    openedCurlyBracesInTextCounter--;\r\n                    plaintext += match[0];\r\n                    ctx.ignore();\r\n                } else {\r\n                    ctx.pop();\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n                }\r\n            } else {\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n        }, TEXT);\r\n        // comma\r\n        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {\r\n            ctx.accept(COMMA, match[0]);\r\n        }, COMMA);\r\n        // keywords plural and select\r\n        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {\r\n            ctx.accept(PLURAL, match[0]);\r\n        }, PLURAL);\r\n        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {\r\n            ctx.accept(SELECT, match[0]);\r\n        }, SELECT);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\s]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    private containsNonWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (!/\\s/.test(text.charAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): ICUToken[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n    input(normalizedMessage: string) {\r\n        this.lexer = this.getLexer();\r\n        this.lexer.input(normalizedMessage);\r\n    }\r\n\r\n    next(): ICUToken {\r\n        return this.lexer.token();\r\n    }\r\n\r\n    peek(): ICUToken {\r\n        return this.lexer.peek();\r\n    }\r\n}\r\n","import {IICUMessage, IICUMessageCategory, IICUMessageTranslation, INormalizedMessage} from '../api/index';\r\nimport {format, isNullOrUndefined, isString} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\nclass MessageCategory implements IICUMessageCategory {\r\n\r\n    constructor(private _category: string, private _message: INormalizedMessage) {}\r\n\r\n    public getCategory(): string {\r\n        return this._category;\r\n    }\r\n\r\n    public getMessageNormalized(): INormalizedMessage {\r\n        return this._message;\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nexport class ICUMessage implements IICUMessage {\r\n\r\n    private _isPluralMessage: boolean;\r\n\r\n    private _categories: IICUMessageCategory[];\r\n\r\n    constructor(private _parser: IMessageParser, isPluralMessage: boolean) {\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n\r\n    addCategory(category: string, message: INormalizedMessage) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    public asNativeString(): string {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category: IICUMessageCategory) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage(): boolean {\r\n        return this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage(): boolean {\r\n        return !this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories(): IICUMessageCategory[] {\r\n        return this._categories;\r\n    }\r\n\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation: IICUMessageTranslation): IICUMessage {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories: Set<string> = new Set<string>();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage: INormalizedMessage;\r\n            const translationForCategory: string|IICUMessageTranslation = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            } else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(<string> translationForCategory, null);\r\n            } else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)',\r\n                        categoryName));\r\n                } else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    let translatedMessage = this._parser.parseNormalizedString(<string> translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    private checkValidPluralCategory(categoryName: string) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {IICUMessage, INormalizedMessage} from '../api/index';\r\nimport {\r\n    COMMA, CURLY_BRACE_CLOSE, CURLY_BRACE_OPEN, ICUMessageTokenizer, ICUToken, PLURAL, SELECT,\r\n    TEXT\r\n} from './icu-message-tokenizer';\r\nimport {ICUMessage} from './icu-message';\r\nimport {format} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\n\r\nexport class ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n\r\n    private _message: ICUMessage;\r\n    private _messageText: string;\r\n    private _tokenizer: ICUMessageTokenizer;\r\n\r\n    constructor(icuMessageText: string, private _parser: IMessageParser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText: string): boolean {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n\r\n    public asDisplayString(displayFormat?: string) {\r\n        return '<ICU-Message/>';\r\n    }\r\n\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        return this._message;\r\n    }\r\n\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    private parseICUMessage(text: string) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token: ICUToken = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        } else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    private looksLikeICUMessage(text: string): boolean {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token: ICUToken = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    private expectNext(tokentype: string): ICUToken {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)',\r\n                tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    private parseNativeSubMessage(message: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A reference to an ICU message\r\n * icu references are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartICUMessageRef extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE_REF);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '<ICU-Message-Ref_' + this._index + '/>';\r\n    }\r\n\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 14.06.2017.\r\n * A message part consisting of an empty tag like <br/>.\r\n */\r\n\r\nexport class ParsedMessagePartEmptyTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.EMPTY_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {INormalizedMessage, ValidationErrors} from '../api/i-normalized-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {IICUMessage, IICUMessageTranslation} from '../api/i-icu-message';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ICUMessage} from './icu-message';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message text read from a translation file.\r\n * Can contain placeholders, tags, text.\r\n * This class is a representation independent of the concrete format.\r\n */\r\nexport class ParsedMessage implements INormalizedMessage {\r\n\r\n    /**\r\n     * Parser that created this message (determines the native format).\r\n     */\r\n    private _parser: IMessageParser;\r\n\r\n    /**\r\n     * The message where this one stems from as translation.\r\n     * Optional, set only for messages created by calling translate.\r\n     */\r\n    private sourceMessage: ParsedMessage;\r\n\r\n    /**\r\n     * The parts of the message.\r\n     */\r\n    private _parts: ParsedMessagePart[];\r\n\r\n    /**\r\n     * messages xml representation.\r\n     */\r\n    private _xmlRepresentation: Element;\r\n\r\n    constructor(parser: IMessageParser, sourceMessage: ParsedMessage) {\r\n        this._parser = parser;\r\n        this.sourceMessage = sourceMessage;\r\n        this._parts = [];\r\n    }\r\n\r\n    /**\r\n     * Get the parser (for tests only, not part of API)\r\n     * @return parser\r\n     */\r\n    getParser(): IMessageParser {\r\n        return this._parser;\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message as a translation of this one.\r\n     * @param normalizedString the translation in normalized form.\r\n     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is an ICU message.\r\n     */\r\n    translate(normalizedString: string): INormalizedMessage {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return this._parser.parseNormalizedString(<string> normalizedString, this);\r\n        } else {\r\n            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead (\"%s\", \"%s\")',\r\n                normalizedString, this.asNativeString()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized icu message as a translation of this one.\r\n     * @param icuTranslation the translation, this is the translation of the ICU message,\r\n     * which is not a string, but a collections of the translations of the different categories.\r\n     * The message must be an ICUMessage (getICUMessage returns a value)\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is not an ICU message.\r\n     */\r\n    translateICUMessage(icuTranslation: IICUMessageTranslation): INormalizedMessage {\r\n        const icuMessage: IICUMessage = this.getICUMessage();\r\n        if (isNullOrUndefined(icuMessage)) {\r\n            throw new Error(format('this is not an ICU message, use translate() instead (\"%s\", \"%s\")',\r\n                icuTranslation,  this.asNativeString()));\r\n        } else {\r\n            const translatedICUMessage: IICUMessage = icuMessage.translate(icuTranslation);\r\n            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message from a native xml string as a translation of this one.\r\n     * @param nativeString xml string in the format of the underlying file format.\r\n     * Throws an error if native string is not acceptable.\r\n     */\r\n    translateNativeString(nativeString: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);\r\n    }\r\n\r\n    /**\r\n     * normalized message as string.\r\n     * @param displayFormat optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public asDisplayString(displayFormat?: string) {\r\n        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');\r\n    }\r\n\r\n    /**\r\n     * Returns the message content as format dependent native string.\r\n     * Includes all format specific markup like <ph id=\"INTERPOLATION\" ../> ..\r\n     */\r\n    asNativeString(): string {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return DOMUtilities.getXMLContent(this._xmlRepresentation);\r\n        } else {\r\n            return this.getICUMessage().asNativeString();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate the message.\r\n     * @return null, if ok, error object otherwise.\r\n     */\r\n    public validate(): ValidationErrors | null {\r\n        let hasErrors = false;\r\n        const errors: ValidationErrors = {};\r\n        let e;\r\n        e = this.checkPlaceholderAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.placeholderAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefRemoved();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefRemoved = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        return hasErrors ? errors : null;\r\n    }\r\n\r\n    /**\r\n     * Validate the message, check for warnings only.\r\n     * A warning shows, that the message is acceptable, but misses something.\r\n     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.\r\n     * @return null, if no warning, warnings as error object otherwise.\r\n     */\r\n    validateWarnings(): ValidationErrors | null {\r\n        let hasWarnings = false;\r\n        const warnings: ValidationErrors = {};\r\n        let w;\r\n        w = this.checkPlaceholderRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.placeholderRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagAdded();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagAdded = w;\r\n            hasWarnings = true;\r\n        }\r\n        return hasWarnings ? warnings : null;\r\n    }\r\n\r\n    /**\r\n     * If this message is an ICU message, returns its structure.\r\n     * Otherwise this method returns null.\r\n     * @return ICUMessage or null.\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {\r\n            const icuPart = <ParsedMessagePartICUMessage> this._parts[0];\r\n            return icuPart.getICUMessage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for added placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            myPlaceholders.forEach((index) => {\r\n                if (!sourcePlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderRemoved(): any {\r\n        let w = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            sourcePlaceholders.forEach((index) => {\r\n                if (!myPlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Check for added ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            myICURefs.forEach((index) => {\r\n                if (!sourceICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefRemoved(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            sourceICURefs.forEach((index) => {\r\n                if (!myICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of placeholders used in the message.\r\n     */\r\n    private allPlaceholders(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const index = (<ParsedMessagePartPlaceholder> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of placeholder\r\n     * @param index index of placeholder\r\n     * @return disp or null\r\n     */\r\n    public getPlaceholderDisp(index: number): string {\r\n        let placeHolder: ParsedMessagePartPlaceholder = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const phPart: ParsedMessagePartPlaceholder = <ParsedMessagePartPlaceholder> part;\r\n                if (phPart.index() === index) {\r\n                    placeHolder = phPart;\r\n                }\r\n            }\r\n        });\r\n        return placeHolder ? placeHolder.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of ICU message refs used in the message.\r\n     */\r\n    private allICUMessageRefs(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const index = (<ParsedMessagePartICUMessageRef> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of icu message ref\r\n     * @param index of ref\r\n     * @return disp or null\r\n     */\r\n    public getICUMessageRefDisp(index: number): string {\r\n        let icuMessageRefPart: ParsedMessagePartICUMessageRef = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const refPart: ParsedMessagePartICUMessageRef = <ParsedMessagePartICUMessageRef> part;\r\n                if (refPart.index() === index) {\r\n                    icuMessageRefPart = refPart;\r\n                }\r\n            }\r\n        });\r\n        return icuMessageRefPart ? icuMessageRefPart.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Check for added tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagAdded(): any {\r\n        let e = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            myTags.forEach((tagName) => {\r\n                if (!sourceTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagRemoved(): any {\r\n        let w = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            sourceTags.forEach((tagName) => {\r\n                if (!myTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            w = 'removed tag <' + suspiciousTags[0] + '> from original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            w = 'removed tags ' + allSuspiciousTags + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Get all tag names used in the message.\r\n     */\r\n    private allTags(): Set<string> {\r\n        const result = new Set<string>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {\r\n                const tagName = (<ParsedMessagePartStartTag> part).tagName();\r\n                result.add(tagName);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    public parts(): ParsedMessagePart[] {\r\n        return this._parts;\r\n    }\r\n\r\n    setXmlRepresentation(xmlRepresentation: Element) {\r\n        this._xmlRepresentation = xmlRepresentation;\r\n    }\r\n\r\n    addText(text: string) {\r\n        this._parts.push(new ParsedMessagePartText(text));\r\n    }\r\n\r\n    addPlaceholder(index: number, disp: string) {\r\n        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));\r\n    }\r\n\r\n    addStartTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));\r\n    }\r\n\r\n    addEndTag(tagname: string) {\r\n        // check if well formed\r\n        const openTag = this.calculateOpenTagName();\r\n        if (!openTag || openTag !== tagname) {\r\n            // oops, not well formed\r\n            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                tagname, openTag, this.asNativeString()));\r\n        }\r\n        this._parts.push(new ParsedMessagePartEndTag(tagname));\r\n    }\r\n\r\n    addEmptyTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));\r\n    }\r\n\r\n    addICUMessageRef(index: number, disp) {\r\n        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));\r\n    }\r\n\r\n    addICUMessage(text: string) {\r\n        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));\r\n    }\r\n\r\n    /**\r\n     * Determine, wether there is an open tag, that is not closed.\r\n     * Returns the latest one or null, if there is no open tag.\r\n     */\r\n    private calculateOpenTagName(): string {\r\n        const openTags = [];\r\n        this._parts.forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.START_TAG:\r\n                    openTags.push((<ParsedMessagePartStartTag> part).tagName());\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const tagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {\r\n                        // oops, not well formed\r\n                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];\r\n                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                            tagName, openTag, this.asNativeString()));\r\n                    }\r\n                    openTags.pop();\r\n            }\r\n        });\r\n        return openTags.length === 0 ? null : openTags[openTags.length - 1];\r\n    }\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\nimport {isNullOrUndefined} from 'util';\r\n\r\n/**\r\n * Created by martin on 14.05.2017.\r\n * A tokenizer for normalized messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const START_TAG = 'START_TAG';\r\nexport const END_TAG = 'END_TAG';\r\nexport const EMPTY_TAG = 'EMPTY_TAG';\r\nexport const PLACEHOLDER = 'PLACEHOLDER';\r\nexport const ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';\r\nexport const ICU_MESSAGE = 'ICU_MESSAGE';\r\n\r\nexport interface Token {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\nexport class ParsedMesageTokenizer {\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT && plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n                plaintext = '';\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n            }\r\n         });\r\n        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']\r\n        // format is <name id=\"nr\">, nr ist optional, z.B. <img> oder <img id=\"2\">\r\n        lexer.rule(/<(br|hr|img|area|link|wbr)( id=\"([0-9])*\")?\\>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(EMPTY_TAG, {name: match[1], idcounter: idcount});\r\n        }, EMPTY_TAG);\r\n        // start tag, Format <name id=\"nr\">, nr ist optional, z.B. <mytag> oder <mytag id=\"2\">\r\n        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id=\"([0-9]*)\")?>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(START_TAG, {name: match[1], idcounter: idcount});\r\n        }, START_TAG);\r\n        // end tag\r\n        lexer.rule(/<\\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {\r\n            ctx.accept(END_TAG, {name: match[1]});\r\n        }, END_TAG);\r\n        // placeholder\r\n        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {\r\n            ctx.accept(PLACEHOLDER, {idcounter: parseInt(match[1], 10)});\r\n        }, PLACEHOLDER);\r\n        // icu message ref\r\n        lexer.rule(/<ICU-Message-Ref_([0-9]+)\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE_REF, {idcounter: parseInt(match[1], 10)});\r\n        }, ICU_MESSAGE_REF);\r\n        // icu message\r\n        lexer.rule(/<ICU-Message\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE, {message: match[0]});\r\n        }, ICU_MESSAGE);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\t\\r\\n]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): Token[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.reset();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n}\r\n","import {ParsedMessage} from './parsed-message';\r\nimport {\r\n    EMPTY_TAG,\r\n    END_TAG, ICU_MESSAGE, ICU_MESSAGE_REF, ParsedMesageTokenizer, PLACEHOLDER, START_TAG, TEXT,\r\n    Token\r\n} from './parsed-message-tokenizer';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {DOMParser} from 'xmldom';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser can parse the xml content of a translatable message.\r\n * It generates a ParsedMessage from it.\r\n */\r\nexport abstract class AbstractMessageParser implements IMessageParser {\r\n\r\n    /**\r\n     * Parse XML to ParsedMessage.\r\n     * @param xmlElement the xml representation\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    public createNormalizedMessageFromXML(xmlElement: Element, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        if (xmlElement) {\r\n            message.setXmlRepresentation(xmlElement);\r\n            this.addPartsOfNodeToMessage(xmlElement, message, false);\r\n        }\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse XML string to ParsedMessage.\r\n     * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXMLString(xmlString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const doc: Document = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');\r\n        const xmlElement: Element = <Element> doc.childNodes.item(0);\r\n        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * recursively run through a node and add all identified parts to the message.\r\n     * @param node node\r\n     * @param message message to be generated.\r\n     * @param includeSelf if true, add node by itself, otherwise only children.\r\n     */\r\n    private addPartsOfNodeToMessage(node: Node, message: ParsedMessage, includeSelf: boolean) {\r\n        let processChildren = true;\r\n        if (includeSelf) {\r\n            if (node.nodeType === node.TEXT_NODE) {\r\n                message.addText(node.textContent);\r\n                return;\r\n            }\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                processChildren = this.processStartElement(<Element> node, message);\r\n            }\r\n        }\r\n        if (processChildren) {\r\n            const icuMessageText = this.getICUMessageText(node);\r\n            let isICU = !isNullOrUndefined(icuMessageText);\r\n            if (isICU) {\r\n                try {\r\n                    message.addICUMessage(icuMessageText);\r\n                } catch (error) {\r\n                    // if it is not parsable, handle it as non ICU\r\n                    console.log('non ICU message: ', icuMessageText, error);\r\n                    isICU = false;\r\n                }\r\n            }\r\n            if (!isICU) {\r\n                const children = node.childNodes;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    this.addPartsOfNodeToMessage(children.item(i), message, true);\r\n                }\r\n            }\r\n        }\r\n        if (node.nodeType === node.ELEMENT_NODE) {\r\n            this.processEndElement(<Element> node, message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        const firstChild = children.item(0);\r\n        if (firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                return DOMUtilities.getXMLContent(<Element> node);\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether text is beginning of ICU Message.\r\n     * @param text text\r\n     */\r\n    public isICUMessageStart(text: string): boolean {\r\n        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);\r\n//        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');\r\n    }\r\n\r\n    /**\r\n     * Handle this node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected abstract processStartElement(elementNode: Element, message: ParsedMessage): boolean;\r\n\r\n    /**\r\n     * Handle end of this node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected abstract processEndElement(elementNode: Element, message: ParsedMessage);\r\n\r\n    /**\r\n     * Parse normalized string to ParsedMessage.\r\n     * @param normalizedString normalized string\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if normalized string is not well formed.\r\n     */\r\n    public parseNormalizedString(normalizedString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        const openTags = [];\r\n        let tokens: Token[];\r\n        try {\r\n            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);\r\n        } catch (error) {\r\n            throw new Error(format('unexpected error while parsing message: \"%s\" (parsed \"%\")', error.message, normalizedString));\r\n        }\r\n        tokens.forEach((token: Token) => {\r\n            let disp: string = null;\r\n            switch (token.type) {\r\n                case TEXT:\r\n                    message.addText(token.value.text);\r\n                    break;\r\n                case START_TAG:\r\n                    message.addStartTag(token.value.name, token.value.idcounter);\r\n                    openTags.push(token.value.name);\r\n                    break;\r\n                case END_TAG:\r\n                    message.addEndTag(token.value.name);\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {\r\n                        // oops, not well formed\r\n                        throw new Error(format('unexpected close tag \"%s\" (parsed \"%s\")', token.value.name, normalizedString));\r\n                    }\r\n                    openTags.pop();\r\n                    break;\r\n                case EMPTY_TAG:\r\n                    message.addEmptyTag(token.value.name, token.value.idcounter);\r\n                    break;\r\n                case PLACEHOLDER:\r\n                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;\r\n                    message.addPlaceholder(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE_REF:\r\n                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;\r\n                    message.addICUMessageRef(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE:\r\n                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed \"%\")', normalizedString));\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        if (openTags.length > 0) {\r\n            // oops, not well closed tags\r\n            throw new Error(format('missing close tag \"%s\" (parsed \"%s\")', openTags[openTags.length - 1], normalizedString));\r\n        }\r\n        message.setXmlRepresentation(this.createXmlRepresentation(message));\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse a string, that is an ICU message, to ParsedMessage.\r\n     * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if icuMessageString has not the correct syntax.\r\n     */\r\n    parseICUMessage(icuMessageString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        message.addICUMessage(icuMessageString);\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Helper function: Parse ID from a name.\r\n     * name optionally ends with _<number>. This is the idcount.\r\n     * E.g. name=\"TAG_IMG\" returns 0\r\n     * name = \"TAG_IMG_1\" returns 1\r\n     * @param name name\r\n     * @return id count\r\n     */\r\n    protected parseIdCountFromName(name: string): number {\r\n        const regex = /.*_([0-9]*)/;\r\n        const match = regex.exec(name);\r\n        if (isNullOrUndefined(match) || match[1] === '') {\r\n            return 0;\r\n        } else {\r\n            const num = match[1];\r\n            return parseInt(num, 10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the native xml for a message.\r\n     * Parts are already set here.\r\n     * @param message message\r\n     */\r\n    protected createXmlRepresentation(message: ParsedMessage): Element {\r\n        const root: Document = new DOMParser().parseFromString('<dummy/>', 'text/xml');\r\n        const rootElem: Element = root.getElementsByTagName('dummy').item(0);\r\n        this.addXmlRepresentationToRoot(message, rootElem);\r\n        return rootElem;\r\n    }\r\n\r\n    protected abstract addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element);\r\n\r\n    protected createXmlRepresentationOfTextPart(part: ParsedMessagePartText, rootElem: Element): Node {\r\n        return rootElem.ownerDocument.createTextNode(part.asDisplayString());\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node;\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node;\r\n}\r\n","/**\r\n * Created by roobm on 16.05.2017.\r\n * Mapping from normalized tag names to placeholder names.\r\n */\r\n\r\n/*\r\ncopied from https://github.com/angular/angular/blob/master/packages/compiler/src/i18n/serializers/placeholder.ts\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n\r\n/**\r\n * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.\r\n */\r\nconst VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];\r\n\r\nexport class TagMapping {\r\n\r\n    public getStartTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `START_${baseName}` + this.counterString(id);\r\n    }\r\n\r\n    public getCloseTagPlaceholderName(tag: string): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `CLOSE_${baseName}`;\r\n    }\r\n\r\n    public getEmptyTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName =  TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return baseName + this.counterString(id);\r\n    }\r\n\r\n    public getCtypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n                return 'lb';\r\n            case 'img':\r\n                return 'image';\r\n            default:\r\n                return `x-${tag}`;\r\n        }\r\n    }\r\n\r\n    public getTagnameFromStartTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('START_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('START_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('START_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public getTagnameFromCloseTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('CLOSE_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('CLOSE_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Test, wether placeholder name stands for empty html tag.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public isEmptyTagPlaceholderName(placeholderName: string): boolean {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * tagname of empty tag placeholder.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public getTagnameFromEmptyTagPlaceholderName(placeholderName: string): string {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return matchKey.toLowerCase();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * If placeholder ends with _[0-9]+, strip that number.\r\n     * @param placeholderName placeholderName\r\n     * @return placeholderName without counter at end.\r\n     */\r\n    private stripCounter(placeholderName: string): string {\r\n        if (placeholderName) {\r\n            const re = /(.*)_[0-9]+$/;\r\n            if (placeholderName.match(re)) {\r\n                return placeholderName.replace(re, '$1');\r\n            }\r\n        }\r\n        return placeholderName;\r\n    }\r\n\r\n    /**\r\n     * String suffix for counter.\r\n     * If counter is 0, it is empty, otherwise _<id>.\r\n     * @param id id\r\n     * @return suffix for counter.\r\n     */\r\n    private counterString(id: number) {\r\n        if (id === 0) {\r\n            return '';\r\n        } else {\r\n            return '_' + id.toString(10);\r\n        }\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {isNullOrUndefined} from 'util';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 1.2\r\n */\r\nexport class XliffMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        const tagMapping = new TagMapping();\r\n        if (tagName === 'x') {\r\n            // placeholder are like <x id=\"INTERPOLATION\"/> or <x id=\"INTERPOLATION_1\">\r\n            const id = elementNode.getAttribute('id');\r\n            if (!id) {\r\n                return; // should not happen\r\n            }\r\n            if (id.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromId(id);\r\n                message.addPlaceholder(index, null);\r\n            } else if (id.startsWith('ICU')) {\r\n                const index = this.parseICUMessageRefIndexFromId(id);\r\n                message.addICUMessageRef(index, null);\r\n            } else if (id.startsWith('START_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addStartTag(normalizedTagName, idcount);\r\n                }\r\n            } else if (id.startsWith('CLOSE_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    message.addEndTag(normalizedTagName);\r\n                }\r\n            } else if (tagMapping.isEmptyTagPlaceholderName(id)) {\r\n                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addEmptyTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return index\r\n     */\r\n    private parsePlaceholderIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageRefIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            let child: Node;\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    child = this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    child = this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    child = this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    child = this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    child = this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    child = this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n                    break;\r\n            }\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        const ctypeAttrib = 'x-' + part.tagName();\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '/>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an empty <x/>-Element with attribute id=\"INTERPOLATION\" or id=\"INTERPOLATION_n\"\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        const equivTextAttr = part.disp();\r\n        xElem.setAttribute('id', idAttrib);\r\n        if (equivTextAttr) {\r\n            xElem.setAttribute('equiv-text', equivTextAttr);\r\n        }\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        xElem.setAttribute('id', idAttrib);\r\n        return xElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XliffMessageParser} from './xliff-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XLIFF 1.2 file.\r\n */\r\n\r\nexport class XliffTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XliffMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            return targetElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            targetElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'new';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'new':\r\n                return STATE_NEW;\r\n            case 'needs-translation':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-translation':\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            case 'signed-off':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                const contextElements = elem.getElementsByTagName('context');\r\n                let sourcefile = null;\r\n                let linenumber = 0;\r\n                for (let j = 0; j < contextElements.length; j++) {\r\n                    const contextElem = contextElements.item(j);\r\n                    if (contextElem.getAttribute('context-type') === 'sourcefile') {\r\n                        sourcefile = DOMUtilities.getPCDATA(contextElem);\r\n                    }\r\n                    if (contextElem.getAttribute('context-type') === 'linenumber') {\r\n                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);\r\n                    }\r\n                }\r\n                sourceRefs.push({sourcefile: sourcefile, linenumber: linenumber});\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        sourceRefs.forEach((ref) => {\r\n            const contextGroup = this._element.ownerDocument.createElement('context-group');\r\n            contextGroup.setAttribute('purpose', 'location');\r\n            const contextSource = this._element.ownerDocument.createElement('context');\r\n            contextSource.setAttribute('context-type', 'sourcefile');\r\n            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));\r\n            const contextLine = this._element.ownerDocument.createElement('context');\r\n            contextLine.setAttribute('context-type', 'linenumber');\r\n            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));\r\n            contextGroup.appendChild(contextSource);\r\n            contextGroup.appendChild(contextLine);\r\n            this._element.appendChild(contextGroup);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (description) {\r\n           if (isNullOrUndefined(noteElem)) {\r\n               // create it\r\n               noteElem = this.createNoteElementWithFromAttribute('description', description);\r\n           } else {\r\n               DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n           }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithFromAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('from') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('from');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param fromAttrValue value of \"from\" attribute\r\n     * @param content text value of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithFromAttribute(fromAttrValue: string, content: string): Element {\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (fromAttrValue) {\r\n            noteElement.setAttribute('from', fromAttrValue);\r\n        }\r\n        noteElement.setAttribute('priority', '1');\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        this._element.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithFromAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithFromAttribute(attrValue);\r\n        if (noteElement) {\r\n            this._element.removeChild(noteElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            this._element.removeChild(noteElement);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param  meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('from'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n     }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new XliffTransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        if (isDefaultLang) {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n        } else {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n        }\r\n    }\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF12, FILETYPE_XLIFF12} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {XliffTransUnit} from './xliff-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.02.2017.\r\n * Ab xliff file read from a source file.\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class XliffFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xlf-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XliffFile\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): XliffFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '1.2';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 1.2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 1.2'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XliffTransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('source-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('source-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('target-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('target-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');\r\n        if (!bodyElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 1.2 file (should contain a body element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            bodyElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to body\r\n                bodyElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n         return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XMB\r\n */\r\nexport class XmbMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // There are 4 different usages of ph element:\r\n            // 1. placeholders are like <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>\r\n            // or <ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>\r\n            // 2. start tags:\r\n            // <ph name=\"START_LINK\"><ex>&lt;a&gt;</ex></ph>\r\n            // 3. empty tags:\r\n            // <ph name=\"TAG_IMG\"><ex>&lt;img&gt;</ex></ph>\r\n            // 4. ICU:\r\n            // <ph name=\"ICU\"><ex>ICU</ex></ph>\r\n            const name = elementNode.getAttribute('name');\r\n            if (!name) {\r\n                return true; // should not happen\r\n            }\r\n            if (name.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromName(name);\r\n                message.addPlaceholder(index, null);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('START_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                if (tag) {\r\n                    message.addStartTag(tag, idcounter);\r\n                }\r\n                return false; // ignore children\r\n            } else if (name.startsWith('CLOSE_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                if (tag) {\r\n                    message.addEndTag(tag);\r\n                }\r\n                return false; // ignore children\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(name)) {\r\n                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                message.addEmptyTag(emptyTagName, idcounter);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('ICU')) {\r\n                const index = this.parseICUMessageIndexFromName(name);\r\n                message.addICUMessageRef(index, null);\r\n                return false; // ignore children\r\n            }\r\n        } else if (tagName === 'source') {\r\n            // ignore source\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        let firstChild = null;\r\n        // find first child that is no source element.\r\n        let i;\r\n        for (i = 0; i < children.length; i++) {\r\n            const child = children.item(i);\r\n            if (child.nodeType !== child.ELEMENT_NODE || (<Element> child).tagName !== 'source') {\r\n                firstChild = child;\r\n                break;\r\n            }\r\n        }\r\n        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                const messageText = DOMUtilities.getXMLContent(<Element> node);\r\n                if (i > 0) {\r\n                    // drop <source> elements\r\n                    const reSource: RegExp = new RegExp('<source[^>]*>.*</source>', 'g');\r\n                    return messageText.replace(reSource, '');\r\n                } else {\r\n                    return messageText;\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parsePlaceholderIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as ICU message ref index.\r\n     * id can be \"ICU\" or \"ICU_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse the tag name from a ph element.\r\n     * It contained in the <ex> subelements value and enclosed in <>.\r\n     * Example: <ph name=\"START_BOLD_TEXT\"><ex>&lt;b&gt;</ex></ph>\r\n     * @param phElement phElement\r\n     */\r\n    private parseTagnameFromPhElement(phElement: Element): string {\r\n        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');\r\n        if (exElement) {\r\n            const value = DOMUtilities.getPCDATA(exElement);\r\n            if (!value || !value.startsWith('<') || !value.endsWith('>')) {\r\n                // oops\r\n                return null;\r\n            }\r\n            if (value.charAt(1) === '/') {\r\n                return value.substring(2, value.length - 1);\r\n            } else {\r\n                return value.substring(1, value.length - 1);\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            const child = this.createXmlRepresentationOfPart(part, rootElem);\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected createXmlRepresentationOfPart(part: ParsedMessagePart, rootElem: Element): Node {\r\n        switch (part.type) {\r\n            case ParsedMessagePartType.TEXT:\r\n                return this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n            case ParsedMessagePartType.START_TAG:\r\n                return this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n            case ParsedMessagePartType.END_TAG:\r\n                return this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n            case ParsedMessagePartType.EMPTY_TAG:\r\n                return this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n            case ParsedMessagePartType.PLACEHOLDER:\r\n                return this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n            case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                return this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n}\r\n","import {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XMB file.\r\n */\r\n\r\nexport class XmbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and linenumber\r\n     */\r\n    private static parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private static parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return source content\r\n     */\r\n    public sourceContent(): string {\r\n        let msgContent = DOMUtilities.getXMLContent(this._element);\r\n        const reSourceElem: RegExp = /<source>.*<\\/source>/g;\r\n        msgContent = msgContent.replace(reSourceElem, '');\r\n        return msgContent;\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // not supported\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, null);\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        // in fact, target and source are just the same in xmb\r\n        return this.sourceContent();\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     */\r\n    public nativeTargetState(): string {\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // not supported for xmb\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            const sourceAndPos: string = DOMUtilities.getPCDATA(elem);\r\n            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let insertPosition = this._element.childNodes.item(0);\r\n        for (let i = sourceRefs.length - 1; i >= 0; i--) {\r\n            const ref = sourceRefs[i];\r\n            const source = this._element.ownerDocument.createElement('source');\r\n            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            this._element.insertBefore(source, insertPosition);\r\n            insertPosition = source;\r\n        }\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            toBeRemoved.push(elem);\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xmb this is stored in the attribute \"desc\".\r\n     */\r\n    public description(): string {\r\n        return this._element.getAttribute('desc');\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xmb this is stored in the attribute \"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        return this._element.getAttribute('meaning');\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xmb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * In fact, xmb cannot be translated.\r\n     * So this throws an error.\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        throw new Error('You cannot translate xmb files, use xtb instead.');\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XMB, FILETYPE_XMB, FORMAT_XTB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {XmbTransUnit} from './xmb-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\n\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * xmb-File access.\r\n */\r\n\r\n/**\r\n * Doctype of xtb translation file corresponding with thos xmb file.\r\n */\r\nexport const XTB_DOCTYPE = `<!DOCTYPE translationbundle [\r\n  <!ELEMENT translationbundle (translation)*>\r\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n  <!ELEMENT translation (#PCDATA|ph)*>\r\n  <!ATTLIST translation id CDATA #REQUIRED>\r\n  <!ELEMENT ph EMPTY>\r\n  <!ATTLIST ph name CDATA #REQUIRED>\r\n]>`;\r\n\r\nexport class XmbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XmbFile\r\n     */\r\n    constructor(\r\n        private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n        xmlString: string, path: string, encoding: string) {\r\n\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): XmbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xmb file (should contain a messagebundle element)', path));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XmbTransUnit(msg, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XMB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XMB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XMB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['message'];\r\n    }\r\n\r\n    /**\r\n     * Guess language from filename.\r\n     * If filename is foo.xy.xmb, than language is assumed to be xy.\r\n     * @return Language or null\r\n     */\r\n    private guessLanguageFromFilename(): string {\r\n        if (this._filename) {\r\n            const parts: string[] = this._filename.split('.');\r\n            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {\r\n                return parts[parts.length - 2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        throw Error('xmb file cannot be used to store translations, use xtb file');\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationbundleXMLSource =\r\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + XTB_DOCTYPE + '\\n<translationbundle>\\n</translationbundle>\\n';\r\n        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n            FORMAT_XTB,\r\n            translationbundleXMLSource, filename, this.encoding(),\r\n            {xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding()});\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());\r\n        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());\r\n        this.forEachTransUnit((tu) => {\r\n            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nexport class Xliff2MessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            } else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            } else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            } else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        } else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    private tagNameFromPCElement(pcNode: Element): string {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        const stack = [{element: rootElem, tagName: 'root'}];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfPlaceholderPart(<ParsedMessagePartPlaceholder> part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfICUMessageRefPart(<ParsedMessagePartICUMessageRef> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(<ParsedMessagePartStartTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({element: <Element> newTagElem, tagName: (<ParsedMessagePartStartTag> part).tagName()});\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(<ParsedMessagePartEmptyTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        // not used\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n\r\n    private getTypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id: number): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {Xliff2MessageParser} from './xliff2-message-parser';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\n\r\nexport class Xliff2TransUnit extends AbstractTransUnit  implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new Xliff2MessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos: string = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    private parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithCategoryAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithCategoryAttribute(attrValue: string, content: string): Element {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    private removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithCategoryAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            } else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF20, FILETYPE_XLIFF20} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {Xliff2TransUnit} from './xliff2-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * An XLIFF 2.0 file read from a source file.\r\n * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\n *\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class Xliff2File extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an XLIFF 2.0-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return xliff file\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): Xliff2File {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '2.0';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 2.0'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('srcLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('srcLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('trgLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('trgLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (!fileElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 2.0 file (should contain a file element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            fileElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to first file element\r\n                fileElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {isNullOrUndefined} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\n\r\nexport class XtbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceTransUnitFromMaster: AbstractTransUnit;\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile,\r\n                _sourceTransUnitFromMaster: AbstractTransUnit) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    public sourceContent(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    public nativeTargetState(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            } else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public description(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public meaning(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XTB, FILETYPE_XTB, FORMAT_XMB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {XtbTransUnit} from './xtb-trans-unit';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * xtb-File access.\r\n * xtb is the translated counterpart to xmb.\r\n */\r\n\r\nexport class XtbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    // attached master file, if any\r\n    // used as source to determine state ...\r\n    private _masterFile: ITranslationMessagesFile; // an xmb-file\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * @return XmbFile\r\n     */\r\n    constructor(private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n                xmlString: string, path: string, encoding: string,\r\n                optionalMaster?: { xmlContent: string, path: string, encoding: string }) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string,\r\n                                  optionalMaster?: { xmlContent: string, path: string, encoding: string }): XtbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', path));\r\n        }\r\n        if (optionalMaster) {\r\n            try {\r\n                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n                    FORMAT_XMB,\r\n                    optionalMaster.xmlContent,\r\n                    optionalMaster.path,\r\n                    optionalMaster.encoding);\r\n                // check, wether this can be the master ...\r\n                const numberInMaster = this._masterFile.numberOfTransUnits();\r\n                const myNumber = this.numberOfTransUnits();\r\n                if (numberInMaster !== myNumber) {\r\n                    this._warnings.push(format(\r\n                        '%s trans units found in master, but this file has %s. Check if it is the correct master',\r\n                        numberInMaster, myNumber));\r\n                }\r\n            } catch (error) {\r\n                throw new Error(format('File \"%s\" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            let masterUnit: ITransUnit = null;\r\n            if (this._masterFile) {\r\n                masterUnit = this._masterFile.transUnitWithId(id);\r\n            }\r\n            this.transUnits.push(new XtbTransUnit(msg, id, this, <AbstractTransUnit> masterUnit));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XTB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XTB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XTB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['translation'];\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb/xtb.\r\n     * Try to guess it from master filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        if (this._masterFile) {\r\n            return this._masterFile.sourceLanguage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb/xtb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xtb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            return translationbundleElem.getAttribute('lang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            translationbundleElem.setAttribute('lang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newMasterTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (!translationbundleElem) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', this._filename));\r\n        }\r\n        const translationElement = translationbundleElem.ownerDocument.createElement('translation');\r\n        translationElement.setAttribute('id', foreignTransUnit.id);\r\n        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';\r\n        if (!(<AbstractTransUnit> foreignTransUnit).isICUMessage(newContent)) {\r\n            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);\r\n        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            translationbundleElem.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');\r\n            if (firstTranslationElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to bundle at end\r\n                translationbundleElem.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        throw new Error(format('File \"%s\", xtb files are not translatable, they are already translations', filename));\r\n    }\r\n}\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile} from './i-translation-messages-file';\r\nimport {XliffFile} from '../impl/xliff-file';\r\nimport {XmbFile} from '../impl/xmb-file';\r\nimport {format} from 'util';\r\nimport {Xliff2File} from '../impl/xliff2-file';\r\nimport {FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB} from './constants';\r\nimport {XtbFile} from '../impl/xtb-file';\r\nimport {ITranslationMessagesFileFactory} from './i-translation-messages-file-factory';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nexport class TranslationMessagesFileFactory implements ITranslationMessagesFileFactory {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromFileContent(i18nFormat: string,\r\n                                  xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromUnknownFormatFileContent(xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat: string,\r\n                              xmlContent: string,\r\n                              path: string,\r\n                              encoding: string,\r\n                              optionalMaster?: { xmlContent: string, path: string, encoding: string }): ITranslationMessagesFile {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent: string,\r\n                                           path: string,\r\n                                           encoding: string,\r\n                                           optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : ITranslationMessagesFile {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(\r\n                    formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            } catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n\r\n}\r\n\r\n"]}