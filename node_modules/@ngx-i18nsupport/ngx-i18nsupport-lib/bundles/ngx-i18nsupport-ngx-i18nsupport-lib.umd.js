(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('xmldom'), require('util'), require('tokenizr')) :
    typeof define === 'function' && define.amd ? define('@ngx-i18nsupport/ngx-i18nsupport-lib', ['exports', '@angular/core', 'xmldom', 'util', 'tokenizr'], factory) :
    (factory((global['ngx-i18nsupport'] = global['ngx-i18nsupport'] || {}, global['ngx-i18nsupport']['ngx-i18nsupport-lib'] = {}),global.ng.core,global.xmldom,global.util,global.tokenizr));
}(this, (function (exports,core,xmldom,util,Tokenizr) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NgxI18nsupportLibModule = /** @class */ (function () {
        function NgxI18nsupportLibModule() {
        }
        NgxI18nsupportLibModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        declarations: [],
                        exports: []
                    },] }
        ];
        return NgxI18nsupportLibModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * supported file formats
      @type {?} */
    var FORMAT_XLIFF12 = 'xlf';
    /** @type {?} */
    var FORMAT_XLIFF20 = 'xlf2';
    /** @type {?} */
    var FORMAT_XMB = 'xmb';
    /** @type {?} */
    var FORMAT_XTB = 'xtb';
    /** *
     * File types
     * (returned by fileType() method)
      @type {?} */
    var FILETYPE_XLIFF12 = 'XLIFF 1.2';
    /** @type {?} */
    var FILETYPE_XLIFF20 = 'XLIFF 2.0';
    /** @type {?} */
    var FILETYPE_XMB = 'XMB';
    /** @type {?} */
    var FILETYPE_XTB = 'XTB';
    /** *
     * State NEW.
     * Signals an untranslated unit.
      @type {?} */
    var STATE_NEW = 'new';
    /** *
     * State TRANSLATED.
     * Signals a translated unit, that is not reviewed until now.
      @type {?} */
    var STATE_TRANSLATED = 'translated';
    /** *
     * State FINAL.
     * Signals a translated unit, that is reviewed and ready for use.
      @type {?} */
    var STATE_FINAL = 'final';
    /** *
     * Default format, contains placeholders, html markup.
      @type {?} */
    var NORMALIZATION_FORMAT_DEFAULT = 'default';
    /** *
     * Format for usage in ngxtranslate messages.
     * Placeholder are in the form {{n}}, no html markup.
      @type {?} */
    var NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 01.05.2017.
     * Some Tool functions for XML Handling.
     */
    var /**
     * Created by martin on 01.05.2017.
     * Some Tool functions for XML Handling.
     */ DOMUtilities = /** @class */ (function () {
        function DOMUtilities() {
        }
        /**
         * return the first subelement with the given tag.
         * @param {?} element element
         * @param {?} tagName tagName
         * @return {?} subelement or null, if not existing.
         */
        DOMUtilities.getFirstElementByTagName = /**
         * return the first subelement with the given tag.
         * @param {?} element element
         * @param {?} tagName tagName
         * @return {?} subelement or null, if not existing.
         */
            function (element, tagName) {
                /** @type {?} */
                var matchingElements = element.getElementsByTagName(tagName);
                if (matchingElements && matchingElements.length > 0) {
                    return matchingElements.item(0);
                }
                else {
                    return null;
                }
            };
        /**
         * return an element with the given tag and id attribute.
         * @param {?} element element
         * @param {?} tagName tagName
         * @param {?} id id
         * @return {?} subelement or null, if not existing.
         */
        DOMUtilities.getElementByTagNameAndId = /**
         * return an element with the given tag and id attribute.
         * @param {?} element element
         * @param {?} tagName tagName
         * @param {?} id id
         * @return {?} subelement or null, if not existing.
         */
            function (element, tagName, id) {
                /** @type {?} */
                var matchingElements = element.getElementsByTagName(tagName);
                if (matchingElements && matchingElements.length > 0) {
                    for (var i = 0; i < matchingElements.length; i++) {
                        /** @type {?} */
                        var node = matchingElements.item(i);
                        if (node.getAttribute('id') === id) {
                            return node;
                        }
                    }
                }
                return null;
            };
        /**
         * Get next sibling, that is an element.
         * @param {?} element element
         * @return {?}
         */
        DOMUtilities.getElementFollowingSibling = /**
         * Get next sibling, that is an element.
         * @param {?} element element
         * @return {?}
         */
            function (element) {
                if (!element) {
                    return null;
                }
                /** @type {?} */
                var e = element.nextSibling;
                while (e) {
                    if (e.nodeType === e.ELEMENT_NODE) {
                        return /** @type {?} */ (e);
                    }
                    e = e.nextSibling;
                }
                return null;
            };
        /**
         * Get previous sibling, that is an element.
         * @param {?} element element
         * @return {?}
         */
        DOMUtilities.getElementPrecedingSibling = /**
         * Get previous sibling, that is an element.
         * @param {?} element element
         * @return {?}
         */
            function (element) {
                if (!element) {
                    return null;
                }
                /** @type {?} */
                var e = element.previousSibling;
                while (e) {
                    if (e.nodeType === e.ELEMENT_NODE) {
                        return /** @type {?} */ (e);
                    }
                    e = e.previousSibling;
                }
                return null;
            };
        /**
         * return content of element as string, including all markup.
         * @param {?} element element
         * @return {?} content of element as string, including all markup.
         */
        DOMUtilities.getXMLContent = /**
         * return content of element as string, including all markup.
         * @param {?} element element
         * @return {?} content of element as string, including all markup.
         */
            function (element) {
                if (!element) {
                    return null;
                }
                /** @type {?} */
                var result = new xmldom.XMLSerializer().serializeToString(element);
                /** @type {?} */
                var tagName = element.nodeName;
                /** @type {?} */
                var reStartMsg = new RegExp('<' + tagName + '[^>]*>', 'g');
                result = result.replace(reStartMsg, '');
                /** @type {?} */
                var reEndMsg = new RegExp('</' + tagName + '>', 'g');
                result = result.replace(reEndMsg, '');
                return result;
            };
        /**
         * return PCDATA content of element.
         * @param {?} element element
         * @return {?} PCDATA content of element.
         */
        DOMUtilities.getPCDATA = /**
         * return PCDATA content of element.
         * @param {?} element element
         * @return {?} PCDATA content of element.
         */
            function (element) {
                if (!element) {
                    return null;
                }
                /** @type {?} */
                var result = '';
                /** @type {?} */
                var childNodes = element.childNodes;
                for (var i = 0; i < childNodes.length; i++) {
                    /** @type {?} */
                    var child = childNodes.item(i);
                    if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {
                        result = result + child.nodeValue;
                    }
                }
                return result.length === 0 ? null : result;
            };
        /**
         * replace PCDATA content with a new one.
         * @param {?} element element
         * @param {?} pcdata pcdata
         * @return {?}
         */
        DOMUtilities.replaceContentWithXMLContent = /**
         * replace PCDATA content with a new one.
         * @param {?} element element
         * @param {?} pcdata pcdata
         * @return {?}
         */
            function (element, pcdata) {
                // remove all children
                while (element.firstChild) {
                    element.removeChild(element.firstChild);
                }
                /** @type {?} */
                var pcdataFragment = new xmldom.DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');
                /** @type {?} */
                var newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;
                for (var j = 0; j < newChildren.length; j++) {
                    /** @type {?} */
                    var newChild = newChildren.item(j);
                    element.appendChild(element.ownerDocument.importNode(newChild, true));
                }
            };
        /**
         * find the previous sibling that is an element.
         * @param {?} element element
         * @return {?} the previous sibling that is an element or null.
         */
        DOMUtilities.getPreviousElementSibling = /**
         * find the previous sibling that is an element.
         * @param {?} element element
         * @return {?} the previous sibling that is an element or null.
         */
            function (element) {
                /** @type {?} */
                var node = element.previousSibling;
                while (node !== null) {
                    if (node.nodeType === node.ELEMENT_NODE) {
                        return /** @type {?} */ (node);
                    }
                    node = node.previousSibling;
                }
                return null;
            };
        /**
         * Create an Element Node that is the next sibling of a given node.
         * @param {?} elementNameToCreate elementNameToCreate
         * @param {?} previousSibling previousSibling
         * @return {?} new element
         */
        DOMUtilities.createFollowingSibling = /**
         * Create an Element Node that is the next sibling of a given node.
         * @param {?} elementNameToCreate elementNameToCreate
         * @param {?} previousSibling previousSibling
         * @return {?} new element
         */
            function (elementNameToCreate, previousSibling) {
                /** @type {?} */
                var newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);
                return /** @type {?} */ (DOMUtilities.insertAfter(newElement, previousSibling));
            };
        /**
         * Insert newElement directly after previousSibling.
         * @param {?} newElement newElement
         * @param {?} previousSibling previousSibling
         * @return {?}
         */
        DOMUtilities.insertAfter = /**
         * Insert newElement directly after previousSibling.
         * @param {?} newElement newElement
         * @param {?} previousSibling previousSibling
         * @return {?}
         */
            function (newElement, previousSibling) {
                if (previousSibling.nextSibling !== null) {
                    previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);
                }
                else {
                    previousSibling.parentNode.appendChild(newElement);
                }
                return newElement;
            };
        /**
         * Insert newElement directly before nextSibling.
         * @param {?} newElement newElement
         * @param {?} nextSibling nextSibling
         * @return {?}
         */
        DOMUtilities.insertBefore = /**
         * Insert newElement directly before nextSibling.
         * @param {?} newElement newElement
         * @param {?} nextSibling nextSibling
         * @return {?}
         */
            function (newElement, nextSibling) {
                nextSibling.parentNode.insertBefore(newElement, nextSibling);
                return newElement;
            };
        return DOMUtilities;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_INDENT_STRING = '  ';
    var XmlSerializer = /** @class */ (function () {
        function XmlSerializer() {
        }
        /**
         * Serialze xml document to string.
         * @param document the document
         * @param options can be used to activate beautifying.
         */
        /**
         * Serialze xml document to string.
         * @param {?} document the document
         * @param {?=} options can be used to activate beautifying.
         * @return {?}
         */
        XmlSerializer.prototype.serializeToString = /**
         * Serialze xml document to string.
         * @param {?} document the document
         * @param {?=} options can be used to activate beautifying.
         * @return {?}
         */
            function (document, options) {
                /** @type {?} */
                var buf = [];
                /** @type {?} */
                var visibleNamespaces = [];
                /** @type {?} */
                var refNode = document.documentElement;
                /** @type {?} */
                var prefix = refNode.prefix;
                /** @type {?} */
                var uri = refNode.namespaceURI;
                if (uri && prefix == null) {
                    prefix = refNode.lookupPrefix(uri);
                    if (prefix == null) {
                        visibleNamespaces = [
                            { namespace: uri, prefix: null }
                        ];
                    }
                }
                if (!options) {
                    options = {};
                }
                if (options.indentString) {
                    if (!this.containsOnlyWhiteSpace(options.indentString)) {
                        throw new Error('indentString must not contain non white characters');
                    }
                }
                this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);
                return buf.join('');
            };
        /**
         * Main format method that does all the work.
         * Outputs a node to the outputbuffer.
         * @param {?} node the node to be formatted.
         * @param {?} options options
         * @param {?} buf outputbuffer, new output will be appended to this array.
         * @param {?} indentLevel Lever of indentation for formatted output.
         * @param {?} partOfMixedContent true, if node is a subelement of an element containind mixed content.
         * @param {?} visibleNamespaces visibleNamespaces
         * @return {?}
         */
        XmlSerializer.prototype.doSerializeToString = /**
         * Main format method that does all the work.
         * Outputs a node to the outputbuffer.
         * @param {?} node the node to be formatted.
         * @param {?} options options
         * @param {?} buf outputbuffer, new output will be appended to this array.
         * @param {?} indentLevel Lever of indentation for formatted output.
         * @param {?} partOfMixedContent true, if node is a subelement of an element containind mixed content.
         * @param {?} visibleNamespaces visibleNamespaces
         * @return {?}
         */
            function (node, options, buf, indentLevel, partOfMixedContent, visibleNamespaces) {
                /** @type {?} */
                var child;
                switch (node.nodeType) {
                    case node.ELEMENT_NODE:
                        /** @type {?} */
                        var elementNode = /** @type {?} */ (node);
                        /** @type {?} */
                        var attrs = elementNode.attributes;
                        /** @type {?} */
                        var len = attrs.length;
                        child = elementNode.firstChild;
                        /** @type {?} */
                        var nodeName = elementNode.tagName;
                        /** @type {?} */
                        var elementHasMixedContent = this.isMixedContentElement(nodeName, options);
                        if (partOfMixedContent) {
                            buf.push('<', nodeName);
                        }
                        else {
                            this.outputIndented(options, buf, indentLevel, '<', nodeName);
                        }
                        for (var i = 0; i < len; i++) {
                            /** @type {?} */
                            var attr = attrs.item(i);
                            if (attr.prefix === 'xmlns') {
                                visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
                            }
                            else if (attr.nodeName === 'xmlns') {
                                visibleNamespaces.push({ prefix: '', namespace: attr.value });
                            }
                        }
                        for (var i = 0; i < len; i++) {
                            /** @type {?} */
                            var attr = attrs.item(i);
                            if (this.needNamespaceDefine(attr, visibleNamespaces)) {
                                /** @type {?} */
                                var prefix = attr.prefix || '';
                                /** @type {?} */
                                var uri = attr.namespaceURI;
                                /** @type {?} */
                                var ns = prefix ? ' xmlns:' + prefix : ' xmlns';
                                buf.push(ns, '="', uri, '"');
                                visibleNamespaces.push({ prefix: prefix, namespace: uri });
                            }
                            this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);
                        }
                        // add namespace for current node
                        if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {
                            /** @type {?} */
                            var prefix = elementNode.prefix || '';
                            /** @type {?} */
                            var uri = node.namespaceURI;
                            /** @type {?} */
                            var ns = prefix ? ' xmlns:' + prefix : ' xmlns';
                            buf.push(ns, '="', uri, '"');
                            visibleNamespaces.push({ prefix: prefix, namespace: uri });
                        }
                        if (child) {
                            buf.push('>');
                            /** @type {?} */
                            var hasComplexContent = false;
                            while (child) {
                                if (child.nodeType === child.ELEMENT_NODE) {
                                    hasComplexContent = true;
                                }
                                this.doSerializeToString(child, options, buf, indentLevel + 1, partOfMixedContent || elementHasMixedContent, visibleNamespaces);
                                child = child.nextSibling;
                            }
                            if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {
                                this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');
                            }
                            else {
                                buf.push('</', nodeName, '>');
                            }
                        }
                        else {
                            buf.push('/>');
                        }
                        return;
                    case node.DOCUMENT_NODE:
                    case node.DOCUMENT_FRAGMENT_NODE:
                        child = node.firstChild;
                        while (child) {
                            this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);
                            child = child.nextSibling;
                        }
                        return;
                    case node.ATTRIBUTE_NODE:
                        /** @type {?} */
                        var attrNode = /** @type {?} */ (node);
                        return buf.push(' ', attrNode.name, '="', attrNode.value.replace(/[<&"]/g, this._xmlEncoder), '"');
                    case node.TEXT_NODE:
                        /** @type {?} */
                        var textNode = /** @type {?} */ (node);
                        if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {
                            return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));
                        }
                        return;
                    case node.CDATA_SECTION_NODE:
                        /** @type {?} */
                        var cdatasectionNode = /** @type {?} */ (node);
                        return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');
                    case node.COMMENT_NODE:
                        /** @type {?} */
                        var commentNode = /** @type {?} */ (node);
                        return buf.push('<!--', commentNode.data, '-->');
                    case node.DOCUMENT_TYPE_NODE:
                        /** @type {?} */
                        var documenttypeNode = /** @type {?} */ (node);
                        /** @type {?} */
                        var pubid = documenttypeNode.publicId;
                        /** @type {?} */
                        var sysid = documenttypeNode.systemId;
                        buf.push('<!DOCTYPE ', documenttypeNode.name);
                        if (pubid) {
                            buf.push(' PUBLIC "', pubid);
                            if (sysid && sysid !== '.') {
                                buf.push('" "', sysid);
                            }
                            buf.push('">');
                        }
                        else if (sysid && sysid !== '.') {
                            buf.push(' SYSTEM "', sysid, '">');
                        }
                        else {
                            /** @type {?} */
                            var sub = documenttypeNode.internalSubset;
                            if (sub) {
                                buf.push(' [', sub, ']');
                            }
                            buf.push('>');
                        }
                        return;
                    case node.PROCESSING_INSTRUCTION_NODE:
                        /** @type {?} */
                        var piNode = /** @type {?} */ (node);
                        return buf.push('<?', piNode.target, ' ', piNode.data, '?>');
                    case node.ENTITY_REFERENCE_NODE:
                        return buf.push('&', node.nodeName, ';');
                    // case ENTITY_NODE:
                    // case NOTATION_NODE:
                    default:
                        buf.push('??', node.nodeName);
                }
            };
        /**
         * @param {?} node
         * @param {?} visibleNamespaces
         * @return {?}
         */
        XmlSerializer.prototype.needNamespaceDefine = /**
         * @param {?} node
         * @param {?} visibleNamespaces
         * @return {?}
         */
            function (node, visibleNamespaces) {
                /** @type {?} */
                var prefix = node.prefix || '';
                /** @type {?} */
                var uri = node.namespaceURI;
                if (!prefix && !uri) {
                    return false;
                }
                if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'
                    || uri === 'http://www.w3.org/2000/xmlns/') {
                    return false;
                }
                /** @type {?} */
                var i = visibleNamespaces.length;
                while (i--) {
                    /** @type {?} */
                    var ns = visibleNamespaces[i];
                    // get namespace prefix
                    if (ns.prefix === prefix) {
                        return ns.namespace !== uri;
                    }
                }
                return true;
            };
        /**
         * @param {?} c
         * @return {?}
         */
        XmlSerializer.prototype._xmlEncoder = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return c === '<' && '&lt;' ||
                    c === '>' && '&gt;' ||
                    c === '&' && '&amp;' ||
                    c === '"' && '&quot;' ||
                    '&#' + c.charCodeAt(0) + ';';
            };
        /**
         * @param {?} options
         * @param {?} buf
         * @param {?} indentLevel
         * @param {...?} outputParts
         * @return {?}
         */
        XmlSerializer.prototype.outputIndented = /**
         * @param {?} options
         * @param {?} buf
         * @param {?} indentLevel
         * @param {...?} outputParts
         * @return {?}
         */
            function (options, buf, indentLevel) {
                var outputParts = [];
                for (var _i = 3; _i < arguments.length; _i++) {
                    outputParts[_i - 3] = arguments[_i];
                }
                if (options.beautify) {
                    buf.push('\n');
                    if (indentLevel > 0) {
                        buf.push(this.indentationString(options, indentLevel));
                    }
                }
                buf.push.apply(buf, __spread(outputParts));
            };
        /**
         * @param {?} options
         * @param {?} indentLevel
         * @return {?}
         */
        XmlSerializer.prototype.indentationString = /**
         * @param {?} options
         * @param {?} indentLevel
         * @return {?}
         */
            function (options, indentLevel) {
                /** @type {?} */
                var indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;
                /** @type {?} */
                var result = '';
                for (var i = 0; i < indentLevel; i++) {
                    result = result + indent;
                }
                return result;
            };
        /**
         * Test, wether tagName is an element containing mixed content.
         * @param {?} tagName tagName
         * @param {?} options options
         * @return {?}
         */
        XmlSerializer.prototype.isMixedContentElement = /**
         * Test, wether tagName is an element containing mixed content.
         * @param {?} tagName tagName
         * @param {?} options options
         * @return {?}
         */
            function (tagName, options) {
                if (options && options.mixedContentElements) {
                    return !!options.mixedContentElements.find(function (tag) { return tag === tagName; });
                }
                else {
                    return false;
                }
            };
        /**
         * @param {?} text
         * @return {?}
         */
        XmlSerializer.prototype.containsOnlyWhiteSpace = /**
         * @param {?} text
         * @return {?}
         */
            function (text) {
                for (var i = 0; i < text.length; i++) {
                    /** @type {?} */
                    var c = text.charAt(i);
                    if (!(c === ' ' || c === '\t' || c === '\r' || c === '\n')) {
                        return false;
                    }
                }
                return true;
            };
        return XmlSerializer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by roobm on 09.05.2017.
     * Abstract superclass for all implementations of ITranslationMessagesFile.
     * @abstract
     */
    var /**
     * Created by roobm on 09.05.2017.
     * Abstract superclass for all implementations of ITranslationMessagesFile.
     * @abstract
     */ AbstractTranslationMessagesFile = /** @class */ (function () {
        function AbstractTranslationMessagesFile() {
            this.transUnits = null;
            this._warnings = [];
        }
        /**
         * Parse file content.
         * Sets _parsedDocument, line ending, encoding, etc.
         * @param xmlString xmlString
         * @param path path
         * @param encoding encoding
         * @param optionalMaster optionalMaster
         */
        /**
         * Parse file content.
         * Sets _parsedDocument, line ending, encoding, etc.
         * @param {?} xmlString xmlString
         * @param {?} path path
         * @param {?} encoding encoding
         * @param {?=} optionalMaster optionalMaster
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.parseContent = /**
         * Parse file content.
         * Sets _parsedDocument, line ending, encoding, etc.
         * @param {?} xmlString xmlString
         * @param {?} path path
         * @param {?} encoding encoding
         * @param {?=} optionalMaster optionalMaster
         * @return {?}
         */
            function (xmlString, path, encoding, optionalMaster) {
                this._filename = path;
                this._encoding = encoding;
                this._parsedDocument = new xmldom.DOMParser().parseFromString(xmlString, 'text/xml');
                this._fileEndsWithEOL = xmlString.endsWith('\n');
            };
        /**
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.lazyInitializeTransUnits = /**
         * @return {?}
         */
            function () {
                if (util.isNullOrUndefined(this.transUnits)) {
                    this.initializeTransUnits();
                    this.countNumbers();
                }
            };
        /**
         * count units after changes of trans units
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.countNumbers = /**
         * count units after changes of trans units
         * @return {?}
         */
            function () {
                var _this = this;
                this._numberOfTransUnitsWithMissingId = 0;
                this._numberOfUntranslatedTransUnits = 0;
                this._numberOfReviewedTransUnits = 0;
                this.forEachTransUnit(function (tu) {
                    if (util.isNullOrUndefined(tu.id) || tu.id === '') {
                        _this._numberOfTransUnitsWithMissingId++;
                    }
                    /** @type {?} */
                    var state = tu.targetState();
                    if (util.isNullOrUndefined(state) || state === STATE_NEW) {
                        _this._numberOfUntranslatedTransUnits++;
                    }
                    if (state === STATE_TRANSLATED) {
                        _this._numberOfReviewedTransUnits++;
                    }
                });
            };
        /**
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.warnings = /**
         * @return {?}
         */
            function () {
                this.lazyInitializeTransUnits();
                return this._warnings;
            };
        /**
         * Total number of translation units found in the file.
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.numberOfTransUnits = /**
         * Total number of translation units found in the file.
         * @return {?}
         */
            function () {
                this.lazyInitializeTransUnits();
                return this.transUnits.length;
            };
        /**
         * Number of translation units without translation found in the file.
         * These units have state 'translated'.
         */
        /**
         * Number of translation units without translation found in the file.
         * These units have state 'translated'.
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.numberOfUntranslatedTransUnits = /**
         * Number of translation units without translation found in the file.
         * These units have state 'translated'.
         * @return {?}
         */
            function () {
                this.lazyInitializeTransUnits();
                return this._numberOfUntranslatedTransUnits;
            };
        /**
         * Number of translation units with state 'final'.
         */
        /**
         * Number of translation units with state 'final'.
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.numberOfReviewedTransUnits = /**
         * Number of translation units with state 'final'.
         * @return {?}
         */
            function () {
                this.lazyInitializeTransUnits();
                return this._numberOfReviewedTransUnits;
            };
        /**
         * Number of translation units without translation found in the file.
         * These units have state 'translated'.
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.numberOfTransUnitsWithMissingId = /**
         * Number of translation units without translation found in the file.
         * These units have state 'translated'.
         * @return {?}
         */
            function () {
                this.lazyInitializeTransUnits();
                return this._numberOfTransUnitsWithMissingId;
            };
        /**
         * Loop over all Translation Units.
         * @param {?} callback callback
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.forEachTransUnit = /**
         * Loop over all Translation Units.
         * @param {?} callback callback
         * @return {?}
         */
            function (callback) {
                this.lazyInitializeTransUnits();
                this.transUnits.forEach(function (tu) { return callback(tu); });
            };
        /**
         * Get trans-unit with given id.
         * @param {?} id id
         * @return {?} trans-unit with given id.
         */
        AbstractTranslationMessagesFile.prototype.transUnitWithId = /**
         * Get trans-unit with given id.
         * @param {?} id id
         * @return {?} trans-unit with given id.
         */
            function (id) {
                this.lazyInitializeTransUnits();
                return this.transUnits.find(function (tu) { return tu.id === id; });
            };
        /**
         * Set the praefix used when copying source to target.
         * This is used by importNewTransUnit and createTranslationFileForLang methods.
         * (since 1.8.0)
         * @param {?} targetPraefix targetPraefix
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.setNewTransUnitTargetPraefix = /**
         * Set the praefix used when copying source to target.
         * This is used by importNewTransUnit and createTranslationFileForLang methods.
         * (since 1.8.0)
         * @param {?} targetPraefix targetPraefix
         * @return {?}
         */
            function (targetPraefix) {
                this.targetPraefix = targetPraefix;
            };
        /**
         * Get the praefix used when copying source to target.
         * (since 1.8.0)
         * @return the praefix used when copying source to target.
         */
        /**
         * Get the praefix used when copying source to target.
         * (since 1.8.0)
         * @return {?} the praefix used when copying source to target.
         */
        AbstractTranslationMessagesFile.prototype.getNewTransUnitTargetPraefix = /**
         * Get the praefix used when copying source to target.
         * (since 1.8.0)
         * @return {?} the praefix used when copying source to target.
         */
            function () {
                return util.isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;
            };
        /**
         * Set the suffix used when copying source to target.
         * This is used by importNewTransUnit and createTranslationFileForLang methods.
         * (since 1.8.0)
         * @param {?} targetSuffix targetSuffix
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.setNewTransUnitTargetSuffix = /**
         * Set the suffix used when copying source to target.
         * This is used by importNewTransUnit and createTranslationFileForLang methods.
         * (since 1.8.0)
         * @param {?} targetSuffix targetSuffix
         * @return {?}
         */
            function (targetSuffix) {
                this.targetSuffix = targetSuffix;
            };
        /**
         * Get the suffix used when copying source to target.
         * (since 1.8.0)
         * @return the suffix used when copying source to target.
         */
        /**
         * Get the suffix used when copying source to target.
         * (since 1.8.0)
         * @return {?} the suffix used when copying source to target.
         */
        AbstractTranslationMessagesFile.prototype.getNewTransUnitTargetSuffix = /**
         * Get the suffix used when copying source to target.
         * (since 1.8.0)
         * @return {?} the suffix used when copying source to target.
         */
            function () {
                return util.isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;
            };
        /**
         * Remove the trans-unit with the given id.
         * @param {?} id id
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.removeTransUnitWithId = /**
         * Remove the trans-unit with the given id.
         * @param {?} id id
         * @return {?}
         */
            function (id) {
                /** @type {?} */
                var tuNode = this._parsedDocument.getElementById(id);
                if (tuNode) {
                    tuNode.parentNode.removeChild(tuNode);
                    this.lazyInitializeTransUnits();
                    this.transUnits = this.transUnits.filter(function (tu) { return tu.id !== id; });
                    this.countNumbers();
                }
            };
        /**
         * The filename where the data is read from.
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.filename = /**
         * The filename where the data is read from.
         * @return {?}
         */
            function () {
                return this._filename;
            };
        /**
         * The encoding if the xml content (UTF-8, ISO-8859-1, ...)
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.encoding = /**
         * The encoding if the xml content (UTF-8, ISO-8859-1, ...)
         * @return {?}
         */
            function () {
                return this._encoding;
            };
        /**
         * The xml content to be saved after changes are made.
         * @param {?=} beautifyOutput Flag whether to use pretty-data to format the output.
         * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
         * See issue #64 for details.
         * Default is false.
         * @return {?}
         */
        AbstractTranslationMessagesFile.prototype.editedContent = /**
         * The xml content to be saved after changes are made.
         * @param {?=} beautifyOutput Flag whether to use pretty-data to format the output.
         * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
         * See issue #64 for details.
         * Default is false.
         * @return {?}
         */
            function (beautifyOutput) {
                /** @type {?} */
                var options = {};
                if (beautifyOutput === true) {
                    options.beautify = true;
                    options.indentString = '  ';
                    options.mixedContentElements = this.elementsWithMixedContent();
                }
                /** @type {?} */
                var result = new XmlSerializer().serializeToString(this._parsedDocument, options);
                if (this._fileEndsWithEOL) {
                    // add eol if there was eol in original source
                    return result + '\n';
                }
                else {
                    return result;
                }
            };
        return AbstractTranslationMessagesFile;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by roobm on 10.05.2017.
     * Abstract superclass for all implementations of ITransUnit.
     * @abstract
     */
    var /**
     * Created by roobm on 10.05.2017.
     * Abstract superclass for all implementations of ITransUnit.
     * @abstract
     */ AbstractTransUnit = /** @class */ (function () {
        function AbstractTransUnit(_element, _id, _translationMessagesFile) {
            this._element = _element;
            this._id = _id;
            this._translationMessagesFile = _translationMessagesFile;
        }
        Object.defineProperty(AbstractTransUnit.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * The file the unit belongs to.,
         */
        /**
         * The file the unit belongs to.,
         * @return {?}
         */
        AbstractTransUnit.prototype.translationMessagesFile = /**
         * The file the unit belongs to.,
         * @return {?}
         */
            function () {
                return this._translationMessagesFile;
            };
        /**
         * Test, wether setting of source content is supported.
         * If not, setSourceContent in trans-unit will do nothing.
         * xtb does not support this, all other formats do.
         */
        /**
         * Test, wether setting of source content is supported.
         * If not, setSourceContent in trans-unit will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        AbstractTransUnit.prototype.supportsSetSourceContent = /**
         * Test, wether setting of source content is supported.
         * If not, setSourceContent in trans-unit will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return true;
            };
        /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
        AbstractTransUnit.prototype.sourceContentNormalized = /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
            function () {
                if (util.isNullOrUndefined(this._sourceContentNormalized)) {
                    this._sourceContentNormalized = this.createSourceContentNormalized();
                }
                return this._sourceContentNormalized;
            };
        /**
         * State of the translation.
         * (on of new, translated, final)
         * Return values are defined as Constants STATE_...
         * @return {?}
         */
        AbstractTransUnit.prototype.targetState = /**
         * State of the translation.
         * (on of new, translated, final)
         * Return values are defined as Constants STATE_...
         * @return {?}
         */
            function () {
                /** @type {?} */
                var nativeState = this.nativeTargetState();
                return this.mapNativeStateToState(nativeState);
            };
        /**
         * Modify the target state.
         * @param newState one of the 3 allowed target states new, translated, final.
         * Constants STATE_...
         * Invalid states throw an error.
         */
        /**
         * Modify the target state.
         * @param {?} newState one of the 3 allowed target states new, translated, final.
         * Constants STATE_...
         * Invalid states throw an error.
         * @return {?}
         */
        AbstractTransUnit.prototype.setTargetState = /**
         * Modify the target state.
         * @param {?} newState one of the 3 allowed target states new, translated, final.
         * Constants STATE_...
         * Invalid states throw an error.
         * @return {?}
         */
            function (newState) {
                this.setNativeTargetState(this.mapStateToNativeState(newState));
                if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {
                    ( /** @type {?} */(this.translationMessagesFile())).countNumbers();
                }
            };
        /**
         * Test, wether setting of source refs is supported.
         * If not, setSourceReferences will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        AbstractTransUnit.prototype.supportsSetSourceReferences = /**
         * Test, wether setting of source refs is supported.
         * If not, setSourceReferences will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return true;
            };
        /**
         * Test, wether setting of description and meaning is supported.
         * If not, setDescription and setMeaning will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        AbstractTransUnit.prototype.supportsSetDescriptionAndMeaning = /**
         * Test, wether setting of description and meaning is supported.
         * If not, setDescription and setMeaning will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return true;
            };
        /**
         * Check notes
         * @param newNotes the notes to add.
         * @throws an Error if any note contains description or meaning as from attribute.
         */
        /**
         * Check notes
         * @throws an Error if any note contains description or meaning as from attribute.
         * @param {?} newNotes the notes to add.
         * @return {?}
         */
        AbstractTransUnit.prototype.checkNotes = /**
         * Check notes
         * @throws an Error if any note contains description or meaning as from attribute.
         * @param {?} newNotes the notes to add.
         * @return {?}
         */
            function (newNotes) {
                /** @type {?} */
                var errorInFromNote = newNotes.find(function (note) { return note.from === 'description' || note.from === 'meaning'; });
                if (!util.isNullOrUndefined(errorInFromNote)) {
                    throw new Error('description or meaning are not allowed as from atttribute');
                }
            };
        /**
         * The real xml element used for the trans unit.
         * (internal usage only, a client should never need this)
         * @return {?} real xml element used for the trans unit.
         */
        AbstractTransUnit.prototype.asXmlElement = /**
         * The real xml element used for the trans unit.
         * (internal usage only, a client should never need this)
         * @return {?} real xml element used for the trans unit.
         */
            function () {
                return this._element;
            };
        /**
         * Translate the trans unit.
         * @param {?} translation the translated string or (preferred) a normalized message.
         * The pure string can contain any markup and will not be checked.
         * So it can damage the document.
         * A normalized message prevents this.
         * @return {?}
         */
        AbstractTransUnit.prototype.translate = /**
         * Translate the trans unit.
         * @param {?} translation the translated string or (preferred) a normalized message.
         * The pure string can contain any markup and will not be checked.
         * So it can damage the document.
         * A normalized message prevents this.
         * @return {?}
         */
            function (translation) {
                /** @type {?} */
                var translationNative;
                if (util.isString(translation)) {
                    translationNative = /** @type {?} */ (translation);
                }
                else {
                    translationNative = ( /** @type {?} */(translation)).asNativeString();
                }
                this.translateNative(translationNative);
                this.setTargetState(STATE_TRANSLATED);
            };
        /**
         * Test, wether message looks like ICU message.
         * @param {?} message message
         * @return {?} wether message looks like ICU message.
         */
        AbstractTransUnit.prototype.isICUMessage = /**
         * Test, wether message looks like ICU message.
         * @param {?} message message
         * @return {?} wether message looks like ICU message.
         */
            function (message) {
                return this.messageParser().isICUMessageStart(message);
            };
        return AbstractTransUnit;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 05.05.2017.
     * A part of a parsed message.
     * Can be a text, a placeholder, a tag
     */
    /** @enum {number} */
    var ParsedMessagePartType = {
        TEXT: 0,
        PLACEHOLDER: 1,
        START_TAG: 2,
        END_TAG: 3,
        EMPTY_TAG: 4,
        ICU_MESSAGE: 5,
        ICU_MESSAGE_REF: 6,
    };
    ParsedMessagePartType[ParsedMessagePartType.TEXT] = 'TEXT';
    ParsedMessagePartType[ParsedMessagePartType.PLACEHOLDER] = 'PLACEHOLDER';
    ParsedMessagePartType[ParsedMessagePartType.START_TAG] = 'START_TAG';
    ParsedMessagePartType[ParsedMessagePartType.END_TAG] = 'END_TAG';
    ParsedMessagePartType[ParsedMessagePartType.EMPTY_TAG] = 'EMPTY_TAG';
    ParsedMessagePartType[ParsedMessagePartType.ICU_MESSAGE] = 'ICU_MESSAGE';
    ParsedMessagePartType[ParsedMessagePartType.ICU_MESSAGE_REF] = 'ICU_MESSAGE_REF';
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ ParsedMessagePart = /** @class */ (function () {
        function ParsedMessagePart(type) {
            this.type = type;
        }
        return ParsedMessagePart;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 05.05.2017.
     * A message part consisting of just simple text.
     */
    var /**
     * Created by martin on 05.05.2017.
     * A message part consisting of just simple text.
     */ ParsedMessagePartText = /** @class */ (function (_super) {
        __extends(ParsedMessagePartText, _super);
        function ParsedMessagePartText(text) {
            var _this = _super.call(this, ParsedMessagePartType.TEXT) || this;
            _this.text = text;
            return _this;
        }
        /**
         * @param {?=} format
         * @return {?}
         */
        ParsedMessagePartText.prototype.asDisplayString = /**
         * @param {?=} format
         * @return {?}
         */
            function (format) {
                return this.text;
            };
        return ParsedMessagePartText;
    }(ParsedMessagePart));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 05.05.2017.
     * A message part consisting of a placeholder.
     * Placeholders are numbered from 0 to n.
     */
    var /**
     * Created by martin on 05.05.2017.
     * A message part consisting of a placeholder.
     * Placeholders are numbered from 0 to n.
     */ ParsedMessagePartPlaceholder = /** @class */ (function (_super) {
        __extends(ParsedMessagePartPlaceholder, _super);
        function ParsedMessagePartPlaceholder(index, disp) {
            var _this = _super.call(this, ParsedMessagePartType.PLACEHOLDER) || this;
            _this._index = index;
            _this._disp = disp;
            return _this;
        }
        /**
         * @param {?=} format
         * @return {?}
         */
        ParsedMessagePartPlaceholder.prototype.asDisplayString = /**
         * @param {?=} format
         * @return {?}
         */
            function (format) {
                if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {
                    return '{{' + this._index + '}}';
                }
                return '{{' + this._index + '}}';
            };
        /**
         * @return {?}
         */
        ParsedMessagePartPlaceholder.prototype.index = /**
         * @return {?}
         */
            function () {
                return this._index;
            };
        /**
         * @return {?}
         */
        ParsedMessagePartPlaceholder.prototype.disp = /**
         * @return {?}
         */
            function () {
                return this._disp;
            };
        return ParsedMessagePartPlaceholder;
    }(ParsedMessagePart));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 05.05.2017.
     * A message part consisting of an opening tag like <b> or <strange>.
     */
    var /**
     * Created by martin on 05.05.2017.
     * A message part consisting of an opening tag like <b> or <strange>.
     */ ParsedMessagePartStartTag = /** @class */ (function (_super) {
        __extends(ParsedMessagePartStartTag, _super);
        function ParsedMessagePartStartTag(tagname, idcounter) {
            var _this = _super.call(this, ParsedMessagePartType.START_TAG) || this;
            _this._tagname = tagname;
            _this._idcounter = idcounter;
            return _this;
        }
        /**
         * @param {?=} format
         * @return {?}
         */
        ParsedMessagePartStartTag.prototype.asDisplayString = /**
         * @param {?=} format
         * @return {?}
         */
            function (format) {
                if (this._idcounter === 0) {
                    return '<' + this._tagname + '>';
                }
                else {
                    return '<' + this._tagname + ' id="' + this._idcounter.toString() + '">';
                }
            };
        /**
         * @return {?}
         */
        ParsedMessagePartStartTag.prototype.tagName = /**
         * @return {?}
         */
            function () {
                return this._tagname;
            };
        /**
         * @return {?}
         */
        ParsedMessagePartStartTag.prototype.idCounter = /**
         * @return {?}
         */
            function () {
                return this._idcounter;
            };
        return ParsedMessagePartStartTag;
    }(ParsedMessagePart));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 05.05.2017.
     * A message part consisting of a closing tag like </b> or </strange>.
     */
    var /**
     * Created by martin on 05.05.2017.
     * A message part consisting of a closing tag like </b> or </strange>.
     */ ParsedMessagePartEndTag = /** @class */ (function (_super) {
        __extends(ParsedMessagePartEndTag, _super);
        function ParsedMessagePartEndTag(tagname) {
            var _this = _super.call(this, ParsedMessagePartType.END_TAG) || this;
            _this._tagname = tagname;
            return _this;
        }
        /**
         * @param {?=} format
         * @return {?}
         */
        ParsedMessagePartEndTag.prototype.asDisplayString = /**
         * @param {?=} format
         * @return {?}
         */
            function (format) {
                return '</' + this._tagname + '>';
            };
        /**
         * @return {?}
         */
        ParsedMessagePartEndTag.prototype.tagName = /**
         * @return {?}
         */
            function () {
                return this._tagname;
            };
        return ParsedMessagePartEndTag;
    }(ParsedMessagePart));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Created by martin on 04.06.2017.
     * A tokenizer for ICU messages.
      @type {?} */
    var TEXT = 'TEXT';
    /** @type {?} */
    var CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';
    /** @type {?} */
    var CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';
    /** @type {?} */
    var COMMA = 'COMMA';
    /** @type {?} */
    var PLURAL = 'PLURAL';
    /** @type {?} */
    var SELECT = 'SELECT';
    /** @type {?} */
    var STATE_DEFAULT = 'default';
    /** @type {?} */
    var STATE_NORMAL = 'normal';
    /** @type {?} */
    var STATE_IN_MESSAGE = 'in_message';
    var ICUMessageTokenizer = /** @class */ (function () {
        function ICUMessageTokenizer() {
        }
        /**
         * @return {?}
         */
        ICUMessageTokenizer.prototype.getLexer = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var lexer = new Tokenizr();
                /** @type {?} */
                var plaintext = '';
                /** @type {?} */
                var openedCurlyBracesInTextCounter = 0;
                lexer.before(function (ctx, match, rule) {
                    if (rule.name !== TEXT) {
                        if (_this.containsNonWhiteSpace(plaintext)) {
                            ctx.accept(TEXT, plaintext);
                            plaintext = '';
                        }
                        else {
                            ctx.ignore();
                        }
                    }
                });
                lexer.finish(function (ctx) {
                    if (_this.containsNonWhiteSpace(plaintext)) {
                        ctx.accept(TEXT, plaintext);
                    }
                });
                // curly brace
                lexer.rule(STATE_DEFAULT, /{/, function (ctx, match) {
                    ctx.accept(CURLY_BRACE_OPEN, match[0]);
                    ctx.push(STATE_NORMAL);
                }, CURLY_BRACE_OPEN);
                lexer.rule(STATE_NORMAL, /{/, function (ctx, match) {
                    ctx.accept(CURLY_BRACE_OPEN, match[0]);
                    ctx.push(STATE_IN_MESSAGE);
                }, CURLY_BRACE_OPEN);
                lexer.rule(STATE_NORMAL, /}/, function (ctx, match) {
                    ctx.pop();
                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);
                }, CURLY_BRACE_CLOSE);
                // masked ' { and }
                lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, function (ctx, match) {
                    if (match[0] === '\'\'') {
                        plaintext += '\'';
                    }
                    else if (match[0] === '\'{\'') {
                        plaintext += '{';
                    }
                    else if (match[0] === '\'}\'') {
                        plaintext += '}';
                    }
                    ctx.ignore();
                }, TEXT);
                lexer.rule(STATE_IN_MESSAGE, /./, function (ctx, match) {
                    /** @type {?} */
                    var char = match[0];
                    if (char === '{') {
                        openedCurlyBracesInTextCounter++;
                        plaintext += match[0];
                        ctx.ignore();
                    }
                    else if (char === '}') {
                        if (openedCurlyBracesInTextCounter > 0) {
                            openedCurlyBracesInTextCounter--;
                            plaintext += match[0];
                            ctx.ignore();
                        }
                        else {
                            ctx.pop();
                            ctx.accept(TEXT, plaintext);
                            plaintext = '';
                            ctx.accept(CURLY_BRACE_CLOSE, match[0]);
                        }
                    }
                    else {
                        plaintext += match[0];
                        ctx.ignore();
                    }
                }, TEXT);
                // comma
                lexer.rule(STATE_NORMAL, /,/, function (ctx, match) {
                    ctx.accept(COMMA, match[0]);
                }, COMMA);
                // keywords plural and select
                lexer.rule(STATE_NORMAL, /plural/, function (ctx, match) {
                    ctx.accept(PLURAL, match[0]);
                }, PLURAL);
                lexer.rule(STATE_NORMAL, /select/, function (ctx, match) {
                    ctx.accept(SELECT, match[0]);
                }, SELECT);
                // text
                lexer.rule(/./, function (ctx, match) {
                    plaintext += match[0];
                    ctx.ignore();
                }, TEXT);
                lexer.rule(/[\s]+/, function (ctx, match) {
                    plaintext += match[0];
                    ctx.ignore();
                }, TEXT);
                return lexer;
            };
        /**
         * @param {?} text
         * @return {?}
         */
        ICUMessageTokenizer.prototype.containsNonWhiteSpace = /**
         * @param {?} text
         * @return {?}
         */
            function (text) {
                for (var i = 0; i < text.length; i++) {
                    if (!/\s/.test(text.charAt(i))) {
                        return true;
                    }
                }
                return false;
            };
        /**
         * @param {?} normalizedMessage
         * @return {?}
         */
        ICUMessageTokenizer.prototype.tokenize = /**
         * @param {?} normalizedMessage
         * @return {?}
         */
            function (normalizedMessage) {
                /** @type {?} */
                var lexer = this.getLexer();
                lexer.input(normalizedMessage);
                return lexer.tokens();
            };
        /**
         * @param {?} normalizedMessage
         * @return {?}
         */
        ICUMessageTokenizer.prototype.input = /**
         * @param {?} normalizedMessage
         * @return {?}
         */
            function (normalizedMessage) {
                this.lexer = this.getLexer();
                this.lexer.input(normalizedMessage);
            };
        /**
         * @return {?}
         */
        ICUMessageTokenizer.prototype.next = /**
         * @return {?}
         */
            function () {
                return this.lexer.token();
            };
        /**
         * @return {?}
         */
        ICUMessageTokenizer.prototype.peek = /**
         * @return {?}
         */
            function () {
                return this.lexer.peek();
            };
        return ICUMessageTokenizer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var MessageCategory = /** @class */ (function () {
        function MessageCategory(_category, _message) {
            this._category = _category;
            this._message = _message;
        }
        /**
         * @return {?}
         */
        MessageCategory.prototype.getCategory = /**
         * @return {?}
         */
            function () {
                return this._category;
            };
        /**
         * @return {?}
         */
        MessageCategory.prototype.getMessageNormalized = /**
         * @return {?}
         */
            function () {
                return this._message;
            };
        return MessageCategory;
    }());
    /**
     * Implementation of an ICU Message.
     * Created by martin on 05.06.2017.
     */
    var /**
     * Implementation of an ICU Message.
     * Created by martin on 05.06.2017.
     */ ICUMessage = /** @class */ (function () {
        function ICUMessage(_parser, isPluralMessage) {
            this._parser = _parser;
            this._isPluralMessage = isPluralMessage;
            this._categories = [];
        }
        /**
         * @param {?} category
         * @param {?} message
         * @return {?}
         */
        ICUMessage.prototype.addCategory = /**
         * @param {?} category
         * @param {?} message
         * @return {?}
         */
            function (category, message) {
                this._categories.push(new MessageCategory(category, message));
            };
        /**
         * ICU message as native string.
         * This is, how it is stored, something like '{x, plural, =0 {..}'
         * @return {?} ICU message as native string.
         */
        ICUMessage.prototype.asNativeString = /**
         * ICU message as native string.
         * This is, how it is stored, something like '{x, plural, =0 {..}'
         * @return {?} ICU message as native string.
         */
            function () {
                /** @type {?} */
                var varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';
                /** @type {?} */
                var type = (this.isPluralMessage()) ? 'plural' : 'select';
                /** @type {?} */
                var choiceString = '';
                this._categories.forEach(function (category) {
                    choiceString = choiceString + util.format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());
                });
                return util.format('{%s, %s,%s}', varname, type, choiceString);
            };
        /**
         * Is it a plural message?
         */
        /**
         * Is it a plural message?
         * @return {?}
         */
        ICUMessage.prototype.isPluralMessage = /**
         * Is it a plural message?
         * @return {?}
         */
            function () {
                return this._isPluralMessage;
            };
        /**
         * Is it a select message?
         */
        /**
         * Is it a select message?
         * @return {?}
         */
        ICUMessage.prototype.isSelectMessage = /**
         * Is it a select message?
         * @return {?}
         */
            function () {
                return !this._isPluralMessage;
            };
        /**
         * All the parts of the message.
         * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}
         * has 4 category objects with the categories =0, =1, =2, other.
         */
        /**
         * All the parts of the message.
         * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}
         * has 4 category objects with the categories =0, =1, =2, other.
         * @return {?}
         */
        ICUMessage.prototype.getCategories = /**
         * All the parts of the message.
         * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}
         * has 4 category objects with the categories =0, =1, =2, other.
         * @return {?}
         */
            function () {
                return this._categories;
            };
        /**
         * Translate message and return a new, translated message
         * @param translation the translation (hashmap of categories and translations).
         * @return new message wit translated content.
         * @throws an error if translation does not match the message.
         * This is the case, if there are categories not contained in the original message.
         */
        /**
         * Translate message and return a new, translated message
         * @throws an error if translation does not match the message.
         * This is the case, if there are categories not contained in the original message.
         * @param {?} translation the translation (hashmap of categories and translations).
         * @return {?} new message wit translated content.
         */
        ICUMessage.prototype.translate = /**
         * Translate message and return a new, translated message
         * @throws an error if translation does not match the message.
         * This is the case, if there are categories not contained in the original message.
         * @param {?} translation the translation (hashmap of categories and translations).
         * @return {?} new message wit translated content.
         */
            function (translation) {
                var _this = this;
                /** @type {?} */
                var message = new ICUMessage(this._parser, this.isPluralMessage());
                /** @type {?} */
                var translatedCategories = new Set();
                this._categories.forEach(function (category) {
                    /** @type {?} */
                    var translatedMessage;
                    /** @type {?} */
                    var translationForCategory = translation[category.getCategory()];
                    if (util.isNullOrUndefined(translationForCategory)) {
                        translatedMessage = category.getMessageNormalized();
                    }
                    else if (util.isString(translationForCategory)) {
                        translatedCategories.add(category.getCategory());
                        translatedMessage = _this._parser.parseNormalizedString(/** @type {?} */ (translationForCategory), null);
                    }
                    else {
                        // TODO embedded ICU Message
                        translatedMessage = null;
                    }
                    message.addCategory(category.getCategory(), translatedMessage);
                });
                // new categories, which are not part of the original message
                Object.keys(translation).forEach(function (categoryName) {
                    if (!translatedCategories.has(categoryName)) {
                        if (_this.isSelectMessage()) {
                            throw new Error(util.format('adding a new category not allowed for select messages ("%s" is not part of message)', categoryName));
                        }
                        else {
                            _this.checkValidPluralCategory(categoryName);
                            /** @type {?} */
                            var translatedMessage = _this._parser.parseNormalizedString(/** @type {?} */ (translation[categoryName]), null);
                            message.addCategory(categoryName, translatedMessage);
                        }
                    }
                });
                return message;
            };
        /**
         * Check, wether category is valid plural category.
         * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'
         * @throws an error, if it is not a valid category name
         * @param {?} categoryName category
         * @return {?}
         */
        ICUMessage.prototype.checkValidPluralCategory = /**
         * Check, wether category is valid plural category.
         * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'
         * @throws an error, if it is not a valid category name
         * @param {?} categoryName category
         * @return {?}
         */
            function (categoryName) {
                /** @type {?} */
                var allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];
                if (categoryName.match(/=\d+/)) {
                    return;
                }
                if (allowedKeywords.find(function (key) { return key === categoryName; })) {
                    return;
                }
                throw new Error(util.format('invalid plural category "%s", allowed are =<n> and %s', categoryName, allowedKeywords));
            };
        return ICUMessage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 02.06.2017.
     * A message part consisting of an icu message.
     * There can only be one icu message in a parsed message.
     * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'
     */
    var /**
     * Created by martin on 02.06.2017.
     * A message part consisting of an icu message.
     * There can only be one icu message in a parsed message.
     * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'
     */ ParsedMessagePartICUMessage = /** @class */ (function (_super) {
        __extends(ParsedMessagePartICUMessage, _super);
        function ParsedMessagePartICUMessage(icuMessageText, _parser) {
            var _this = _super.call(this, ParsedMessagePartType.ICU_MESSAGE) || this;
            _this._parser = _parser;
            if (icuMessageText) {
                _this.parseICUMessage(icuMessageText);
            }
            return _this;
        }
        /**
         * Test wether text might be an ICU message.
         * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'
         * @param icuMessageText icuMessageText
         * @return wether text might be an ICU message.
         */
        /**
         * Test wether text might be an ICU message.
         * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'
         * @param {?} icuMessageText icuMessageText
         * @return {?} wether text might be an ICU message.
         */
        ParsedMessagePartICUMessage.looksLikeICUMessage = /**
         * Test wether text might be an ICU message.
         * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'
         * @param {?} icuMessageText icuMessageText
         * @return {?} wether text might be an ICU message.
         */
            function (icuMessageText) {
                /** @type {?} */
                var part = new ParsedMessagePartICUMessage(null, null);
                return part.looksLikeICUMessage(icuMessageText);
            };
        /**
         * @param {?=} displayFormat
         * @return {?}
         */
        ParsedMessagePartICUMessage.prototype.asDisplayString = /**
         * @param {?=} displayFormat
         * @return {?}
         */
            function (displayFormat) {
                return '<ICU-Message/>';
            };
        /**
         * return the parsed message.
         * @return {?} parsed message
         */
        ParsedMessagePartICUMessage.prototype.getICUMessage = /**
         * return the parsed message.
         * @return {?} parsed message
         */
            function () {
                return this._message;
            };
        /**
         * Parse the message.
         * @throws an error if the syntax is not ok in any way.
         * @param {?} text message text to parse
         * @return {?}
         */
        ParsedMessagePartICUMessage.prototype.parseICUMessage = /**
         * Parse the message.
         * @throws an error if the syntax is not ok in any way.
         * @param {?} text message text to parse
         * @return {?}
         */
            function (text) {
                // console.log('message ', text);
                // const tokens = new ICUMessageTokenizer().tokenize(text);
                // tokens.forEach((tok) => {
                //     console.log('Token', tok.type, tok.value);
                // });
                this._messageText = text;
                this._tokenizer = new ICUMessageTokenizer();
                this._tokenizer.input(text);
                this.expectNext(CURLY_BRACE_OPEN);
                this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT
                this.expectNext(COMMA);
                /** @type {?} */
                var token = this._tokenizer.next();
                if (token.type === PLURAL) {
                    this._message = new ICUMessage(this._parser, true);
                }
                else if (token.type === SELECT) {
                    this._message = new ICUMessage(this._parser, false);
                }
                this.expectNext(COMMA);
                token = this._tokenizer.peek();
                while (token.type !== CURLY_BRACE_CLOSE) {
                    /** @type {?} */
                    var category = this.expectNext(TEXT).value.trim();
                    this.expectNext(CURLY_BRACE_OPEN);
                    /** @type {?} */
                    var message = this.expectNext(TEXT).value;
                    this._message.addCategory(category, this.parseNativeSubMessage(message));
                    this.expectNext(CURLY_BRACE_CLOSE);
                    token = this._tokenizer.peek();
                }
                this.expectNext(CURLY_BRACE_CLOSE);
                this.expectNext('EOF');
            };
        /**
         * Parse the message to check, wether it might be an ICU message.
         * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'
         * @param {?} text message text to parse
         * @return {?}
         */
        ParsedMessagePartICUMessage.prototype.looksLikeICUMessage = /**
         * Parse the message to check, wether it might be an ICU message.
         * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'
         * @param {?} text message text to parse
         * @return {?}
         */
            function (text) {
                // console.log('message ', text);
                // const tokens = new ICUMessageTokenizer().tokenize(text);
                // tokens.forEach((tok) => {
                //     console.log('Token', tok.type, tok.value);
                // });
                this._tokenizer = new ICUMessageTokenizer();
                this._tokenizer.input(text);
                try {
                    this.expectNext(CURLY_BRACE_OPEN);
                    this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT
                    this.expectNext(COMMA);
                    /** @type {?} */
                    var token = this._tokenizer.next();
                    if (token.type !== PLURAL && token.type !== SELECT) {
                        return false;
                    }
                    this.expectNext(COMMA);
                    return true;
                }
                catch (error) {
                    return false;
                }
            };
        /**
         * Read next token and expect, that it is of the given type.
         * @throws error, if next token has wrong type.
         * @param {?} tokentype expected type.
         * @return {?} Token
         */
        ParsedMessagePartICUMessage.prototype.expectNext = /**
         * Read next token and expect, that it is of the given type.
         * @throws error, if next token has wrong type.
         * @param {?} tokentype expected type.
         * @return {?} Token
         */
            function (tokentype) {
                /** @type {?} */
                var token = this._tokenizer.next();
                if (token.type !== tokentype) {
                    throw new Error(util.format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)', tokentype, token.type, token.value, this._messageText));
                }
                return token;
            };
        /**
         * Parse XML text to normalized message.
         * @param {?} message message in format dependent xml syntax.
         * @return {?} normalized message
         */
        ParsedMessagePartICUMessage.prototype.parseNativeSubMessage = /**
         * Parse XML text to normalized message.
         * @param {?} message message in format dependent xml syntax.
         * @return {?} normalized message
         */
            function (message) {
                return this._parser.createNormalizedMessageFromXMLString(message, null);
            };
        return ParsedMessagePartICUMessage;
    }(ParsedMessagePart));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 05.05.2017.
     * A reference to an ICU message
     * icu references are numbered from 0 to n.
     */
    var /**
     * Created by martin on 05.05.2017.
     * A reference to an ICU message
     * icu references are numbered from 0 to n.
     */ ParsedMessagePartICUMessageRef = /** @class */ (function (_super) {
        __extends(ParsedMessagePartICUMessageRef, _super);
        function ParsedMessagePartICUMessageRef(index, disp) {
            var _this = _super.call(this, ParsedMessagePartType.ICU_MESSAGE_REF) || this;
            _this._index = index;
            _this._disp = disp;
            return _this;
        }
        /**
         * @param {?=} format
         * @return {?}
         */
        ParsedMessagePartICUMessageRef.prototype.asDisplayString = /**
         * @param {?=} format
         * @return {?}
         */
            function (format) {
                return '<ICU-Message-Ref_' + this._index + '/>';
            };
        /**
         * @return {?}
         */
        ParsedMessagePartICUMessageRef.prototype.index = /**
         * @return {?}
         */
            function () {
                return this._index;
            };
        /**
         * @return {?}
         */
        ParsedMessagePartICUMessageRef.prototype.disp = /**
         * @return {?}
         */
            function () {
                return this._disp;
            };
        return ParsedMessagePartICUMessageRef;
    }(ParsedMessagePart));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 14.06.2017.
     * A message part consisting of an empty tag like <br/>.
     */
    var /**
     * Created by martin on 14.06.2017.
     * A message part consisting of an empty tag like <br/>.
     */ ParsedMessagePartEmptyTag = /** @class */ (function (_super) {
        __extends(ParsedMessagePartEmptyTag, _super);
        function ParsedMessagePartEmptyTag(tagname, idcounter) {
            var _this = _super.call(this, ParsedMessagePartType.EMPTY_TAG) || this;
            _this._tagname = tagname;
            _this._idcounter = idcounter;
            return _this;
        }
        /**
         * @param {?=} format
         * @return {?}
         */
        ParsedMessagePartEmptyTag.prototype.asDisplayString = /**
         * @param {?=} format
         * @return {?}
         */
            function (format) {
                if (this._idcounter === 0) {
                    return '<' + this._tagname + '>';
                }
                else {
                    return '<' + this._tagname + ' id="' + this._idcounter.toString() + '">';
                }
            };
        /**
         * @return {?}
         */
        ParsedMessagePartEmptyTag.prototype.tagName = /**
         * @return {?}
         */
            function () {
                return this._tagname;
            };
        /**
         * @return {?}
         */
        ParsedMessagePartEmptyTag.prototype.idCounter = /**
         * @return {?}
         */
            function () {
                return this._idcounter;
            };
        return ParsedMessagePartEmptyTag;
    }(ParsedMessagePart));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 05.05.2017.
     * A message text read from a translation file.
     * Can contain placeholders, tags, text.
     * This class is a representation independent of the concrete format.
     */
    var /**
     * Created by martin on 05.05.2017.
     * A message text read from a translation file.
     * Can contain placeholders, tags, text.
     * This class is a representation independent of the concrete format.
     */ ParsedMessage = /** @class */ (function () {
        function ParsedMessage(parser, sourceMessage) {
            this._parser = parser;
            this.sourceMessage = sourceMessage;
            this._parts = [];
        }
        /**
         * Get the parser (for tests only, not part of API)
         * @return parser
         */
        /**
         * Get the parser (for tests only, not part of API)
         * @return {?} parser
         */
        ParsedMessage.prototype.getParser = /**
         * Get the parser (for tests only, not part of API)
         * @return {?} parser
         */
            function () {
                return this._parser;
            };
        /**
         * Create a new normalized message as a translation of this one.
         * @param normalizedString the translation in normalized form.
         * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.
         * @throws an error if normalized string is not well formed.
         * Throws an error too, if this is an ICU message.
         */
        /**
         * Create a new normalized message as a translation of this one.
         * @throws an error if normalized string is not well formed.
         * Throws an error too, if this is an ICU message.
         * @param {?} normalizedString the translation in normalized form.
         * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.
         * @return {?}
         */
        ParsedMessage.prototype.translate = /**
         * Create a new normalized message as a translation of this one.
         * @throws an error if normalized string is not well formed.
         * Throws an error too, if this is an ICU message.
         * @param {?} normalizedString the translation in normalized form.
         * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.
         * @return {?}
         */
            function (normalizedString) {
                if (util.isNullOrUndefined(this.getICUMessage())) {
                    return this._parser.parseNormalizedString(/** @type {?} */ (normalizedString), this);
                }
                else {
                    throw new Error(util.format('cannot translate ICU message with simple string, use translateICUMessage() instead ("%s", "%s")', normalizedString, this.asNativeString()));
                }
            };
        /**
         * Create a new normalized icu message as a translation of this one.
         * @param icuTranslation the translation, this is the translation of the ICU message,
         * which is not a string, but a collections of the translations of the different categories.
         * The message must be an ICUMessage (getICUMessage returns a value)
         * @throws an error if normalized string is not well formed.
         * Throws an error too, if this is not an ICU message.
         */
        /**
         * Create a new normalized icu message as a translation of this one.
         * @throws an error if normalized string is not well formed.
         * Throws an error too, if this is not an ICU message.
         * @param {?} icuTranslation the translation, this is the translation of the ICU message,
         * which is not a string, but a collections of the translations of the different categories.
         * The message must be an ICUMessage (getICUMessage returns a value)
         * @return {?}
         */
        ParsedMessage.prototype.translateICUMessage = /**
         * Create a new normalized icu message as a translation of this one.
         * @throws an error if normalized string is not well formed.
         * Throws an error too, if this is not an ICU message.
         * @param {?} icuTranslation the translation, this is the translation of the ICU message,
         * which is not a string, but a collections of the translations of the different categories.
         * The message must be an ICUMessage (getICUMessage returns a value)
         * @return {?}
         */
            function (icuTranslation) {
                /** @type {?} */
                var icuMessage = this.getICUMessage();
                if (util.isNullOrUndefined(icuMessage)) {
                    throw new Error(util.format('this is not an ICU message, use translate() instead ("%s", "%s")', icuTranslation, this.asNativeString()));
                }
                else {
                    /** @type {?} */
                    var translatedICUMessage = icuMessage.translate(icuTranslation);
                    return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);
                }
            };
        /**
         * Create a new normalized message from a native xml string as a translation of this one.
         * @param nativeString xml string in the format of the underlying file format.
         * Throws an error if native string is not acceptable.
         */
        /**
         * Create a new normalized message from a native xml string as a translation of this one.
         * @param {?} nativeString xml string in the format of the underlying file format.
         * Throws an error if native string is not acceptable.
         * @return {?}
         */
        ParsedMessage.prototype.translateNativeString = /**
         * Create a new normalized message from a native xml string as a translation of this one.
         * @param {?} nativeString xml string in the format of the underlying file format.
         * Throws an error if native string is not acceptable.
         * @return {?}
         */
            function (nativeString) {
                return this._parser.createNormalizedMessageFromXMLString(nativeString, this);
            };
        /**
         * normalized message as string.
         * @param {?=} displayFormat optional way to determine the exact syntax.
         * Allowed formats are defined as constants NORMALIZATION_FORMAT...
         * @return {?}
         */
        ParsedMessage.prototype.asDisplayString = /**
         * normalized message as string.
         * @param {?=} displayFormat optional way to determine the exact syntax.
         * Allowed formats are defined as constants NORMALIZATION_FORMAT...
         * @return {?}
         */
            function (displayFormat) {
                return this._parts.map(function (part) { return part.asDisplayString(displayFormat); }).join('');
            };
        /**
         * Returns the message content as format dependent native string.
         * Includes all format specific markup like <ph id="INTERPOLATION" ../> ..
         */
        /**
         * Returns the message content as format dependent native string.
         * Includes all format specific markup like <ph id="INTERPOLATION" ../> ..
         * @return {?}
         */
        ParsedMessage.prototype.asNativeString = /**
         * Returns the message content as format dependent native string.
         * Includes all format specific markup like <ph id="INTERPOLATION" ../> ..
         * @return {?}
         */
            function () {
                if (util.isNullOrUndefined(this.getICUMessage())) {
                    return DOMUtilities.getXMLContent(this._xmlRepresentation);
                }
                else {
                    return this.getICUMessage().asNativeString();
                }
            };
        /**
         * Validate the message.
         * @return {?} null, if ok, error object otherwise.
         */
        ParsedMessage.prototype.validate = /**
         * Validate the message.
         * @return {?} null, if ok, error object otherwise.
         */
            function () {
                /** @type {?} */
                var hasErrors = false;
                /** @type {?} */
                var errors = {};
                /** @type {?} */
                var e;
                e = this.checkPlaceholderAdded();
                if (!util.isNullOrUndefined(e)) {
                    errors.placeholderAdded = e;
                    hasErrors = true;
                }
                e = this.checkICUMessageRefRemoved();
                if (!util.isNullOrUndefined(e)) {
                    errors["icuMessageRefRemoved"] = e;
                    hasErrors = true;
                }
                e = this.checkICUMessageRefAdded();
                if (!util.isNullOrUndefined(e)) {
                    errors["icuMessageRefAdded"] = e;
                    hasErrors = true;
                }
                return hasErrors ? errors : null;
            };
        /**
         * Validate the message, check for warnings only.
         * A warning shows, that the message is acceptable, but misses something.
         * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.
         * @return null, if no warning, warnings as error object otherwise.
         */
        /**
         * Validate the message, check for warnings only.
         * A warning shows, that the message is acceptable, but misses something.
         * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.
         * @return {?} null, if no warning, warnings as error object otherwise.
         */
        ParsedMessage.prototype.validateWarnings = /**
         * Validate the message, check for warnings only.
         * A warning shows, that the message is acceptable, but misses something.
         * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.
         * @return {?} null, if no warning, warnings as error object otherwise.
         */
            function () {
                /** @type {?} */
                var hasWarnings = false;
                /** @type {?} */
                var warnings = {};
                /** @type {?} */
                var w;
                w = this.checkPlaceholderRemoved();
                if (!util.isNullOrUndefined(w)) {
                    warnings.placeholderRemoved = w;
                    hasWarnings = true;
                }
                w = this.checkTagRemoved();
                if (!util.isNullOrUndefined(w)) {
                    warnings.tagRemoved = w;
                    hasWarnings = true;
                }
                w = this.checkTagAdded();
                if (!util.isNullOrUndefined(w)) {
                    warnings.tagAdded = w;
                    hasWarnings = true;
                }
                return hasWarnings ? warnings : null;
            };
        /**
         * If this message is an ICU message, returns its structure.
         * Otherwise this method returns null.
         * @return {?} ICUMessage or null.
         */
        ParsedMessage.prototype.getICUMessage = /**
         * If this message is an ICU message, returns its structure.
         * Otherwise this method returns null.
         * @return {?} ICUMessage or null.
         */
            function () {
                if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {
                    /** @type {?} */
                    var icuPart = /** @type {?} */ (this._parts[0]);
                    return icuPart.getICUMessage();
                }
                else {
                    return null;
                }
            };
        /**
         * Check for added placeholder.
         * @return {?} null or message, if fulfilled.
         */
        ParsedMessage.prototype.checkPlaceholderAdded = /**
         * Check for added placeholder.
         * @return {?} null or message, if fulfilled.
         */
            function () {
                /** @type {?} */
                var e = null;
                /** @type {?} */
                var suspiciousIndexes = [];
                if (this.sourceMessage) {
                    /** @type {?} */
                    var sourcePlaceholders_1 = this.sourceMessage.allPlaceholders();
                    /** @type {?} */
                    var myPlaceholders = this.allPlaceholders();
                    myPlaceholders.forEach(function (index) {
                        if (!sourcePlaceholders_1.has(index)) {
                            suspiciousIndexes.push(index);
                        }
                    });
                }
                if (suspiciousIndexes.length === 1) {
                    e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';
                }
                else if (suspiciousIndexes.length > 1) {
                    /** @type {?} */
                    var allSuspiciousIndexes_1 = '';
                    /** @type {?} */
                    var first_1 = true;
                    suspiciousIndexes.forEach(function (index) {
                        if (!first_1) {
                            allSuspiciousIndexes_1 = allSuspiciousIndexes_1 + ', ';
                        }
                        allSuspiciousIndexes_1 = allSuspiciousIndexes_1 + index;
                        first_1 = false;
                    });
                    e = 'added placeholders ' + allSuspiciousIndexes_1 + ', which are not in original message';
                }
                return e;
            };
        /**
         * Check for removed placeholder.
         * @return {?} null or message, if fulfilled.
         */
        ParsedMessage.prototype.checkPlaceholderRemoved = /**
         * Check for removed placeholder.
         * @return {?} null or message, if fulfilled.
         */
            function () {
                /** @type {?} */
                var w = null;
                /** @type {?} */
                var suspiciousIndexes = [];
                if (this.sourceMessage) {
                    /** @type {?} */
                    var sourcePlaceholders = this.sourceMessage.allPlaceholders();
                    /** @type {?} */
                    var myPlaceholders_1 = this.allPlaceholders();
                    sourcePlaceholders.forEach(function (index) {
                        if (!myPlaceholders_1.has(index)) {
                            suspiciousIndexes.push(index);
                        }
                    });
                }
                if (suspiciousIndexes.length === 1) {
                    w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';
                }
                else if (suspiciousIndexes.length > 1) {
                    /** @type {?} */
                    var allSuspiciousIndexes_2 = '';
                    /** @type {?} */
                    var first_2 = true;
                    suspiciousIndexes.forEach(function (index) {
                        if (!first_2) {
                            allSuspiciousIndexes_2 = allSuspiciousIndexes_2 + ', ';
                        }
                        allSuspiciousIndexes_2 = allSuspiciousIndexes_2 + index;
                        first_2 = false;
                    });
                    w = 'removed placeholders ' + allSuspiciousIndexes_2 + ' from original message';
                }
                return w;
            };
        /**
         * Check for added ICU Message Refs.
         * @return {?} null or message, if fulfilled.
         */
        ParsedMessage.prototype.checkICUMessageRefAdded = /**
         * Check for added ICU Message Refs.
         * @return {?} null or message, if fulfilled.
         */
            function () {
                /** @type {?} */
                var e = null;
                /** @type {?} */
                var suspiciousIndexes = [];
                if (this.sourceMessage) {
                    /** @type {?} */
                    var sourceICURefs_1 = this.sourceMessage.allICUMessageRefs();
                    /** @type {?} */
                    var myICURefs = this.allICUMessageRefs();
                    myICURefs.forEach(function (index) {
                        if (!sourceICURefs_1.has(index)) {
                            suspiciousIndexes.push(index);
                        }
                    });
                }
                if (suspiciousIndexes.length === 1) {
                    e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';
                }
                else if (suspiciousIndexes.length > 1) {
                    /** @type {?} */
                    var allSuspiciousIndexes_3 = '';
                    /** @type {?} */
                    var first_3 = true;
                    suspiciousIndexes.forEach(function (index) {
                        if (!first_3) {
                            allSuspiciousIndexes_3 = allSuspiciousIndexes_3 + ', ';
                        }
                        allSuspiciousIndexes_3 = allSuspiciousIndexes_3 + index;
                        first_3 = false;
                    });
                    e = 'added ICU message references ' + allSuspiciousIndexes_3 + ', which are not in original message';
                }
                return e;
            };
        /**
         * Check for removed ICU Message Refs.
         * @return {?} null or message, if fulfilled.
         */
        ParsedMessage.prototype.checkICUMessageRefRemoved = /**
         * Check for removed ICU Message Refs.
         * @return {?} null or message, if fulfilled.
         */
            function () {
                /** @type {?} */
                var e = null;
                /** @type {?} */
                var suspiciousIndexes = [];
                if (this.sourceMessage) {
                    /** @type {?} */
                    var sourceICURefs = this.sourceMessage.allICUMessageRefs();
                    /** @type {?} */
                    var myICURefs_1 = this.allICUMessageRefs();
                    sourceICURefs.forEach(function (index) {
                        if (!myICURefs_1.has(index)) {
                            suspiciousIndexes.push(index);
                        }
                    });
                }
                if (suspiciousIndexes.length === 1) {
                    e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';
                }
                else if (suspiciousIndexes.length > 1) {
                    /** @type {?} */
                    var allSuspiciousIndexes_4 = '';
                    /** @type {?} */
                    var first_4 = true;
                    suspiciousIndexes.forEach(function (index) {
                        if (!first_4) {
                            allSuspiciousIndexes_4 = allSuspiciousIndexes_4 + ', ';
                        }
                        allSuspiciousIndexes_4 = allSuspiciousIndexes_4 + index;
                        first_4 = false;
                    });
                    e = 'removed ICU message references ' + allSuspiciousIndexes_4 + ' from original message';
                }
                return e;
            };
        /**
         * Get all indexes of placeholders used in the message.
         * @return {?}
         */
        ParsedMessage.prototype.allPlaceholders = /**
         * Get all indexes of placeholders used in the message.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var result = new Set();
                this.parts().forEach(function (part) {
                    if (part.type === ParsedMessagePartType.PLACEHOLDER) {
                        /** @type {?} */
                        var index = ( /** @type {?} */(part)).index();
                        result.add(index);
                    }
                });
                return result;
            };
        /**
         * Return the disp-Attribute of placeholder
         * @param {?} index index of placeholder
         * @return {?} disp or null
         */
        ParsedMessage.prototype.getPlaceholderDisp = /**
         * Return the disp-Attribute of placeholder
         * @param {?} index index of placeholder
         * @return {?} disp or null
         */
            function (index) {
                /** @type {?} */
                var placeHolder = null;
                this.parts().forEach(function (part) {
                    if (part.type === ParsedMessagePartType.PLACEHOLDER) {
                        /** @type {?} */
                        var phPart = /** @type {?} */ (part);
                        if (phPart.index() === index) {
                            placeHolder = phPart;
                        }
                    }
                });
                return placeHolder ? placeHolder.disp() : null;
            };
        /**
         * Get all indexes of ICU message refs used in the message.
         * @return {?}
         */
        ParsedMessage.prototype.allICUMessageRefs = /**
         * Get all indexes of ICU message refs used in the message.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var result = new Set();
                this.parts().forEach(function (part) {
                    if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {
                        /** @type {?} */
                        var index = ( /** @type {?} */(part)).index();
                        result.add(index);
                    }
                });
                return result;
            };
        /**
         * Return the disp-Attribute of icu message ref
         * @param {?} index of ref
         * @return {?} disp or null
         */
        ParsedMessage.prototype.getICUMessageRefDisp = /**
         * Return the disp-Attribute of icu message ref
         * @param {?} index of ref
         * @return {?} disp or null
         */
            function (index) {
                /** @type {?} */
                var icuMessageRefPart = null;
                this.parts().forEach(function (part) {
                    if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {
                        /** @type {?} */
                        var refPart = /** @type {?} */ (part);
                        if (refPart.index() === index) {
                            icuMessageRefPart = refPart;
                        }
                    }
                });
                return icuMessageRefPart ? icuMessageRefPart.disp() : null;
            };
        /**
         * Check for added tags.
         * @return {?} null or message, if fulfilled.
         */
        ParsedMessage.prototype.checkTagAdded = /**
         * Check for added tags.
         * @return {?} null or message, if fulfilled.
         */
            function () {
                /** @type {?} */
                var e = null;
                /** @type {?} */
                var suspiciousTags = [];
                if (this.sourceMessage) {
                    /** @type {?} */
                    var sourceTags_1 = this.sourceMessage.allTags();
                    /** @type {?} */
                    var myTags = this.allTags();
                    myTags.forEach(function (tagName) {
                        if (!sourceTags_1.has(tagName)) {
                            suspiciousTags.push(tagName);
                        }
                    });
                }
                if (suspiciousTags.length === 1) {
                    e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';
                }
                else if (suspiciousTags.length > 1) {
                    /** @type {?} */
                    var allSuspiciousTags_1 = '';
                    /** @type {?} */
                    var first_5 = true;
                    suspiciousTags.forEach(function (tag) {
                        if (!first_5) {
                            allSuspiciousTags_1 = allSuspiciousTags_1 + ', ';
                        }
                        allSuspiciousTags_1 = allSuspiciousTags_1 + '<' + tag + '>';
                        first_5 = false;
                    });
                    e = 'added tags ' + allSuspiciousTags_1 + ', which are not in original message';
                }
                return e;
            };
        /**
         * Check for removed tags.
         * @return {?} null or message, if fulfilled.
         */
        ParsedMessage.prototype.checkTagRemoved = /**
         * Check for removed tags.
         * @return {?} null or message, if fulfilled.
         */
            function () {
                /** @type {?} */
                var w = null;
                /** @type {?} */
                var suspiciousTags = [];
                if (this.sourceMessage) {
                    /** @type {?} */
                    var sourceTags = this.sourceMessage.allTags();
                    /** @type {?} */
                    var myTags_1 = this.allTags();
                    sourceTags.forEach(function (tagName) {
                        if (!myTags_1.has(tagName)) {
                            suspiciousTags.push(tagName);
                        }
                    });
                }
                if (suspiciousTags.length === 1) {
                    w = 'removed tag <' + suspiciousTags[0] + '> from original message';
                }
                else if (suspiciousTags.length > 1) {
                    /** @type {?} */
                    var allSuspiciousTags_2 = '';
                    /** @type {?} */
                    var first_6 = true;
                    suspiciousTags.forEach(function (tag) {
                        if (!first_6) {
                            allSuspiciousTags_2 = allSuspiciousTags_2 + ', ';
                        }
                        allSuspiciousTags_2 = allSuspiciousTags_2 + '<' + tag + '>';
                        first_6 = false;
                    });
                    w = 'removed tags ' + allSuspiciousTags_2 + ' from original message';
                }
                return w;
            };
        /**
         * Get all tag names used in the message.
         * @return {?}
         */
        ParsedMessage.prototype.allTags = /**
         * Get all tag names used in the message.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var result = new Set();
                this.parts().forEach(function (part) {
                    if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {
                        /** @type {?} */
                        var tagName = ( /** @type {?} */(part)).tagName();
                        result.add(tagName);
                    }
                });
                return result;
            };
        /**
         * @return {?}
         */
        ParsedMessage.prototype.parts = /**
         * @return {?}
         */
            function () {
                return this._parts;
            };
        /**
         * @param {?} xmlRepresentation
         * @return {?}
         */
        ParsedMessage.prototype.setXmlRepresentation = /**
         * @param {?} xmlRepresentation
         * @return {?}
         */
            function (xmlRepresentation) {
                this._xmlRepresentation = xmlRepresentation;
            };
        /**
         * @param {?} text
         * @return {?}
         */
        ParsedMessage.prototype.addText = /**
         * @param {?} text
         * @return {?}
         */
            function (text) {
                this._parts.push(new ParsedMessagePartText(text));
            };
        /**
         * @param {?} index
         * @param {?} disp
         * @return {?}
         */
        ParsedMessage.prototype.addPlaceholder = /**
         * @param {?} index
         * @param {?} disp
         * @return {?}
         */
            function (index, disp) {
                this._parts.push(new ParsedMessagePartPlaceholder(index, disp));
            };
        /**
         * @param {?} tagname
         * @param {?} idcounter
         * @return {?}
         */
        ParsedMessage.prototype.addStartTag = /**
         * @param {?} tagname
         * @param {?} idcounter
         * @return {?}
         */
            function (tagname, idcounter) {
                this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));
            };
        /**
         * @param {?} tagname
         * @return {?}
         */
        ParsedMessage.prototype.addEndTag = /**
         * @param {?} tagname
         * @return {?}
         */
            function (tagname) {
                /** @type {?} */
                var openTag = this.calculateOpenTagName();
                if (!openTag || openTag !== tagname) {
                    // oops, not well formed
                    throw new Error(util.format('unexpected close tag %s (currently open is %s, native xml is "%s")', tagname, openTag, this.asNativeString()));
                }
                this._parts.push(new ParsedMessagePartEndTag(tagname));
            };
        /**
         * @param {?} tagname
         * @param {?} idcounter
         * @return {?}
         */
        ParsedMessage.prototype.addEmptyTag = /**
         * @param {?} tagname
         * @param {?} idcounter
         * @return {?}
         */
            function (tagname, idcounter) {
                this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));
            };
        /**
         * @param {?} index
         * @param {?} disp
         * @return {?}
         */
        ParsedMessage.prototype.addICUMessageRef = /**
         * @param {?} index
         * @param {?} disp
         * @return {?}
         */
            function (index, disp) {
                this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));
            };
        /**
         * @param {?} text
         * @return {?}
         */
        ParsedMessage.prototype.addICUMessage = /**
         * @param {?} text
         * @return {?}
         */
            function (text) {
                this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));
            };
        /**
         * Determine, wether there is an open tag, that is not closed.
         * Returns the latest one or null, if there is no open tag.
         * @return {?}
         */
        ParsedMessage.prototype.calculateOpenTagName = /**
         * Determine, wether there is an open tag, that is not closed.
         * Returns the latest one or null, if there is no open tag.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var openTags = [];
                this._parts.forEach(function (part) {
                    switch (part.type) {
                        case ParsedMessagePartType.START_TAG:
                            openTags.push(( /** @type {?} */(part)).tagName());
                            break;
                        case ParsedMessagePartType.END_TAG:
                            /** @type {?} */
                            var tagName = ( /** @type {?} */(part)).tagName();
                            if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {
                                /** @type {?} */
                                var openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];
                                throw new Error(util.format('unexpected close tag %s (currently open is %s, native xml is "%s")', tagName, openTag, _this.asNativeString()));
                            }
                            openTags.pop();
                    }
                });
                return openTags.length === 0 ? null : openTags[openTags.length - 1];
            };
        return ParsedMessage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Created by martin on 14.05.2017.
     * A tokenizer for normalized messages.
      @type {?} */
    var TEXT$1 = 'TEXT';
    /** @type {?} */
    var START_TAG = 'START_TAG';
    /** @type {?} */
    var END_TAG = 'END_TAG';
    /** @type {?} */
    var EMPTY_TAG = 'EMPTY_TAG';
    /** @type {?} */
    var PLACEHOLDER = 'PLACEHOLDER';
    /** @type {?} */
    var ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';
    /** @type {?} */
    var ICU_MESSAGE = 'ICU_MESSAGE';
    var ParsedMesageTokenizer = /** @class */ (function () {
        function ParsedMesageTokenizer() {
        }
        /**
         * @return {?}
         */
        ParsedMesageTokenizer.prototype.getLexer = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var lexer = new Tokenizr();
                /** @type {?} */
                var plaintext = '';
                lexer.before(function (ctx, match, rule) {
                    if (rule.name !== TEXT$1 && plaintext !== '') {
                        ctx.accept(TEXT$1, { text: plaintext });
                        plaintext = '';
                    }
                });
                lexer.finish(function (ctx) {
                    if (plaintext !== '') {
                        ctx.accept(TEXT$1, { text: plaintext });
                    }
                });
                // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']
                // format is <name id="nr">, nr ist optional, z.B. <img> oder <img id="2">
                lexer.rule(/<(br|hr|img|area|link|wbr)( id="([0-9])*")?\>/, function (ctx, match) {
                    /** @type {?} */
                    var idcount = util.isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);
                    ctx.accept(EMPTY_TAG, { name: match[1], idcounter: idcount });
                }, EMPTY_TAG);
                // start tag, Format <name id="nr">, nr ist optional, z.B. <mytag> oder <mytag id="2">
                lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id="([0-9]*)")?>/, function (ctx, match) {
                    /** @type {?} */
                    var idcount = util.isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);
                    ctx.accept(START_TAG, { name: match[1], idcounter: idcount });
                }, START_TAG);
                // end tag
                lexer.rule(/<\/([a-zA-Z][a-zA-Z-0-9]*)>/, function (ctx, match) {
                    ctx.accept(END_TAG, { name: match[1] });
                }, END_TAG);
                // placeholder
                lexer.rule(/{{([0-9]+)}}/, function (ctx, match) {
                    ctx.accept(PLACEHOLDER, { idcounter: parseInt(match[1], 10) });
                }, PLACEHOLDER);
                // icu message ref
                lexer.rule(/<ICU-Message-Ref_([0-9]+)\/>/, function (ctx, match) {
                    ctx.accept(ICU_MESSAGE_REF, { idcounter: parseInt(match[1], 10) });
                }, ICU_MESSAGE_REF);
                // icu message
                lexer.rule(/<ICU-Message\/>/, function (ctx, match) {
                    ctx.accept(ICU_MESSAGE, { message: match[0] });
                }, ICU_MESSAGE);
                // text
                lexer.rule(/./, function (ctx, match) {
                    plaintext += match[0];
                    ctx.ignore();
                }, TEXT$1);
                lexer.rule(/[\t\r\n]+/, function (ctx, match) {
                    plaintext += match[0];
                    ctx.ignore();
                }, TEXT$1);
                return lexer;
            };
        /**
         * @param {?} normalizedMessage
         * @return {?}
         */
        ParsedMesageTokenizer.prototype.tokenize = /**
         * @param {?} normalizedMessage
         * @return {?}
         */
            function (normalizedMessage) {
                /** @type {?} */
                var lexer = this.getLexer();
                lexer.reset();
                lexer.input(normalizedMessage);
                return lexer.tokens();
            };
        return ParsedMesageTokenizer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by roobm on 10.05.2017.
     * A message parser can parse the xml content of a translatable message.
     * It generates a ParsedMessage from it.
     * @abstract
     */
    var /**
     * Created by roobm on 10.05.2017.
     * A message parser can parse the xml content of a translatable message.
     * It generates a ParsedMessage from it.
     * @abstract
     */ AbstractMessageParser = /** @class */ (function () {
        function AbstractMessageParser() {
        }
        /**
         * Parse XML to ParsedMessage.
         * @param {?} xmlElement the xml representation
         * @param {?} sourceMessage optional original message that will be translated by normalized new one
         * Throws an error if normalized xml is not well formed.
         * @return {?}
         */
        AbstractMessageParser.prototype.createNormalizedMessageFromXML = /**
         * Parse XML to ParsedMessage.
         * @param {?} xmlElement the xml representation
         * @param {?} sourceMessage optional original message that will be translated by normalized new one
         * Throws an error if normalized xml is not well formed.
         * @return {?}
         */
            function (xmlElement, sourceMessage) {
                /** @type {?} */
                var message = new ParsedMessage(this, sourceMessage);
                if (xmlElement) {
                    message.setXmlRepresentation(xmlElement);
                    this.addPartsOfNodeToMessage(xmlElement, message, false);
                }
                return message;
            };
        /**
         * Parse XML string to ParsedMessage.
         * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.
         * @param sourceMessage optional original message that will be translated by normalized new one
         * Throws an error if normalized xml is not well formed.
         */
        /**
         * Parse XML string to ParsedMessage.
         * @param {?} xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.
         * @param {?} sourceMessage optional original message that will be translated by normalized new one
         * Throws an error if normalized xml is not well formed.
         * @return {?}
         */
        AbstractMessageParser.prototype.createNormalizedMessageFromXMLString = /**
         * Parse XML string to ParsedMessage.
         * @param {?} xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.
         * @param {?} sourceMessage optional original message that will be translated by normalized new one
         * Throws an error if normalized xml is not well formed.
         * @return {?}
         */
            function (xmlString, sourceMessage) {
                /** @type {?} */
                var doc = new xmldom.DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');
                /** @type {?} */
                var xmlElement = /** @type {?} */ (doc.childNodes.item(0));
                return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);
            };
        /**
         * recursively run through a node and add all identified parts to the message.
         * @param {?} node node
         * @param {?} message message to be generated.
         * @param {?} includeSelf if true, add node by itself, otherwise only children.
         * @return {?}
         */
        AbstractMessageParser.prototype.addPartsOfNodeToMessage = /**
         * recursively run through a node and add all identified parts to the message.
         * @param {?} node node
         * @param {?} message message to be generated.
         * @param {?} includeSelf if true, add node by itself, otherwise only children.
         * @return {?}
         */
            function (node, message, includeSelf) {
                /** @type {?} */
                var processChildren = true;
                if (includeSelf) {
                    if (node.nodeType === node.TEXT_NODE) {
                        message.addText(node.textContent);
                        return;
                    }
                    if (node.nodeType === node.ELEMENT_NODE) {
                        processChildren = this.processStartElement(/** @type {?} */ (node), message);
                    }
                }
                if (processChildren) {
                    /** @type {?} */
                    var icuMessageText = this.getICUMessageText(node);
                    /** @type {?} */
                    var isICU = !util.isNullOrUndefined(icuMessageText);
                    if (isICU) {
                        try {
                            message.addICUMessage(icuMessageText);
                        }
                        catch (error) {
                            // if it is not parsable, handle it as non ICU
                            console.log('non ICU message: ', icuMessageText, error);
                            isICU = false;
                        }
                    }
                    if (!isICU) {
                        /** @type {?} */
                        var children = node.childNodes;
                        for (var i = 0; i < children.length; i++) {
                            this.addPartsOfNodeToMessage(children.item(i), message, true);
                        }
                    }
                }
                if (node.nodeType === node.ELEMENT_NODE) {
                    this.processEndElement(/** @type {?} */ (node), message);
                }
            };
        /**
         * Return the ICU message content of the node, if it is an ICU Message.
         * @param node node
         * @return message or null, if it is no ICU Message.
         */
        /**
         * Return the ICU message content of the node, if it is an ICU Message.
         * @param {?} node node
         * @return {?} message or null, if it is no ICU Message.
         */
        AbstractMessageParser.prototype.getICUMessageText = /**
         * Return the ICU message content of the node, if it is an ICU Message.
         * @param {?} node node
         * @return {?} message or null, if it is no ICU Message.
         */
            function (node) {
                /** @type {?} */
                var children = node.childNodes;
                if (children.length === 0) {
                    return null;
                }
                /** @type {?} */
                var firstChild = children.item(0);
                if (firstChild.nodeType === firstChild.TEXT_NODE) {
                    if (this.isICUMessageStart(firstChild.textContent)) {
                        return DOMUtilities.getXMLContent(/** @type {?} */ (node));
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            };
        /**
         * Test, wether text is beginning of ICU Message.
         * @param {?} text text
         * @return {?}
         */
        AbstractMessageParser.prototype.isICUMessageStart = /**
         * Test, wether text is beginning of ICU Message.
         * @param {?} text text
         * @return {?}
         */
            function (text) {
                return ParsedMessagePartICUMessage.looksLikeICUMessage(text);
                //        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');
            };
        /**
         * Parse normalized string to ParsedMessage.
         * @param {?} normalizedString normalized string
         * @param {?} sourceMessage optional original message that will be translated by normalized new one
         * @return {?} a new parsed message.
         * Throws an error if normalized string is not well formed.
         */
        AbstractMessageParser.prototype.parseNormalizedString = /**
         * Parse normalized string to ParsedMessage.
         * @param {?} normalizedString normalized string
         * @param {?} sourceMessage optional original message that will be translated by normalized new one
         * @return {?} a new parsed message.
         * Throws an error if normalized string is not well formed.
         */
            function (normalizedString, sourceMessage) {
                /** @type {?} */
                var message = new ParsedMessage(this, sourceMessage);
                /** @type {?} */
                var openTags = [];
                /** @type {?} */
                var tokens;
                try {
                    tokens = new ParsedMesageTokenizer().tokenize(normalizedString);
                }
                catch (error) {
                    throw new Error(util.format('unexpected error while parsing message: "%s" (parsed "%")', error.message, normalizedString));
                }
                tokens.forEach(function (token) {
                    /** @type {?} */
                    var disp = null;
                    switch (token.type) {
                        case TEXT$1:
                            message.addText(token.value.text);
                            break;
                        case START_TAG:
                            message.addStartTag(token.value.name, token.value.idcounter);
                            openTags.push(token.value.name);
                            break;
                        case END_TAG:
                            message.addEndTag(token.value.name);
                            if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {
                                // oops, not well formed
                                throw new Error(util.format('unexpected close tag "%s" (parsed "%s")', token.value.name, normalizedString));
                            }
                            openTags.pop();
                            break;
                        case EMPTY_TAG:
                            message.addEmptyTag(token.value.name, token.value.idcounter);
                            break;
                        case PLACEHOLDER:
                            disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;
                            message.addPlaceholder(token.value.idcounter, disp);
                            break;
                        case ICU_MESSAGE_REF:
                            disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;
                            message.addICUMessageRef(token.value.idcounter, disp);
                            break;
                        case ICU_MESSAGE:
                            throw new Error(util.format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed "%")', normalizedString));
                        default:
                            break;
                    }
                });
                if (openTags.length > 0) {
                    // oops, not well closed tags
                    throw new Error(util.format('missing close tag "%s" (parsed "%s")', openTags[openTags.length - 1], normalizedString));
                }
                message.setXmlRepresentation(this.createXmlRepresentation(message));
                return message;
            };
        /**
         * Parse a string, that is an ICU message, to ParsedMessage.
         * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.
         * @param sourceMessage optional original message that will be translated by normalized new one
         * @return a new parsed message.
         * Throws an error if icuMessageString has not the correct syntax.
         */
        /**
         * Parse a string, that is an ICU message, to ParsedMessage.
         * @param {?} icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.
         * @param {?} sourceMessage optional original message that will be translated by normalized new one
         * @return {?} a new parsed message.
         * Throws an error if icuMessageString has not the correct syntax.
         */
        AbstractMessageParser.prototype.parseICUMessage = /**
         * Parse a string, that is an ICU message, to ParsedMessage.
         * @param {?} icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.
         * @param {?} sourceMessage optional original message that will be translated by normalized new one
         * @return {?} a new parsed message.
         * Throws an error if icuMessageString has not the correct syntax.
         */
            function (icuMessageString, sourceMessage) {
                /** @type {?} */
                var message = new ParsedMessage(this, sourceMessage);
                message.addICUMessage(icuMessageString);
                return message;
            };
        /**
         * Helper function: Parse ID from a name.
         * name optionally ends with _<number>. This is the idcount.
         * E.g. name="TAG_IMG" returns 0
         * name = "TAG_IMG_1" returns 1
         * @param name name
         * @return id count
         */
        /**
         * Helper function: Parse ID from a name.
         * name optionally ends with _<number>. This is the idcount.
         * E.g. name="TAG_IMG" returns 0
         * name = "TAG_IMG_1" returns 1
         * @param {?} name name
         * @return {?} id count
         */
        AbstractMessageParser.prototype.parseIdCountFromName = /**
         * Helper function: Parse ID from a name.
         * name optionally ends with _<number>. This is the idcount.
         * E.g. name="TAG_IMG" returns 0
         * name = "TAG_IMG_1" returns 1
         * @param {?} name name
         * @return {?} id count
         */
            function (name) {
                /** @type {?} */
                var regex = /.*_([0-9]*)/;
                /** @type {?} */
                var match = regex.exec(name);
                if (util.isNullOrUndefined(match) || match[1] === '') {
                    return 0;
                }
                else {
                    /** @type {?} */
                    var num = match[1];
                    return parseInt(num, 10);
                }
            };
        /**
         * Create the native xml for a message.
         * Parts are already set here.
         * @param message message
         */
        /**
         * Create the native xml for a message.
         * Parts are already set here.
         * @param {?} message message
         * @return {?}
         */
        AbstractMessageParser.prototype.createXmlRepresentation = /**
         * Create the native xml for a message.
         * Parts are already set here.
         * @param {?} message message
         * @return {?}
         */
            function (message) {
                /** @type {?} */
                var root = new xmldom.DOMParser().parseFromString('<dummy/>', 'text/xml');
                /** @type {?} */
                var rootElem = root.getElementsByTagName('dummy').item(0);
                this.addXmlRepresentationToRoot(message, rootElem);
                return rootElem;
            };
        /**
         * @param {?} part
         * @param {?} rootElem
         * @return {?}
         */
        AbstractMessageParser.prototype.createXmlRepresentationOfTextPart = /**
         * @param {?} part
         * @param {?} rootElem
         * @return {?}
         */
            function (part, rootElem) {
                return rootElem.ownerDocument.createTextNode(part.asDisplayString());
            };
        return AbstractMessageParser;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Created by roobm on 16.05.2017.
     * Mapping from normalized tag names to placeholder names.
      @type {?} */
    var TAG_TO_PLACEHOLDER_NAMES = {
        'A': 'LINK',
        'B': 'BOLD_TEXT',
        'BR': 'LINE_BREAK',
        'EM': 'EMPHASISED_TEXT',
        'H1': 'HEADING_LEVEL1',
        'H2': 'HEADING_LEVEL2',
        'H3': 'HEADING_LEVEL3',
        'H4': 'HEADING_LEVEL4',
        'H5': 'HEADING_LEVEL5',
        'H6': 'HEADING_LEVEL6',
        'HR': 'HORIZONTAL_RULE',
        'I': 'ITALIC_TEXT',
        'LI': 'LIST_ITEM',
        'LINK': 'MEDIA_LINK',
        'OL': 'ORDERED_LIST',
        'P': 'PARAGRAPH',
        'Q': 'QUOTATION',
        'S': 'STRIKETHROUGH_TEXT',
        'SMALL': 'SMALL_TEXT',
        'SUB': 'SUBSTRIPT',
        'SUP': 'SUPERSCRIPT',
        'TBODY': 'TABLE_BODY',
        'TD': 'TABLE_CELL',
        'TFOOT': 'TABLE_FOOTER',
        'TH': 'TABLE_HEADER_CELL',
        'THEAD': 'TABLE_HEADER',
        'TR': 'TABLE_ROW',
        'TT': 'MONOSPACED_TEXT',
        'U': 'UNDERLINED_TEXT',
        'UL': 'UNORDERED_LIST',
    };
    /** *
     * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.
      @type {?} */
    var VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];
    var TagMapping = /** @class */ (function () {
        function TagMapping() {
        }
        /**
         * @param {?} tag
         * @param {?} id
         * @return {?}
         */
        TagMapping.prototype.getStartTagPlaceholderName = /**
         * @param {?} tag
         * @param {?} id
         * @return {?}
         */
            function (tag, id) {
                /** @type {?} */
                var upperTag = tag.toUpperCase();
                /** @type {?} */
                var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
                return "START_" + baseName + this.counterString(id);
            };
        /**
         * @param {?} tag
         * @return {?}
         */
        TagMapping.prototype.getCloseTagPlaceholderName = /**
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                /** @type {?} */
                var upperTag = tag.toUpperCase();
                /** @type {?} */
                var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
                return "CLOSE_" + baseName;
            };
        /**
         * @param {?} tag
         * @param {?} id
         * @return {?}
         */
        TagMapping.prototype.getEmptyTagPlaceholderName = /**
         * @param {?} tag
         * @param {?} id
         * @return {?}
         */
            function (tag, id) {
                /** @type {?} */
                var upperTag = tag.toUpperCase();
                /** @type {?} */
                var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
                return baseName + this.counterString(id);
            };
        /**
         * @param {?} tag
         * @return {?}
         */
        TagMapping.prototype.getCtypeForTag = /**
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                switch (tag.toLowerCase()) {
                    case 'br':
                        return 'lb';
                    case 'img':
                        return 'image';
                    default:
                        return "x-" + tag;
                }
            };
        /**
         * @param {?} placeholderName
         * @return {?}
         */
        TagMapping.prototype.getTagnameFromStartTagPlaceholderName = /**
         * @param {?} placeholderName
         * @return {?}
         */
            function (placeholderName) {
                if (placeholderName.startsWith('START_TAG_')) {
                    return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();
                }
                else if (placeholderName.startsWith('START_')) {
                    /** @type {?} */
                    var ph_1 = this.stripCounter(placeholderName.substring('START_'.length));
                    /** @type {?} */
                    var matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find(function (key) { return TAG_TO_PLACEHOLDER_NAMES[key] === ph_1; });
                    return matchKey ? matchKey.toLowerCase() : null;
                }
                return null;
            };
        /**
         * @param {?} placeholderName
         * @return {?}
         */
        TagMapping.prototype.getTagnameFromCloseTagPlaceholderName = /**
         * @param {?} placeholderName
         * @return {?}
         */
            function (placeholderName) {
                if (placeholderName.startsWith('CLOSE_TAG_')) {
                    return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();
                }
                else if (placeholderName.startsWith('CLOSE_')) {
                    /** @type {?} */
                    var ph_2 = this.stripCounter(placeholderName.substring('CLOSE_'.length));
                    /** @type {?} */
                    var matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find(function (key) { return TAG_TO_PLACEHOLDER_NAMES[key] === ph_2; });
                    return matchKey ? matchKey.toLowerCase() : null;
                }
                return null;
            };
        /**
         * Test, wether placeholder name stands for empty html tag.
         * @param {?} placeholderName can be TAG_<name> or just <name>
         * @return {?}
         */
        TagMapping.prototype.isEmptyTagPlaceholderName = /**
         * Test, wether placeholder name stands for empty html tag.
         * @param {?} placeholderName can be TAG_<name> or just <name>
         * @return {?}
         */
            function (placeholderName) {
                /** @type {?} */
                var ph = this.stripCounter(placeholderName);
                /** @type {?} */
                var matchKey;
                if (ph.startsWith('TAG_')) {
                    matchKey = ph.substring(4).toUpperCase();
                }
                else {
                    matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find(function (key) { return TAG_TO_PLACEHOLDER_NAMES[key] === ph; });
                }
                if (matchKey) {
                    if (VOID_TAGS.indexOf(matchKey) >= 0) {
                        return true;
                    }
                }
                return false;
            };
        /**
         * tagname of empty tag placeholder.
         * @param {?} placeholderName can be TAG_<name> or just <name>
         * @return {?}
         */
        TagMapping.prototype.getTagnameFromEmptyTagPlaceholderName = /**
         * tagname of empty tag placeholder.
         * @param {?} placeholderName can be TAG_<name> or just <name>
         * @return {?}
         */
            function (placeholderName) {
                /** @type {?} */
                var ph = this.stripCounter(placeholderName);
                /** @type {?} */
                var matchKey;
                if (ph.startsWith('TAG_')) {
                    matchKey = ph.substring(4).toUpperCase();
                }
                else {
                    matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find(function (key) { return TAG_TO_PLACEHOLDER_NAMES[key] === ph; });
                }
                if (matchKey) {
                    if (VOID_TAGS.indexOf(matchKey) >= 0) {
                        return matchKey.toLowerCase();
                    }
                    else {
                        return null;
                    }
                }
                return null;
            };
        /**
         * If placeholder ends with _[0-9]+, strip that number.
         * @param {?} placeholderName placeholderName
         * @return {?} placeholderName without counter at end.
         */
        TagMapping.prototype.stripCounter = /**
         * If placeholder ends with _[0-9]+, strip that number.
         * @param {?} placeholderName placeholderName
         * @return {?} placeholderName without counter at end.
         */
            function (placeholderName) {
                if (placeholderName) {
                    /** @type {?} */
                    var re = /(.*)_[0-9]+$/;
                    if (placeholderName.match(re)) {
                        return placeholderName.replace(re, '$1');
                    }
                }
                return placeholderName;
            };
        /**
         * String suffix for counter.
         * If counter is 0, it is empty, otherwise _<id>.
         * @param {?} id id
         * @return {?} suffix for counter.
         */
        TagMapping.prototype.counterString = /**
         * String suffix for counter.
         * If counter is 0, it is empty, otherwise _<id>.
         * @param {?} id id
         * @return {?} suffix for counter.
         */
            function (id) {
                if (id === 0) {
                    return '';
                }
                else {
                    return '_' + id.toString(10);
                }
            };
        return TagMapping;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by roobm on 10.05.2017.
     * A message parser for XLIFF 1.2
     */
    var /**
     * Created by roobm on 10.05.2017.
     * A message parser for XLIFF 1.2
     */ XliffMessageParser = /** @class */ (function (_super) {
        __extends(XliffMessageParser, _super);
        function XliffMessageParser() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Handle this element node.
         * This is called before the children are done.
         * @param elementNode elementNode
         * @param message message to be altered
         * @return true, if children should be processed too, false otherwise (children ignored then)
         */
        /**
         * Handle this element node.
         * This is called before the children are done.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?} true, if children should be processed too, false otherwise (children ignored then)
         */
        XliffMessageParser.prototype.processStartElement = /**
         * Handle this element node.
         * This is called before the children are done.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?} true, if children should be processed too, false otherwise (children ignored then)
         */
            function (elementNode, message) {
                /** @type {?} */
                var tagName = elementNode.tagName;
                /** @type {?} */
                var tagMapping = new TagMapping();
                if (tagName === 'x') {
                    /** @type {?} */
                    var id = elementNode.getAttribute('id');
                    if (!id) {
                        return; // should not happen
                    }
                    if (id.startsWith('INTERPOLATION')) {
                        /** @type {?} */
                        var index = this.parsePlaceholderIndexFromId(id);
                        message.addPlaceholder(index, null);
                    }
                    else if (id.startsWith('ICU')) {
                        /** @type {?} */
                        var index = this.parseICUMessageRefIndexFromId(id);
                        message.addICUMessageRef(index, null);
                    }
                    else if (id.startsWith('START_')) {
                        /** @type {?} */
                        var normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);
                        if (normalizedTagName) {
                            /** @type {?} */
                            var idcount = this.parseIdCountFromName(id);
                            message.addStartTag(normalizedTagName, idcount);
                        }
                    }
                    else if (id.startsWith('CLOSE_')) {
                        /** @type {?} */
                        var normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);
                        if (normalizedTagName) {
                            message.addEndTag(normalizedTagName);
                        }
                    }
                    else if (tagMapping.isEmptyTagPlaceholderName(id)) {
                        /** @type {?} */
                        var normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);
                        if (normalizedTagName) {
                            /** @type {?} */
                            var idcount = this.parseIdCountFromName(id);
                            message.addEmptyTag(normalizedTagName, idcount);
                        }
                    }
                }
                return true;
            };
        /**
         * Handle end of this element node.
         * This is called after all children are processed.
         * @param elementNode elementNode
         * @param message message to be altered
         */
        /**
         * Handle end of this element node.
         * This is called after all children are processed.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?}
         */
        XliffMessageParser.prototype.processEndElement = /**
         * Handle end of this element node.
         * This is called after all children are processed.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?}
         */
            function (elementNode, message) {
            };
        /**
         * Parse id attribute of x element as placeholder index.
         * id can be "INTERPOLATION" or "INTERPOLATION_n"
         * @param {?} id id
         * @return {?} index
         */
        XliffMessageParser.prototype.parsePlaceholderIndexFromId = /**
         * Parse id attribute of x element as placeholder index.
         * id can be "INTERPOLATION" or "INTERPOLATION_n"
         * @param {?} id id
         * @return {?} index
         */
            function (id) {
                /** @type {?} */
                var indexString = '';
                if (id === 'INTERPOLATION') {
                    indexString = '0';
                }
                else {
                    indexString = id.substring('INTERPOLATION_'.length);
                }
                return Number.parseInt(indexString, 10);
            };
        /**
         * Parse id attribute of x element as placeholder index.
         * id can be "INTERPOLATION" or "INTERPOLATION_n"
         * @param {?} id id
         * @return {?} id as number
         */
        XliffMessageParser.prototype.parseICUMessageRefIndexFromId = /**
         * Parse id attribute of x element as placeholder index.
         * id can be "INTERPOLATION" or "INTERPOLATION_n"
         * @param {?} id id
         * @return {?} id as number
         */
            function (id) {
                /** @type {?} */
                var indexString = '';
                if (id === 'ICU') {
                    indexString = '0';
                }
                else {
                    indexString = id.substring('ICU_'.length);
                }
                return Number.parseInt(indexString, 10);
            };
        /**
         * @param {?} message
         * @param {?} rootElem
         * @return {?}
         */
        XliffMessageParser.prototype.addXmlRepresentationToRoot = /**
         * @param {?} message
         * @param {?} rootElem
         * @return {?}
         */
            function (message, rootElem) {
                var _this = this;
                message.parts().forEach(function (part) {
                    /** @type {?} */
                    var child;
                    switch (part.type) {
                        case ParsedMessagePartType.TEXT:
                            child = _this.createXmlRepresentationOfTextPart(/** @type {?} */ (part), rootElem);
                            break;
                        case ParsedMessagePartType.START_TAG:
                            child = _this.createXmlRepresentationOfStartTagPart(( /** @type {?} */(part)), rootElem);
                            break;
                        case ParsedMessagePartType.END_TAG:
                            child = _this.createXmlRepresentationOfEndTagPart(( /** @type {?} */(part)), rootElem);
                            break;
                        case ParsedMessagePartType.EMPTY_TAG:
                            child = _this.createXmlRepresentationOfEmptyTagPart(( /** @type {?} */(part)), rootElem);
                            break;
                        case ParsedMessagePartType.PLACEHOLDER:
                            child = _this.createXmlRepresentationOfPlaceholderPart(( /** @type {?} */(part)), rootElem);
                            break;
                        case ParsedMessagePartType.ICU_MESSAGE_REF:
                            child = _this.createXmlRepresentationOfICUMessageRefPart(( /** @type {?} */(part)), rootElem);
                            break;
                    }
                    if (child) {
                        rootElem.appendChild(child);
                    }
                });
            };
        /**
         * the xml used for start tag in the message.
         * Returns an empty <x/>-Element with attributes id and ctype
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for start tag in the message.
         * Returns an empty <x/>-Element with attributes id and ctype
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XliffMessageParser.prototype.createXmlRepresentationOfStartTagPart = /**
         * the xml used for start tag in the message.
         * Returns an empty <x/>-Element with attributes id and ctype
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var xElem = rootElem.ownerDocument.createElement('x');
                /** @type {?} */
                var tagMapping = new TagMapping();
                /** @type {?} */
                var idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());
                /** @type {?} */
                var ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());
                /** @type {?} */
                var equivTextAttr = '<' + part.tagName() + '>';
                xElem.setAttribute('id', idAttrib);
                xElem.setAttribute('ctype', ctypeAttrib);
                xElem.setAttribute('equiv-text', equivTextAttr);
                return xElem;
            };
        /**
         * the xml used for end tag in the message.
         * Returns an empty <x/>-Element with attributes id and ctype
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for end tag in the message.
         * Returns an empty <x/>-Element with attributes id and ctype
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XliffMessageParser.prototype.createXmlRepresentationOfEndTagPart = /**
         * the xml used for end tag in the message.
         * Returns an empty <x/>-Element with attributes id and ctype
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var xElem = rootElem.ownerDocument.createElement('x');
                /** @type {?} */
                var tagMapping = new TagMapping();
                /** @type {?} */
                var idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());
                /** @type {?} */
                var ctypeAttrib = 'x-' + part.tagName();
                xElem.setAttribute('id', idAttrib);
                xElem.setAttribute('ctype', ctypeAttrib);
                return xElem;
            };
        /**
         * the xml used for empty tag in the message.
         * Returns an empty <x/>-Element with attributes id and ctype
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for empty tag in the message.
         * Returns an empty <x/>-Element with attributes id and ctype
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XliffMessageParser.prototype.createXmlRepresentationOfEmptyTagPart = /**
         * the xml used for empty tag in the message.
         * Returns an empty <x/>-Element with attributes id and ctype
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var xElem = rootElem.ownerDocument.createElement('x');
                /** @type {?} */
                var tagMapping = new TagMapping();
                /** @type {?} */
                var idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());
                /** @type {?} */
                var ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());
                /** @type {?} */
                var equivTextAttr = '<' + part.tagName() + '/>';
                xElem.setAttribute('id', idAttrib);
                xElem.setAttribute('ctype', ctypeAttrib);
                xElem.setAttribute('equiv-text', equivTextAttr);
                return xElem;
            };
        /**
         * the xml used for placeholder in the message.
         * Returns an empty <x/>-Element with attribute id="INTERPOLATION" or id="INTERPOLATION_n"
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for placeholder in the message.
         * Returns an empty <x/>-Element with attribute id="INTERPOLATION" or id="INTERPOLATION_n"
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XliffMessageParser.prototype.createXmlRepresentationOfPlaceholderPart = /**
         * the xml used for placeholder in the message.
         * Returns an empty <x/>-Element with attribute id="INTERPOLATION" or id="INTERPOLATION_n"
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var xElem = rootElem.ownerDocument.createElement('x');
                /** @type {?} */
                var idAttrib = 'INTERPOLATION';
                if (part.index() > 0) {
                    idAttrib = 'INTERPOLATION_' + part.index().toString(10);
                }
                /** @type {?} */
                var equivTextAttr = part.disp();
                xElem.setAttribute('id', idAttrib);
                if (equivTextAttr) {
                    xElem.setAttribute('equiv-text', equivTextAttr);
                }
                return xElem;
            };
        /**
         * the xml used for icu message refs in the message.
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for icu message refs in the message.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XliffMessageParser.prototype.createXmlRepresentationOfICUMessageRefPart = /**
         * the xml used for icu message refs in the message.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var xElem = rootElem.ownerDocument.createElement('x');
                /** @type {?} */
                var idAttrib = 'ICU';
                if (part.index() > 0) {
                    idAttrib = 'ICU_' + part.index().toString(10);
                }
                xElem.setAttribute('id', idAttrib);
                return xElem;
            };
        return XliffMessageParser;
    }(AbstractMessageParser));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 01.05.2017.
     * A Translation Unit in an XLIFF 1.2 file.
     */
    var /**
     * Created by martin on 01.05.2017.
     * A Translation Unit in an XLIFF 1.2 file.
     */ XliffTransUnit = /** @class */ (function (_super) {
        __extends(XliffTransUnit, _super);
        function XliffTransUnit(_element, _id, _translationMessagesFile) {
            return _super.call(this, _element, _id, _translationMessagesFile) || this;
        }
        /**
         * @return {?}
         */
        XliffTransUnit.prototype.sourceContent = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                return DOMUtilities.getXMLContent(sourceElement);
            };
        /**
         * Set new source content in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing changed source content.
         * @param {?} newContent the new content.
         * @return {?}
         */
        XliffTransUnit.prototype.setSourceContent = /**
         * Set new source content in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing changed source content.
         * @param {?} newContent the new content.
         * @return {?}
         */
            function (newContent) {
                /** @type {?} */
                var source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                if (!source) {
                    // should not happen, there always has to be a source, but who knows..
                    source = this._element.appendChild(this._element.ownerDocument.createElement('source'));
                }
                DOMUtilities.replaceContentWithXMLContent(source, newContent);
            };
        /**
         * Return a parser used for normalized messages.
         */
        /**
         * Return a parser used for normalized messages.
         * @return {?}
         */
        XliffTransUnit.prototype.messageParser = /**
         * Return a parser used for normalized messages.
         * @return {?}
         */
            function () {
                return new XliffMessageParser();
            };
        /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
        XliffTransUnit.prototype.createSourceContentNormalized = /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                if (sourceElement) {
                    return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);
                }
                else {
                    return null;
                }
            };
        /**
         * the translated value (containing all markup, depends on the concrete format used).
         * @return {?}
         */
        XliffTransUnit.prototype.targetContent = /**
         * the translated value (containing all markup, depends on the concrete format used).
         * @return {?}
         */
            function () {
                /** @type {?} */
                var targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                return DOMUtilities.getXMLContent(targetElement);
            };
        /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         */
        /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         * @return {?}
         */
        XliffTransUnit.prototype.targetContentNormalized = /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());
            };
        /**
         * State of the translation as stored in the xml.
         * @return {?}
         */
        XliffTransUnit.prototype.nativeTargetState = /**
         * State of the translation as stored in the xml.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                if (targetElement) {
                    return targetElement.getAttribute('state');
                }
                else {
                    return null;
                }
            };
        /**
         * set state in xml.
         * @param nativeState nativeState
         */
        /**
         * set state in xml.
         * @param {?} nativeState nativeState
         * @return {?}
         */
        XliffTransUnit.prototype.setNativeTargetState = /**
         * set state in xml.
         * @param {?} nativeState nativeState
         * @return {?}
         */
            function (nativeState) {
                /** @type {?} */
                var targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                if (targetElement) {
                    targetElement.setAttribute('state', nativeState);
                }
            };
        /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @param state one of Constants.STATE...
         * @returns a native state (depends on concrete format)
         * @throws error, if state is invalid.
         */
        /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @throws error, if state is invalid.
         * @param {?} state one of Constants.STATE...
         * @return {?} a native state (depends on concrete format)
         */
        XliffTransUnit.prototype.mapStateToNativeState = /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @throws error, if state is invalid.
         * @param {?} state one of Constants.STATE...
         * @return {?} a native state (depends on concrete format)
         */
            function (state) {
                switch (state) {
                    case STATE_NEW:
                        return 'new';
                    case STATE_TRANSLATED:
                        return 'translated';
                    case STATE_FINAL:
                        return 'final';
                    default:
                        throw new Error('unknown state ' + state);
                }
            };
        /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param nativeState nativeState
         */
        /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param {?} nativeState nativeState
         * @return {?}
         */
        XliffTransUnit.prototype.mapNativeStateToState = /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param {?} nativeState nativeState
         * @return {?}
         */
            function (nativeState) {
                switch (nativeState) {
                    case 'new':
                        return STATE_NEW;
                    case 'needs-translation':
                        return STATE_NEW;
                    case 'translated':
                        return STATE_TRANSLATED;
                    case 'needs-adaptation':
                        return STATE_TRANSLATED;
                    case 'needs-l10n':
                        return STATE_TRANSLATED;
                    case 'needs-review-adaptation':
                        return STATE_TRANSLATED;
                    case 'needs-review-l10n':
                        return STATE_TRANSLATED;
                    case 'needs-review-translation':
                        return STATE_TRANSLATED;
                    case 'final':
                        return STATE_FINAL;
                    case 'signed-off':
                        return STATE_FINAL;
                    default:
                        return STATE_NEW;
                }
            };
        /**
         * All the source elements in the trans unit.
         * The source element is a reference to the original template.
         * It contains the name of the template file and a line number with the position inside the template.
         * It is just a help for translators to find the context for the translation.
         * This is set when using Angular 4.0 or greater.
         * Otherwise it just returns an empty array.
         * @return {?}
         */
        XliffTransUnit.prototype.sourceReferences = /**
         * All the source elements in the trans unit.
         * The source element is a reference to the original template.
         * It contains the name of the template file and a line number with the position inside the template.
         * It is just a help for translators to find the context for the translation.
         * This is set when using Angular 4.0 or greater.
         * Otherwise it just returns an empty array.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceElements = this._element.getElementsByTagName('context-group');
                /** @type {?} */
                var sourceRefs = [];
                for (var i = 0; i < sourceElements.length; i++) {
                    /** @type {?} */
                    var elem = sourceElements.item(i);
                    if (elem.getAttribute('purpose') === 'location') {
                        /** @type {?} */
                        var contextElements = elem.getElementsByTagName('context');
                        /** @type {?} */
                        var sourcefile = null;
                        /** @type {?} */
                        var linenumber = 0;
                        for (var j = 0; j < contextElements.length; j++) {
                            /** @type {?} */
                            var contextElem = contextElements.item(j);
                            if (contextElem.getAttribute('context-type') === 'sourcefile') {
                                sourcefile = DOMUtilities.getPCDATA(contextElem);
                            }
                            if (contextElem.getAttribute('context-type') === 'linenumber') {
                                linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);
                            }
                        }
                        sourceRefs.push({ sourcefile: sourcefile, linenumber: linenumber });
                    }
                }
                return sourceRefs;
            };
        /**
         * Set source ref elements in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing source refs.
         * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
         * @return {?}
         */
        XliffTransUnit.prototype.setSourceReferences = /**
         * Set source ref elements in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing source refs.
         * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
         * @return {?}
         */
            function (sourceRefs) {
                var _this = this;
                this.removeAllSourceReferences();
                sourceRefs.forEach(function (ref) {
                    /** @type {?} */
                    var contextGroup = _this._element.ownerDocument.createElement('context-group');
                    contextGroup.setAttribute('purpose', 'location');
                    /** @type {?} */
                    var contextSource = _this._element.ownerDocument.createElement('context');
                    contextSource.setAttribute('context-type', 'sourcefile');
                    contextSource.appendChild(_this._element.ownerDocument.createTextNode(ref.sourcefile));
                    /** @type {?} */
                    var contextLine = _this._element.ownerDocument.createElement('context');
                    contextLine.setAttribute('context-type', 'linenumber');
                    contextLine.appendChild(_this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));
                    contextGroup.appendChild(contextSource);
                    contextGroup.appendChild(contextLine);
                    _this._element.appendChild(contextGroup);
                });
            };
        /**
         * @return {?}
         */
        XliffTransUnit.prototype.removeAllSourceReferences = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceElements = this._element.getElementsByTagName('context-group');
                /** @type {?} */
                var toBeRemoved = [];
                for (var i = 0; i < sourceElements.length; i++) {
                    /** @type {?} */
                    var elem = sourceElements.item(i);
                    if (elem.getAttribute('purpose') === 'location') {
                        toBeRemoved.push(elem);
                    }
                }
                toBeRemoved.forEach(function (elem) { elem.parentNode.removeChild(elem); });
            };
        /**
         * The description set in the template as value of the i18n-attribute.
         * e.g. i18n="mydescription".
         * In xliff this is stored as a note element with attribute from="description".
         * @return {?}
         */
        XliffTransUnit.prototype.description = /**
         * The description set in the template as value of the i18n-attribute.
         * e.g. i18n="mydescription".
         * In xliff this is stored as a note element with attribute from="description".
         * @return {?}
         */
            function () {
                /** @type {?} */
                var noteElem = this.findNoteElementWithFromAttribute('description');
                if (noteElem) {
                    return DOMUtilities.getPCDATA(noteElem);
                }
                else {
                    return null;
                }
            };
        /**
         * Change description property of trans-unit.
         * @param {?} description description
         * @return {?}
         */
        XliffTransUnit.prototype.setDescription = /**
         * Change description property of trans-unit.
         * @param {?} description description
         * @return {?}
         */
            function (description) {
                /** @type {?} */
                var noteElem = this.findNoteElementWithFromAttribute('description');
                if (description) {
                    if (util.isNullOrUndefined(noteElem)) {
                        // create it
                        noteElem = this.createNoteElementWithFromAttribute('description', description);
                    }
                    else {
                        DOMUtilities.replaceContentWithXMLContent(noteElem, description);
                    }
                }
                else {
                    if (!util.isNullOrUndefined(noteElem)) {
                        // remove node
                        this.removeNoteElementWithFromAttribute('description');
                    }
                }
            };
        /**
         * Find a note element with attribute from='<attrValue>'
         * @param {?} attrValue attrValue
         * @return {?} element or null is absent
         */
        XliffTransUnit.prototype.findNoteElementWithFromAttribute = /**
         * Find a note element with attribute from='<attrValue>'
         * @param {?} attrValue attrValue
         * @return {?} element or null is absent
         */
            function (attrValue) {
                /** @type {?} */
                var noteElements = this._element.getElementsByTagName('note');
                for (var i = 0; i < noteElements.length; i++) {
                    /** @type {?} */
                    var noteElem = noteElements.item(i);
                    if (noteElem.getAttribute('from') === attrValue) {
                        return noteElem;
                    }
                }
                return null;
            };
        /**
         * Get all note elements where from attribute is not description or meaning
         * @return {?} elements
         */
        XliffTransUnit.prototype.findAllAdditionalNoteElements = /**
         * Get all note elements where from attribute is not description or meaning
         * @return {?} elements
         */
            function () {
                /** @type {?} */
                var noteElements = this._element.getElementsByTagName('note');
                /** @type {?} */
                var result = [];
                for (var i = 0; i < noteElements.length; i++) {
                    /** @type {?} */
                    var noteElem = noteElements.item(i);
                    /** @type {?} */
                    var fromAttribute = noteElem.getAttribute('from');
                    if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {
                        result.push(noteElem);
                    }
                }
                return result;
            };
        /**
         * Create a new note element with attribute from='<attrValue>'
         * @param {?} fromAttrValue value of "from" attribute
         * @param {?} content text value of note element
         * @return {?} the new created element
         */
        XliffTransUnit.prototype.createNoteElementWithFromAttribute = /**
         * Create a new note element with attribute from='<attrValue>'
         * @param {?} fromAttrValue value of "from" attribute
         * @param {?} content text value of note element
         * @return {?} the new created element
         */
            function (fromAttrValue, content) {
                /** @type {?} */
                var noteElement = this._element.ownerDocument.createElement('note');
                if (fromAttrValue) {
                    noteElement.setAttribute('from', fromAttrValue);
                }
                noteElement.setAttribute('priority', '1');
                if (content) {
                    DOMUtilities.replaceContentWithXMLContent(noteElement, content);
                }
                this._element.appendChild(noteElement);
                return noteElement;
            };
        /**
         * Remove note element with attribute from='<attrValue>'
         * @param {?} attrValue attrValue
         * @return {?}
         */
        XliffTransUnit.prototype.removeNoteElementWithFromAttribute = /**
         * Remove note element with attribute from='<attrValue>'
         * @param {?} attrValue attrValue
         * @return {?}
         */
            function (attrValue) {
                /** @type {?} */
                var noteElement = this.findNoteElementWithFromAttribute(attrValue);
                if (noteElement) {
                    this._element.removeChild(noteElement);
                }
            };
        /**
         * Remove all note elements where attribute "from" is not description or meaning.
         * @return {?}
         */
        XliffTransUnit.prototype.removeAllAdditionalNoteElements = /**
         * Remove all note elements where attribute "from" is not description or meaning.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var noteElements = this.findAllAdditionalNoteElements();
                noteElements.forEach(function (noteElement) {
                    _this._element.removeChild(noteElement);
                });
            };
        /**
         * The meaning (intent) set in the template as value of the i18n-attribute.
         * This is the part in front of the | symbol.
         * e.g. i18n="meaning|mydescription".
         * In xliff this is stored as a note element with attribute from="meaning".
         * @return {?}
         */
        XliffTransUnit.prototype.meaning = /**
         * The meaning (intent) set in the template as value of the i18n-attribute.
         * This is the part in front of the | symbol.
         * e.g. i18n="meaning|mydescription".
         * In xliff this is stored as a note element with attribute from="meaning".
         * @return {?}
         */
            function () {
                /** @type {?} */
                var noteElem = this.findNoteElementWithFromAttribute('meaning');
                if (noteElem) {
                    return DOMUtilities.getPCDATA(noteElem);
                }
                else {
                    return null;
                }
            };
        /**
         * Change meaning property of trans-unit.
         * @param {?} meaning meaning
         * @return {?}
         */
        XliffTransUnit.prototype.setMeaning = /**
         * Change meaning property of trans-unit.
         * @param {?} meaning meaning
         * @return {?}
         */
            function (meaning) {
                /** @type {?} */
                var noteElem = this.findNoteElementWithFromAttribute('meaning');
                if (meaning) {
                    if (util.isNullOrUndefined(noteElem)) {
                        // create it
                        noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);
                    }
                    else {
                        DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);
                    }
                }
                else {
                    if (!util.isNullOrUndefined(noteElem)) {
                        // remove node
                        this.removeNoteElementWithFromAttribute('meaning');
                    }
                }
            };
        /**
         * Get all notes of the trans-unit.
         * Notes are remarks made by a translator.
         * (description and meaning are not included here!)
         * @return {?}
         */
        XliffTransUnit.prototype.notes = /**
         * Get all notes of the trans-unit.
         * Notes are remarks made by a translator.
         * (description and meaning are not included here!)
         * @return {?}
         */
            function () {
                /** @type {?} */
                var noteElememts = this.findAllAdditionalNoteElements();
                return noteElememts.map(function (elem) {
                    return {
                        from: elem.getAttribute('from'),
                        text: DOMUtilities.getPCDATA(elem)
                    };
                });
            };
        /**
         * Test, wether setting of notes is supported.
         * If not, setNotes will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        XliffTransUnit.prototype.supportsSetNotes = /**
         * Test, wether setting of notes is supported.
         * If not, setNotes will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return true;
            };
        /**
         * Add notes to trans unit.
         * @throws an Error if any note contains description or meaning as from attribute.
         * @param {?} newNotes the notes to add.
         * @return {?}
         */
        XliffTransUnit.prototype.setNotes = /**
         * Add notes to trans unit.
         * @throws an Error if any note contains description or meaning as from attribute.
         * @param {?} newNotes the notes to add.
         * @return {?}
         */
            function (newNotes) {
                var _this = this;
                if (!util.isNullOrUndefined(newNotes)) {
                    this.checkNotes(newNotes);
                }
                this.removeAllAdditionalNoteElements();
                if (!util.isNullOrUndefined(newNotes)) {
                    newNotes.forEach(function (note) {
                        /** @type {?} */
                        var noteElem = _this.createNoteElementWithFromAttribute(note.from, note.text);
                    });
                }
            };
        /**
         * Set the translation to a given string (including markup).
         * @param translation translation
         */
        /**
         * Set the translation to a given string (including markup).
         * @param {?} translation translation
         * @return {?}
         */
        XliffTransUnit.prototype.translateNative = /**
         * Set the translation to a given string (including markup).
         * @param {?} translation translation
         * @return {?}
         */
            function (translation) {
                /** @type {?} */
                var target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                if (!target) {
                    /** @type {?} */
                    var source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                    target = DOMUtilities.createFollowingSibling('target', source);
                }
                DOMUtilities.replaceContentWithXMLContent(target, /** @type {?} */ (translation));
                this.setTargetState(STATE_TRANSLATED);
            };
        /**
         * Copy source to target to use it as dummy translation.
         * Returns a changed copy of this trans unit.
         * receiver is not changed.
         * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @param {?} targetFile
         * @return {?}
         */
        XliffTransUnit.prototype.cloneWithSourceAsTarget = /**
         * Copy source to target to use it as dummy translation.
         * Returns a changed copy of this trans unit.
         * receiver is not changed.
         * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @param {?} targetFile
         * @return {?}
         */
            function (isDefaultLang, copyContent, targetFile) {
                /** @type {?} */
                var element = /** @type {?} */ (this._element.cloneNode(true));
                /** @type {?} */
                var clone = new XliffTransUnit(element, this._id, targetFile);
                clone.useSourceAsTarget(isDefaultLang, copyContent);
                return clone;
            };
        /**
         * Copy source to target to use it as dummy translation.
         * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @return {?}
         */
        XliffTransUnit.prototype.useSourceAsTarget = /**
         * Copy source to target to use it as dummy translation.
         * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @return {?}
         */
            function (isDefaultLang, copyContent) {
                /** @type {?} */
                var source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                /** @type {?} */
                var target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                if (!target) {
                    target = DOMUtilities.createFollowingSibling('target', source);
                }
                if (isDefaultLang || copyContent) {
                    /** @type {?} */
                    var sourceString = DOMUtilities.getXMLContent(source);
                    /** @type {?} */
                    var newTargetString = sourceString;
                    if (!this.isICUMessage(sourceString)) {
                        newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()
                            + sourceString
                            + this.translationMessagesFile().getNewTransUnitTargetSuffix();
                    }
                    DOMUtilities.replaceContentWithXMLContent(target, newTargetString);
                }
                else {
                    DOMUtilities.replaceContentWithXMLContent(target, '');
                }
                if (isDefaultLang) {
                    target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));
                }
                else {
                    target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));
                }
            };
        return XliffTransUnit;
    }(AbstractTransUnit));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 23.02.2017.
     * Ab xliff file read from a source file.
     * Defines some relevant get and set method for reading and modifying such a file.
     */
    var /**
     * Created by martin on 23.02.2017.
     * Ab xliff file read from a source file.
     * Defines some relevant get and set method for reading and modifying such a file.
     */ XliffFile = /** @class */ (function (_super) {
        __extends(XliffFile, _super);
        /**
         * Create an xlf-File from source.
         * @param xmlString source read from file.
         * @param path Path to file
         * @param encoding optional encoding of the xml.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @return XliffFile
         */
        function XliffFile(xmlString, path, encoding) {
            var _this = _super.call(this) || this;
            _this._warnings = [];
            _this._numberOfTransUnitsWithMissingId = 0;
            _this.initializeFromContent(xmlString, path, encoding);
            return _this;
        }
        /**
         * @param {?} xmlString
         * @param {?} path
         * @param {?} encoding
         * @return {?}
         */
        XliffFile.prototype.initializeFromContent = /**
         * @param {?} xmlString
         * @param {?} path
         * @param {?} encoding
         * @return {?}
         */
            function (xmlString, path, encoding) {
                this.parseContent(xmlString, path, encoding);
                /** @type {?} */
                var xliffList = this._parsedDocument.getElementsByTagName('xliff');
                if (xliffList.length !== 1) {
                    throw new Error(util.format('File "%s" seems to be no xliff file (should contain an xliff element)', path));
                }
                else {
                    /** @type {?} */
                    var version = xliffList.item(0).getAttribute('version');
                    /** @type {?} */
                    var expectedVersion = '1.2';
                    if (version !== expectedVersion) {
                        throw new Error(util.format('File "%s" seems to be no xliff 1.2 file, version should be %s, found %s', path, expectedVersion, version));
                    }
                }
                return this;
            };
        /**
         * File format as it is used in config files.
         * Currently 'xlf', 'xmb', 'xmb2'
         * Returns one of the constants FORMAT_..
         * @return {?}
         */
        XliffFile.prototype.i18nFormat = /**
         * File format as it is used in config files.
         * Currently 'xlf', 'xmb', 'xmb2'
         * Returns one of the constants FORMAT_..
         * @return {?}
         */
            function () {
                return FORMAT_XLIFF12;
            };
        /**
         * File type.
         * Here 'XLIFF 1.2'
         * @return {?}
         */
        XliffFile.prototype.fileType = /**
         * File type.
         * Here 'XLIFF 1.2'
         * @return {?}
         */
            function () {
                return FILETYPE_XLIFF12;
            };
        /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         */
        /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         * @return {?}
         */
        XliffFile.prototype.elementsWithMixedContent = /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         * @return {?}
         */
            function () {
                return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];
            };
        /**
         * @return {?}
         */
        XliffFile.prototype.initializeTransUnits = /**
         * @return {?}
         */
            function () {
                this.transUnits = [];
                /** @type {?} */
                var transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');
                for (var i = 0; i < transUnitsInFile.length; i++) {
                    /** @type {?} */
                    var transunit = transUnitsInFile.item(i);
                    /** @type {?} */
                    var id = transunit.getAttribute('id');
                    if (!id) {
                        this._warnings.push(util.format('oops, trans-unit without "id" found in master, please check file %s', this._filename));
                    }
                    this.transUnits.push(new XliffTransUnit(transunit, id, this));
                }
            };
        /**
         * Get source language.
         * @return {?} source language.
         */
        XliffFile.prototype.sourceLanguage = /**
         * Get source language.
         * @return {?} source language.
         */
            function () {
                /** @type {?} */
                var fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
                if (fileElem) {
                    return fileElem.getAttribute('source-language');
                }
                else {
                    return null;
                }
            };
        /**
         * Edit the source language.
         * @param {?} language language
         * @return {?}
         */
        XliffFile.prototype.setSourceLanguage = /**
         * Edit the source language.
         * @param {?} language language
         * @return {?}
         */
            function (language) {
                /** @type {?} */
                var fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
                if (fileElem) {
                    fileElem.setAttribute('source-language', language);
                }
            };
        /**
         * Get target language.
         * @return {?} target language.
         */
        XliffFile.prototype.targetLanguage = /**
         * Get target language.
         * @return {?} target language.
         */
            function () {
                /** @type {?} */
                var fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
                if (fileElem) {
                    return fileElem.getAttribute('target-language');
                }
                else {
                    return null;
                }
            };
        /**
         * Edit the target language.
         * @param {?} language language
         * @return {?}
         */
        XliffFile.prototype.setTargetLanguage = /**
         * Edit the target language.
         * @param {?} language language
         * @return {?}
         */
            function (language) {
                /** @type {?} */
                var fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
                if (fileElem) {
                    fileElem.setAttribute('target-language', language);
                }
            };
        /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @param foreignTransUnit the trans unit to be imported.
         * @param isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return the newly imported trans unit (since version 1.7.0)
         * @throws an error if trans-unit with same id already is in the file.
         */
        /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @throws an error if trans-unit with same id already is in the file.
         * @param {?} foreignTransUnit the trans unit to be imported.
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return {?} the newly imported trans unit (since version 1.7.0)
         */
        XliffFile.prototype.importNewTransUnit = /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @throws an error if trans-unit with same id already is in the file.
         * @param {?} foreignTransUnit the trans unit to be imported.
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return {?} the newly imported trans unit (since version 1.7.0)
         */
            function (foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {
                if (this.transUnitWithId(foreignTransUnit.id)) {
                    throw new Error(util.format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));
                }
                /** @type {?} */
                var newTu = ( /** @type {?} */(foreignTransUnit)).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);
                /** @type {?} */
                var bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');
                if (!bodyElement) {
                    throw new Error(util.format('File "%s" seems to be no xliff 1.2 file (should contain a body element)', this._filename));
                }
                /** @type {?} */
                var inserted = false;
                /** @type {?} */
                var isAfterElementPartOfFile = false;
                if (!!importAfterElement) {
                    /** @type {?} */
                    var insertionPoint = this.transUnitWithId(importAfterElement.id);
                    if (!!insertionPoint) {
                        isAfterElementPartOfFile = true;
                    }
                }
                if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {
                    bodyElement.appendChild(newTu.asXmlElement());
                    inserted = true;
                }
                else if (importAfterElement === null) {
                    /** @type {?} */
                    var firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');
                    if (firstUnitElement) {
                        DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);
                        inserted = true;
                    }
                    else {
                        // no trans-unit, empty file, so add to body
                        bodyElement.appendChild(newTu.asXmlElement());
                        inserted = true;
                    }
                }
                else {
                    /** @type {?} */
                    var refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);
                    if (refUnitElement) {
                        DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);
                        inserted = true;
                    }
                }
                if (inserted) {
                    this.lazyInitializeTransUnits();
                    this.transUnits.push(newTu);
                    this.countNumbers();
                    return newTu;
                }
                else {
                    return null;
                }
            };
        /**
         * Create a new translation file for this file for a given language.
         * Normally, this is just a copy of the original one.
         * But for XMB the translation file has format 'XTB'.
         * @param {?} lang Language code
         * @param {?} filename expected filename to store file
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @return {?}
         */
        XliffFile.prototype.createTranslationFileForLang = /**
         * Create a new translation file for this file for a given language.
         * Normally, this is just a copy of the original one.
         * But for XMB the translation file has format 'XTB'.
         * @param {?} lang Language code
         * @param {?} filename expected filename to store file
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @return {?}
         */
            function (lang, filename, isDefaultLang, copyContent) {
                /** @type {?} */
                var translationFile = new XliffFile(this.editedContent(), filename, this.encoding());
                translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);
                translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);
                translationFile.setTargetLanguage(lang);
                translationFile.forEachTransUnit(function (transUnit) {
                    ( /** @type {?} */(transUnit)).useSourceAsTarget(isDefaultLang, copyContent);
                });
                return translationFile;
            };
        return XliffFile;
    }(AbstractTranslationMessagesFile));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by roobm on 10.05.2017.
     * A message parser for XMB
     */
    var /**
     * Created by roobm on 10.05.2017.
     * A message parser for XMB
     */ XmbMessageParser = /** @class */ (function (_super) {
        __extends(XmbMessageParser, _super);
        function XmbMessageParser() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Handle this element node.
         * This is called before the children are done.
         * @param elementNode elementNode
         * @param message message to be altered
         * @return true, if children should be processed too, false otherwise (children ignored then)
         */
        /**
         * Handle this element node.
         * This is called before the children are done.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?} true, if children should be processed too, false otherwise (children ignored then)
         */
        XmbMessageParser.prototype.processStartElement = /**
         * Handle this element node.
         * This is called before the children are done.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?} true, if children should be processed too, false otherwise (children ignored then)
         */
            function (elementNode, message) {
                /** @type {?} */
                var tagName = elementNode.tagName;
                if (tagName === 'ph') {
                    /** @type {?} */
                    var name_1 = elementNode.getAttribute('name');
                    if (!name_1) {
                        return true; // should not happen
                    }
                    if (name_1.startsWith('INTERPOLATION')) {
                        /** @type {?} */
                        var index = this.parsePlaceholderIndexFromName(name_1);
                        message.addPlaceholder(index, null);
                        return false; // ignore children
                    }
                    else if (name_1.startsWith('START_')) {
                        /** @type {?} */
                        var tag = this.parseTagnameFromPhElement(elementNode);
                        /** @type {?} */
                        var idcounter = this.parseIdCountFromName(name_1);
                        if (tag) {
                            message.addStartTag(tag, idcounter);
                        }
                        return false; // ignore children
                    }
                    else if (name_1.startsWith('CLOSE_')) {
                        /** @type {?} */
                        var tag = this.parseTagnameFromPhElement(elementNode);
                        if (tag) {
                            message.addEndTag(tag);
                        }
                        return false; // ignore children
                    }
                    else if (new TagMapping().isEmptyTagPlaceholderName(name_1)) {
                        /** @type {?} */
                        var emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name_1);
                        /** @type {?} */
                        var idcounter = this.parseIdCountFromName(name_1);
                        message.addEmptyTag(emptyTagName, idcounter);
                        return false; // ignore children
                    }
                    else if (name_1.startsWith('ICU')) {
                        /** @type {?} */
                        var index = this.parseICUMessageIndexFromName(name_1);
                        message.addICUMessageRef(index, null);
                        return false; // ignore children
                    }
                }
                else if (tagName === 'source') {
                    // ignore source
                    return false;
                }
                return true;
            };
        /**
         * Return the ICU message content of the node, if it is an ICU Message.
         * @param node node
         * @return message or null, if it is no ICU Message.
         */
        /**
         * Return the ICU message content of the node, if it is an ICU Message.
         * @param {?} node node
         * @return {?} message or null, if it is no ICU Message.
         */
        XmbMessageParser.prototype.getICUMessageText = /**
         * Return the ICU message content of the node, if it is an ICU Message.
         * @param {?} node node
         * @return {?} message or null, if it is no ICU Message.
         */
            function (node) {
                /** @type {?} */
                var children = node.childNodes;
                if (children.length === 0) {
                    return null;
                }
                /** @type {?} */
                var firstChild = null;
                /** @type {?} */
                var i;
                for (i = 0; i < children.length; i++) {
                    /** @type {?} */
                    var child = children.item(i);
                    if (child.nodeType !== child.ELEMENT_NODE || ( /** @type {?} */(child)).tagName !== 'source') {
                        firstChild = child;
                        break;
                    }
                }
                if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {
                    if (this.isICUMessageStart(firstChild.textContent)) {
                        /** @type {?} */
                        var messageText = DOMUtilities.getXMLContent(/** @type {?} */ (node));
                        if (i > 0) {
                            /** @type {?} */
                            var reSource = new RegExp('<source[^>]*>.*</source>', 'g');
                            return messageText.replace(reSource, '');
                        }
                        else {
                            return messageText;
                        }
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            };
        /**
         * Handle end of this element node.
         * This is called after all children are processed.
         * @param elementNode elementNode
         * @param message message to be altered
         */
        /**
         * Handle end of this element node.
         * This is called after all children are processed.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?}
         */
        XmbMessageParser.prototype.processEndElement = /**
         * Handle end of this element node.
         * This is called after all children are processed.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?}
         */
            function (elementNode, message) {
            };
        /**
         * Parse id attribute of x element as placeholder index.
         * id can be "INTERPOLATION" or "INTERPOLATION_n"
         * @param {?} name name
         * @return {?} id as number
         */
        XmbMessageParser.prototype.parsePlaceholderIndexFromName = /**
         * Parse id attribute of x element as placeholder index.
         * id can be "INTERPOLATION" or "INTERPOLATION_n"
         * @param {?} name name
         * @return {?} id as number
         */
            function (name) {
                /** @type {?} */
                var indexString = '';
                if (name === 'INTERPOLATION') {
                    indexString = '0';
                }
                else {
                    indexString = name.substring('INTERPOLATION_'.length);
                }
                return Number.parseInt(indexString, 10);
            };
        /**
         * Parse id attribute of x element as ICU message ref index.
         * id can be "ICU" or "ICU_n"
         * @param {?} name name
         * @return {?} id as number
         */
        XmbMessageParser.prototype.parseICUMessageIndexFromName = /**
         * Parse id attribute of x element as ICU message ref index.
         * id can be "ICU" or "ICU_n"
         * @param {?} name name
         * @return {?} id as number
         */
            function (name) {
                /** @type {?} */
                var indexString = '';
                if (name === 'ICU') {
                    indexString = '0';
                }
                else {
                    indexString = name.substring('ICU_'.length);
                }
                return Number.parseInt(indexString, 10);
            };
        /**
         * Parse the tag name from a ph element.
         * It contained in the <ex> subelements value and enclosed in <>.
         * Example: <ph name="START_BOLD_TEXT"><ex>&lt;b&gt;</ex></ph>
         * @param {?} phElement phElement
         * @return {?}
         */
        XmbMessageParser.prototype.parseTagnameFromPhElement = /**
         * Parse the tag name from a ph element.
         * It contained in the <ex> subelements value and enclosed in <>.
         * Example: <ph name="START_BOLD_TEXT"><ex>&lt;b&gt;</ex></ph>
         * @param {?} phElement phElement
         * @return {?}
         */
            function (phElement) {
                /** @type {?} */
                var exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');
                if (exElement) {
                    /** @type {?} */
                    var value = DOMUtilities.getPCDATA(exElement);
                    if (!value || !value.startsWith('<') || !value.endsWith('>')) {
                        // oops
                        return null;
                    }
                    if (value.charAt(1) === '/') {
                        return value.substring(2, value.length - 1);
                    }
                    else {
                        return value.substring(1, value.length - 1);
                    }
                }
                else {
                    return null;
                }
            };
        /**
         * @param {?} message
         * @param {?} rootElem
         * @return {?}
         */
        XmbMessageParser.prototype.addXmlRepresentationToRoot = /**
         * @param {?} message
         * @param {?} rootElem
         * @return {?}
         */
            function (message, rootElem) {
                var _this = this;
                message.parts().forEach(function (part) {
                    /** @type {?} */
                    var child = _this.createXmlRepresentationOfPart(part, rootElem);
                    if (child) {
                        rootElem.appendChild(child);
                    }
                });
            };
        /**
         * @param {?} part
         * @param {?} rootElem
         * @return {?}
         */
        XmbMessageParser.prototype.createXmlRepresentationOfPart = /**
         * @param {?} part
         * @param {?} rootElem
         * @return {?}
         */
            function (part, rootElem) {
                switch (part.type) {
                    case ParsedMessagePartType.TEXT:
                        return this.createXmlRepresentationOfTextPart(/** @type {?} */ (part), rootElem);
                    case ParsedMessagePartType.START_TAG:
                        return this.createXmlRepresentationOfStartTagPart(( /** @type {?} */(part)), rootElem);
                    case ParsedMessagePartType.END_TAG:
                        return this.createXmlRepresentationOfEndTagPart(( /** @type {?} */(part)), rootElem);
                    case ParsedMessagePartType.EMPTY_TAG:
                        return this.createXmlRepresentationOfEmptyTagPart(( /** @type {?} */(part)), rootElem);
                    case ParsedMessagePartType.PLACEHOLDER:
                        return this.createXmlRepresentationOfPlaceholderPart(( /** @type {?} */(part)), rootElem);
                    case ParsedMessagePartType.ICU_MESSAGE_REF:
                        return this.createXmlRepresentationOfICUMessageRefPart(( /** @type {?} */(part)), rootElem);
                }
            };
        /**
         * the xml used for start tag in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for start tag in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XmbMessageParser.prototype.createXmlRepresentationOfStartTagPart = /**
         * the xml used for start tag in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var phElem = rootElem.ownerDocument.createElement('ph');
                /** @type {?} */
                var tagMapping = new TagMapping();
                /** @type {?} */
                var nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());
                phElem.setAttribute('name', nameAttrib);
                /** @type {?} */
                var exElem = rootElem.ownerDocument.createElement('ex');
                exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));
                phElem.appendChild(exElem);
                return phElem;
            };
        /**
         * the xml used for end tag in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for end tag in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XmbMessageParser.prototype.createXmlRepresentationOfEndTagPart = /**
         * the xml used for end tag in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var phElem = rootElem.ownerDocument.createElement('ph');
                /** @type {?} */
                var tagMapping = new TagMapping();
                /** @type {?} */
                var nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());
                phElem.setAttribute('name', nameAttrib);
                /** @type {?} */
                var exElem = rootElem.ownerDocument.createElement('ex');
                exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));
                phElem.appendChild(exElem);
                return phElem;
            };
        /**
         * the xml used for empty tag in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for empty tag in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XmbMessageParser.prototype.createXmlRepresentationOfEmptyTagPart = /**
         * the xml used for empty tag in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var phElem = rootElem.ownerDocument.createElement('ph');
                /** @type {?} */
                var tagMapping = new TagMapping();
                /** @type {?} */
                var nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());
                phElem.setAttribute('name', nameAttrib);
                /** @type {?} */
                var exElem = rootElem.ownerDocument.createElement('ex');
                exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));
                phElem.appendChild(exElem);
                return phElem;
            };
        /**
         * the xml used for placeholder in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for placeholder in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XmbMessageParser.prototype.createXmlRepresentationOfPlaceholderPart = /**
         * the xml used for placeholder in the message.
         * Returns an <ph>-Element with attribute name and subelement ex
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var phElem = rootElem.ownerDocument.createElement('ph');
                /** @type {?} */
                var nameAttrib = 'INTERPOLATION';
                if (part.index() > 0) {
                    nameAttrib = 'INTERPOLATION_' + part.index().toString(10);
                }
                phElem.setAttribute('name', nameAttrib);
                /** @type {?} */
                var exElem = rootElem.ownerDocument.createElement('ex');
                exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));
                phElem.appendChild(exElem);
                return phElem;
            };
        /**
         * the xml used for icu message refs in the message.
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for icu message refs in the message.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        XmbMessageParser.prototype.createXmlRepresentationOfICUMessageRefPart = /**
         * the xml used for icu message refs in the message.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var phElem = rootElem.ownerDocument.createElement('ph');
                /** @type {?} */
                var nameAttrib = 'ICU';
                if (part.index() > 0) {
                    nameAttrib = 'ICU_' + part.index().toString(10);
                }
                phElem.setAttribute('name', nameAttrib);
                /** @type {?} */
                var exElem = rootElem.ownerDocument.createElement('ex');
                exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));
                phElem.appendChild(exElem);
                return phElem;
            };
        return XmbMessageParser;
    }(AbstractMessageParser));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 01.05.2017.
     * A Translation Unit in an XMB file.
     */
    var /**
     * Created by martin on 01.05.2017.
     * A Translation Unit in an XMB file.
     */ XmbTransUnit = /** @class */ (function (_super) {
        __extends(XmbTransUnit, _super);
        function XmbTransUnit(_element, _id, _translationMessagesFile) {
            return _super.call(this, _element, _id, _translationMessagesFile) || this;
        }
        /**
         * Parses something like 'c:\xxx:7' and returns source and linenumber.
         * @param {?} sourceAndPos something like 'c:\xxx:7', last colon is the separator
         * @return {?} source and linenumber
         */
        XmbTransUnit.parseSourceAndPos = /**
         * Parses something like 'c:\xxx:7' and returns source and linenumber.
         * @param {?} sourceAndPos something like 'c:\xxx:7', last colon is the separator
         * @return {?} source and linenumber
         */
            function (sourceAndPos) {
                /** @type {?} */
                var index = sourceAndPos.lastIndexOf(':');
                if (index < 0) {
                    return {
                        sourcefile: sourceAndPos,
                        linenumber: 0
                    };
                }
                else {
                    return {
                        sourcefile: sourceAndPos.substring(0, index),
                        linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))
                    };
                }
            };
        /**
         * @param {?} lineNumberString
         * @return {?}
         */
        XmbTransUnit.parseLineNumber = /**
         * @param {?} lineNumberString
         * @return {?}
         */
            function (lineNumberString) {
                return Number.parseInt(lineNumberString, 10);
            };
        /**
         * Get content to translate.
         * Source parts are excluded here.
         * @return {?} source content
         */
        XmbTransUnit.prototype.sourceContent = /**
         * Get content to translate.
         * Source parts are excluded here.
         * @return {?} source content
         */
            function () {
                /** @type {?} */
                var msgContent = DOMUtilities.getXMLContent(this._element);
                /** @type {?} */
                var reSourceElem = /<source>.*<\/source>/g;
                msgContent = msgContent.replace(reSourceElem, '');
                return msgContent;
            };
        /**
         * Test, wether setting of source content is supported.
         * If not, setSourceContent in trans-unit will do nothing.
         * xtb does not support this, all other formats do.
         */
        /**
         * Test, wether setting of source content is supported.
         * If not, setSourceContent in trans-unit will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        XmbTransUnit.prototype.supportsSetSourceContent = /**
         * Test, wether setting of source content is supported.
         * If not, setSourceContent in trans-unit will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Set new source content in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing changed source content.
         * @param {?} newContent the new content.
         * @return {?}
         */
        XmbTransUnit.prototype.setSourceContent = /**
         * Set new source content in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing changed source content.
         * @param {?} newContent the new content.
         * @return {?}
         */
            function (newContent) {
                // not supported
            };
        /**
         * Return a parser used for normalized messages.
         */
        /**
         * Return a parser used for normalized messages.
         * @return {?}
         */
        XmbTransUnit.prototype.messageParser = /**
         * Return a parser used for normalized messages.
         * @return {?}
         */
            function () {
                return new XmbMessageParser();
            };
        /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
        XmbTransUnit.prototype.createSourceContentNormalized = /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
            function () {
                return this.messageParser().createNormalizedMessageFromXML(this._element, null);
            };
        /**
         * the translated value (containing all markup, depends on the concrete format used).
         * @return {?}
         */
        XmbTransUnit.prototype.targetContent = /**
         * the translated value (containing all markup, depends on the concrete format used).
         * @return {?}
         */
            function () {
                // in fact, target and source are just the same in xmb
                return this.sourceContent();
            };
        /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         */
        /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         * @return {?}
         */
        XmbTransUnit.prototype.targetContentNormalized = /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         * @return {?}
         */
            function () {
                return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());
            };
        /**
         * State of the translation.
         * (not supported in xmb)
         * @return {?}
         */
        XmbTransUnit.prototype.nativeTargetState = /**
         * State of the translation.
         * (not supported in xmb)
         * @return {?}
         */
            function () {
                return null; // not supported in xmb
            };
        /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @param state one of Constants.STATE...
         * @returns a native state (depends on concrete format)
         * @throws error, if state is invalid.
         */
        /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @throws error, if state is invalid.
         * @param {?} state one of Constants.STATE...
         * @return {?} a native state (depends on concrete format)
         */
        XmbTransUnit.prototype.mapStateToNativeState = /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @throws error, if state is invalid.
         * @param {?} state one of Constants.STATE...
         * @return {?} a native state (depends on concrete format)
         */
            function (state) {
                return state;
            };
        /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param nativeState nativeState
         */
        /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param {?} nativeState nativeState
         * @return {?}
         */
        XmbTransUnit.prototype.mapNativeStateToState = /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param {?} nativeState nativeState
         * @return {?}
         */
            function (nativeState) {
                return nativeState;
            };
        /**
         * set state in xml.
         * (not supported in xmb)
         * @param nativeState nativeState
         */
        /**
         * set state in xml.
         * (not supported in xmb)
         * @param {?} nativeState nativeState
         * @return {?}
         */
        XmbTransUnit.prototype.setNativeTargetState = /**
         * set state in xml.
         * (not supported in xmb)
         * @param {?} nativeState nativeState
         * @return {?}
         */
            function (nativeState) {
                // not supported for xmb
            };
        /**
         * All the source elements in the trans unit.
         * The source element is a reference to the original template.
         * It contains the name of the template file and a line number with the position inside the template.
         * It is just a help for translators to find the context for the translation.
         * This is set when using Angular 4.0 or greater.
         * Otherwise it just returns an empty array.
         * @return {?}
         */
        XmbTransUnit.prototype.sourceReferences = /**
         * All the source elements in the trans unit.
         * The source element is a reference to the original template.
         * It contains the name of the template file and a line number with the position inside the template.
         * It is just a help for translators to find the context for the translation.
         * This is set when using Angular 4.0 or greater.
         * Otherwise it just returns an empty array.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceElements = this._element.getElementsByTagName('source');
                /** @type {?} */
                var sourceRefs = [];
                for (var i = 0; i < sourceElements.length; i++) {
                    /** @type {?} */
                    var elem = sourceElements.item(i);
                    /** @type {?} */
                    var sourceAndPos = DOMUtilities.getPCDATA(elem);
                    sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));
                }
                return sourceRefs;
            };
        /**
         * Set source ref elements in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing source refs.
         * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
         * @return {?}
         */
        XmbTransUnit.prototype.setSourceReferences = /**
         * Set source ref elements in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing source refs.
         * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
         * @return {?}
         */
            function (sourceRefs) {
                this.removeAllSourceReferences();
                /** @type {?} */
                var insertPosition = this._element.childNodes.item(0);
                for (var i = sourceRefs.length - 1; i >= 0; i--) {
                    /** @type {?} */
                    var ref = sourceRefs[i];
                    /** @type {?} */
                    var source = this._element.ownerDocument.createElement('source');
                    source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));
                    this._element.insertBefore(source, insertPosition);
                    insertPosition = source;
                }
            };
        /**
         * @return {?}
         */
        XmbTransUnit.prototype.removeAllSourceReferences = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceElements = this._element.getElementsByTagName('source');
                /** @type {?} */
                var toBeRemoved = [];
                for (var i = 0; i < sourceElements.length; i++) {
                    /** @type {?} */
                    var elem = sourceElements.item(i);
                    toBeRemoved.push(elem);
                }
                toBeRemoved.forEach(function (elem) { elem.parentNode.removeChild(elem); });
            };
        /**
         * The description set in the template as value of the i18n-attribute.
         * e.g. i18n="mydescription".
         * In xmb this is stored in the attribute "desc".
         * @return {?}
         */
        XmbTransUnit.prototype.description = /**
         * The description set in the template as value of the i18n-attribute.
         * e.g. i18n="mydescription".
         * In xmb this is stored in the attribute "desc".
         * @return {?}
         */
            function () {
                return this._element.getAttribute('desc');
            };
        /**
         * The meaning (intent) set in the template as value of the i18n-attribute.
         * This is the part in front of the | symbol.
         * e.g. i18n="meaning|mydescription".
         * In xmb this is stored in the attribute "meaning".
         * @return {?}
         */
        XmbTransUnit.prototype.meaning = /**
         * The meaning (intent) set in the template as value of the i18n-attribute.
         * This is the part in front of the | symbol.
         * e.g. i18n="meaning|mydescription".
         * In xmb this is stored in the attribute "meaning".
         * @return {?}
         */
            function () {
                return this._element.getAttribute('meaning');
            };
        /**
         * Test, wether setting of description and meaning is supported.
         * If not, setDescription and setMeaning will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        XmbTransUnit.prototype.supportsSetDescriptionAndMeaning = /**
         * Test, wether setting of description and meaning is supported.
         * If not, setDescription and setMeaning will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Change description property of trans-unit.
         * @param {?} description description
         * @return {?}
         */
        XmbTransUnit.prototype.setDescription = /**
         * Change description property of trans-unit.
         * @param {?} description description
         * @return {?}
         */
            function (description) {
                // not supported, do nothing
            };
        /**
         * Change meaning property of trans-unit.
         * @param {?} meaning meaning
         * @return {?}
         */
        XmbTransUnit.prototype.setMeaning = /**
         * Change meaning property of trans-unit.
         * @param {?} meaning meaning
         * @return {?}
         */
            function (meaning) {
                // not supported, do nothing
            };
        /**
         * Get all notes of the trans-unit.
         * There are NO notes in xmb/xtb
         * @return {?}
         */
        XmbTransUnit.prototype.notes = /**
         * Get all notes of the trans-unit.
         * There are NO notes in xmb/xtb
         * @return {?}
         */
            function () {
                return [];
            };
        /**
         * Test, wether setting of notes is supported.
         * If not, setNotes will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        XmbTransUnit.prototype.supportsSetNotes = /**
         * Test, wether setting of notes is supported.
         * If not, setNotes will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Add notes to trans unit.
         * @param {?} newNotes the notes to add.
         * NOT Supported in xmb/xtb
         * @return {?}
         */
        XmbTransUnit.prototype.setNotes = /**
         * Add notes to trans unit.
         * @param {?} newNotes the notes to add.
         * NOT Supported in xmb/xtb
         * @return {?}
         */
            function (newNotes) {
                // not supported, do nothing
            };
        /**
         * Copy source to target to use it as dummy translation.
         * Returns a changed copy of this trans unit.
         * receiver is not changed.
         * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
         * In xmb there is nothing to do, because there is only a target, no source.
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @param {?} targetFile
         * @return {?}
         */
        XmbTransUnit.prototype.cloneWithSourceAsTarget = /**
         * Copy source to target to use it as dummy translation.
         * Returns a changed copy of this trans unit.
         * receiver is not changed.
         * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
         * In xmb there is nothing to do, because there is only a target, no source.
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @param {?} targetFile
         * @return {?}
         */
            function (isDefaultLang, copyContent, targetFile) {
                return this;
            };
        /**
         * Copy source to target to use it as dummy translation.
         * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @return {?}
         */
        XmbTransUnit.prototype.useSourceAsTarget = /**
         * Copy source to target to use it as dummy translation.
         * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @return {?}
         */
            function (isDefaultLang, copyContent) {
                // do nothing
            };
        /**
         * Set the translation to a given string (including markup).
         * In fact, xmb cannot be translated.
         * So this throws an error.
         * @param translation translation
         */
        /**
         * Set the translation to a given string (including markup).
         * In fact, xmb cannot be translated.
         * So this throws an error.
         * @param {?} translation translation
         * @return {?}
         */
        XmbTransUnit.prototype.translateNative = /**
         * Set the translation to a given string (including markup).
         * In fact, xmb cannot be translated.
         * So this throws an error.
         * @param {?} translation translation
         * @return {?}
         */
            function (translation) {
                throw new Error('You cannot translate xmb files, use xtb instead.');
            };
        return XmbTransUnit;
    }(AbstractTransUnit));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Doctype of xtb translation file corresponding with thos xmb file.
      @type {?} */
    var XTB_DOCTYPE = "<!DOCTYPE translationbundle [\n  <!ELEMENT translationbundle (translation)*>\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\n  <!ELEMENT translation (#PCDATA|ph)*>\n  <!ATTLIST translation id CDATA #REQUIRED>\n  <!ELEMENT ph EMPTY>\n  <!ATTLIST ph name CDATA #REQUIRED>\n]>";
    var XmbFile = /** @class */ (function (_super) {
        __extends(XmbFile, _super);
        /**
         * Create an xmb-File from source.
         * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file
         * @param xmlString file content
         * @param path Path to file
         * @param encoding optional encoding of the xml.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @return XmbFile
         */
        function XmbFile(_translationMessageFileFactory, xmlString, path, encoding) {
            var _this = _super.call(this) || this;
            _this._translationMessageFileFactory = _translationMessageFileFactory;
            _this._warnings = [];
            _this._numberOfTransUnitsWithMissingId = 0;
            _this.initializeFromContent(xmlString, path, encoding);
            return _this;
        }
        /**
         * @param {?} xmlString
         * @param {?} path
         * @param {?} encoding
         * @return {?}
         */
        XmbFile.prototype.initializeFromContent = /**
         * @param {?} xmlString
         * @param {?} path
         * @param {?} encoding
         * @return {?}
         */
            function (xmlString, path, encoding) {
                this.parseContent(xmlString, path, encoding);
                if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {
                    throw new Error(util.format('File "%s" seems to be no xmb file (should contain a messagebundle element)', path));
                }
                return this;
            };
        /**
         * @return {?}
         */
        XmbFile.prototype.initializeTransUnits = /**
         * @return {?}
         */
            function () {
                this.transUnits = [];
                /** @type {?} */
                var transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');
                for (var i = 0; i < transUnitsInFile.length; i++) {
                    /** @type {?} */
                    var msg = transUnitsInFile.item(i);
                    /** @type {?} */
                    var id = msg.getAttribute('id');
                    if (!id) {
                        this._warnings.push(util.format('oops, msg without "id" found in master, please check file %s', this._filename));
                    }
                    this.transUnits.push(new XmbTransUnit(msg, id, this));
                }
            };
        /**
         * File format as it is used in config files.
         * Currently 'xlf', 'xmb', 'xmb2'
         * Returns one of the constants FORMAT_..
         * @return {?}
         */
        XmbFile.prototype.i18nFormat = /**
         * File format as it is used in config files.
         * Currently 'xlf', 'xmb', 'xmb2'
         * Returns one of the constants FORMAT_..
         * @return {?}
         */
            function () {
                return FORMAT_XMB;
            };
        /**
         * File type.
         * Here 'XMB'
         * @return {?}
         */
        XmbFile.prototype.fileType = /**
         * File type.
         * Here 'XMB'
         * @return {?}
         */
            function () {
                return FILETYPE_XMB;
            };
        /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         */
        /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         * @return {?}
         */
        XmbFile.prototype.elementsWithMixedContent = /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         * @return {?}
         */
            function () {
                return ['message'];
            };
        /**
         * Guess language from filename.
         * If filename is foo.xy.xmb, than language is assumed to be xy.
         * @return {?} Language or null
         */
        XmbFile.prototype.guessLanguageFromFilename = /**
         * Guess language from filename.
         * If filename is foo.xy.xmb, than language is assumed to be xy.
         * @return {?} Language or null
         */
            function () {
                if (this._filename) {
                    /** @type {?} */
                    var parts = this._filename.split('.');
                    if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {
                        return parts[parts.length - 2];
                    }
                }
                return null;
            };
        /**
         * Get source language.
         * Unsupported in xmb.
         * Try to guess it from filename if any..
         * @return {?} source language.
         */
        XmbFile.prototype.sourceLanguage = /**
         * Get source language.
         * Unsupported in xmb.
         * Try to guess it from filename if any..
         * @return {?} source language.
         */
            function () {
                return this.guessLanguageFromFilename();
            };
        /**
         * Edit the source language.
         * Unsupported in xmb.
         * @param {?} language language
         * @return {?}
         */
        XmbFile.prototype.setSourceLanguage = /**
         * Edit the source language.
         * Unsupported in xmb.
         * @param {?} language language
         * @return {?}
         */
            function (language) {
                // do nothing, xmb has no notation for this.
            };
        /**
         * Get target language.
         * Unsupported in xmb.
         * Try to guess it from filename if any..
         * @return {?} target language.
         */
        XmbFile.prototype.targetLanguage = /**
         * Get target language.
         * Unsupported in xmb.
         * Try to guess it from filename if any..
         * @return {?} target language.
         */
            function () {
                return this.guessLanguageFromFilename();
            };
        /**
         * Edit the target language.
         * Unsupported in xmb.
         * @param {?} language language
         * @return {?}
         */
        XmbFile.prototype.setTargetLanguage = /**
         * Edit the target language.
         * Unsupported in xmb.
         * @param {?} language language
         * @return {?}
         */
            function (language) {
                // do nothing, xmb has no notation for this.
            };
        /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @param foreignTransUnit the trans unit to be imported.
         * @param isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return the newly imported trans unit (since version 1.7.0)
         * @throws an error if trans-unit with same id already is in the file.
         */
        /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @throws an error if trans-unit with same id already is in the file.
         * @param {?} foreignTransUnit the trans unit to be imported.
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return {?} the newly imported trans unit (since version 1.7.0)
         */
        XmbFile.prototype.importNewTransUnit = /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @throws an error if trans-unit with same id already is in the file.
         * @param {?} foreignTransUnit the trans unit to be imported.
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return {?} the newly imported trans unit (since version 1.7.0)
         */
            function (foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {
                throw Error('xmb file cannot be used to store translations, use xtb file');
            };
        /**
         * Create a new translation file for this file for a given language.
         * Normally, this is just a copy of the original one.
         * But for XMB the translation file has format 'XTB'.
         * @param {?} lang Language code
         * @param {?} filename expected filename to store file
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @return {?}
         */
        XmbFile.prototype.createTranslationFileForLang = /**
         * Create a new translation file for this file for a given language.
         * Normally, this is just a copy of the original one.
         * But for XMB the translation file has format 'XTB'.
         * @param {?} lang Language code
         * @param {?} filename expected filename to store file
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @return {?}
         */
            function (lang, filename, isDefaultLang, copyContent) {
                /** @type {?} */
                var translationbundleXMLSource = '<?xml version="1.0" encoding="UTF-8"?>\n' + XTB_DOCTYPE + '\n<translationbundle>\n</translationbundle>\n';
                /** @type {?} */
                var translationFile = this._translationMessageFileFactory.createFileFromFileContent(FORMAT_XTB, translationbundleXMLSource, filename, this.encoding(), { xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding() });
                translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);
                translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);
                translationFile.setTargetLanguage(lang);
                translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());
                translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());
                this.forEachTransUnit(function (tu) {
                    translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);
                });
                return translationFile;
            };
        return XmbFile;
    }(AbstractTranslationMessagesFile));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by roobm on 10.05.2017.
     * A message parser for XLIFF 2.0
     */
    var /**
     * Created by roobm on 10.05.2017.
     * A message parser for XLIFF 2.0
     */ Xliff2MessageParser = /** @class */ (function (_super) {
        __extends(Xliff2MessageParser, _super);
        function Xliff2MessageParser() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Handle this element node.
         * This is called before the children are done.
         * @param elementNode elementNode
         * @param message message to be altered
         * @return true, if children should be processed too, false otherwise (children ignored then)
         */
        /**
         * Handle this element node.
         * This is called before the children are done.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?} true, if children should be processed too, false otherwise (children ignored then)
         */
        Xliff2MessageParser.prototype.processStartElement = /**
         * Handle this element node.
         * This is called before the children are done.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?} true, if children should be processed too, false otherwise (children ignored then)
         */
            function (elementNode, message) {
                /** @type {?} */
                var tagName = elementNode.tagName;
                if (tagName === 'ph') {
                    /** @type {?} */
                    var isInterpolation = false;
                    /** @type {?} */
                    var isICU = false;
                    /** @type {?} */
                    var isEmptyTag = false;
                    /** @type {?} */
                    var equiv = elementNode.getAttribute('equiv');
                    /** @type {?} */
                    var disp = elementNode.getAttribute('disp');
                    /** @type {?} */
                    var indexString = null;
                    /** @type {?} */
                    var index = 0;
                    /** @type {?} */
                    var emptyTagName = null;
                    if (!equiv) {
                        // old ICU syntax, fixed with #17344
                        isICU = true;
                        indexString = elementNode.getAttribute('id');
                        index = Number.parseInt(indexString, 10);
                    }
                    else if (equiv.startsWith('ICU')) {
                        // new ICU syntax, fixed with #17344
                        isICU = true;
                        if (equiv === 'ICU') {
                            indexString = '0';
                        }
                        else {
                            indexString = equiv.substring('ICU_'.length);
                        }
                        index = Number.parseInt(indexString, 10);
                    }
                    else if (equiv.startsWith('INTERPOLATION')) {
                        isInterpolation = true;
                        if (equiv === 'INTERPOLATION') {
                            indexString = '0';
                        }
                        else {
                            indexString = equiv.substring('INTERPOLATION_'.length);
                        }
                        index = Number.parseInt(indexString, 10);
                    }
                    else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {
                        isEmptyTag = true;
                        emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);
                    }
                    else {
                        return true;
                    }
                    if (isInterpolation) {
                        message.addPlaceholder(index, disp);
                    }
                    else if (isICU) {
                        message.addICUMessageRef(index, disp);
                    }
                    else if (isEmptyTag) {
                        message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));
                    }
                }
                else if (tagName === 'pc') {
                    /** @type {?} */
                    var embeddedTagName = this.tagNameFromPCElement(elementNode);
                    if (embeddedTagName) {
                        message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));
                    }
                }
                return true;
            };
        /**
         * Handle end of this element node.
         * This is called after all children are processed.
         * @param elementNode elementNode
         * @param message message to be altered
         */
        /**
         * Handle end of this element node.
         * This is called after all children are processed.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?}
         */
        Xliff2MessageParser.prototype.processEndElement = /**
         * Handle end of this element node.
         * This is called after all children are processed.
         * @param {?} elementNode elementNode
         * @param {?} message message to be altered
         * @return {?}
         */
            function (elementNode, message) {
                /** @type {?} */
                var tagName = elementNode.tagName;
                if (tagName === 'pc') {
                    /** @type {?} */
                    var embeddedTagName = this.tagNameFromPCElement(elementNode);
                    if (embeddedTagName) {
                        message.addEndTag(embeddedTagName);
                    }
                    return;
                }
            };
        /**
         * @param {?} pcNode
         * @return {?}
         */
        Xliff2MessageParser.prototype.tagNameFromPCElement = /**
         * @param {?} pcNode
         * @return {?}
         */
            function (pcNode) {
                /** @type {?} */
                var dispStart = pcNode.getAttribute('dispStart');
                if (dispStart.startsWith('<')) {
                    dispStart = dispStart.substring(1);
                }
                if (dispStart.endsWith('>')) {
                    dispStart = dispStart.substring(0, dispStart.length - 1);
                }
                return dispStart;
            };
        /**
         * reimplemented here, because XLIFF 2.0 uses a deeper xml model.
         * So we cannot simply replace the message parts by xml parts.
         * @param message message
         * @param rootElem rootElem
         */
        /**
         * reimplemented here, because XLIFF 2.0 uses a deeper xml model.
         * So we cannot simply replace the message parts by xml parts.
         * @param {?} message message
         * @param {?} rootElem rootElem
         * @return {?}
         */
        Xliff2MessageParser.prototype.addXmlRepresentationToRoot = /**
         * reimplemented here, because XLIFF 2.0 uses a deeper xml model.
         * So we cannot simply replace the message parts by xml parts.
         * @param {?} message message
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (message, rootElem) {
                var _this = this;
                /** @type {?} */
                var stack = [{ element: rootElem, tagName: 'root' }];
                /** @type {?} */
                var id = 0;
                message.parts().forEach(function (part) {
                    switch (part.type) {
                        case ParsedMessagePartType.TEXT:
                            stack[stack.length - 1].element.appendChild(_this.createXmlRepresentationOfTextPart(/** @type {?} */ (part), rootElem));
                            break;
                        case ParsedMessagePartType.PLACEHOLDER:
                            stack[stack.length - 1].element.appendChild(_this.createXmlRepresentationOfPlaceholderPart(/** @type {?} */ (part), rootElem, id++));
                            break;
                        case ParsedMessagePartType.ICU_MESSAGE_REF:
                            stack[stack.length - 1].element.appendChild(_this.createXmlRepresentationOfICUMessageRefPart(/** @type {?} */ (part), rootElem));
                            break;
                        case ParsedMessagePartType.START_TAG:
                            /** @type {?} */
                            var newTagElem = _this.createXmlRepresentationOfStartTagPart(/** @type {?} */ (part), rootElem, id++);
                            stack[stack.length - 1].element.appendChild(newTagElem);
                            stack.push({ element: /** @type {?} */ (newTagElem), tagName: ( /** @type {?} */(part)).tagName() });
                            break;
                        case ParsedMessagePartType.END_TAG:
                            /** @type {?} */
                            var closeTagName = ( /** @type {?} */(part)).tagName();
                            if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {
                                // oops, not well formed
                                throw new Error('unexpected close tag ' + closeTagName);
                            }
                            stack.pop();
                            break;
                        case ParsedMessagePartType.EMPTY_TAG:
                            /** @type {?} */
                            var emptyTagElem = _this.createXmlRepresentationOfEmptyTagPart(/** @type {?} */ (part), rootElem, id++);
                            stack[stack.length - 1].element.appendChild(emptyTagElem);
                            break;
                    }
                });
                if (stack.length !== 1) {
                    // oops, not well closed tags
                    throw new Error('missing close tag ' + stack[stack.length - 1].tagName);
                }
            };
        /**
         * the xml used for start tag in the message.
         * Returns an empty pc-Element.
         * e.g. <pc id="0" equivStart="START_BOLD_TEXT" equivEnd="CLOSE_BOLD_TEXT" type="fmt" dispStart="&lt;b&gt;" dispEnd="&lt;/b&gt;">
         * Text content will be added later.
         * @param part part
         * @param rootElem rootElem
         * @param id id number in xliff2
         */
        /**
         * the xml used for start tag in the message.
         * Returns an empty pc-Element.
         * e.g. <pc id="0" equivStart="START_BOLD_TEXT" equivEnd="CLOSE_BOLD_TEXT" type="fmt" dispStart="&lt;b&gt;" dispEnd="&lt;/b&gt;">
         * Text content will be added later.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @param {?} id id number in xliff2
         * @return {?}
         */
        Xliff2MessageParser.prototype.createXmlRepresentationOfStartTagPart = /**
         * the xml used for start tag in the message.
         * Returns an empty pc-Element.
         * e.g. <pc id="0" equivStart="START_BOLD_TEXT" equivEnd="CLOSE_BOLD_TEXT" type="fmt" dispStart="&lt;b&gt;" dispEnd="&lt;/b&gt;">
         * Text content will be added later.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @param {?} id id number in xliff2
         * @return {?}
         */
            function (part, rootElem, id) {
                /** @type {?} */
                var tagMapping = new TagMapping();
                /** @type {?} */
                var pcElem = rootElem.ownerDocument.createElement('pc');
                /** @type {?} */
                var tagName = part.tagName();
                /** @type {?} */
                var equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());
                /** @type {?} */
                var equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);
                /** @type {?} */
                var dispStart = '<' + tagName + '>';
                /** @type {?} */
                var dispEnd = '</' + tagName + '>';
                pcElem.setAttribute('id', id.toString(10));
                pcElem.setAttribute('equivStart', equivStart);
                pcElem.setAttribute('equivEnd', equivEnd);
                pcElem.setAttribute('type', this.getTypeForTag(tagName));
                pcElem.setAttribute('dispStart', dispStart);
                pcElem.setAttribute('dispEnd', dispEnd);
                return pcElem;
            };
        /**
         * the xml used for end tag in the message.
         * Not used here, because content is child of start tag.
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for end tag in the message.
         * Not used here, because content is child of start tag.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        Xliff2MessageParser.prototype.createXmlRepresentationOfEndTagPart = /**
         * the xml used for end tag in the message.
         * Not used here, because content is child of start tag.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                // not used
                return null;
            };
        /**
         * the xml used for empty tag in the message.
         * Returns an empty ph-Element.
         * e.g. <ph id="3" equiv="TAG_IMG" type="image" disp="&lt;img/>"/>
         * @param part part
         * @param rootElem rootElem
         * @param id id number in xliff2
         */
        /**
         * the xml used for empty tag in the message.
         * Returns an empty ph-Element.
         * e.g. <ph id="3" equiv="TAG_IMG" type="image" disp="&lt;img/>"/>
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @param {?} id id number in xliff2
         * @return {?}
         */
        Xliff2MessageParser.prototype.createXmlRepresentationOfEmptyTagPart = /**
         * the xml used for empty tag in the message.
         * Returns an empty ph-Element.
         * e.g. <ph id="3" equiv="TAG_IMG" type="image" disp="&lt;img/>"/>
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @param {?} id id number in xliff2
         * @return {?}
         */
            function (part, rootElem, id) {
                /** @type {?} */
                var tagMapping = new TagMapping();
                /** @type {?} */
                var phElem = rootElem.ownerDocument.createElement('ph');
                /** @type {?} */
                var tagName = part.tagName();
                /** @type {?} */
                var equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());
                /** @type {?} */
                var disp = '<' + tagName + '/>';
                phElem.setAttribute('id', id.toString(10));
                phElem.setAttribute('equiv', equiv);
                phElem.setAttribute('type', this.getTypeForTag(tagName));
                phElem.setAttribute('disp', disp);
                return phElem;
            };
        /**
         * @param {?} tag
         * @return {?}
         */
        Xliff2MessageParser.prototype.getTypeForTag = /**
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                switch (tag.toLowerCase()) {
                    case 'br':
                    case 'b':
                    case 'i':
                    case 'u':
                        return 'fmt';
                    case 'img':
                        return 'image';
                    case 'a':
                        return 'link';
                    default:
                        return 'other';
                }
            };
        /**
         * the xml used for placeholder in the message.
         * Returns e.g. <ph id="1" equiv="INTERPOLATION_1" disp="{{total()}}"/>
         * @param part part
         * @param rootElem rootElem
         * @param id id number in xliff2
         */
        /**
         * the xml used for placeholder in the message.
         * Returns e.g. <ph id="1" equiv="INTERPOLATION_1" disp="{{total()}}"/>
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @param {?} id id number in xliff2
         * @return {?}
         */
        Xliff2MessageParser.prototype.createXmlRepresentationOfPlaceholderPart = /**
         * the xml used for placeholder in the message.
         * Returns e.g. <ph id="1" equiv="INTERPOLATION_1" disp="{{total()}}"/>
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @param {?} id id number in xliff2
         * @return {?}
         */
            function (part, rootElem, id) {
                /** @type {?} */
                var phElem = rootElem.ownerDocument.createElement('ph');
                /** @type {?} */
                var equivAttrib = 'INTERPOLATION';
                if (part.index() > 0) {
                    equivAttrib = 'INTERPOLATION_' + part.index().toString(10);
                }
                phElem.setAttribute('id', id.toString(10));
                phElem.setAttribute('equiv', equivAttrib);
                /** @type {?} */
                var disp = part.disp();
                if (disp) {
                    phElem.setAttribute('disp', disp);
                }
                return phElem;
            };
        /**
         * the xml used for icu message refs in the message.
         * @param part part
         * @param rootElem rootElem
         */
        /**
         * the xml used for icu message refs in the message.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
        Xliff2MessageParser.prototype.createXmlRepresentationOfICUMessageRefPart = /**
         * the xml used for icu message refs in the message.
         * @param {?} part part
         * @param {?} rootElem rootElem
         * @return {?}
         */
            function (part, rootElem) {
                /** @type {?} */
                var phElem = rootElem.ownerDocument.createElement('ph');
                /** @type {?} */
                var equivAttrib = 'ICU';
                if (part.index() > 0) {
                    equivAttrib = 'ICU_' + part.index().toString(10);
                }
                phElem.setAttribute('id', part.index().toString(10));
                phElem.setAttribute('equiv', equivAttrib);
                /** @type {?} */
                var disp = part.disp();
                if (disp) {
                    phElem.setAttribute('disp', disp);
                }
                return phElem;
            };
        return Xliff2MessageParser;
    }(AbstractMessageParser));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 04.05.2017.
     * A Translation Unit in an XLIFF 2.0 file.
     */
    var /**
     * Created by martin on 04.05.2017.
     * A Translation Unit in an XLIFF 2.0 file.
     */ Xliff2TransUnit = /** @class */ (function (_super) {
        __extends(Xliff2TransUnit, _super);
        function Xliff2TransUnit(_element, _id, _translationMessagesFile) {
            return _super.call(this, _element, _id, _translationMessagesFile) || this;
        }
        /**
         * @return {?}
         */
        Xliff2TransUnit.prototype.sourceContent = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                return DOMUtilities.getXMLContent(sourceElement);
            };
        /**
         * Set new source content in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing changed source content.
         * @param {?} newContent the new content.
         * @return {?}
         */
        Xliff2TransUnit.prototype.setSourceContent = /**
         * Set new source content in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing changed source content.
         * @param {?} newContent the new content.
         * @return {?}
         */
            function (newContent) {
                /** @type {?} */
                var source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                if (!source) {
                    /** @type {?} */
                    var segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');
                    source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));
                }
                DOMUtilities.replaceContentWithXMLContent(source, newContent);
            };
        /**
         * Return a parser used for normalized messages.
         */
        /**
         * Return a parser used for normalized messages.
         * @return {?}
         */
        Xliff2TransUnit.prototype.messageParser = /**
         * Return a parser used for normalized messages.
         * @return {?}
         */
            function () {
                return new Xliff2MessageParser();
            };
        /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
        Xliff2TransUnit.prototype.createSourceContentNormalized = /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                if (sourceElement) {
                    return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);
                }
                else {
                    return null;
                }
            };
        /**
         * the translated value (containing all markup, depends on the concrete format used).
         * @return {?}
         */
        Xliff2TransUnit.prototype.targetContent = /**
         * the translated value (containing all markup, depends on the concrete format used).
         * @return {?}
         */
            function () {
                /** @type {?} */
                var targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                return DOMUtilities.getXMLContent(targetElement);
            };
        /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         */
        /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         * @return {?}
         */
        Xliff2TransUnit.prototype.targetContentNormalized = /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());
            };
        /**
         * State of the translation as stored in the xml.
         * @return {?}
         */
        Xliff2TransUnit.prototype.nativeTargetState = /**
         * State of the translation as stored in the xml.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');
                if (segmentElement) {
                    return segmentElement.getAttribute('state');
                }
                else {
                    return null;
                }
            };
        /**
         * set state in xml.
         * @param nativeState nativeState
         */
        /**
         * set state in xml.
         * @param {?} nativeState nativeState
         * @return {?}
         */
        Xliff2TransUnit.prototype.setNativeTargetState = /**
         * set state in xml.
         * @param {?} nativeState nativeState
         * @return {?}
         */
            function (nativeState) {
                /** @type {?} */
                var segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');
                if (segmentElement) {
                    segmentElement.setAttribute('state', nativeState);
                }
            };
        /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @param state one of Constants.STATE...
         * @returns a native state (depends on concrete format)
         * @throws error, if state is invalid.
         */
        /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @throws error, if state is invalid.
         * @param {?} state one of Constants.STATE...
         * @return {?} a native state (depends on concrete format)
         */
        Xliff2TransUnit.prototype.mapStateToNativeState = /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @throws error, if state is invalid.
         * @param {?} state one of Constants.STATE...
         * @return {?} a native state (depends on concrete format)
         */
            function (state) {
                switch (state) {
                    case STATE_NEW:
                        return 'initial';
                    case STATE_TRANSLATED:
                        return 'translated';
                    case STATE_FINAL:
                        return 'final';
                    default:
                        throw new Error('unknown state ' + state);
                }
            };
        /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param nativeState nativeState
         */
        /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param {?} nativeState nativeState
         * @return {?}
         */
        Xliff2TransUnit.prototype.mapNativeStateToState = /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param {?} nativeState nativeState
         * @return {?}
         */
            function (nativeState) {
                switch (nativeState) {
                    case 'initial':
                        return STATE_NEW;
                    case 'translated':
                        return STATE_TRANSLATED;
                    case 'reviewed': // same as translated
                        // same as translated
                        return STATE_TRANSLATED;
                    case 'final':
                        return STATE_FINAL;
                    default:
                        return STATE_NEW;
                }
            };
        /**
         * All the source elements in the trans unit.
         * The source element is a reference to the original template.
         * It contains the name of the template file and a line number with the position inside the template.
         * It is just a help for translators to find the context for the translation.
         * This is set when using Angular 4.0 or greater.
         * Otherwise it just returns an empty array.
         * @return {?}
         */
        Xliff2TransUnit.prototype.sourceReferences = /**
         * All the source elements in the trans unit.
         * The source element is a reference to the original template.
         * It contains the name of the template file and a line number with the position inside the template.
         * It is just a help for translators to find the context for the translation.
         * This is set when using Angular 4.0 or greater.
         * Otherwise it just returns an empty array.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var noteElements = this._element.getElementsByTagName('note');
                /** @type {?} */
                var sourceRefs = [];
                for (var i = 0; i < noteElements.length; i++) {
                    /** @type {?} */
                    var noteElem = noteElements.item(i);
                    if (noteElem.getAttribute('category') === 'location') {
                        /** @type {?} */
                        var sourceAndPos = DOMUtilities.getPCDATA(noteElem);
                        sourceRefs.push(this.parseSourceAndPos(sourceAndPos));
                    }
                }
                return sourceRefs;
            };
        /**
         * Parses something like 'c:\xxx:7' and returns source and linenumber.
         * @param {?} sourceAndPos something like 'c:\xxx:7', last colon is the separator
         * @return {?} source and line number
         */
        Xliff2TransUnit.prototype.parseSourceAndPos = /**
         * Parses something like 'c:\xxx:7' and returns source and linenumber.
         * @param {?} sourceAndPos something like 'c:\xxx:7', last colon is the separator
         * @return {?} source and line number
         */
            function (sourceAndPos) {
                /** @type {?} */
                var index = sourceAndPos.lastIndexOf(':');
                if (index < 0) {
                    return {
                        sourcefile: sourceAndPos,
                        linenumber: 0
                    };
                }
                else {
                    return {
                        sourcefile: sourceAndPos.substring(0, index),
                        linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))
                    };
                }
            };
        /**
         * @param {?} lineNumberString
         * @return {?}
         */
        Xliff2TransUnit.prototype.parseLineNumber = /**
         * @param {?} lineNumberString
         * @return {?}
         */
            function (lineNumberString) {
                return Number.parseInt(lineNumberString, 10);
            };
        /**
         * Set source ref elements in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing source refs.
         * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
         * @return {?}
         */
        Xliff2TransUnit.prototype.setSourceReferences = /**
         * Set source ref elements in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing source refs.
         * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
         * @return {?}
         */
            function (sourceRefs) {
                var _this = this;
                this.removeAllSourceReferences();
                /** @type {?} */
                var notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');
                if (sourceRefs.length === 0 && !util.isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {
                    // remove empty notes element
                    notesElement.parentNode.removeChild(notesElement);
                    return;
                }
                if (util.isNullOrUndefined(notesElement)) {
                    notesElement = this._element.ownerDocument.createElement('notes');
                    this._element.insertBefore(notesElement, this._element.childNodes.item(0));
                }
                sourceRefs.forEach(function (ref) {
                    /** @type {?} */
                    var note = _this._element.ownerDocument.createElement('note');
                    note.setAttribute('category', 'location');
                    note.appendChild(_this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));
                    notesElement.appendChild(note);
                });
            };
        /**
         * @return {?}
         */
        Xliff2TransUnit.prototype.removeAllSourceReferences = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var noteElements = this._element.getElementsByTagName('note');
                /** @type {?} */
                var toBeRemoved = [];
                for (var i = 0; i < noteElements.length; i++) {
                    /** @type {?} */
                    var elem = noteElements.item(i);
                    if (elem.getAttribute('category') === 'location') {
                        toBeRemoved.push(elem);
                    }
                }
                toBeRemoved.forEach(function (elem) { elem.parentNode.removeChild(elem); });
            };
        /**
         * The description set in the template as value of the i18n-attribute.
         * e.g. i18n="mydescription".
         * In xliff 2.0 this is stored as a note element with attribute category="description".
         * @return {?}
         */
        Xliff2TransUnit.prototype.description = /**
         * The description set in the template as value of the i18n-attribute.
         * e.g. i18n="mydescription".
         * In xliff 2.0 this is stored as a note element with attribute category="description".
         * @return {?}
         */
            function () {
                /** @type {?} */
                var noteElem = this.findNoteElementWithCategoryAttribute('description');
                if (noteElem) {
                    return DOMUtilities.getPCDATA(noteElem);
                }
                else {
                    return null;
                }
            };
        /**
         * Change description property of trans-unit.
         * @param {?} description description
         * @return {?}
         */
        Xliff2TransUnit.prototype.setDescription = /**
         * Change description property of trans-unit.
         * @param {?} description description
         * @return {?}
         */
            function (description) {
                /** @type {?} */
                var noteElem = this.findNoteElementWithCategoryAttribute('description');
                if (description) {
                    if (util.isNullOrUndefined(noteElem)) {
                        // create it
                        this.createNoteElementWithCategoryAttribute('description', description);
                    }
                    else {
                        DOMUtilities.replaceContentWithXMLContent(noteElem, description);
                    }
                }
                else {
                    if (!util.isNullOrUndefined(noteElem)) {
                        // remove node
                        this.removeNoteElementWithCategoryAttribute('description');
                    }
                }
            };
        /**
         * Find a note element with attribute category='<attrValue>'
         * @param {?} attrValue value of category attribute
         * @return {?} element or null is absent
         */
        Xliff2TransUnit.prototype.findNoteElementWithCategoryAttribute = /**
         * Find a note element with attribute category='<attrValue>'
         * @param {?} attrValue value of category attribute
         * @return {?} element or null is absent
         */
            function (attrValue) {
                /** @type {?} */
                var noteElements = this._element.getElementsByTagName('note');
                for (var i = 0; i < noteElements.length; i++) {
                    /** @type {?} */
                    var noteElem = noteElements.item(i);
                    if (noteElem.getAttribute('category') === attrValue) {
                        return noteElem;
                    }
                }
                return null;
            };
        /**
         * Get all note elements where from attribute is not description or meaning
         * @return {?} elements
         */
        Xliff2TransUnit.prototype.findAllAdditionalNoteElements = /**
         * Get all note elements where from attribute is not description or meaning
         * @return {?} elements
         */
            function () {
                /** @type {?} */
                var noteElements = this._element.getElementsByTagName('note');
                /** @type {?} */
                var result = [];
                for (var i = 0; i < noteElements.length; i++) {
                    /** @type {?} */
                    var noteElem = noteElements.item(i);
                    /** @type {?} */
                    var fromAttribute = noteElem.getAttribute('category');
                    if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {
                        result.push(noteElem);
                    }
                }
                return result;
            };
        /**
         * Create a new note element with attribute from='<attrValue>'
         * @param {?} attrValue category attribute value
         * @param {?} content content of note element
         * @return {?} the new created element
         */
        Xliff2TransUnit.prototype.createNoteElementWithCategoryAttribute = /**
         * Create a new note element with attribute from='<attrValue>'
         * @param {?} attrValue category attribute value
         * @param {?} content content of note element
         * @return {?} the new created element
         */
            function (attrValue, content) {
                /** @type {?} */
                var notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');
                if (util.isNullOrUndefined(notesElement)) {
                    // create it
                    notesElement = this._element.ownerDocument.createElement('notes');
                    this._element.appendChild(notesElement);
                }
                /** @type {?} */
                var noteElement = this._element.ownerDocument.createElement('note');
                if (attrValue) {
                    noteElement.setAttribute('category', attrValue);
                }
                if (content) {
                    DOMUtilities.replaceContentWithXMLContent(noteElement, content);
                }
                notesElement.appendChild(noteElement);
                return noteElement;
            };
        /**
         * @return {?}
         */
        Xliff2TransUnit.prototype.removeNotesElementIfEmpty = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');
                if (notesElement) {
                    /** @type {?} */
                    var childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');
                    if (!childNote) {
                        // remove notes element
                        notesElement.parentNode.removeChild(notesElement);
                    }
                }
            };
        /**
         * Remove note element with attribute from='<attrValue>'
         * @param {?} attrValue attrValue
         * @return {?}
         */
        Xliff2TransUnit.prototype.removeNoteElementWithCategoryAttribute = /**
         * Remove note element with attribute from='<attrValue>'
         * @param {?} attrValue attrValue
         * @return {?}
         */
            function (attrValue) {
                /** @type {?} */
                var noteElement = this.findNoteElementWithCategoryAttribute(attrValue);
                if (noteElement) {
                    noteElement.parentNode.removeChild(noteElement);
                }
                this.removeNotesElementIfEmpty();
            };
        /**
         * Remove all note elements where attribute "from" is not description or meaning.
         * @return {?}
         */
        Xliff2TransUnit.prototype.removeAllAdditionalNoteElements = /**
         * Remove all note elements where attribute "from" is not description or meaning.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var noteElements = this.findAllAdditionalNoteElements();
                noteElements.forEach(function (noteElement) {
                    noteElement.parentNode.removeChild(noteElement);
                });
                this.removeNotesElementIfEmpty();
            };
        /**
         * The meaning (intent) set in the template as value of the i18n-attribute.
         * This is the part in front of the | symbol.
         * e.g. i18n="meaning|mydescription".
         * In xliff 2.0 this is stored as a note element with attribute category="meaning".
         * @return {?}
         */
        Xliff2TransUnit.prototype.meaning = /**
         * The meaning (intent) set in the template as value of the i18n-attribute.
         * This is the part in front of the | symbol.
         * e.g. i18n="meaning|mydescription".
         * In xliff 2.0 this is stored as a note element with attribute category="meaning".
         * @return {?}
         */
            function () {
                /** @type {?} */
                var noteElem = this.findNoteElementWithCategoryAttribute('meaning');
                if (noteElem) {
                    return DOMUtilities.getPCDATA(noteElem);
                }
                else {
                    return null;
                }
            };
        /**
         * Change meaning property of trans-unit.
         * @param {?} meaning meaning
         * @return {?}
         */
        Xliff2TransUnit.prototype.setMeaning = /**
         * Change meaning property of trans-unit.
         * @param {?} meaning meaning
         * @return {?}
         */
            function (meaning) {
                /** @type {?} */
                var noteElem = this.findNoteElementWithCategoryAttribute('meaning');
                if (meaning) {
                    if (util.isNullOrUndefined(noteElem)) {
                        // create it
                        this.createNoteElementWithCategoryAttribute('meaning', meaning);
                    }
                    else {
                        DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);
                    }
                }
                else {
                    if (!util.isNullOrUndefined(noteElem)) {
                        // remove node
                        this.removeNoteElementWithCategoryAttribute('meaning');
                    }
                }
            };
        /**
         * Get all notes of the trans-unit.
         * Notes are remarks made by a translator.
         * (description and meaning are not included here!)
         * @return {?}
         */
        Xliff2TransUnit.prototype.notes = /**
         * Get all notes of the trans-unit.
         * Notes are remarks made by a translator.
         * (description and meaning are not included here!)
         * @return {?}
         */
            function () {
                /** @type {?} */
                var noteElememts = this.findAllAdditionalNoteElements();
                return noteElememts.map(function (elem) {
                    return {
                        from: elem.getAttribute('category'),
                        text: DOMUtilities.getPCDATA(elem)
                    };
                });
            };
        /**
         * Test, wether setting of notes is supported.
         * If not, setNotes will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        Xliff2TransUnit.prototype.supportsSetNotes = /**
         * Test, wether setting of notes is supported.
         * If not, setNotes will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return true;
            };
        /**
         * Add notes to trans unit.
         * @param {?} newNotes the notes to add.
         * @return {?}
         */
        Xliff2TransUnit.prototype.setNotes = /**
         * Add notes to trans unit.
         * @param {?} newNotes the notes to add.
         * @return {?}
         */
            function (newNotes) {
                var _this = this;
                if (!util.isNullOrUndefined(newNotes)) {
                    this.checkNotes(newNotes);
                }
                this.removeAllAdditionalNoteElements();
                if (!util.isNullOrUndefined(newNotes)) {
                    newNotes.forEach(function (note) {
                        _this.createNoteElementWithCategoryAttribute(note.from, note.text);
                    });
                }
            };
        /**
         * Set the translation to a given string (including markup).
         * @param translation translation
         */
        /**
         * Set the translation to a given string (including markup).
         * @param {?} translation translation
         * @return {?}
         */
        Xliff2TransUnit.prototype.translateNative = /**
         * Set the translation to a given string (including markup).
         * @param {?} translation translation
         * @return {?}
         */
            function (translation) {
                /** @type {?} */
                var target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                if (!target) {
                    /** @type {?} */
                    var source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                    target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));
                }
                DOMUtilities.replaceContentWithXMLContent(target, /** @type {?} */ (translation));
                this.setTargetState(STATE_TRANSLATED);
            };
        /**
         * Copy source to target to use it as dummy translation.
         * Returns a changed copy of this trans unit.
         * receiver is not changed.
         * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @param {?} targetFile
         * @return {?}
         */
        Xliff2TransUnit.prototype.cloneWithSourceAsTarget = /**
         * Copy source to target to use it as dummy translation.
         * Returns a changed copy of this trans unit.
         * receiver is not changed.
         * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @param {?} targetFile
         * @return {?}
         */
            function (isDefaultLang, copyContent, targetFile) {
                /** @type {?} */
                var element = /** @type {?} */ (this._element.cloneNode(true));
                /** @type {?} */
                var clone = new Xliff2TransUnit(element, this._id, targetFile);
                clone.useSourceAsTarget(isDefaultLang, copyContent);
                return clone;
            };
        /**
         * Copy source to target to use it as dummy translation.
         * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @return {?}
         */
        Xliff2TransUnit.prototype.useSourceAsTarget = /**
         * Copy source to target to use it as dummy translation.
         * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @return {?}
         */
            function (isDefaultLang, copyContent) {
                /** @type {?} */
                var source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
                /** @type {?} */
                var target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
                if (!target) {
                    target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));
                }
                if (isDefaultLang || copyContent) {
                    /** @type {?} */
                    var sourceString = DOMUtilities.getXMLContent(source);
                    /** @type {?} */
                    var newTargetString = sourceString;
                    if (!this.isICUMessage(sourceString)) {
                        newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()
                            + sourceString
                            + this.translationMessagesFile().getNewTransUnitTargetSuffix();
                    }
                    DOMUtilities.replaceContentWithXMLContent(target, newTargetString);
                }
                else {
                    DOMUtilities.replaceContentWithXMLContent(target, '');
                }
                /** @type {?} */
                var segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');
                if (segment) {
                    if (isDefaultLang) {
                        segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));
                    }
                    else {
                        segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));
                    }
                }
            };
        return Xliff2TransUnit;
    }(AbstractTransUnit));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 04.05.2017.
     * An XLIFF 2.0 file read from a source file.
     * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html
     *
     * Defines some relevant get and set method for reading and modifying such a file.
     */
    var /**
     * Created by martin on 04.05.2017.
     * An XLIFF 2.0 file read from a source file.
     * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html
     *
     * Defines some relevant get and set method for reading and modifying such a file.
     */ Xliff2File = /** @class */ (function (_super) {
        __extends(Xliff2File, _super);
        /**
         * Create an XLIFF 2.0-File from source.
         * @param xmlString source read from file.
         * @param path Path to file
         * @param encoding optional encoding of the xml.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @return xliff file
         */
        function Xliff2File(xmlString, path, encoding) {
            var _this = _super.call(this) || this;
            _this._warnings = [];
            _this._numberOfTransUnitsWithMissingId = 0;
            _this.initializeFromContent(xmlString, path, encoding);
            return _this;
        }
        /**
         * @param {?} xmlString
         * @param {?} path
         * @param {?} encoding
         * @return {?}
         */
        Xliff2File.prototype.initializeFromContent = /**
         * @param {?} xmlString
         * @param {?} path
         * @param {?} encoding
         * @return {?}
         */
            function (xmlString, path, encoding) {
                this.parseContent(xmlString, path, encoding);
                /** @type {?} */
                var xliffList = this._parsedDocument.getElementsByTagName('xliff');
                if (xliffList.length !== 1) {
                    throw new Error(util.format('File "%s" seems to be no xliff file (should contain an xliff element)', path));
                }
                else {
                    /** @type {?} */
                    var version = xliffList.item(0).getAttribute('version');
                    /** @type {?} */
                    var expectedVersion = '2.0';
                    if (version !== expectedVersion) {
                        throw new Error(util.format('File "%s" seems to be no xliff 2 file, version should be %s, found %s', path, expectedVersion, version));
                    }
                }
                return this;
            };
        /**
         * File format as it is used in config files.
         * Currently 'xlf', 'xmb', 'xmb2'
         * Returns one of the constants FORMAT_..
         * @return {?}
         */
        Xliff2File.prototype.i18nFormat = /**
         * File format as it is used in config files.
         * Currently 'xlf', 'xmb', 'xmb2'
         * Returns one of the constants FORMAT_..
         * @return {?}
         */
            function () {
                return FORMAT_XLIFF20;
            };
        /**
         * File type.
         * Here 'XLIFF 2.0'
         * @return {?}
         */
        Xliff2File.prototype.fileType = /**
         * File type.
         * Here 'XLIFF 2.0'
         * @return {?}
         */
            function () {
                return FILETYPE_XLIFF20;
            };
        /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         */
        /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         * @return {?}
         */
        Xliff2File.prototype.elementsWithMixedContent = /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         * @return {?}
         */
            function () {
                return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];
            };
        /**
         * @return {?}
         */
        Xliff2File.prototype.initializeTransUnits = /**
         * @return {?}
         */
            function () {
                this.transUnits = [];
                /** @type {?} */
                var transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');
                for (var i = 0; i < transUnitsInFile.length; i++) {
                    /** @type {?} */
                    var transunit = transUnitsInFile.item(i);
                    /** @type {?} */
                    var id = transunit.getAttribute('id');
                    if (!id) {
                        this._warnings.push(util.format('oops, trans-unit without "id" found in master, please check file %s', this._filename));
                    }
                    this.transUnits.push(new Xliff2TransUnit(transunit, id, this));
                }
            };
        /**
         * Get source language.
         * @return {?} source language.
         */
        Xliff2File.prototype.sourceLanguage = /**
         * Get source language.
         * @return {?} source language.
         */
            function () {
                /** @type {?} */
                var xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');
                if (xliffElem) {
                    return xliffElem.getAttribute('srcLang');
                }
                else {
                    return null;
                }
            };
        /**
         * Edit the source language.
         * @param {?} language language
         * @return {?}
         */
        Xliff2File.prototype.setSourceLanguage = /**
         * Edit the source language.
         * @param {?} language language
         * @return {?}
         */
            function (language) {
                /** @type {?} */
                var xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');
                if (xliffElem) {
                    xliffElem.setAttribute('srcLang', language);
                }
            };
        /**
         * Get target language.
         * @return {?} target language.
         */
        Xliff2File.prototype.targetLanguage = /**
         * Get target language.
         * @return {?} target language.
         */
            function () {
                /** @type {?} */
                var xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');
                if (xliffElem) {
                    return xliffElem.getAttribute('trgLang');
                }
                else {
                    return null;
                }
            };
        /**
         * Edit the target language.
         * @param {?} language language
         * @return {?}
         */
        Xliff2File.prototype.setTargetLanguage = /**
         * Edit the target language.
         * @param {?} language language
         * @return {?}
         */
            function (language) {
                /** @type {?} */
                var xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');
                if (xliffElem) {
                    xliffElem.setAttribute('trgLang', language);
                }
            };
        /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @param foreignTransUnit the trans unit to be imported.
         * @param isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return the newly imported trans unit (since version 1.7.0)
         * @throws an error if trans-unit with same id already is in the file.
         */
        /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @throws an error if trans-unit with same id already is in the file.
         * @param {?} foreignTransUnit the trans unit to be imported.
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return {?} the newly imported trans unit (since version 1.7.0)
         */
        Xliff2File.prototype.importNewTransUnit = /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @throws an error if trans-unit with same id already is in the file.
         * @param {?} foreignTransUnit the trans unit to be imported.
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return {?} the newly imported trans unit (since version 1.7.0)
         */
            function (foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {
                if (this.transUnitWithId(foreignTransUnit.id)) {
                    throw new Error(util.format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));
                }
                /** @type {?} */
                var newTu = ( /** @type {?} */(foreignTransUnit)).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);
                /** @type {?} */
                var fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');
                if (!fileElement) {
                    throw new Error(util.format('File "%s" seems to be no xliff 2.0 file (should contain a file element)', this._filename));
                }
                /** @type {?} */
                var inserted = false;
                /** @type {?} */
                var isAfterElementPartOfFile = false;
                if (!!importAfterElement) {
                    /** @type {?} */
                    var insertionPoint = this.transUnitWithId(importAfterElement.id);
                    if (!!insertionPoint) {
                        isAfterElementPartOfFile = true;
                    }
                }
                if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {
                    fileElement.appendChild(newTu.asXmlElement());
                    inserted = true;
                }
                else if (importAfterElement === null) {
                    /** @type {?} */
                    var firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');
                    if (firstUnitElement) {
                        DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);
                        inserted = true;
                    }
                    else {
                        // no trans-unit, empty file, so add to first file element
                        fileElement.appendChild(newTu.asXmlElement());
                        inserted = true;
                    }
                }
                else {
                    /** @type {?} */
                    var refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);
                    if (refUnitElement) {
                        DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);
                        inserted = true;
                    }
                }
                if (inserted) {
                    this.lazyInitializeTransUnits();
                    this.transUnits.push(newTu);
                    this.countNumbers();
                    return newTu;
                }
                else {
                    return null;
                }
            };
        /**
         * Create a new translation file for this file for a given language.
         * Normally, this is just a copy of the original one.
         * But for XMB the translation file has format 'XTB'.
         * @param {?} lang Language code
         * @param {?} filename expected filename to store file
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @return {?}
         */
        Xliff2File.prototype.createTranslationFileForLang = /**
         * Create a new translation file for this file for a given language.
         * Normally, this is just a copy of the original one.
         * But for XMB the translation file has format 'XTB'.
         * @param {?} lang Language code
         * @param {?} filename expected filename to store file
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @return {?}
         */
            function (lang, filename, isDefaultLang, copyContent) {
                /** @type {?} */
                var translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());
                translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);
                translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);
                translationFile.setTargetLanguage(lang);
                translationFile.forEachTransUnit(function (transUnit) {
                    ( /** @type {?} */(transUnit)).useSourceAsTarget(isDefaultLang, copyContent);
                });
                return translationFile;
            };
        return Xliff2File;
    }(AbstractTranslationMessagesFile));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 23.05.2017.
     * A Translation Unit in an XTB file.
     */
    var /**
     * Created by martin on 23.05.2017.
     * A Translation Unit in an XTB file.
     */ XtbTransUnit = /** @class */ (function (_super) {
        __extends(XtbTransUnit, _super);
        function XtbTransUnit(_element, _id, _translationMessagesFile, _sourceTransUnitFromMaster) {
            var _this = _super.call(this, _element, _id, _translationMessagesFile) || this;
            _this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;
            return _this;
        }
        /**
         * Get content to translate.
         * Source parts are excluded here.
         * @return {?} content to translate.
         */
        XtbTransUnit.prototype.sourceContent = /**
         * Get content to translate.
         * Source parts are excluded here.
         * @return {?} content to translate.
         */
            function () {
                if (this._sourceTransUnitFromMaster) {
                    return this._sourceTransUnitFromMaster.sourceContent();
                }
                else {
                    return null;
                }
            };
        /**
         * Test, wether setting of source content is supported.
         * If not, setSourceContent in trans-unit will do nothing.
         * xtb does not support this, all other formats do.
         */
        /**
         * Test, wether setting of source content is supported.
         * If not, setSourceContent in trans-unit will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        XtbTransUnit.prototype.supportsSetSourceContent = /**
         * Test, wether setting of source content is supported.
         * If not, setSourceContent in trans-unit will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Set new source content in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing changed source content.
         * @param {?} newContent the new content.
         * @return {?}
         */
        XtbTransUnit.prototype.setSourceContent = /**
         * Set new source content in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing changed source content.
         * @param {?} newContent the new content.
         * @return {?}
         */
            function (newContent) {
                // xtb has no source content, they are part of the master
            };
        /**
         * Return a parser used for normalized messages.
         */
        /**
         * Return a parser used for normalized messages.
         * @return {?}
         */
        XtbTransUnit.prototype.messageParser = /**
         * Return a parser used for normalized messages.
         * @return {?}
         */
            function () {
                return new XmbMessageParser(); // no typo!, Same as for Xmb
            };
        /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
        XtbTransUnit.prototype.createSourceContentNormalized = /**
         * The original text value, that is to be translated, as normalized message.
         * @return {?}
         */
            function () {
                if (this._sourceTransUnitFromMaster) {
                    return this._sourceTransUnitFromMaster.createSourceContentNormalized();
                }
                else {
                    return null;
                }
            };
        /**
         * the translated value (containing all markup, depends on the concrete format used).
         * @return {?}
         */
        XtbTransUnit.prototype.targetContent = /**
         * the translated value (containing all markup, depends on the concrete format used).
         * @return {?}
         */
            function () {
                return DOMUtilities.getXMLContent(this._element);
            };
        /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         */
        /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         * @return {?}
         */
        XtbTransUnit.prototype.targetContentNormalized = /**
         * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
         * and all embedded html is replaced by direct html markup.
         * @return {?}
         */
            function () {
                return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());
            };
        /**
         * State of the translation.
         * (not supported in xmb)
         * If we have a master, we assumed it is translated if the content is not the same as the masters one.
         * @return {?}
         */
        XtbTransUnit.prototype.nativeTargetState = /**
         * State of the translation.
         * (not supported in xmb)
         * If we have a master, we assumed it is translated if the content is not the same as the masters one.
         * @return {?}
         */
            function () {
                if (this._sourceTransUnitFromMaster) {
                    /** @type {?} */
                    var sourceContent = this._sourceTransUnitFromMaster.sourceContent();
                    if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {
                        return 'new';
                    }
                    else {
                        return 'final';
                    }
                }
                return null; // not supported in xmb
            };
        /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @param state one of Constants.STATE...
         * @returns a native state (depends on concrete format)
         * @throws error, if state is invalid.
         */
        /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @throws error, if state is invalid.
         * @param {?} state one of Constants.STATE...
         * @return {?} a native state (depends on concrete format)
         */
        XtbTransUnit.prototype.mapStateToNativeState = /**
         * Map an abstract state (new, translated, final) to a concrete state used in the xml.
         * Returns the state to be used in the xml.
         * @throws error, if state is invalid.
         * @param {?} state one of Constants.STATE...
         * @return {?} a native state (depends on concrete format)
         */
            function (state) {
                return state;
            };
        /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param nativeState nativeState
         */
        /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param {?} nativeState nativeState
         * @return {?}
         */
        XtbTransUnit.prototype.mapNativeStateToState = /**
         * Map a native state (found in the document) to an abstract state (new, translated, final).
         * Returns the abstract state.
         * @param {?} nativeState nativeState
         * @return {?}
         */
            function (nativeState) {
                return nativeState;
            };
        /**
         * set state in xml.
         * (not supported in xmb)
         * @param nativeState nativeState
         */
        /**
         * set state in xml.
         * (not supported in xmb)
         * @param {?} nativeState nativeState
         * @return {?}
         */
        XtbTransUnit.prototype.setNativeTargetState = /**
         * set state in xml.
         * (not supported in xmb)
         * @param {?} nativeState nativeState
         * @return {?}
         */
            function (nativeState) {
                // TODO some logic to store it anywhere
            };
        /**
         * All the source elements in the trans unit.
         * The source element is a reference to the original template.
         * It contains the name of the template file and a line number with the position inside the template.
         * It is just a help for translators to find the context for the translation.
         * This is set when using Angular 4.0 or greater.
         * Otherwise it just returns an empty array.
         * @return {?}
         */
        XtbTransUnit.prototype.sourceReferences = /**
         * All the source elements in the trans unit.
         * The source element is a reference to the original template.
         * It contains the name of the template file and a line number with the position inside the template.
         * It is just a help for translators to find the context for the translation.
         * This is set when using Angular 4.0 or greater.
         * Otherwise it just returns an empty array.
         * @return {?}
         */
            function () {
                if (this._sourceTransUnitFromMaster) {
                    return this._sourceTransUnitFromMaster.sourceReferences();
                }
                else {
                    return [];
                }
            };
        /**
         * Test, wether setting of source refs is supported.
         * If not, setSourceReferences will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        XtbTransUnit.prototype.supportsSetSourceReferences = /**
         * Test, wether setting of source refs is supported.
         * If not, setSourceReferences will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Set source ref elements in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing source refs.
         * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
         * @return {?}
         */
        XtbTransUnit.prototype.setSourceReferences = /**
         * Set source ref elements in the transunit.
         * Normally, this is done by ng-extract.
         * Method only exists to allow xliffmerge to merge missing source refs.
         * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
         * @return {?}
         */
            function (sourceRefs) {
                // xtb has no source refs, they are part of the master
            };
        /**
         * The description set in the template as value of the i18n-attribute.
         * e.g. i18n="mydescription".
         * In xtb only the master stores it.
         * @return {?}
         */
        XtbTransUnit.prototype.description = /**
         * The description set in the template as value of the i18n-attribute.
         * e.g. i18n="mydescription".
         * In xtb only the master stores it.
         * @return {?}
         */
            function () {
                if (this._sourceTransUnitFromMaster) {
                    return this._sourceTransUnitFromMaster.description();
                }
                else {
                    return null;
                }
            };
        /**
         * The meaning (intent) set in the template as value of the i18n-attribute.
         * This is the part in front of the | symbol.
         * e.g. i18n="meaning|mydescription".
         * In xtb only the master stores it.
         * @return {?}
         */
        XtbTransUnit.prototype.meaning = /**
         * The meaning (intent) set in the template as value of the i18n-attribute.
         * This is the part in front of the | symbol.
         * e.g. i18n="meaning|mydescription".
         * In xtb only the master stores it.
         * @return {?}
         */
            function () {
                if (this._sourceTransUnitFromMaster) {
                    return this._sourceTransUnitFromMaster.meaning();
                }
                else {
                    return null;
                }
            };
        /**
         * Test, wether setting of description and meaning is supported.
         * If not, setDescription and setMeaning will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        XtbTransUnit.prototype.supportsSetDescriptionAndMeaning = /**
         * Test, wether setting of description and meaning is supported.
         * If not, setDescription and setMeaning will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Change description property of trans-unit.
         * @param {?} description description
         * @return {?}
         */
        XtbTransUnit.prototype.setDescription = /**
         * Change description property of trans-unit.
         * @param {?} description description
         * @return {?}
         */
            function (description) {
                // not supported, do nothing
            };
        /**
         * Change meaning property of trans-unit.
         * @param {?} meaning meaning
         * @return {?}
         */
        XtbTransUnit.prototype.setMeaning = /**
         * Change meaning property of trans-unit.
         * @param {?} meaning meaning
         * @return {?}
         */
            function (meaning) {
                // not supported, do nothing
            };
        /**
         * Get all notes of the trans-unit.
         * There are NO notes in xmb/xtb
         * @return {?}
         */
        XtbTransUnit.prototype.notes = /**
         * Get all notes of the trans-unit.
         * There are NO notes in xmb/xtb
         * @return {?}
         */
            function () {
                return [];
            };
        /**
         * Test, wether setting of notes is supported.
         * If not, setNotes will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
        XtbTransUnit.prototype.supportsSetNotes = /**
         * Test, wether setting of notes is supported.
         * If not, setNotes will do nothing.
         * xtb does not support this, all other formats do.
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Add notes to trans unit.
         * @param {?} newNotes the notes to add.
         * NOT Supported in xmb/xtb
         * @return {?}
         */
        XtbTransUnit.prototype.setNotes = /**
         * Add notes to trans unit.
         * @param {?} newNotes the notes to add.
         * NOT Supported in xmb/xtb
         * @return {?}
         */
            function (newNotes) {
                // not supported, do nothing
            };
        /**
         * Copy source to target to use it as dummy translation.
         * Returns a changed copy of this trans unit.
         * receiver is not changed.
         * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
         * In xtb there is nothing to do, because there is only a target, no source.
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @param {?} targetFile
         * @return {?}
         */
        XtbTransUnit.prototype.cloneWithSourceAsTarget = /**
         * Copy source to target to use it as dummy translation.
         * Returns a changed copy of this trans unit.
         * receiver is not changed.
         * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
         * In xtb there is nothing to do, because there is only a target, no source.
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @param {?} targetFile
         * @return {?}
         */
            function (isDefaultLang, copyContent, targetFile) {
                return this;
            };
        /**
         * Copy source to target to use it as dummy translation.
         * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @return {?}
         */
        XtbTransUnit.prototype.useSourceAsTarget = /**
         * Copy source to target to use it as dummy translation.
         * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
         * @param {?} isDefaultLang
         * @param {?} copyContent
         * @return {?}
         */
            function (isDefaultLang, copyContent) {
                // do nothing
            };
        /**
         * Set the translation to a given string (including markup).
         * @param translation translation
         */
        /**
         * Set the translation to a given string (including markup).
         * @param {?} translation translation
         * @return {?}
         */
        XtbTransUnit.prototype.translateNative = /**
         * Set the translation to a given string (including markup).
         * @param {?} translation translation
         * @return {?}
         */
            function (translation) {
                /** @type {?} */
                var target = this._element;
                if (util.isNullOrUndefined(translation)) {
                    translation = '';
                }
                DOMUtilities.replaceContentWithXMLContent(target, translation);
            };
        return XtbTransUnit;
    }(AbstractTransUnit));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 23.05.2017.
     * xtb-File access.
     * xtb is the translated counterpart to xmb.
     */
    var /**
     * Created by martin on 23.05.2017.
     * xtb-File access.
     * xtb is the translated counterpart to xmb.
     */ XtbFile = /** @class */ (function (_super) {
        __extends(XtbFile, _super);
        /**
         * Create an xmb-File from source.
         * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file
         * @param xmlString file content
         * @param path Path to file
         * @param encoding optional encoding of the xml.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * @return XmbFile
         */
        function XtbFile(_translationMessageFileFactory, xmlString, path, encoding, optionalMaster) {
            var _this = _super.call(this) || this;
            _this._translationMessageFileFactory = _translationMessageFileFactory;
            _this._warnings = [];
            _this._numberOfTransUnitsWithMissingId = 0;
            _this.initializeFromContent(xmlString, path, encoding, optionalMaster);
            return _this;
        }
        /**
         * @param {?} xmlString
         * @param {?} path
         * @param {?} encoding
         * @param {?=} optionalMaster
         * @return {?}
         */
        XtbFile.prototype.initializeFromContent = /**
         * @param {?} xmlString
         * @param {?} path
         * @param {?} encoding
         * @param {?=} optionalMaster
         * @return {?}
         */
            function (xmlString, path, encoding, optionalMaster) {
                this.parseContent(xmlString, path, encoding);
                if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {
                    throw new Error(util.format('File "%s" seems to be no xtb file (should contain a translationbundle element)', path));
                }
                if (optionalMaster) {
                    try {
                        this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(FORMAT_XMB, optionalMaster.xmlContent, optionalMaster.path, optionalMaster.encoding);
                        /** @type {?} */
                        var numberInMaster = this._masterFile.numberOfTransUnits();
                        /** @type {?} */
                        var myNumber = this.numberOfTransUnits();
                        if (numberInMaster !== myNumber) {
                            this._warnings.push(util.format('%s trans units found in master, but this file has %s. Check if it is the correct master', numberInMaster, myNumber));
                        }
                    }
                    catch (error) {
                        throw new Error(util.format('File "%s" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));
                    }
                }
                return this;
            };
        /**
         * @return {?}
         */
        XtbFile.prototype.initializeTransUnits = /**
         * @return {?}
         */
            function () {
                this.transUnits = [];
                /** @type {?} */
                var transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');
                for (var i = 0; i < transUnitsInFile.length; i++) {
                    /** @type {?} */
                    var msg = transUnitsInFile.item(i);
                    /** @type {?} */
                    var id = msg.getAttribute('id');
                    if (!id) {
                        this._warnings.push(util.format('oops, msg without "id" found in master, please check file %s', this._filename));
                    }
                    /** @type {?} */
                    var masterUnit = null;
                    if (this._masterFile) {
                        masterUnit = this._masterFile.transUnitWithId(id);
                    }
                    this.transUnits.push(new XtbTransUnit(msg, id, this, /** @type {?} */ (masterUnit)));
                }
            };
        /**
         * File format as it is used in config files.
         * Currently 'xlf', 'xlf2', 'xmb', 'xtb'
         * Returns one of the constants FORMAT_..
         * @return {?}
         */
        XtbFile.prototype.i18nFormat = /**
         * File format as it is used in config files.
         * Currently 'xlf', 'xlf2', 'xmb', 'xtb'
         * Returns one of the constants FORMAT_..
         * @return {?}
         */
            function () {
                return FORMAT_XTB;
            };
        /**
         * File type.
         * Here 'XTB'
         * @return {?}
         */
        XtbFile.prototype.fileType = /**
         * File type.
         * Here 'XTB'
         * @return {?}
         */
            function () {
                return FILETYPE_XTB;
            };
        /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         */
        /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         * @return {?}
         */
        XtbFile.prototype.elementsWithMixedContent = /**
         * return tag names of all elements that have mixed content.
         * These elements will not be beautified.
         * Typical candidates are source and target.
         * @return {?}
         */
            function () {
                return ['translation'];
            };
        /**
         * Get source language.
         * Unsupported in xmb/xtb.
         * Try to guess it from master filename if any..
         * @return {?} source language.
         */
        XtbFile.prototype.sourceLanguage = /**
         * Get source language.
         * Unsupported in xmb/xtb.
         * Try to guess it from master filename if any..
         * @return {?} source language.
         */
            function () {
                if (this._masterFile) {
                    return this._masterFile.sourceLanguage();
                }
                else {
                    return null;
                }
            };
        /**
         * Edit the source language.
         * Unsupported in xmb/xtb.
         * @param {?} language language
         * @return {?}
         */
        XtbFile.prototype.setSourceLanguage = /**
         * Edit the source language.
         * Unsupported in xmb/xtb.
         * @param {?} language language
         * @return {?}
         */
            function (language) {
                // do nothing, xtb has no notation for this.
            };
        /**
         * Get target language.
         * @return {?} target language.
         */
        XtbFile.prototype.targetLanguage = /**
         * Get target language.
         * @return {?} target language.
         */
            function () {
                /** @type {?} */
                var translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');
                if (translationbundleElem) {
                    return translationbundleElem.getAttribute('lang');
                }
                else {
                    return null;
                }
            };
        /**
         * Edit the target language.
         * @param {?} language language
         * @return {?}
         */
        XtbFile.prototype.setTargetLanguage = /**
         * Edit the target language.
         * @param {?} language language
         * @return {?}
         */
            function (language) {
                /** @type {?} */
                var translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');
                if (translationbundleElem) {
                    translationbundleElem.setAttribute('lang', language);
                }
            };
        /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @param foreignTransUnit the trans unit to be imported.
         * @param isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return the newly imported trans unit (since version 1.7.0)
         * @throws an error if trans-unit with same id already is in the file.
         */
        /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @throws an error if trans-unit with same id already is in the file.
         * @param {?} foreignTransUnit the trans unit to be imported.
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return {?} the newly imported trans unit (since version 1.7.0)
         */
        XtbFile.prototype.importNewTransUnit = /**
         * Add a new trans-unit to this file.
         * The trans unit stems from another file.
         * It copies the source content of the tu to the target content too,
         * depending on the values of isDefaultLang and copyContent.
         * So the source can be used as a dummy translation.
         * (used by xliffmerge)
         * @throws an error if trans-unit with same id already is in the file.
         * @param {?} foreignTransUnit the trans unit to be imported.
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @param {?=} importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.
         * Newly imported trans unit is then inserted directly after this element.
         * If not set or not part of this file, new unit will be imported at the end.
         * If explicity set to null, new unit will be imported at the start.
         * @return {?} the newly imported trans unit (since version 1.7.0)
         */
            function (foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {
                if (this.transUnitWithId(foreignTransUnit.id)) {
                    throw new Error(util.format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));
                }
                /** @type {?} */
                var newMasterTu = ( /** @type {?} */(foreignTransUnit)).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);
                /** @type {?} */
                var translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');
                if (!translationbundleElem) {
                    throw new Error(util.format('File "%s" seems to be no xtb file (should contain a translationbundle element)', this._filename));
                }
                /** @type {?} */
                var translationElement = translationbundleElem.ownerDocument.createElement('translation');
                translationElement.setAttribute('id', foreignTransUnit.id);
                /** @type {?} */
                var newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';
                if (!( /** @type {?} */(foreignTransUnit)).isICUMessage(newContent)) {
                    newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();
                }
                DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);
                /** @type {?} */
                var newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);
                /** @type {?} */
                var inserted = false;
                /** @type {?} */
                var isAfterElementPartOfFile = false;
                if (!!importAfterElement) {
                    /** @type {?} */
                    var insertionPoint = this.transUnitWithId(importAfterElement.id);
                    if (!!insertionPoint) {
                        isAfterElementPartOfFile = true;
                    }
                }
                if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {
                    translationbundleElem.appendChild(newTu.asXmlElement());
                    inserted = true;
                }
                else if (importAfterElement === null) {
                    /** @type {?} */
                    var firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');
                    if (firstTranslationElement) {
                        DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);
                        inserted = true;
                    }
                    else {
                        // no trans-unit, empty file, so add to bundle at end
                        translationbundleElem.appendChild(newTu.asXmlElement());
                        inserted = true;
                    }
                }
                else {
                    /** @type {?} */
                    var refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);
                    if (refUnitElement) {
                        DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);
                        inserted = true;
                    }
                }
                if (inserted) {
                    this.lazyInitializeTransUnits();
                    this.transUnits.push(newTu);
                    this.countNumbers();
                    return newTu;
                }
                else {
                    return null;
                }
            };
        /**
         * Create a new translation file for this file for a given language.
         * Normally, this is just a copy of the original one.
         * But for XMB the translation file has format 'XTB'.
         * @param {?} lang Language code
         * @param {?} filename expected filename to store file
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @return {?}
         */
        XtbFile.prototype.createTranslationFileForLang = /**
         * Create a new translation file for this file for a given language.
         * Normally, this is just a copy of the original one.
         * But for XMB the translation file has format 'XTB'.
         * @param {?} lang Language code
         * @param {?} filename expected filename to store file
         * @param {?} isDefaultLang Flag, wether file contains the default language.
         * Then source and target are just equal.
         * The content will be copied.
         * State will be final.
         * @param {?} copyContent Flag, wether to copy content or leave it empty.
         * Wben true, content will be copied from source.
         * When false, content will be left empty (if it is not the default language).
         * @return {?}
         */
            function (lang, filename, isDefaultLang, copyContent) {
                throw new Error(util.format('File "%s", xtb files are not translatable, they are already translations', filename));
            };
        return XtbFile;
    }(AbstractTranslationMessagesFile));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Helper class to read translation files depending on format.
     * This is part of the public api
     */
    var /**
     * Helper class to read translation files depending on format.
     * This is part of the public api
     */ TranslationMessagesFileFactory = /** @class */ (function () {
        function TranslationMessagesFileFactory() {
        }
        /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
         * @param {?} xmlContent the file content
         * @param {?} path the path of the file (only used to remember it)
         * @param {?} encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return {?} either XliffFile or XmbFile
         */
        TranslationMessagesFileFactory.fromFileContent = /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
         * @param {?} xmlContent the file content
         * @param {?} path the path of the file (only used to remember it)
         * @param {?} encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return {?} either XliffFile or XmbFile
         */
            function (i18nFormat, xmlContent, path, encoding, optionalMaster) {
                return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);
            };
        /**
         * Read file function for any file with unknown format.
         * This functions tries to guess the format based on the filename and the content of the file.
         * Result depends on detected format, either XliffFile or XmbFile.
         * @param {?} xmlContent the file content
         * @param {?} path the path of the file (only used to remember it)
         * @param {?} encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return {?} either XliffFile or XmbFile
         */
        TranslationMessagesFileFactory.fromUnknownFormatFileContent = /**
         * Read file function for any file with unknown format.
         * This functions tries to guess the format based on the filename and the content of the file.
         * Result depends on detected format, either XliffFile or XmbFile.
         * @param {?} xmlContent the file content
         * @param {?} path the path of the file (only used to remember it)
         * @param {?} encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return {?} either XliffFile or XmbFile
         */
            function (xmlContent, path, encoding, optionalMaster) {
                return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);
            };
        /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
         * @param xmlContent the file content
         * @param path the path of the file (only used to remember it)
         * @param encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return either XliffFile or XmbFile
         */
        /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
         * @param {?} xmlContent the file content
         * @param {?} path the path of the file (only used to remember it)
         * @param {?} encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return {?} either XliffFile or XmbFile
         */
        TranslationMessagesFileFactory.prototype.createFileFromFileContent = /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
         * @param {?} xmlContent the file content
         * @param {?} path the path of the file (only used to remember it)
         * @param {?} encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return {?} either XliffFile or XmbFile
         */
            function (i18nFormat, xmlContent, path, encoding, optionalMaster) {
                if (i18nFormat === FORMAT_XLIFF12) {
                    return new XliffFile(xmlContent, path, encoding);
                }
                if (i18nFormat === FORMAT_XLIFF20) {
                    return new Xliff2File(xmlContent, path, encoding);
                }
                if (i18nFormat === FORMAT_XMB) {
                    return new XmbFile(this, xmlContent, path, encoding);
                }
                if (i18nFormat === FORMAT_XTB) {
                    return new XtbFile(this, xmlContent, path, encoding, optionalMaster);
                }
                throw new Error(util.format('oops, unsupported format "%s"', i18nFormat));
            };
        /**
         * Read file function for any file with unknown format.
         * This functions tries to guess the format based on the filename and the content of the file.
         * Result depends on detected format, either XliffFile or XmbFile.
         * @param xmlContent the file content
         * @param path the path of the file (only used to remember it)
         * @param encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return either XliffFile or XmbFile
         */
        /**
         * Read file function for any file with unknown format.
         * This functions tries to guess the format based on the filename and the content of the file.
         * Result depends on detected format, either XliffFile or XmbFile.
         * @param {?} xmlContent the file content
         * @param {?} path the path of the file (only used to remember it)
         * @param {?} encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return {?} either XliffFile or XmbFile
         */
        TranslationMessagesFileFactory.prototype.createFileFromUnknownFormatFileContent = /**
         * Read file function for any file with unknown format.
         * This functions tries to guess the format based on the filename and the content of the file.
         * Result depends on detected format, either XliffFile or XmbFile.
         * @param {?} xmlContent the file content
         * @param {?} path the path of the file (only used to remember it)
         * @param {?} encoding utf-8, ... used to parse XML.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
         * (this is used to support state infos, that are based on comparing original with translated version)
         * Ignored for other formats.
         * @return {?} either XliffFile or XmbFile
         */
            function (xmlContent, path, encoding, optionalMaster) {
                /** @type {?} */
                var formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];
                if (path && path.endsWith('xmb')) {
                    formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];
                }
                if (path && path.endsWith('xtb')) {
                    formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];
                }
                // try all candidate formats to get the right one
                for (var i = 0; i < formatCandidates.length; i++) {
                    /** @type {?} */
                    var formatCandidate = formatCandidates[i];
                    try {
                        /** @type {?} */
                        var translationFile = TranslationMessagesFileFactory.fromFileContent(formatCandidate, xmlContent, path, encoding, optionalMaster);
                        if (translationFile) {
                            return translationFile;
                        }
                    }
                    catch (e) {
                        // seams to be the wrong format
                    }
                }
                throw new Error(util.format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));
            };
        return TranslationMessagesFileFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.NgxI18nsupportLibModule = NgxI18nsupportLibModule;
    exports.TranslationMessagesFileFactory = TranslationMessagesFileFactory;
    exports.FORMAT_XLIFF12 = FORMAT_XLIFF12;
    exports.FORMAT_XLIFF20 = FORMAT_XLIFF20;
    exports.FORMAT_XMB = FORMAT_XMB;
    exports.FORMAT_XTB = FORMAT_XTB;
    exports.FILETYPE_XLIFF12 = FILETYPE_XLIFF12;
    exports.FILETYPE_XLIFF20 = FILETYPE_XLIFF20;
    exports.FILETYPE_XMB = FILETYPE_XMB;
    exports.FILETYPE_XTB = FILETYPE_XTB;
    exports.STATE_NEW = STATE_NEW;
    exports.STATE_TRANSLATED = STATE_TRANSLATED;
    exports.STATE_FINAL = STATE_FINAL;
    exports.NORMALIZATION_FORMAT_DEFAULT = NORMALIZATION_FORMAT_DEFAULT;
    exports.NORMALIZATION_FORMAT_NGXTRANSLATE = NORMALIZATION_FORMAT_NGXTRANSLATE;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWkxOG5zdXBwb3J0LW5neC1pMThuc3VwcG9ydC1saWIudW1kLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvbGliL25neC1pMThuc3VwcG9ydC1saWIubW9kdWxlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvYXBpL2NvbnN0YW50cy50cyIsIi4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL2RvbS11dGlsaXRpZXMudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3htbC1zZXJpYWxpemVyLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9hYnN0cmFjdC10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9hYnN0cmFjdC10cmFucy11bml0LnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9wYXJzZWQtbWVzc2FnZS1wYXJ0LnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9wYXJzZWQtbWVzc2FnZS1wYXJ0LXRleHQudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3BhcnNlZC1tZXNzYWdlLXBhcnQtcGxhY2Vob2xkZXIudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3BhcnNlZC1tZXNzYWdlLXBhcnQtc3RhcnQtdGFnLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9wYXJzZWQtbWVzc2FnZS1wYXJ0LWVuZC10YWcudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL2ljdS1tZXNzYWdlLXRva2VuaXplci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwvaWN1LW1lc3NhZ2UudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3BhcnNlZC1tZXNzYWdlLXBhcnQtaWN1LW1lc3NhZ2UudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3BhcnNlZC1tZXNzYWdlLXBhcnQtaWN1LW1lc3NhZ2UtcmVmLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC9wYXJzZWQtbWVzc2FnZS1wYXJ0LWVtcHR5LXRhZy50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwvcGFyc2VkLW1lc3NhZ2UudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3BhcnNlZC1tZXNzYWdlLXRva2VuaXplci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwvYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXIudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3RhZy1tYXBwaW5nLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC94bGlmZi1tZXNzYWdlLXBhcnNlci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwveGxpZmYtdHJhbnMtdW5pdC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwveGxpZmYtZmlsZS50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwveG1iLW1lc3NhZ2UtcGFyc2VyLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC94bWItdHJhbnMtdW5pdC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwveG1iLWZpbGUudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3hsaWZmMi1tZXNzYWdlLXBhcnNlci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwveGxpZmYyLXRyYW5zLXVuaXQudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9pbXBsL3hsaWZmMi1maWxlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWIvaW1wbC94dGItdHJhbnMtdW5pdC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliL2ltcGwveHRiLWZpbGUudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi9hcGkvdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZS1mYWN0b3J5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtcclxuICBdLFxyXG4gIGRlY2xhcmF0aW9uczogW10sXHJcbiAgZXhwb3J0czogW11cclxufSlcclxuZXhwb3J0IGNsYXNzIE5neEkxOG5zdXBwb3J0TGliTW9kdWxlIHsgfVxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAwOC4wNS4yMDE3LlxyXG4gKiBTb21lIGNvbnN0YW50IHZhbHVlcyB1c2VkIGluIHRoZSBBUEkuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIHN1cHBvcnRlZCBmaWxlIGZvcm1hdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBGT1JNQVRfWExJRkYxMiA9ICd4bGYnO1xyXG5leHBvcnQgY29uc3QgRk9STUFUX1hMSUZGMjAgPSAneGxmMic7XHJcbmV4cG9ydCBjb25zdCBGT1JNQVRfWE1CID0gJ3htYic7XHJcbmV4cG9ydCBjb25zdCBGT1JNQVRfWFRCID0gJ3h0Yic7XHJcblxyXG4vKipcclxuICogRmlsZSB0eXBlc1xyXG4gKiAocmV0dXJuZWQgYnkgZmlsZVR5cGUoKSBtZXRob2QpXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRklMRVRZUEVfWExJRkYxMiA9ICdYTElGRiAxLjInO1xyXG5leHBvcnQgY29uc3QgRklMRVRZUEVfWExJRkYyMCA9ICdYTElGRiAyLjAnO1xyXG5leHBvcnQgY29uc3QgRklMRVRZUEVfWE1CID0gJ1hNQic7XHJcbmV4cG9ydCBjb25zdCBGSUxFVFlQRV9YVEIgPSAnWFRCJztcclxuXHJcbi8qKlxyXG4gKiBhYnN0cmFjdCBzdGF0ZSB2YWx1ZS5cclxuICogVGhlcmUgYXJlIG9ubHkgMyBzdXBwb3J0ZWQgc3RhdGUgdmFsdWVzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBORVcuXHJcbiAqIFNpZ25hbHMgYW4gdW50cmFuc2xhdGVkIHVuaXQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU1RBVEVfTkVXID0gJ25ldyc7XHJcbi8qKlxyXG4gKiBTdGF0ZSBUUkFOU0xBVEVELlxyXG4gKiBTaWduYWxzIGEgdHJhbnNsYXRlZCB1bml0LCB0aGF0IGlzIG5vdCByZXZpZXdlZCB1bnRpbCBub3cuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU1RBVEVfVFJBTlNMQVRFRCA9ICd0cmFuc2xhdGVkJztcclxuLyoqXHJcbiAqIFN0YXRlIEZJTkFMLlxyXG4gKiBTaWduYWxzIGEgdHJhbnNsYXRlZCB1bml0LCB0aGF0IGlzIHJldmlld2VkIGFuZCByZWFkeSBmb3IgdXNlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFNUQVRFX0ZJTkFMID0gJ2ZpbmFsJztcclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemF0b24gbWVzc2FnZSBmb3JtYXRzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IGZvcm1hdCwgY29udGFpbnMgcGxhY2Vob2xkZXJzLCBodG1sIG1hcmt1cC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBOT1JNQUxJWkFUSU9OX0ZPUk1BVF9ERUZBVUxUID0gJ2RlZmF1bHQnO1xyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBmb3IgdXNhZ2UgaW4gbmd4dHJhbnNsYXRlIG1lc3NhZ2VzLlxyXG4gKiBQbGFjZWhvbGRlciBhcmUgaW4gdGhlIGZvcm0ge3tufX0sIG5vIGh0bWwgbWFya3VwLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE5PUk1BTElaQVRJT05fRk9STUFUX05HWFRSQU5TTEFURSA9ICduZ3h0cmFuc2xhdGUnO1xyXG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsImltcG9ydCB7RE9NUGFyc2VyLCBYTUxTZXJpYWxpemVyfSBmcm9tICd4bWxkb20nO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDEuMDUuMjAxNy5cclxuICogU29tZSBUb29sIGZ1bmN0aW9ucyBmb3IgWE1MIEhhbmRsaW5nLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBET01VdGlsaXRpZXMge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRoZSBmaXJzdCBzdWJlbGVtZW50IHdpdGggdGhlIGdpdmVuIHRhZy5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB0YWdOYW1lIHRhZ05hbWVcclxuICAgICAqIEByZXR1cm4gc3ViZWxlbWVudCBvciBudWxsLCBpZiBub3QgZXhpc3RpbmcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKGVsZW1lbnQ6IEVsZW1lbnQgfCBEb2N1bWVudCwgdGFnTmFtZTogc3RyaW5nKTogRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdFbGVtZW50cyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nRWxlbWVudHMgJiYgbWF0Y2hpbmdFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ0VsZW1lbnRzLml0ZW0oMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIGFuIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gdGFnIGFuZCBpZCBhdHRyaWJ1dGUuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gdGFnTmFtZSB0YWdOYW1lXHJcbiAgICAgKiBAcGFyYW0gaWQgaWRcclxuICAgICAqIEByZXR1cm4gc3ViZWxlbWVudCBvciBudWxsLCBpZiBub3QgZXhpc3RpbmcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RWxlbWVudEJ5VGFnTmFtZUFuZElkKGVsZW1lbnQ6IEVsZW1lbnQgfCBEb2N1bWVudCwgdGFnTmFtZTogc3RyaW5nLCBpZDogc3RyaW5nKTogRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdFbGVtZW50cyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nRWxlbWVudHMgJiYgbWF0Y2hpbmdFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hpbmdFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZTogRWxlbWVudCA9IG1hdGNoaW5nRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBuZXh0IHNpYmxpbmcsIHRoYXQgaXMgYW4gZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRFbGVtZW50Rm9sbG93aW5nU2libGluZyhlbGVtZW50OiBFbGVtZW50KTogRWxlbWVudCB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZSA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgd2hpbGUgKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUubm9kZVR5cGUgPT09IGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPEVsZW1lbnQ+IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZSA9IGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHByZXZpb3VzIHNpYmxpbmcsIHRoYXQgaXMgYW4gZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRFbGVtZW50UHJlY2VkaW5nU2libGluZyhlbGVtZW50OiBFbGVtZW50KTogRWxlbWVudCB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZSA9IGVsZW1lbnQucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgICAgIHdoaWxlIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChlLm5vZGVUeXBlID09PSBlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxFbGVtZW50PiBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUgPSBlLnByZXZpb3VzU2libGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gY29udGVudCBvZiBlbGVtZW50IGFzIHN0cmluZywgaW5jbHVkaW5nIGFsbCBtYXJrdXAuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIGNvbnRlbnQgb2YgZWxlbWVudCBhcyBzdHJpbmcsIGluY2x1ZGluZyBhbGwgbWFya3VwLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFhNTENvbnRlbnQoZWxlbWVudDogRWxlbWVudCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhlbGVtZW50KTtcclxuICAgICAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcclxuICAgICAgICBjb25zdCByZVN0YXJ0TXNnOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCc8JyArIHRhZ05hbWUgKyAnW14+XSo+JywgJ2cnKTtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShyZVN0YXJ0TXNnLCAnJyk7XHJcbiAgICAgICAgY29uc3QgcmVFbmRNc2c6IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJzwvJyArIHRhZ05hbWUgKyAnPicsICdnJyk7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UocmVFbmRNc2csICcnKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIFBDREFUQSBjb250ZW50IG9mIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIFBDREFUQSBjb250ZW50IG9mIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UENEQVRBKGVsZW1lbnQ6IEVsZW1lbnQpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkTm9kZXM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGROb2Rlcy5pdGVtKGkpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IGNoaWxkLlRFWFRfTk9ERSB8fCBjaGlsZC5ub2RlVHlwZSA9PT0gY2hpbGQuQ0RBVEFfU0VDVElPTl9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBjaGlsZC5ub2RlVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDAgPyBudWxsIDogcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVwbGFjZSBQQ0RBVEEgY29udGVudCB3aXRoIGEgbmV3IG9uZS5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSBwY2RhdGEgcGNkYXRhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChlbGVtZW50OiBFbGVtZW50LCBwY2RhdGE6IHN0cmluZykge1xyXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgY2hpbGRyZW5cclxuICAgICAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGFyc2VJQ1VNZXNzYWdlIHBjZGF0YVxyXG4gICAgICAgIGNvbnN0IHBjZGF0YUZyYWdtZW50OiBEb2N1bWVudCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoJzxmcmFnbWVudD4nICsgcGNkYXRhICsgJzwvZnJhZ21lbnQ+JywgJ2FwcGxpY2F0aW9uL3htbCcpO1xyXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gcGNkYXRhRnJhZ21lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZyYWdtZW50JykuaXRlbSgwKS5jaGlsZE5vZGVzO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBuZXdDaGlsZHJlbi5pdGVtKGopO1xyXG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKG5ld0NoaWxkLCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmluZCB0aGUgcHJldmlvdXMgc2libGluZyB0aGF0IGlzIGFuIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHRoZSBwcmV2aW91cyBzaWJsaW5nIHRoYXQgaXMgYW4gZWxlbWVudCBvciBudWxsLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFByZXZpb3VzRWxlbWVudFNpYmxpbmcoZWxlbWVudDogTm9kZSk6IEVsZW1lbnQge1xyXG4gICAgICAgIGxldCBub2RlID0gZWxlbWVudC5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPEVsZW1lbnQ+IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBFbGVtZW50IE5vZGUgdGhhdCBpcyB0aGUgbmV4dCBzaWJsaW5nIG9mIGEgZ2l2ZW4gbm9kZS5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50TmFtZVRvQ3JlYXRlIGVsZW1lbnROYW1lVG9DcmVhdGVcclxuICAgICAqIEBwYXJhbSBwcmV2aW91c1NpYmxpbmcgcHJldmlvdXNTaWJsaW5nXHJcbiAgICAgKiBAcmV0dXJuIG5ldyBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRm9sbG93aW5nU2libGluZyhlbGVtZW50TmFtZVRvQ3JlYXRlOiBzdHJpbmcsIHByZXZpb3VzU2libGluZzogTm9kZSk6IEVsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBwcmV2aW91c1NpYmxpbmcub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnROYW1lVG9DcmVhdGUpO1xyXG4gICAgICAgIHJldHVybiA8RWxlbWVudD4gRE9NVXRpbGl0aWVzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHByZXZpb3VzU2libGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgbmV3RWxlbWVudCBkaXJlY3RseSBhZnRlciBwcmV2aW91c1NpYmxpbmcuXHJcbiAgICAgKiBAcGFyYW0gbmV3RWxlbWVudCBuZXdFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gcHJldmlvdXNTaWJsaW5nIHByZXZpb3VzU2libGluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluc2VydEFmdGVyKG5ld0VsZW1lbnQ6IE5vZGUsIHByZXZpb3VzU2libGluZzogTm9kZSk6IE5vZGUge1xyXG4gICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIHByZXZpb3VzU2libGluZy5uZXh0U2libGluZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobmV3RWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdFbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0IG5ld0VsZW1lbnQgZGlyZWN0bHkgYmVmb3JlIG5leHRTaWJsaW5nLlxyXG4gICAgICogQHBhcmFtIG5ld0VsZW1lbnQgbmV3RWxlbWVudFxyXG4gICAgICogQHBhcmFtIG5leHRTaWJsaW5nIG5leHRTaWJsaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQ6IE5vZGUsIG5leHRTaWJsaW5nOiBOb2RlKTogTm9kZSB7XHJcbiAgICAgICAgbmV4dFNpYmxpbmcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgbmV4dFNpYmxpbmcpO1xyXG4gICAgICAgIHJldHVybiBuZXdFbGVtZW50O1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBBbiBYbWxTZXJpYWxpemVyIHRoYXQgc3VwcG9ydHMgZm9ybWF0dGluZy5cclxuICogT3JpZ2luYWwgY29kZSBpcyBiYXNlZCBvbiBbeG1sZG9tXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS94bWxkb20pXHJcbiAqIEl0IGlzIGV4dGVuZGVkIHRvIHN1cHBvcnQgZm9ybWF0dGluZyBpbmNsdWRpbmcgaGFuZGxpbmcgb2YgZWxlbWVudHMgd2l0aCBtaXhlZCBjb250ZW50LlxyXG4gKiBFeGFtcGxlIGZvcm1hdHRlZCBvdXRwdXQ6XHJcbiAqIDxwcmU+XHJcbiAqICAgICA8ZG9jPlxyXG4gKiAgICAgICAgIDxlbGVtZW50PkFuIGVsZW1lbnQgd2l0aFxyXG4gKiAgICAgICAgICAgICA8Yj5taXhlZDwvYj5cclxuICogICAgICAgICAgICAgIGNvbnRlbnRcclxuICogICAgICAgICA8L2VsZW1lbnQ+XHJcbiAqICAgICA8L2RvYz5cclxuICogPC9wcmU+XHJcbiAqIFNhbWUgd2hlbiBcImVsZW1lbnRcIiBpcyBpbmRpY2F0ZWQgYXMgXCJtaXhlZENvbnRlbnRFbGVtZW50XCI6XHJcbiAqIDxwcmU+XHJcbiAqICAgICA8ZG9jPlxyXG4gKiAgICAgICAgIDxlbGVtZW50PkFuIGVsZW1lbnQgd2l0aCA8Yj5taXhlZDwvYj4gY29udGVudDwvZWxlbWVudD5cclxuICogICAgIDwvZG9jPlxyXG4gKiA8L3ByZT5cclxuICovXHJcblxyXG5pbnRlcmZhY2UgTmFtZXNwYWNlIHtcclxuICAgIHByZWZpeDogc3RyaW5nO1xyXG4gICAgbmFtZXNwYWNlOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIHVzZWQgdG8gY29udHJvbCB0aGUgZm9ybWF0dGluZ1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBYbWxTZXJpYWxpemVyT3B0aW9ucyB7XHJcbiAgICBiZWF1dGlmeT86IGJvb2xlYW47IC8vIHNldCB0byBhY3RpdmF0ZSBiZWF1dGlmeVxyXG4gICAgaW5kZW50U3RyaW5nPzogc3RyaW5nOyAvLyBTZXF1ZW5jZSB1c2VzIGZvciBpbmRlbnRhdGlvbiwgbXVzdCBvbmx5IGNvbnRhaW4gd2hpdGUgc3BhY2UgY2hhcnMsIGUuZy4gXCIgIFwiIG9yIFwiICAgIFwiIG9yIFwiXFx0XCJcclxuICAgIG1peGVkQ29udGVudEVsZW1lbnRzPzogc3RyaW5nW107IC8vIE5hbWVzIG9mIGVsZW1lbnRzIGNvbnRhaW5pbmcgbWl4ZWQgY29udGVudCAodGhlc2UgYXJlIG5vdCBiZWF1dGlmaWVkKVxyXG59XHJcblxyXG5jb25zdCBERUZBVUxUX0lOREVOVF9TVFJJTkcgPSAnICAnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFhtbFNlcmlhbGl6ZXIge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlcmlhbHplIHhtbCBkb2N1bWVudCB0byBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgdGhlIGRvY3VtZW50XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjYW4gYmUgdXNlZCB0byBhY3RpdmF0ZSBiZWF1dGlmeWluZy5cclxuICAgICAqL1xyXG4gICAgc2VyaWFsaXplVG9TdHJpbmcoZG9jdW1lbnQ6IERvY3VtZW50LCBvcHRpb25zPzogWG1sU2VyaWFsaXplck9wdGlvbnMpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IFtdO1xyXG4gICAgICAgIGxldCB2aXNpYmxlTmFtZXNwYWNlczogTmFtZXNwYWNlW10gPSBbXTtcclxuICAgICAgICBjb25zdCByZWZOb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgIGxldCBwcmVmaXggPSByZWZOb2RlLnByZWZpeDtcclxuICAgICAgICBjb25zdCB1cmkgPSByZWZOb2RlLm5hbWVzcGFjZVVSSTtcclxuXHJcbiAgICAgICAgaWYgKHVyaSAmJiBwcmVmaXggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcmVmaXggPSByZWZOb2RlLmxvb2t1cFByZWZpeCh1cmkpO1xyXG4gICAgICAgICAgICBpZiAocHJlZml4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZpc2libGVOYW1lc3BhY2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lc3BhY2U6IHVyaSwgcHJlZml4OiBudWxsfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHtuYW1lc3BhY2U6dXJpLHByZWZpeDonJ31cclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5kZW50U3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250YWluc09ubHlXaGl0ZVNwYWNlKG9wdGlvbnMuaW5kZW50U3RyaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmRlbnRTdHJpbmcgbXVzdCBub3QgY29udGFpbiBub24gd2hpdGUgY2hhcmFjdGVycycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZG9TZXJpYWxpemVUb1N0cmluZyhkb2N1bWVudCwgb3B0aW9ucywgYnVmLCAwLCBmYWxzZSwgdmlzaWJsZU5hbWVzcGFjZXMpO1xyXG4gICAgICAgIHJldHVybiBidWYuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWluIGZvcm1hdCBtZXRob2QgdGhhdCBkb2VzIGFsbCB0aGUgd29yay5cclxuICAgICAqIE91dHB1dHMgYSBub2RlIHRvIHRoZSBvdXRwdXRidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0gbm9kZSB0aGUgbm9kZSB0byBiZSBmb3JtYXR0ZWQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gYnVmIG91dHB1dGJ1ZmZlciwgbmV3IG91dHB1dCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoaXMgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0gaW5kZW50TGV2ZWwgTGV2ZXIgb2YgaW5kZW50YXRpb24gZm9yIGZvcm1hdHRlZCBvdXRwdXQuXHJcbiAgICAgKiBAcGFyYW0gcGFydE9mTWl4ZWRDb250ZW50IHRydWUsIGlmIG5vZGUgaXMgYSBzdWJlbGVtZW50IG9mIGFuIGVsZW1lbnQgY29udGFpbmluZCBtaXhlZCBjb250ZW50LlxyXG4gICAgICogQHBhcmFtIHZpc2libGVOYW1lc3BhY2VzIHZpc2libGVOYW1lc3BhY2VzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZG9TZXJpYWxpemVUb1N0cmluZyhub2RlOiBOb2RlLCBvcHRpb25zOiBYbWxTZXJpYWxpemVyT3B0aW9ucywgYnVmOiBzdHJpbmdbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnRMZXZlbDogbnVtYmVyLCBwYXJ0T2ZNaXhlZENvbnRlbnQ6IGJvb2xlYW4sIHZpc2libGVOYW1lc3BhY2VzOiBOYW1lc3BhY2VbXSkge1xyXG4gICAgICAgIGxldCBjaGlsZDogTm9kZTtcclxuICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBub2RlLkVMRU1FTlRfTk9ERTpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnROb2RlOiBFbGVtZW50ID0gPEVsZW1lbnQ+IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IGVsZW1lbnROb2RlLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBhdHRycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnROb2RlLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IGVsZW1lbnROb2RlLnRhZ05hbWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50SGFzTWl4ZWRDb250ZW50ID0gdGhpcy5pc01peGVkQ29udGVudEVsZW1lbnQobm9kZU5hbWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRPZk1peGVkQ29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKCc8JyAsIG5vZGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRJbmRlbnRlZChvcHRpb25zLCBidWYsIGluZGVudExldmVsLCAnPCcgLCBub2RlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBuYW1lc3BhY2VzIGZvciBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSAneG1sbnMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVOYW1lc3BhY2VzLnB1c2goe3ByZWZpeDogYXR0ci5sb2NhbE5hbWUsIG5hbWVzcGFjZTogYXR0ci52YWx1ZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3htbG5zJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlTmFtZXNwYWNlcy5wdXNoKHtwcmVmaXg6ICcnLCBuYW1lc3BhY2U6IGF0dHIudmFsdWV9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmVlZE5hbWVzcGFjZURlZmluZShhdHRyLCB2aXNpYmxlTmFtZXNwYWNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYXR0ci5wcmVmaXggfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVyaSA9IGF0dHIubmFtZXNwYWNlVVJJO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBucyA9IHByZWZpeCA/ICcgeG1sbnM6JyArIHByZWZpeCA6ICcgeG1sbnMnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYucHVzaChucywgJz1cIicsIHVyaSwgJ1wiJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVOYW1lc3BhY2VzLnB1c2goe3ByZWZpeDogcHJlZml4LCBuYW1lc3BhY2U6IHVyaX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvU2VyaWFsaXplVG9TdHJpbmcoYXR0ciwgb3B0aW9ucywgYnVmLCBpbmRlbnRMZXZlbCwgZmFsc2UsIHZpc2libGVOYW1lc3BhY2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGFkZCBuYW1lc3BhY2UgZm9yIGN1cnJlbnQgbm9kZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmVlZE5hbWVzcGFjZURlZmluZShlbGVtZW50Tm9kZSwgdmlzaWJsZU5hbWVzcGFjZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gZWxlbWVudE5vZGUucHJlZml4IHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5vZGUubmFtZXNwYWNlVVJJO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5zID0gcHJlZml4ID8gJyB4bWxuczonICsgcHJlZml4IDogJyB4bWxucyc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2gobnMsICc9XCInLCB1cmksICdcIicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVOYW1lc3BhY2VzLnB1c2goe3ByZWZpeDogcHJlZml4LCBuYW1lc3BhY2U6IHVyaX0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKCc+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXMgY2RhdGEgY2hpbGQgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNDb21wbGV4Q29udGVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IGNoaWxkLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29tcGxleENvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9TZXJpYWxpemVUb1N0cmluZyhjaGlsZCwgb3B0aW9ucywgYnVmLCBpbmRlbnRMZXZlbCArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0T2ZNaXhlZENvbnRlbnQgfHwgZWxlbWVudEhhc01peGVkQ29udGVudCwgdmlzaWJsZU5hbWVzcGFjZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnRPZk1peGVkQ29udGVudCAmJiAhZWxlbWVudEhhc01peGVkQ29udGVudCAmJiBoYXNDb21wbGV4Q29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEluZGVudGVkKG9wdGlvbnMsIGJ1ZiwgaW5kZW50TGV2ZWwsICc8LycsIG5vZGVOYW1lLCAnPicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKCc8LycsIG5vZGVOYW1lLCAnPicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goJy8+Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNhc2Ugbm9kZS5ET0NVTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICBjYXNlIG5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1NlcmlhbGl6ZVRvU3RyaW5nKGNoaWxkLCBvcHRpb25zLCBidWYsIGluZGVudExldmVsLCBmYWxzZSwgdmlzaWJsZU5hbWVzcGFjZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNhc2Ugbm9kZS5BVFRSSUJVVEVfTk9ERTpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJOb2RlID0gPEF0dHI+IG5vZGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmLnB1c2goJyAnLCBhdHRyTm9kZS5uYW1lLCAnPVwiJywgYXR0ck5vZGUudmFsdWUucmVwbGFjZSgvWzwmXCJdL2csIHRoaXMuX3htbEVuY29kZXIpLCAnXCInKTtcclxuICAgICAgICAgICAgY2FzZSBub2RlLlRFWFRfTk9ERTpcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gPFRleHQ+IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuYmVhdXRpZnkgfHwgcGFydE9mTWl4ZWRDb250ZW50IHx8ICF0aGlzLmNvbnRhaW5zT25seVdoaXRlU3BhY2UodGV4dE5vZGUuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmLnB1c2godGV4dE5vZGUuZGF0YS5yZXBsYWNlKC9bPCZdL2csIHRoaXMuX3htbEVuY29kZXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBub2RlLkNEQVRBX1NFQ1RJT05fTk9ERTpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNkYXRhc2VjdGlvbk5vZGUgPSA8Q0RBVEFTZWN0aW9uPiBub2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1Zi5wdXNoKCc8IVtDREFUQVsnLCBjZGF0YXNlY3Rpb25Ob2RlLmRhdGEsICddXT4nKTtcclxuICAgICAgICAgICAgY2FzZSBub2RlLkNPTU1FTlRfTk9ERTpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnROb2RlID0gPENvbW1lbnQ+IG5vZGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmLnB1c2goJzwhLS0nLCBjb21tZW50Tm9kZS5kYXRhLCAnLS0+Jyk7XHJcbiAgICAgICAgICAgIGNhc2Ugbm9kZS5ET0NVTUVOVF9UWVBFX05PREU6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudHR5cGVOb2RlID0gPERvY3VtZW50VHlwZT4gbm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmlkID0gZG9jdW1lbnR0eXBlTm9kZS5wdWJsaWNJZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN5c2lkID0gZG9jdW1lbnR0eXBlTm9kZS5zeXN0ZW1JZDtcclxuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKCc8IURPQ1RZUEUgJywgZG9jdW1lbnR0eXBlTm9kZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChwdWJpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKCcgUFVCTElDIFwiJywgcHViaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzeXNpZCAmJiBzeXNpZCAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKCdcIiBcIicsIHN5c2lkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goJ1wiPicpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzeXNpZCAmJiBzeXNpZCAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goJyBTWVNURU0gXCInLCBzeXNpZCwgJ1wiPicpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWIgPSBkb2N1bWVudHR5cGVOb2RlLmludGVybmFsU3Vic2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goJyBbJywgc3ViLCAnXScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBidWYucHVzaCgnPicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjYXNlIG5vZGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGlOb2RlID0gPFByb2Nlc3NpbmdJbnN0cnVjdGlvbj4gbm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWYucHVzaCggJzw/JywgcGlOb2RlLnRhcmdldCwgJyAnLCBwaU5vZGUuZGF0YSwgJz8+Jyk7XHJcbiAgICAgICAgICAgIGNhc2Ugbm9kZS5FTlRJVFlfUkVGRVJFTkNFX05PREU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmLnB1c2goJyYnLCBub2RlLm5vZGVOYW1lLCAnOycpO1xyXG4gICAgICAgICAgICAvLyBjYXNlIEVOVElUWV9OT0RFOlxyXG4gICAgICAgICAgICAvLyBjYXNlIE5PVEFUSU9OX05PREU6XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBidWYucHVzaCgnPz8nLCBub2RlLm5vZGVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBuZWVkTmFtZXNwYWNlRGVmaW5lKG5vZGU6IEVsZW1lbnQgfCBBdHRyLCB2aXNpYmxlTmFtZXNwYWNlczogTmFtZXNwYWNlW10pOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBwcmVmaXggPSBub2RlLnByZWZpeCB8fCAnJztcclxuICAgICAgICBjb25zdCB1cmkgPSBub2RlLm5hbWVzcGFjZVVSSTtcclxuICAgICAgICBpZiAoIXByZWZpeCAmJiAhdXJpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJ3htbCcgJiYgdXJpID09PSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xyXG4gICAgICAgICAgICB8fCB1cmkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGkgPSB2aXNpYmxlTmFtZXNwYWNlcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCBucyA9IHZpc2libGVOYW1lc3BhY2VzW2ldO1xyXG4gICAgICAgICAgICAvLyBnZXQgbmFtZXNwYWNlIHByZWZpeFxyXG4gICAgICAgICAgICBpZiAobnMucHJlZml4ID09PSBwcmVmaXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBucy5uYW1lc3BhY2UgIT09IHVyaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF94bWxFbmNvZGVyKGM6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGMgPT09ICc8JyAmJiAnJmx0OycgfHxcclxuICAgICAgICAgICAgYyA9PT0gJz4nICYmICcmZ3Q7JyB8fFxyXG4gICAgICAgICAgICBjID09PSAnJicgJiYgJyZhbXA7JyB8fFxyXG4gICAgICAgICAgICBjID09PSAnXCInICYmICcmcXVvdDsnIHx8XHJcbiAgICAgICAgICAgICcmIycgKyBjLmNoYXJDb2RlQXQoMCkgKyAnOyc7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvdXRwdXRJbmRlbnRlZChvcHRpb25zOiBYbWxTZXJpYWxpemVyT3B0aW9ucywgYnVmOiBzdHJpbmdbXSwgaW5kZW50TGV2ZWw6IG51bWJlciwgLi4ub3V0cHV0UGFydHM6IHN0cmluZ1tdKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYmVhdXRpZnkpIHtcclxuICAgICAgICAgICAgYnVmLnB1c2goJ1xcbicpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZW50TGV2ZWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBidWYucHVzaCh0aGlzLmluZGVudGF0aW9uU3RyaW5nKG9wdGlvbnMsIGluZGVudExldmVsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnVmLnB1c2goLi4ub3V0cHV0UGFydHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5kZW50YXRpb25TdHJpbmcob3B0aW9uczogWG1sU2VyaWFsaXplck9wdGlvbnMsIGluZGVudExldmVsOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGluZGVudCA9IChvcHRpb25zLmluZGVudFN0cmluZykgPyBvcHRpb25zLmluZGVudFN0cmluZyA6IERFRkFVTFRfSU5ERU5UX1NUUklORztcclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRlbnRMZXZlbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIGluZGVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciB0YWdOYW1lIGlzIGFuIGVsZW1lbnQgY29udGFpbmluZyBtaXhlZCBjb250ZW50LlxyXG4gICAgICogQHBhcmFtIHRhZ05hbWUgdGFnTmFtZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzTWl4ZWRDb250ZW50RWxlbWVudCh0YWdOYW1lOiBzdHJpbmcsIG9wdGlvbnM6IFhtbFNlcmlhbGl6ZXJPcHRpb25zKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5taXhlZENvbnRlbnRFbGVtZW50cykge1xyXG4gICAgICAgICAgICByZXR1cm4gISFvcHRpb25zLm1peGVkQ29udGVudEVsZW1lbnRzLmZpbmQoKHRhZykgPT4gdGFnID09PSB0YWdOYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29udGFpbnNPbmx5V2hpdGVTcGFjZSh0ZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYyA9IHRleHQuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICBpZiAoIShjID09PSAnICcgfHwgYyA9PT0gJ1xcdCcgfHwgYyA9PT0gJ1xccicgfHwgYyA9PT0gJ1xcbicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtTVEFURV9ORVcsIFNUQVRFX1RSQU5TTEFURUR9IGZyb20gJy4uL2FwaS9jb25zdGFudHMnO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7SU5vcm1hbGl6ZWRNZXNzYWdlfSBmcm9tICcuLi9hcGkvaS1ub3JtYWxpemVkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge0lUcmFuc1VuaXR9IGZyb20gJy4uL2FwaS9pLXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtET01QYXJzZXJ9IGZyb20gJ3htbGRvbSc7XHJcbmltcG9ydCB7WG1sU2VyaWFsaXplciwgWG1sU2VyaWFsaXplck9wdGlvbnN9IGZyb20gJy4veG1sLXNlcmlhbGl6ZXInO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAwOS4wNS4yMDE3LlxyXG4gKiBBYnN0cmFjdCBzdXBlcmNsYXNzIGZvciBhbGwgaW1wbGVtZW50YXRpb25zIG9mIElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZS5cclxuICovXHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSBpbXBsZW1lbnRzIElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maWxlbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCBfZW5jb2Rpbmc6IHN0cmluZztcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3BhcnNlZERvY3VtZW50OiBEb2N1bWVudDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbGVFbmRzV2l0aEVPTDogYm9vbGVhbjtcclxuXHJcbiAgICAvLyB0cmFucy11bml0IGVsZW1lbnRzIGFuZCB0aGVpciBpZCBmcm9tIHRoZSBmaWxlXHJcbiAgICBwcm90ZWN0ZWQgdHJhbnNVbml0czogSVRyYW5zVW5pdFtdO1xyXG5cclxuICAgIHByb3RlY3RlZCBfd2FybmluZ3M6IHN0cmluZ1tdO1xyXG5cclxuICAgIHByb3RlY3RlZCBfbnVtYmVyT2ZUcmFuc1VuaXRzV2l0aE1pc3NpbmdJZDogbnVtYmVyO1xyXG5cclxuICAgIHByb3RlY3RlZCBfbnVtYmVyT2ZVbnRyYW5zbGF0ZWRUcmFuc1VuaXRzOiBudW1iZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9udW1iZXJPZlJldmlld2VkVHJhbnNVbml0czogbnVtYmVyO1xyXG5cclxuICAgIHByb3RlY3RlZCB0YXJnZXRQcmFlZml4OiBzdHJpbmc7XHJcblxyXG4gICAgcHJvdGVjdGVkIHRhcmdldFN1ZmZpeDogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnRyYW5zVW5pdHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3dhcm5pbmdzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBmaWxlIGNvbnRlbnQuXHJcbiAgICAgKiBTZXRzIF9wYXJzZWREb2N1bWVudCwgbGluZSBlbmRpbmcsIGVuY29kaW5nLCBldGMuXHJcbiAgICAgKiBAcGFyYW0geG1sU3RyaW5nIHhtbFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHBhdGggcGF0aFxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIGVuY29kaW5nXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXIgb3B0aW9uYWxNYXN0ZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29udGVudChcclxuICAgICAgICB4bWxTdHJpbmc6IHN0cmluZyxcclxuICAgICAgICBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcsXHJcbiAgICAgICAgb3B0aW9uYWxNYXN0ZXI/OiB7IHhtbENvbnRlbnQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nIH0pXHJcbiAgICAgICAgOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9maWxlbmFtZSA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNvZGluZztcclxuICAgICAgICB0aGlzLl9wYXJzZWREb2N1bWVudCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoeG1sU3RyaW5nLCAndGV4dC94bWwnKTtcclxuICAgICAgICB0aGlzLl9maWxlRW5kc1dpdGhFT0wgPSB4bWxTdHJpbmcuZW5kc1dpdGgoJ1xcbicpO1xyXG4gICAgfVxyXG5cclxuICAgIGFic3RyYWN0IGkxOG5Gb3JtYXQoKTogc3RyaW5nO1xyXG5cclxuICAgIGFic3RyYWN0IGZpbGVUeXBlKCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiB0YWcgbmFtZXMgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBtaXhlZCBjb250ZW50LlxyXG4gICAgICogVGhlc2UgZWxlbWVudHMgd2lsbCBub3QgYmUgYmVhdXRpZmllZC5cclxuICAgICAqIFR5cGljYWwgY2FuZGlkYXRlcyBhcmUgc291cmNlIGFuZCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBlbGVtZW50c1dpdGhNaXhlZENvbnRlbnQoKTogc3RyaW5nW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGFsbCB0cmFucyB1bml0cyBmcm9tIHhtbCBjb250ZW50LlxyXG4gICAgICogUHV0cyB0aGUgZm91bmQgdW5pdHMgaW50byB0cmFuc1VuaXRzLlxyXG4gICAgICogUHV0cyB3YXJuaW5ncyBmb3IgbWlzc2luZyBpZHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBpbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG5cclxuICAgIHByb3RlY3RlZCBsYXp5SW5pdGlhbGl6ZVRyYW5zVW5pdHMoKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMudHJhbnNVbml0cykpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50TnVtYmVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNvdW50IHVuaXRzIGFmdGVyIGNoYW5nZXMgb2YgdHJhbnMgdW5pdHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvdW50TnVtYmVycygpIHtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkID0gMDtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlVudHJhbnNsYXRlZFRyYW5zVW5pdHMgPSAwO1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mUmV2aWV3ZWRUcmFuc1VuaXRzID0gMDtcclxuICAgICAgICB0aGlzLmZvckVhY2hUcmFuc1VuaXQoKHR1OiBJVHJhbnNVbml0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh0dS5pZCkgfHwgdHUuaWQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0dS50YXJnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc3RhdGUpIHx8IHN0YXRlID09PSBTVEFURV9ORVcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX251bWJlck9mVW50cmFuc2xhdGVkVHJhbnNVbml0cysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gU1RBVEVfVFJBTlNMQVRFRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyT2ZSZXZpZXdlZFRyYW5zVW5pdHMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB3YXJuaW5ncygpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgdGhpcy5sYXp5SW5pdGlhbGl6ZVRyYW5zVW5pdHMoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2FybmluZ3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUb3RhbCBudW1iZXIgb2YgdHJhbnNsYXRpb24gdW5pdHMgZm91bmQgaW4gdGhlIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBudW1iZXJPZlRyYW5zVW5pdHMoKTogbnVtYmVyIHtcclxuICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zVW5pdHMubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIHRyYW5zbGF0aW9uIHVuaXRzIHdpdGhvdXQgdHJhbnNsYXRpb24gZm91bmQgaW4gdGhlIGZpbGUuXHJcbiAgICAgKiBUaGVzZSB1bml0cyBoYXZlIHN0YXRlICd0cmFuc2xhdGVkJy5cclxuICAgICAqL1xyXG4gICAgbnVtYmVyT2ZVbnRyYW5zbGF0ZWRUcmFuc1VuaXRzKCk6IG51bWJlciB7XHJcbiAgICAgICAgdGhpcy5sYXp5SW5pdGlhbGl6ZVRyYW5zVW5pdHMoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZVbnRyYW5zbGF0ZWRUcmFuc1VuaXRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIHRyYW5zbGF0aW9uIHVuaXRzIHdpdGggc3RhdGUgJ2ZpbmFsJy5cclxuICAgICAqL1xyXG4gICAgbnVtYmVyT2ZSZXZpZXdlZFRyYW5zVW5pdHMoKTogbnVtYmVyIHtcclxuICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZlJldmlld2VkVHJhbnNVbml0cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE51bWJlciBvZiB0cmFuc2xhdGlvbiB1bml0cyB3aXRob3V0IHRyYW5zbGF0aW9uIGZvdW5kIGluIHRoZSBmaWxlLlxyXG4gICAgICogVGhlc2UgdW5pdHMgaGF2ZSBzdGF0ZSAndHJhbnNsYXRlZCcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBudW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkKCk6IG51bWJlciB7XHJcbiAgICAgICAgdGhpcy5sYXp5SW5pdGlhbGl6ZVRyYW5zVW5pdHMoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZUcmFuc1VuaXRzV2l0aE1pc3NpbmdJZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBzb3VyY2UgbGFuZ3VhZ2UuXHJcbiAgICAgKiBAcmV0dXJuIHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc291cmNlTGFuZ3VhZ2UoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRhcmdldCBsYW5ndWFnZS5cclxuICAgICAqIEByZXR1cm4gdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCB0YXJnZXRMYW5ndWFnZSgpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb29wIG92ZXIgYWxsIFRyYW5zbGF0aW9uIFVuaXRzLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmb3JFYWNoVHJhbnNVbml0KGNhbGxiYWNrOiAoKHRyYW5zdW5pdDogSVRyYW5zVW5pdCkgPT4gdm9pZCkpIHtcclxuICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNVbml0cy5mb3JFYWNoKCh0dSkgPT4gY2FsbGJhY2sodHUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0cmFucy11bml0IHdpdGggZ2l2ZW4gaWQuXHJcbiAgICAgKiBAcGFyYW0gaWQgaWRcclxuICAgICAqIEByZXR1cm4gdHJhbnMtdW5pdCB3aXRoIGdpdmVuIGlkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNVbml0V2l0aElkKGlkOiBzdHJpbmcpOiBJVHJhbnNVbml0IHtcclxuICAgICAgICB0aGlzLmxhenlJbml0aWFsaXplVHJhbnNVbml0cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zVW5pdHMuZmluZCgodHUpID0+IHR1LmlkID09PSBpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFZGl0IGZ1bmN0aW9ucyBmb2xsb3dpbmcgaGVyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXQgdGhlIHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZSBsYW5ndWFnZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzZXRTb3VyY2VMYW5ndWFnZShsYW5ndWFnZTogc3RyaW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXQgdGhlIHRhcmdldCBsYW5ndWFnZS5cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZSBsYW5ndWFnZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzZXRUYXJnZXRMYW5ndWFnZShsYW5ndWFnZTogc3RyaW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcHJhZWZpeCB1c2VkIHdoZW4gY29weWluZyBzb3VyY2UgdG8gdGFyZ2V0LlxyXG4gICAgICogVGhpcyBpcyB1c2VkIGJ5IGltcG9ydE5ld1RyYW5zVW5pdCBhbmQgY3JlYXRlVHJhbnNsYXRpb25GaWxlRm9yTGFuZyBtZXRob2RzLlxyXG4gICAgICogKHNpbmNlIDEuOC4wKVxyXG4gICAgICogQHBhcmFtIHRhcmdldFByYWVmaXggdGFyZ2V0UHJhZWZpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCh0YXJnZXRQcmFlZml4OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnRhcmdldFByYWVmaXggPSB0YXJnZXRQcmFlZml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBwcmFlZml4IHVzZWQgd2hlbiBjb3B5aW5nIHNvdXJjZSB0byB0YXJnZXQuXHJcbiAgICAgKiAoc2luY2UgMS44LjApXHJcbiAgICAgKiBAcmV0dXJuIHRoZSBwcmFlZml4IHVzZWQgd2hlbiBjb3B5aW5nIHNvdXJjZSB0byB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIGdldE5ld1RyYW5zVW5pdFRhcmdldFByYWVmaXgoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQodGhpcy50YXJnZXRQcmFlZml4KSA/ICcnIDogdGhpcy50YXJnZXRQcmFlZml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzdWZmaXggdXNlZCB3aGVuIGNvcHlpbmcgc291cmNlIHRvIHRhcmdldC5cclxuICAgICAqIFRoaXMgaXMgdXNlZCBieSBpbXBvcnROZXdUcmFuc1VuaXQgYW5kIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcgbWV0aG9kcy5cclxuICAgICAqIChzaW5jZSAxLjguMClcclxuICAgICAqIEBwYXJhbSB0YXJnZXRTdWZmaXggdGFyZ2V0U3VmZml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgodGFyZ2V0U3VmZml4OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnRhcmdldFN1ZmZpeCA9IHRhcmdldFN1ZmZpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3VmZml4IHVzZWQgd2hlbiBjb3B5aW5nIHNvdXJjZSB0byB0YXJnZXQuXHJcbiAgICAgKiAoc2luY2UgMS44LjApXHJcbiAgICAgKiBAcmV0dXJuIHRoZSBzdWZmaXggdXNlZCB3aGVuIGNvcHlpbmcgc291cmNlIHRvIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmV3VHJhbnNVbml0VGFyZ2V0U3VmZml4KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMudGFyZ2V0U3VmZml4KSA/ICcnIDogdGhpcy50YXJnZXRTdWZmaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBuZXcgdHJhbnMtdW5pdCB0byB0aGlzIGZpbGUuXHJcbiAgICAgKiBUaGUgdHJhbnMgdW5pdCBzdGVtcyBmcm9tIGFub3RoZXIgZmlsZS5cclxuICAgICAqIEl0IGNvcGllcyB0aGUgc291cmNlIGNvbnRlbnQgb2YgdGhlIHR1IHRvIHRoZSB0YXJnZXQgY29udGVudCB0b28sXHJcbiAgICAgKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiBpc0RlZmF1bHRMYW5nIGFuZCBjb3B5Q29udGVudC5cclxuICAgICAqIFNvIHRoZSBzb3VyY2UgY2FuIGJlIHVzZWQgYXMgYSBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqICh1c2VkIGJ5IHhsaWZmbWVyZ2UpXHJcbiAgICAgKiBAcGFyYW0gZm9yZWlnblRyYW5zVW5pdCB0aGUgdHJhbnMgdW5pdCB0byBiZSBpbXBvcnRlZC5cclxuICAgICAqIEBwYXJhbSBpc0RlZmF1bHRMYW5nIEZsYWcsIHdldGhlciBmaWxlIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGxhbmd1YWdlLlxyXG4gICAgICogVGhlbiBzb3VyY2UgYW5kIHRhcmdldCBhcmUganVzdCBlcXVhbC5cclxuICAgICAqIFRoZSBjb250ZW50IHdpbGwgYmUgY29waWVkLlxyXG4gICAgICogU3RhdGUgd2lsbCBiZSBmaW5hbC5cclxuICAgICAqIEBwYXJhbSBjb3B5Q29udGVudCBGbGFnLCB3ZXRoZXIgdG8gY29weSBjb250ZW50IG9yIGxlYXZlIGl0IGVtcHR5LlxyXG4gICAgICogV2JlbiB0cnVlLCBjb250ZW50IHdpbGwgYmUgY29waWVkIGZyb20gc291cmNlLlxyXG4gICAgICogV2hlbiBmYWxzZSwgY29udGVudCB3aWxsIGJlIGxlZnQgZW1wdHkgKGlmIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBsYW5ndWFnZSkuXHJcbiAgICAgKiBAcGFyYW0gaW1wb3J0QWZ0ZXJFbGVtZW50IG9wdGlvbmFsIChzaW5jZSAxLjEwKSBvdGhlciB0cmFuc3VuaXQgKHBhcnQgb2YgdGhpcyBmaWxlKSwgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBhbmNlc3Rvci5cclxuICAgICAqIE5ld2x5IGltcG9ydGVkIHRyYW5zIHVuaXQgaXMgdGhlbiBpbnNlcnRlZCBkaXJlY3RseSBhZnRlciB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBJZiBub3Qgc2V0IG9yIG5vdCBwYXJ0IG9mIHRoaXMgZmlsZSwgbmV3IHVuaXQgd2lsbCBiZSBpbXBvcnRlZCBhdCB0aGUgZW5kLlxyXG4gICAgICogSWYgZXhwbGljaXR5IHNldCB0byBudWxsLCBuZXcgdW5pdCB3aWxsIGJlIGltcG9ydGVkIGF0IHRoZSBzdGFydC5cclxuICAgICAqIEByZXR1cm4gdGhlIG5ld2x5IGltcG9ydGVkIHRyYW5zIHVuaXQgKHNpbmNlIHZlcnNpb24gMS43LjApXHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yIGlmIHRyYW5zLXVuaXQgd2l0aCBzYW1lIGlkIGFscmVhZHkgaXMgaW4gdGhlIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGltcG9ydE5ld1RyYW5zVW5pdChmb3JlaWduVHJhbnNVbml0OiBJVHJhbnNVbml0LCBpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbiwgaW1wb3J0QWZ0ZXJFbGVtZW50PzogSVRyYW5zVW5pdClcclxuICAgICAgICA6IElUcmFuc1VuaXQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgdGhlIHRyYW5zLXVuaXQgd2l0aCB0aGUgZ2l2ZW4gaWQuXHJcbiAgICAgKiBAcGFyYW0gaWQgaWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZVRyYW5zVW5pdFdpdGhJZChpZDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgdHVOb2RlOiBOb2RlID0gdGhpcy5fcGFyc2VkRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG4gICAgICAgIGlmICh0dU5vZGUpIHtcclxuICAgICAgICAgICAgdHVOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodHVOb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5sYXp5SW5pdGlhbGl6ZVRyYW5zVW5pdHMoKTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc1VuaXRzID0gdGhpcy50cmFuc1VuaXRzLmZpbHRlcigodHUpID0+IHR1LmlkICE9PSBpZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnROdW1iZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpbGVuYW1lIHdoZXJlIHRoZSBkYXRhIGlzIHJlYWQgZnJvbS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGZpbGVuYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGVuY29kaW5nIGlmIHRoZSB4bWwgY29udGVudCAoVVRGLTgsIElTTy04ODU5LTEsIC4uLilcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuY29kaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHhtbCBjb250ZW50IHRvIGJlIHNhdmVkIGFmdGVyIGNoYW5nZXMgYXJlIG1hZGUuXHJcbiAgICAgKiBAcGFyYW0gYmVhdXRpZnlPdXRwdXQgRmxhZyB3aGV0aGVyIHRvIHVzZSBwcmV0dHktZGF0YSB0byBmb3JtYXQgdGhlIG91dHB1dC5cclxuICAgICAqIFhNTFNlcmlhbGl6ZXIgcHJvZHVjZXMgc29tZSBjb3JyZWN0IGJ1dCBzdHJhbmdlbHkgZm9ybWF0dGVkIG91dHB1dCwgd2hpY2ggcHJldHR5LWRhdGEgY2FuIGNvcnJlY3QuXHJcbiAgICAgKiBTZWUgaXNzdWUgIzY0IGZvciBkZXRhaWxzLlxyXG4gICAgICogRGVmYXVsdCBpcyBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVkaXRlZENvbnRlbnQoYmVhdXRpZnlPdXRwdXQ/OiBib29sZWFuKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBYbWxTZXJpYWxpemVyT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGlmIChiZWF1dGlmeU91dHB1dCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgIG9wdGlvbnMuYmVhdXRpZnkgPSB0cnVlO1xyXG4gICAgICAgICAgIG9wdGlvbnMuaW5kZW50U3RyaW5nID0gJyAgJztcclxuICAgICAgICAgICBvcHRpb25zLm1peGVkQ29udGVudEVsZW1lbnRzID0gdGhpcy5lbGVtZW50c1dpdGhNaXhlZENvbnRlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFhtbFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyh0aGlzLl9wYXJzZWREb2N1bWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGVFbmRzV2l0aEVPTCkge1xyXG4gICAgICAgICAgICAvLyBhZGQgZW9sIGlmIHRoZXJlIHdhcyBlb2wgaW4gb3JpZ2luYWwgc291cmNlXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXFxuJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2xhdGlvbiBmaWxlIGZvciB0aGlzIGZpbGUgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBqdXN0IGEgY29weSBvZiB0aGUgb3JpZ2luYWwgb25lLlxyXG4gICAgICogQnV0IGZvciBYTUIgdGhlIHRyYW5zbGF0aW9uIGZpbGUgaGFzIGZvcm1hdCAnWFRCJy5cclxuICAgICAqIEBwYXJhbSBsYW5nIExhbmd1YWdlIGNvZGVcclxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBleHBlY3RlZCBmaWxlbmFtZSB0byBzdG9yZSBmaWxlXHJcbiAgICAgKiBAcGFyYW0gaXNEZWZhdWx0TGFuZyBGbGFnLCB3ZXRoZXIgZmlsZSBjb250YWlucyB0aGUgZGVmYXVsdCBsYW5ndWFnZS5cclxuICAgICAqIFRoZW4gc291cmNlIGFuZCB0YXJnZXQgYXJlIGp1c3QgZXF1YWwuXHJcbiAgICAgKiBUaGUgY29udGVudCB3aWxsIGJlIGNvcGllZC5cclxuICAgICAqIFN0YXRlIHdpbGwgYmUgZmluYWwuXHJcbiAgICAgKiBAcGFyYW0gY29weUNvbnRlbnQgRmxhZywgd2V0aGVyIHRvIGNvcHkgY29udGVudCBvciBsZWF2ZSBpdCBlbXB0eS5cclxuICAgICAqIFdiZW4gdHJ1ZSwgY29udGVudCB3aWxsIGJlIGNvcGllZCBmcm9tIHNvdXJjZS5cclxuICAgICAqIFdoZW4gZmFsc2UsIGNvbnRlbnQgd2lsbCBiZSBsZWZ0IGVtcHR5IChpZiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UpLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nKGxhbmc6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZywgaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4pXHJcbiAgICAgICAgOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGU7XHJcbn1cclxuIiwiaW1wb3J0IHtTVEFURV9UUkFOU0xBVEVELCBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsIElOb3JtYWxpemVkTWVzc2FnZSwgSVRyYW5zVW5pdCwgSU5vdGV9IGZyb20gJy4vaW50ZXJuYWxhcGknO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWQsIGlzU3RyaW5nfSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXInO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAxMC4wNS4yMDE3LlxyXG4gKiBBYnN0cmFjdCBzdXBlcmNsYXNzIGZvciBhbGwgaW1wbGVtZW50YXRpb25zIG9mIElUcmFuc1VuaXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0VHJhbnNVbml0IGltcGxlbWVudHMgSVRyYW5zVW5pdCB7XHJcblxyXG4gICAgcHJpdmF0ZSBfc291cmNlQ29udGVudE5vcm1hbGl6ZWQ6IFBhcnNlZE1lc3NhZ2U7XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfZWxlbWVudDogRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgX2lkOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIF90cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKSB7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmaWxlIHRoZSB1bml0IGJlbG9uZ3MgdG8uLFxyXG4gICAgICovXHJcbiAgICB0cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSgpOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHZhbHVlLCB0aGF0IGlzIHRvIGJlIHRyYW5zbGF0ZWQuXHJcbiAgICAgKiBDb250YWlucyBhbGwgbWFya3VwLCBkZXBlbmRzIG9uIHRoZSBjb25jcmV0ZSBmb3JtYXQgdXNlZC5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc291cmNlQ29udGVudCgpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBzb3VyY2UgY29udGVudCBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldFNvdXJjZUNvbnRlbnQgaW4gdHJhbnMtdW5pdCB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgc3VwcG9ydHNTZXRTb3VyY2VDb250ZW50KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG5ldyBzb3VyY2UgY29udGVudCBpbiB0aGUgdHJhbnN1bml0LlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMgZG9uZSBieSBuZy1leHRyYWN0LlxyXG4gICAgICogTWV0aG9kIG9ubHkgZXhpc3RzIHRvIGFsbG93IHhsaWZmbWVyZ2UgdG8gbWVyZ2UgbWlzc2luZyBjaGFuZ2VkIHNvdXJjZSBjb250ZW50LlxyXG4gICAgICogQHBhcmFtIG5ld0NvbnRlbnQgdGhlIG5ldyBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzZXRTb3VyY2VDb250ZW50KG5ld0NvbnRlbnQ6IHN0cmluZyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCB2YWx1ZSwgdGhhdCBpcyB0byBiZSB0cmFuc2xhdGVkLCBhcyBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fc291cmNlQ29udGVudE5vcm1hbGl6ZWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZUNvbnRlbnROb3JtYWxpemVkID0gdGhpcy5jcmVhdGVTb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlQ29udGVudE5vcm1hbGl6ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCB2YWx1ZSwgdGhhdCBpcyB0byBiZSB0cmFuc2xhdGVkLCBhcyBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGNyZWF0ZVNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCk6IFBhcnNlZE1lc3NhZ2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHJhbnNsYXRlZCB2YWx1ZS5cclxuICAgICAqIENvbnRhaW5zIGFsbCBtYXJrdXAsIGRlcGVuZHMgb24gdGhlIGNvbmNyZXRlIGZvcm1hdCB1c2VkLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCB0YXJnZXRDb250ZW50KCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0cmFuc2xhdGVkIHZhbHVlIGFzIG5vcm1hbGl6ZWQgbWVzc2FnZS5cclxuICAgICAqIEFsbCBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGgge3tufX0gKHN0YXJ0aW5nIGF0IDApXHJcbiAgICAgKiBhbmQgYWxsIGVtYmVkZGVkIGh0bWwgaXMgcmVwbGFjZWQgYnkgZGlyZWN0IGh0bWwgbWFya3VwLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCB0YXJnZXRDb250ZW50Tm9ybWFsaXplZCgpOiBJTm9ybWFsaXplZE1lc3NhZ2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0ZSBvZiB0aGUgdHJhbnNsYXRpb24gYXMgc3RvcmVkIGluIHRoZSB4bWwuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IG5hdGl2ZVRhcmdldFN0YXRlKCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRlIG9mIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIChvbiBvZiBuZXcsIHRyYW5zbGF0ZWQsIGZpbmFsKVxyXG4gICAgICogUmV0dXJuIHZhbHVlcyBhcmUgZGVmaW5lZCBhcyBDb25zdGFudHMgU1RBVEVfLi4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRTdGF0ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG5hdGl2ZVN0YXRlID0gdGhpcy5uYXRpdmVUYXJnZXRTdGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcE5hdGl2ZVN0YXRlVG9TdGF0ZShuYXRpdmVTdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgYW4gYWJzdHJhY3Qgc3RhdGUgKG5ldywgdHJhbnNsYXRlZCwgZmluYWwpIHRvIGEgY29uY3JldGUgc3RhdGUgdXNlZCBpbiB0aGUgeG1sLlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdG8gYmUgdXNlZCBpbiB0aGUgeG1sLlxyXG4gICAgICogQHBhcmFtIHN0YXRlIG9uZSBvZiBDb25zdGFudHMuU1RBVEUuLi5cclxuICAgICAqIEByZXR1cm5zIGEgbmF0aXZlIHN0YXRlIChkZXBlbmRzIG9uIGNvbmNyZXRlIGZvcm1hdClcclxuICAgICAqIEB0aHJvd3MgZXJyb3IsIGlmIHN0YXRlIGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBtYXBTdGF0ZVRvTmF0aXZlU3RhdGUoc3RhdGU6IHN0cmluZyk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBhIG5hdGl2ZSBzdGF0ZSAoZm91bmQgaW4gdGhlIGRvY3VtZW50KSB0byBhbiBhYnN0cmFjdCBzdGF0ZSAobmV3LCB0cmFuc2xhdGVkLCBmaW5hbCkuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhYnN0cmFjdCBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSBuYXRpdmVTdGF0ZSBuYXRpdmVTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgbWFwTmF0aXZlU3RhdGVUb1N0YXRlKG5hdGl2ZVN0YXRlOiBzdHJpbmcpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgc3RhdGUgaW4geG1sLlxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0YXRlIG5hdGl2ZVN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBzZXROYXRpdmVUYXJnZXRTdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmeSB0aGUgdGFyZ2V0IHN0YXRlLlxyXG4gICAgICogQHBhcmFtIG5ld1N0YXRlIG9uZSBvZiB0aGUgMyBhbGxvd2VkIHRhcmdldCBzdGF0ZXMgbmV3LCB0cmFuc2xhdGVkLCBmaW5hbC5cclxuICAgICAqIENvbnN0YW50cyBTVEFURV8uLi5cclxuICAgICAqIEludmFsaWQgc3RhdGVzIHRocm93IGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBzZXRUYXJnZXRTdGF0ZShuZXdTdGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5zZXROYXRpdmVUYXJnZXRTdGF0ZSh0aGlzLm1hcFN0YXRlVG9OYXRpdmVTdGF0ZShuZXdTdGF0ZSkpO1xyXG4gICAgICAgIGlmICh0aGlzLnRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKCkgaW5zdGFuY2VvZiBBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKSB7XHJcbiAgICAgICAgICAgICg8QWJzdHJhY3RUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZT4gdGhpcy50cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSgpKS5jb3VudE51bWJlcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdGhlIHNvdXJjZSBlbGVtZW50cyBpbiB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqIFRoZSBzb3VyY2UgZWxlbWVudCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUgZmlsZSBhbmQgYSBsaW5lIG51bWJlciB3aXRoIHRoZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHRlbXBsYXRlLlxyXG4gICAgICogSXQgaXMganVzdCBhIGhlbHAgZm9yIHRyYW5zbGF0b3JzIHRvIGZpbmQgdGhlIGNvbnRleHQgZm9yIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIFRoaXMgaXMgc2V0IHdoZW4gdXNpbmcgQW5ndWxhciA0LjAgb3IgZ3JlYXRlci5cclxuICAgICAqIE90aGVyd2lzZSBpdCBqdXN0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNvdXJjZVJlZmVyZW5jZXMoKToge3NvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyfVtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2Ygc291cmNlIHJlZnMgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXRTb3VyY2VSZWZlcmVuY2VzIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTZXRTb3VyY2VSZWZlcmVuY2VzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNvdXJjZSByZWYgZWxlbWVudHMgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3Npbmcgc291cmNlIHJlZnMuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlUmVmcyB0aGUgc291cmNlcmVmcyB0byBzZXQuIE9sZCBvbmVzIGFyZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzZXRTb3VyY2VSZWZlcmVuY2VzKHNvdXJjZVJlZnM6IHtzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlcn1bXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGRlc2NyaXB0aW9uKCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtZWFuaW5nIChpbnRlbnQpIHNldCBpbiB0aGUgdGVtcGxhdGUgYXMgdmFsdWUgb2YgdGhlIGkxOG4tYXR0cmlidXRlLlxyXG4gICAgICogVGhpcyBpcyB0aGUgcGFydCBpbiBmcm9udCBvZiB0aGUgfCBzeW1ib2wuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJtZWFuaW5nfG15ZGVzY3JpcHRpb25cIi5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgbWVhbmluZygpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBkZXNjcmlwdGlvbiBhbmQgbWVhbmluZyBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldERlc2NyaXB0aW9uIGFuZCBzZXRNZWFuaW5nIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTZXREZXNjcmlwdGlvbkFuZE1lYW5pbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgZGVzY3JpcHRpb24gcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBkZXNjcmlwdGlvblxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzZXREZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogc3RyaW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBtZWFuaW5nIHByb3BlcnR5IG9mIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBAcGFyYW0gbWVhbmluZyBtZWFuaW5nXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldE1lYW5pbmcobWVhbmluZzogc3RyaW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbm90ZXMgb2YgdGhlIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBOb3RlcyBhcmUgcmVtYXJrcyBtYWRlIGJ5IGEgdHJhbnNsYXRvci5cclxuICAgICAqIChkZXNjcmlwdGlvbiBhbmQgbWVhbmluZyBhcmUgbm90IGluY2x1ZGVkIGhlcmUhKVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBub3RlcygpOiBJTm90ZVtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2Ygbm90ZXMgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXROb3RlcyB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc3VwcG9ydHNTZXROb3RlcygpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIG5vdGVzIHRvIHRyYW5zIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0gbmV3Tm90ZXMgdGhlIG5vdGVzIHRvIGFkZC5cclxuICAgICAqIEB0aHJvd3MgYW4gRXJyb3IgaWYgYW55IG5vdGUgY29udGFpbnMgZGVzY3ByaXB0aW9uIG9yIG1lYW5pbmcgYXMgZnJvbSBhdHRyaWJ1dGUuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldE5vdGVzKG5ld05vdGVzOiBJTm90ZVtdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIG5vdGVzXHJcbiAgICAgKiBAcGFyYW0gbmV3Tm90ZXMgdGhlIG5vdGVzIHRvIGFkZC5cclxuICAgICAqIEB0aHJvd3MgYW4gRXJyb3IgaWYgYW55IG5vdGUgY29udGFpbnMgZGVzY3JpcHRpb24gb3IgbWVhbmluZyBhcyBmcm9tIGF0dHJpYnV0ZS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNoZWNrTm90ZXMobmV3Tm90ZXM6IElOb3RlW10pIHtcclxuICAgICAgICAvLyBjaGVjayBmcm9tIHZhbHVlc1xyXG4gICAgICAgIGNvbnN0IGVycm9ySW5Gcm9tTm90ZSA9IG5ld05vdGVzLmZpbmQoKG5vdGUpID0+IG5vdGUuZnJvbSA9PT0gJ2Rlc2NyaXB0aW9uJyB8fCBub3RlLmZyb20gPT09ICdtZWFuaW5nJyk7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChlcnJvckluRnJvbU5vdGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpcHRpb24gb3IgbWVhbmluZyBhcmUgbm90IGFsbG93ZWQgYXMgZnJvbSBhdHR0cmlidXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlYWwgeG1sIGVsZW1lbnQgdXNlZCBmb3IgdGhlIHRyYW5zIHVuaXQuXHJcbiAgICAgKiAoaW50ZXJuYWwgdXNhZ2Ugb25seSwgYSBjbGllbnQgc2hvdWxkIG5ldmVyIG5lZWQgdGhpcylcclxuICAgICAqIEByZXR1cm4gcmVhbCB4bWwgZWxlbWVudCB1c2VkIGZvciB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzWG1sRWxlbWVudCgpOiBFbGVtZW50IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcHkgc291cmNlIHRvIHRhcmdldCB0byB1c2UgaXQgYXMgZHVtbXkgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBSZXR1cm5zIGEgY2hhbmdlZCBjb3B5IG9mIHRoaXMgdHJhbnMgdW5pdC5cclxuICAgICAqIHJlY2VpdmVyIGlzIG5vdCBjaGFuZ2VkLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGltcG9ydE5ld1RyYW5zVW5pdCBvbiBJVHJhbnNsYXRpb25NZXNzYWdlRmlsZSlcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgY2xvbmVXaXRoU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4sIHRhcmdldEZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSk6IEFic3RyYWN0VHJhbnNVbml0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBzb3VyY2UgdG8gdGFyZ2V0IHRvIHVzZSBpdCBhcyBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgY2FsbCBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nIG9uIElUcmFuc2xhdGlvbk1lc3NhZ2VGaWxlKVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCB1c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGUgdGhlIHRyYW5zIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNsYXRpb24gdGhlIHRyYW5zbGF0ZWQgc3RyaW5nIG9yIChwcmVmZXJyZWQpIGEgbm9ybWFsaXplZCBtZXNzYWdlLlxyXG4gICAgICogVGhlIHB1cmUgc3RyaW5nIGNhbiBjb250YWluIGFueSBtYXJrdXAgYW5kIHdpbGwgbm90IGJlIGNoZWNrZWQuXHJcbiAgICAgKiBTbyBpdCBjYW4gZGFtYWdlIHRoZSBkb2N1bWVudC5cclxuICAgICAqIEEgbm9ybWFsaXplZCBtZXNzYWdlIHByZXZlbnRzIHRoaXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGUodHJhbnNsYXRpb246IHN0cmluZyB8IElOb3JtYWxpemVkTWVzc2FnZSkge1xyXG4gICAgICAgIGxldCB0cmFuc2xhdGlvbk5hdGl2ZTogc3RyaW5nO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyh0cmFuc2xhdGlvbikpIHtcclxuICAgICAgICAgICAgdHJhbnNsYXRpb25OYXRpdmUgPSA8c3RyaW5nPiB0cmFuc2xhdGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbk5hdGl2ZSA9ICg8SU5vcm1hbGl6ZWRNZXNzYWdlPiB0cmFuc2xhdGlvbikuYXNOYXRpdmVTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVOYXRpdmUodHJhbnNsYXRpb25OYXRpdmUpO1xyXG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfVFJBTlNMQVRFRCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBwYXJzZXIgdXNlZCBmb3Igbm9ybWFsaXplZCBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IG1lc3NhZ2VQYXJzZXIoKTogQWJzdHJhY3RNZXNzYWdlUGFyc2VyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIG1lc3NhZ2UgbG9va3MgbGlrZSBJQ1UgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2VcclxuICAgICAqIEByZXR1cm4gd2V0aGVyIG1lc3NhZ2UgbG9va3MgbGlrZSBJQ1UgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSUNVTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlUGFyc2VyKCkuaXNJQ1VNZXNzYWdlU3RhcnQobWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRyYW5zbGF0aW9uIHRvIGEgZ2l2ZW4gc3RyaW5nIChpbmNsdWRpbmcgbWFya3VwKS5cclxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiB0cmFuc2xhdGlvblxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgdHJhbnNsYXRlTmF0aXZlKHRyYW5zbGF0aW9uOiBzdHJpbmcpO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwNS4wNS4yMDE3LlxyXG4gKiBBIHBhcnQgb2YgYSBwYXJzZWQgbWVzc2FnZS5cclxuICogQ2FuIGJlIGEgdGV4dCwgYSBwbGFjZWhvbGRlciwgYSB0YWdcclxuICovXHJcblxyXG5leHBvcnQgZW51bSBQYXJzZWRNZXNzYWdlUGFydFR5cGUge1xyXG4gICAgVEVYVCxcclxuICAgIFBMQUNFSE9MREVSLFxyXG4gICAgU1RBUlRfVEFHLFxyXG4gICAgRU5EX1RBRyxcclxuICAgIEVNUFRZX1RBRyxcclxuICAgIElDVV9NRVNTQUdFLFxyXG4gICAgSUNVX01FU1NBR0VfUkVGXHJcbn1cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQYXJzZWRNZXNzYWdlUGFydCB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHVibGljIHR5cGU6IFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZSkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGFydC5cclxuICAgICAqIEBwYXJhbSBmb3JtYXQgb3B0aW9uYWwgd2F5IHRvIGRldGVybWluZSB0aGUgZXhhY3Qgc3ludGF4LlxyXG4gICAgICogQWxsb3dlZCBmb3JtYXRzIGFyZSBkZWZpbmVkIGFzIGNvbnN0YW50cyBOT1JNQUxJWkFUSU9OX0ZPUk1BVC4uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgYXNEaXNwbGF5U3RyaW5nKGZvcm1hdD86IHN0cmluZyk6IHN0cmluZztcclxuXHJcbn1cclxuIiwiaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydCwgUGFyc2VkTWVzc2FnZVBhcnRUeXBlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDUuMDUuMjAxNy5cclxuICogQSBtZXNzYWdlIHBhcnQgY29uc2lzdGluZyBvZiBqdXN0IHNpbXBsZSB0ZXh0LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBQYXJzZWRNZXNzYWdlUGFydFRleHQgZXh0ZW5kcyBQYXJzZWRNZXNzYWdlUGFydCB7XHJcblxyXG4gICAgcHJpdmF0ZSB0ZXh0OiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IodGV4dDogc3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIoUGFyc2VkTWVzc2FnZVBhcnRUeXBlLlRFWFQpO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzRGlzcGxheVN0cmluZyhmb3JtYXQ/OiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnQsIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuaW1wb3J0IHtOT1JNQUxJWkFUSU9OX0ZPUk1BVF9OR1hUUkFOU0xBVEV9IGZyb20gJy4uL2FwaS9jb25zdGFudHMnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDUuMDUuMjAxNy5cclxuICogQSBtZXNzYWdlIHBhcnQgY29uc2lzdGluZyBvZiBhIHBsYWNlaG9sZGVyLlxyXG4gKiBQbGFjZWhvbGRlcnMgYXJlIG51bWJlcmVkIGZyb20gMCB0byBuLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyIGV4dGVuZHMgUGFyc2VkTWVzc2FnZVBhcnQge1xyXG5cclxuICAgIC8vIGluZGV4IDAgLi4gblxyXG4gICAgcHJpdmF0ZSBfaW5kZXg6IG51bWJlcjtcclxuICAgIC8vIG9wdGlvbmFsIGRpc3AtQXR0cmlidXRlIHZhbHVlLCBjb250YWlucyB0aGUgb3JpZ2luYWwgZXhwcmVzc2lvbi5cclxuICAgIHByaXZhdGUgX2Rpc3A/OiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoaW5kZXg6IG51bWJlciwgZGlzcDogc3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIoUGFyc2VkTWVzc2FnZVBhcnRUeXBlLlBMQUNFSE9MREVSKTtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2Rpc3AgPSBkaXNwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc0Rpc3BsYXlTdHJpbmcoZm9ybWF0Pzogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gTk9STUFMSVpBVElPTl9GT1JNQVRfTkdYVFJBTlNMQVRFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAne3snICsgdGhpcy5faW5kZXggKyAnfX0nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ3t7JyArIHRoaXMuX2luZGV4ICsgJ319JztcclxuICAgIH1cclxuICAgIHB1YmxpYyBpbmRleCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGlzcCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnQsIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDA1LjA1LjIwMTcuXHJcbiAqIEEgbWVzc2FnZSBwYXJ0IGNvbnNpc3Rpbmcgb2YgYW4gb3BlbmluZyB0YWcgbGlrZSA8Yj4gb3IgPHN0cmFuZ2U+LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnIGV4dGVuZHMgUGFyc2VkTWVzc2FnZVBhcnQge1xyXG5cclxuICAgIHByaXZhdGUgX3RhZ25hbWU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2lkY291bnRlcjogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRhZ25hbWU6IHN0cmluZywgaWRjb3VudGVyOiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlcihQYXJzZWRNZXNzYWdlUGFydFR5cGUuU1RBUlRfVEFHKTtcclxuICAgICAgICB0aGlzLl90YWduYW1lID0gdGFnbmFtZTtcclxuICAgICAgICB0aGlzLl9pZGNvdW50ZXIgPSBpZGNvdW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzRGlzcGxheVN0cmluZyhmb3JtYXQ/OiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAodGhpcy5faWRjb3VudGVyID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPCcgKyB0aGlzLl90YWduYW1lICsgJz4nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPCcgKyB0aGlzLl90YWduYW1lICsgJyBpZD1cIicgKyB0aGlzLl9pZGNvdW50ZXIudG9TdHJpbmcoKSArICdcIj4nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdGFnTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YWduYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpZENvdW50ZXIoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faWRjb3VudGVyO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnQsIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDA1LjA1LjIwMTcuXHJcbiAqIEEgbWVzc2FnZSBwYXJ0IGNvbnNpc3Rpbmcgb2YgYSBjbG9zaW5nIHRhZyBsaWtlIDwvYj4gb3IgPC9zdHJhbmdlPi5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgUGFyc2VkTWVzc2FnZVBhcnRFbmRUYWcgZXh0ZW5kcyBQYXJzZWRNZXNzYWdlUGFydCB7XHJcblxyXG4gICAgcHJpdmF0ZSBfdGFnbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRhZ25hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5FTkRfVEFHKTtcclxuICAgICAgICB0aGlzLl90YWduYW1lID0gdGFnbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXNEaXNwbGF5U3RyaW5nKGZvcm1hdD86IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiAnPC8nICsgdGhpcy5fdGFnbmFtZSArICc+JztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdGFnTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YWduYW1lO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBUb2tlbml6ciBmcm9tICd0b2tlbml6cic7XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDQuMDYuMjAxNy5cclxuICogQSB0b2tlbml6ZXIgZm9yIElDVSBtZXNzYWdlcy5cclxuICovXHJcblxyXG4vLyBUb2tlbnNcclxuZXhwb3J0IGNvbnN0IFRFWFQgPSAnVEVYVCc7XHJcbmV4cG9ydCBjb25zdCBDVVJMWV9CUkFDRV9PUEVOID0gJ0NVUkxZX0JSQUNFX09QRU4nO1xyXG5leHBvcnQgY29uc3QgQ1VSTFlfQlJBQ0VfQ0xPU0UgPSAnQ1VSTFlfQlJBQ0VfQ0xPU0UnO1xyXG5leHBvcnQgY29uc3QgQ09NTUEgPSAnQ09NTUEnO1xyXG5leHBvcnQgY29uc3QgUExVUkFMID0gJ1BMVVJBTCc7XHJcbmV4cG9ydCBjb25zdCBTRUxFQ1QgPSAnU0VMRUNUJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNVVG9rZW4ge1xyXG4gICAgdHlwZTogc3RyaW5nO1xyXG4gICAgdmFsdWU6IGFueTtcclxufVxyXG5cclxuLy8gc3RhdGVzOiBkZWZhdWx0IG5vcm1hbCBpbl9tZXNzYWdlXHJcbmNvbnN0IFNUQVRFX0RFRkFVTFQgPSAnZGVmYXVsdCc7XHJcbmNvbnN0IFNUQVRFX05PUk1BTCA9ICdub3JtYWwnO1xyXG5jb25zdCBTVEFURV9JTl9NRVNTQUdFID0gJ2luX21lc3NhZ2UnO1xyXG5cclxuZXhwb3J0IGNsYXNzIElDVU1lc3NhZ2VUb2tlbml6ZXIge1xyXG4gICAgcHJpdmF0ZSBsZXhlcjogVG9rZW5penI7XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRMZXhlcigpOiBUb2tlbml6ciB7XHJcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgVG9rZW5penIoKTtcclxuICAgICAgICBsZXQgcGxhaW50ZXh0ID0gJyc7XHJcbiAgICAgICAgbGV0IG9wZW5lZEN1cmx5QnJhY2VzSW5UZXh0Q291bnRlciA9IDA7XHJcbiAgICAgICAgbGV4ZXIuYmVmb3JlKChjdHgsIG1hdGNoLCBydWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChydWxlLm5hbWUgIT09IFRFWFQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zTm9uV2hpdGVTcGFjZShwbGFpbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFjY2VwdChURVhULCBwbGFpbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYWludGV4dCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguaWdub3JlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXhlci5maW5pc2goKGN0eCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb250YWluc05vbldoaXRlU3BhY2UocGxhaW50ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmFjY2VwdChURVhULCBwbGFpbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGN1cmx5IGJyYWNlXHJcbiAgICAgICAgbGV4ZXIucnVsZShTVEFURV9ERUZBVUxULCAvey8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoQ1VSTFlfQlJBQ0VfT1BFTiwgbWF0Y2hbMF0pO1xyXG4gICAgICAgICAgICBjdHgucHVzaChTVEFURV9OT1JNQUwpO1xyXG4gICAgICAgIH0sIENVUkxZX0JSQUNFX09QRU4pO1xyXG4gICAgICAgIGxleGVyLnJ1bGUoU1RBVEVfTk9STUFMLCAvey8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoQ1VSTFlfQlJBQ0VfT1BFTiwgbWF0Y2hbMF0pO1xyXG4gICAgICAgICAgICBjdHgucHVzaChTVEFURV9JTl9NRVNTQUdFKTtcclxuICAgICAgICB9LCBDVVJMWV9CUkFDRV9PUEVOKTtcclxuICAgICAgICBsZXhlci5ydWxlKFNUQVRFX05PUk1BTCwgL30vLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBjdHgucG9wKCk7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoQ1VSTFlfQlJBQ0VfQ0xPU0UsIG1hdGNoWzBdKTtcclxuICAgICAgICB9LCBDVVJMWV9CUkFDRV9DTE9TRSk7XHJcbiAgICAgICAgLy8gbWFza2VkICcgeyBhbmQgfVxyXG4gICAgICAgIGxleGVyLnJ1bGUoU1RBVEVfSU5fTUVTU0FHRSwgLydbe31dPycvLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hbMF0gPT09ICdcXCdcXCcnKSB7XHJcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgKz0gJ1xcJyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICdcXCd7XFwnJykge1xyXG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0ICs9ICd7JztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJ1xcJ31cXCcnKSB7XHJcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgKz0gJ30nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5pZ25vcmUoKTtcclxuICAgICAgICB9LCBURVhUKTtcclxuICAgICAgICBsZXhlci5ydWxlKFNUQVRFX0lOX01FU1NBR0UsIC8uLywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hhciA9IG1hdGNoWzBdO1xyXG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJ3snKSB7XHJcbiAgICAgICAgICAgICAgICBvcGVuZWRDdXJseUJyYWNlc0luVGV4dENvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgIHBsYWludGV4dCArPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgICAgIGN0eC5pZ25vcmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnfScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcGVuZWRDdXJseUJyYWNlc0luVGV4dENvdW50ZXIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVkQ3VybHlCcmFjZXNJblRleHRDb3VudGVyLS07XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhaW50ZXh0ICs9IG1hdGNoWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5pZ25vcmUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5hY2NlcHQoVEVYVCwgcGxhaW50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBwbGFpbnRleHQgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBjdHguYWNjZXB0KENVUkxZX0JSQUNFX0NMT1NFLCBtYXRjaFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgKz0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgICAgICBjdHguaWdub3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBURVhUKTtcclxuICAgICAgICAvLyBjb21tYVxyXG4gICAgICAgIGxleGVyLnJ1bGUoU1RBVEVfTk9STUFMLCAvLC8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoQ09NTUEsIG1hdGNoWzBdKTtcclxuICAgICAgICB9LCBDT01NQSk7XHJcbiAgICAgICAgLy8ga2V5d29yZHMgcGx1cmFsIGFuZCBzZWxlY3RcclxuICAgICAgICBsZXhlci5ydWxlKFNUQVRFX05PUk1BTCwgL3BsdXJhbC8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoUExVUkFMLCBtYXRjaFswXSk7XHJcbiAgICAgICAgfSwgUExVUkFMKTtcclxuICAgICAgICBsZXhlci5ydWxlKFNUQVRFX05PUk1BTCwgL3NlbGVjdC8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoU0VMRUNULCBtYXRjaFswXSk7XHJcbiAgICAgICAgfSwgU0VMRUNUKTtcclxuICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgbGV4ZXIucnVsZSgvLi8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIHBsYWludGV4dCArPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgY3R4Lmlnbm9yZSgpO1xyXG4gICAgICAgIH0sIFRFWFQpO1xyXG4gICAgICAgIGxleGVyLnJ1bGUoL1tcXHNdKy8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIHBsYWludGV4dCArPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgY3R4Lmlnbm9yZSgpO1xyXG4gICAgICAgIH0sIFRFWFQpO1xyXG4gICAgICAgIHJldHVybiBsZXhlcjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbnRhaW5zTm9uV2hpdGVTcGFjZSh0ZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCEvXFxzLy50ZXN0KHRleHQuY2hhckF0KGkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRva2VuaXplKG5vcm1hbGl6ZWRNZXNzYWdlOiBzdHJpbmcpOiBJQ1VUb2tlbltdIHtcclxuICAgICAgICBjb25zdCBsZXhlcjogVG9rZW5penIgPSB0aGlzLmdldExleGVyKCk7XHJcbiAgICAgICAgbGV4ZXIuaW5wdXQobm9ybWFsaXplZE1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiBsZXhlci50b2tlbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpbnB1dChub3JtYWxpemVkTWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5sZXhlciA9IHRoaXMuZ2V0TGV4ZXIoKTtcclxuICAgICAgICB0aGlzLmxleGVyLmlucHV0KG5vcm1hbGl6ZWRNZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICBuZXh0KCk6IElDVVRva2VuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZXhlci50b2tlbigpO1xyXG4gICAgfVxyXG5cclxuICAgIHBlZWsoKTogSUNVVG9rZW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxleGVyLnBlZWsoKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge0lJQ1VNZXNzYWdlLCBJSUNVTWVzc2FnZUNhdGVnb3J5LCBJSUNVTWVzc2FnZVRyYW5zbGF0aW9uLCBJTm9ybWFsaXplZE1lc3NhZ2V9IGZyb20gJy4uL2FwaS9pbmRleCc7XHJcbmltcG9ydCB7Zm9ybWF0LCBpc051bGxPclVuZGVmaW5lZCwgaXNTdHJpbmd9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0lNZXNzYWdlUGFyc2VyfSBmcm9tICcuL2ktbWVzc2FnZS1wYXJzZXInO1xyXG5cclxuY2xhc3MgTWVzc2FnZUNhdGVnb3J5IGltcGxlbWVudHMgSUlDVU1lc3NhZ2VDYXRlZ29yeSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2F0ZWdvcnk6IHN0cmluZywgcHJpdmF0ZSBfbWVzc2FnZTogSU5vcm1hbGl6ZWRNZXNzYWdlKSB7fVxyXG5cclxuICAgIHB1YmxpYyBnZXRDYXRlZ29yeSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYXRlZ29yeTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TWVzc2FnZU5vcm1hbGl6ZWQoKTogSU5vcm1hbGl6ZWRNZXNzYWdlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIGFuIElDVSBNZXNzYWdlLlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwNS4wNi4yMDE3LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIElDVU1lc3NhZ2UgaW1wbGVtZW50cyBJSUNVTWVzc2FnZSB7XHJcblxyXG4gICAgcHJpdmF0ZSBfaXNQbHVyYWxNZXNzYWdlOiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgX2NhdGVnb3JpZXM6IElJQ1VNZXNzYWdlQ2F0ZWdvcnlbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJzZXI6IElNZXNzYWdlUGFyc2VyLCBpc1BsdXJhbE1lc3NhZ2U6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9pc1BsdXJhbE1lc3NhZ2UgPSBpc1BsdXJhbE1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZENhdGVnb3J5KGNhdGVnb3J5OiBzdHJpbmcsIG1lc3NhZ2U6IElOb3JtYWxpemVkTWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMuX2NhdGVnb3JpZXMucHVzaChuZXcgTWVzc2FnZUNhdGVnb3J5KGNhdGVnb3J5LCBtZXNzYWdlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJQ1UgbWVzc2FnZSBhcyBuYXRpdmUgc3RyaW5nLlxyXG4gICAgICogVGhpcyBpcywgaG93IGl0IGlzIHN0b3JlZCwgc29tZXRoaW5nIGxpa2UgJ3t4LCBwbHVyYWwsID0wIHsuLn0nXHJcbiAgICAgKiBAcmV0dXJuIElDVSBtZXNzYWdlIGFzIG5hdGl2ZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc05hdGl2ZVN0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHZhcm5hbWUgPSAodGhpcy5pc1BsdXJhbE1lc3NhZ2UoKSkgPyAnVkFSX1BMVVJBTCcgOiAnVkFSX1NFTEVDVCc7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0aGlzLmlzUGx1cmFsTWVzc2FnZSgpKSA/ICdwbHVyYWwnIDogJ3NlbGVjdCc7XHJcbiAgICAgICAgbGV0IGNob2ljZVN0cmluZyA9ICcnO1xyXG4gICAgICAgIHRoaXMuX2NhdGVnb3JpZXMuZm9yRWFjaCgoY2F0ZWdvcnk6IElJQ1VNZXNzYWdlQ2F0ZWdvcnkpID0+IHtcclxuICAgICAgICAgICAgY2hvaWNlU3RyaW5nID0gY2hvaWNlU3RyaW5nICsgZm9ybWF0KCcgJXMgeyVzfScsIGNhdGVnb3J5LmdldENhdGVnb3J5KCksIGNhdGVnb3J5LmdldE1lc3NhZ2VOb3JtYWxpemVkKCkuYXNOYXRpdmVTdHJpbmcoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdCgneyVzLCAlcywlc30nLCB2YXJuYW1lLCB0eXBlLCBjaG9pY2VTdHJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXMgaXQgYSBwbHVyYWwgbWVzc2FnZT9cclxuICAgICAqL1xyXG4gICAgaXNQbHVyYWxNZXNzYWdlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BsdXJhbE1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyBpdCBhIHNlbGVjdCBtZXNzYWdlP1xyXG4gICAgICovXHJcbiAgICBpc1NlbGVjdE1lc3NhZ2UoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLl9pc1BsdXJhbE1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdGhlIHBhcnRzIG9mIHRoZSBtZXNzYWdlLlxyXG4gICAgICogRS5nLiB0aGUgSUNVIG1lc3NhZ2Uge3dvbHZlcywgcGx1cmFsLCA9MCB7bm8gd29sdmVzfSA9MSB7b25lIHdvbGZ9ID0yIHt0d28gd29sdmVzfSBvdGhlciB7YSB3b2xmIHBhY2t9fVxyXG4gICAgICogaGFzIDQgY2F0ZWdvcnkgb2JqZWN0cyB3aXRoIHRoZSBjYXRlZ29yaWVzID0wLCA9MSwgPTIsIG90aGVyLlxyXG4gICAgICovXHJcbiAgICBnZXRDYXRlZ29yaWVzKCk6IElJQ1VNZXNzYWdlQ2F0ZWdvcnlbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhdGVnb3JpZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGUgbWVzc2FnZSBhbmQgcmV0dXJuIGEgbmV3LCB0cmFuc2xhdGVkIG1lc3NhZ2VcclxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiB0aGUgdHJhbnNsYXRpb24gKGhhc2htYXAgb2YgY2F0ZWdvcmllcyBhbmQgdHJhbnNsYXRpb25zKS5cclxuICAgICAqIEByZXR1cm4gbmV3IG1lc3NhZ2Ugd2l0IHRyYW5zbGF0ZWQgY29udGVudC5cclxuICAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdHJhbnNsYXRpb24gZG9lcyBub3QgbWF0Y2ggdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBjYXNlLCBpZiB0aGVyZSBhcmUgY2F0ZWdvcmllcyBub3QgY29udGFpbmVkIGluIHRoZSBvcmlnaW5hbCBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICB0cmFuc2xhdGUodHJhbnNsYXRpb246IElJQ1VNZXNzYWdlVHJhbnNsYXRpb24pOiBJSUNVTWVzc2FnZSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBJQ1VNZXNzYWdlKHRoaXMuX3BhcnNlciwgdGhpcy5pc1BsdXJhbE1lc3NhZ2UoKSk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlZENhdGVnb3JpZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdHJhbnNsYXRlZE1lc3NhZ2U6IElOb3JtYWxpemVkTWVzc2FnZTtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRpb25Gb3JDYXRlZ29yeTogc3RyaW5nfElJQ1VNZXNzYWdlVHJhbnNsYXRpb24gPSB0cmFuc2xhdGlvbltjYXRlZ29yeS5nZXRDYXRlZ29yeSgpXTtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHRyYW5zbGF0aW9uRm9yQ2F0ZWdvcnkpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkTWVzc2FnZSA9IGNhdGVnb3J5LmdldE1lc3NhZ2VOb3JtYWxpemVkKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodHJhbnNsYXRpb25Gb3JDYXRlZ29yeSkpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRDYXRlZ29yaWVzLmFkZChjYXRlZ29yeS5nZXRDYXRlZ29yeSgpKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRNZXNzYWdlID0gdGhpcy5fcGFyc2VyLnBhcnNlTm9ybWFsaXplZFN0cmluZyg8c3RyaW5nPiB0cmFuc2xhdGlvbkZvckNhdGVnb3J5LCBudWxsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gZW1iZWRkZWQgSUNVIE1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRNZXNzYWdlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZXNzYWdlLmFkZENhdGVnb3J5KGNhdGVnb3J5LmdldENhdGVnb3J5KCksIHRyYW5zbGF0ZWRNZXNzYWdlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBuZXcgY2F0ZWdvcmllcywgd2hpY2ggYXJlIG5vdCBwYXJ0IG9mIHRoZSBvcmlnaW5hbCBtZXNzYWdlXHJcbiAgICAgICAgT2JqZWN0LmtleXModHJhbnNsYXRpb24pLmZvckVhY2goKGNhdGVnb3J5TmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRyYW5zbGF0ZWRDYXRlZ29yaWVzLmhhcyhjYXRlZ29yeU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NlbGVjdE1lc3NhZ2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ2FkZGluZyBhIG5ldyBjYXRlZ29yeSBub3QgYWxsb3dlZCBmb3Igc2VsZWN0IG1lc3NhZ2VzIChcIiVzXCIgaXMgbm90IHBhcnQgb2YgbWVzc2FnZSknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeU5hbWUpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbGlkUGx1cmFsQ2F0ZWdvcnkoY2F0ZWdvcnlOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGVtYmVkZGVkIElDVSBNZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZWRNZXNzYWdlID0gdGhpcy5fcGFyc2VyLnBhcnNlTm9ybWFsaXplZFN0cmluZyg8c3RyaW5nPiB0cmFuc2xhdGlvbltjYXRlZ29yeU5hbWVdLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZENhdGVnb3J5KGNhdGVnb3J5TmFtZSwgdHJhbnNsYXRlZE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjaywgd2V0aGVyIGNhdGVnb3J5IGlzIHZhbGlkIHBsdXJhbCBjYXRlZ29yeS5cclxuICAgICAqIEFsbG93ZWQgYXJlID1uLCAnemVybycsICdvbmUnLCAndHdvJywgJ2ZldycsICdtYW55JyBhbmQgJ290aGVyJ1xyXG4gICAgICogQHBhcmFtIGNhdGVnb3J5TmFtZSBjYXRlZ29yeVxyXG4gICAgICogQHRocm93cyBhbiBlcnJvciwgaWYgaXQgaXMgbm90IGEgdmFsaWQgY2F0ZWdvcnkgbmFtZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoZWNrVmFsaWRQbHVyYWxDYXRlZ29yeShjYXRlZ29yeU5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IGFsbG93ZWRLZXl3b3JkcyA9IFsnemVybycsICdvbmUnLCAndHdvJywgJ2ZldycsICdtYW55JywgJ290aGVyJ107XHJcbiAgICAgICAgaWYgKGNhdGVnb3J5TmFtZS5tYXRjaCgvPVxcZCsvKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbGxvd2VkS2V5d29yZHMuZmluZCgoa2V5KSA9PiBrZXkgPT09IGNhdGVnb3J5TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdpbnZhbGlkIHBsdXJhbCBjYXRlZ29yeSBcIiVzXCIsIGFsbG93ZWQgYXJlID08bj4gYW5kICVzJywgY2F0ZWdvcnlOYW1lLCBhbGxvd2VkS2V5d29yZHMpKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0LCBQYXJzZWRNZXNzYWdlUGFydFR5cGV9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydCc7XHJcbmltcG9ydCB7SUlDVU1lc3NhZ2UsIElOb3JtYWxpemVkTWVzc2FnZX0gZnJvbSAnLi4vYXBpL2luZGV4JztcclxuaW1wb3J0IHtcclxuICAgIENPTU1BLCBDVVJMWV9CUkFDRV9DTE9TRSwgQ1VSTFlfQlJBQ0VfT1BFTiwgSUNVTWVzc2FnZVRva2VuaXplciwgSUNVVG9rZW4sIFBMVVJBTCwgU0VMRUNULFxyXG4gICAgVEVYVFxyXG59IGZyb20gJy4vaWN1LW1lc3NhZ2UtdG9rZW5pemVyJztcclxuaW1wb3J0IHtJQ1VNZXNzYWdlfSBmcm9tICcuL2ljdS1tZXNzYWdlJztcclxuaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0lNZXNzYWdlUGFyc2VyfSBmcm9tICcuL2ktbWVzc2FnZS1wYXJzZXInO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDAyLjA2LjIwMTcuXHJcbiAqIEEgbWVzc2FnZSBwYXJ0IGNvbnNpc3Rpbmcgb2YgYW4gaWN1IG1lc3NhZ2UuXHJcbiAqIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBpY3UgbWVzc2FnZSBpbiBhIHBhcnNlZCBtZXNzYWdlLlxyXG4gKiBTeW50YXggb2YgSUNVIG1lc3NhZ2UgaXMgJ3snIDxrZXluYW1lPiAnLCcgJ3NlbGVjdCd8J3BsdXJhbCcgJywnICg8Y2F0ZWdvcnk+ICd7JyB0ZXh0ICd9JykrICd9J1xyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2UgZXh0ZW5kcyBQYXJzZWRNZXNzYWdlUGFydCB7XHJcblxyXG4gICAgcHJpdmF0ZSBfbWVzc2FnZTogSUNVTWVzc2FnZTtcclxuICAgIHByaXZhdGUgX21lc3NhZ2VUZXh0OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF90b2tlbml6ZXI6IElDVU1lc3NhZ2VUb2tlbml6ZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoaWN1TWVzc2FnZVRleHQ6IHN0cmluZywgcHJpdmF0ZSBfcGFyc2VyOiBJTWVzc2FnZVBhcnNlcikge1xyXG4gICAgICAgIHN1cGVyKFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5JQ1VfTUVTU0FHRSk7XHJcbiAgICAgICAgaWYgKGljdU1lc3NhZ2VUZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VJQ1VNZXNzYWdlKGljdU1lc3NhZ2VUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IHdldGhlciB0ZXh0IG1pZ2h0IGJlIGFuIElDVSBtZXNzYWdlLlxyXG4gICAgICogU2hvdWxkIGF0IGxlYXN0IHN0YXJ0IHdpdGggc29tZXRoaW5nIGxpa2UgJ3s8bmFtZT4sIHNlbGVjdCwgLi4nIG9yICd7PG5hbWU+LCBwbHVyYWwsIC4uLidcclxuICAgICAqIEBwYXJhbSBpY3VNZXNzYWdlVGV4dCBpY3VNZXNzYWdlVGV4dFxyXG4gICAgICogQHJldHVybiB3ZXRoZXIgdGV4dCBtaWdodCBiZSBhbiBJQ1UgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxvb2tzTGlrZUlDVU1lc3NhZ2UoaWN1TWVzc2FnZVRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHBhcnQgPSBuZXcgUGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlKG51bGwsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0Lmxvb2tzTGlrZUlDVU1lc3NhZ2UoaWN1TWVzc2FnZVRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc0Rpc3BsYXlTdHJpbmcoZGlzcGxheUZvcm1hdD86IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiAnPElDVS1NZXNzYWdlLz4nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRoZSBwYXJzZWQgbWVzc2FnZS5cclxuICAgICAqIEByZXR1cm4gcGFyc2VkIG1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldElDVU1lc3NhZ2UoKTogSUlDVU1lc3NhZ2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gdGV4dCBtZXNzYWdlIHRleHQgdG8gcGFyc2VcclxuICAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIHN5bnRheCBpcyBub3Qgb2sgaW4gYW55IHdheS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXJzZUlDVU1lc3NhZ2UodGV4dDogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ21lc3NhZ2UgJywgdGV4dCk7XHJcbiAgICAgICAgLy8gY29uc3QgdG9rZW5zID0gbmV3IElDVU1lc3NhZ2VUb2tlbml6ZXIoKS50b2tlbml6ZSh0ZXh0KTtcclxuICAgICAgICAvLyB0b2tlbnMuZm9yRWFjaCgodG9rKSA9PiB7XHJcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdUb2tlbicsIHRvay50eXBlLCB0b2sudmFsdWUpO1xyXG4gICAgICAgIC8vIH0pO1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VUZXh0ID0gdGV4dDtcclxuICAgICAgICB0aGlzLl90b2tlbml6ZXIgPSBuZXcgSUNVTWVzc2FnZVRva2VuaXplcigpO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuaXplci5pbnB1dCh0ZXh0KTtcclxuICAgICAgICB0aGlzLmV4cGVjdE5leHQoQ1VSTFlfQlJBQ0VfT1BFTik7XHJcbiAgICAgICAgdGhpcy5leHBlY3ROZXh0KFRFWFQpOyAvLyB2YXJuYW1lLCBub3QgdXNlZCBjdXJyZW50bHksIG5nIGFsd2F5cyB1c2VkIFZBUl9QTFVSQUwgb3IgVkFSX1NFTEVDVFxyXG4gICAgICAgIHRoaXMuZXhwZWN0TmV4dChDT01NQSk7XHJcbiAgICAgICAgbGV0IHRva2VuOiBJQ1VUb2tlbiA9IHRoaXMuX3Rva2VuaXplci5uZXh0KCk7XHJcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFBMVVJBTCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlID0gbmV3IElDVU1lc3NhZ2UodGhpcy5fcGFyc2VyLCB0cnVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFNFTEVDVCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlID0gbmV3IElDVU1lc3NhZ2UodGhpcy5fcGFyc2VyLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXhwZWN0TmV4dChDT01NQSk7XHJcbiAgICAgICAgdG9rZW4gPSB0aGlzLl90b2tlbml6ZXIucGVlaygpO1xyXG4gICAgICAgIHdoaWxlICh0b2tlbi50eXBlICE9PSBDVVJMWV9CUkFDRV9DTE9TRSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IHRoaXMuZXhwZWN0TmV4dChURVhUKS52YWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0TmV4dChDVVJMWV9CUkFDRV9PUEVOKTtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZXhwZWN0TmV4dChURVhUKS52YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZS5hZGRDYXRlZ29yeShjYXRlZ29yeSwgdGhpcy5wYXJzZU5hdGl2ZVN1Yk1lc3NhZ2UobWVzc2FnZSkpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdE5leHQoQ1VSTFlfQlJBQ0VfQ0xPU0UpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMuX3Rva2VuaXplci5wZWVrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXhwZWN0TmV4dChDVVJMWV9CUkFDRV9DTE9TRSk7XHJcbiAgICAgICAgdGhpcy5leHBlY3ROZXh0KCdFT0YnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIHRoZSBtZXNzYWdlIHRvIGNoZWNrLCB3ZXRoZXIgaXQgbWlnaHQgYmUgYW4gSUNVIG1lc3NhZ2UuXHJcbiAgICAgKiBTaG91bGQgYXQgbGVhc3Qgc3RhcnQgd2l0aCBzb21ldGhpbmcgbGlrZSAnezxuYW1lPiwgc2VsZWN0LCAuLicgb3IgJ3s8bmFtZT4sIHBsdXJhbCwgLi4uJ1xyXG4gICAgICogQHBhcmFtIHRleHQgbWVzc2FnZSB0ZXh0IHRvIHBhcnNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9va3NMaWtlSUNVTWVzc2FnZSh0ZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnbWVzc2FnZSAnLCB0ZXh0KTtcclxuICAgICAgICAvLyBjb25zdCB0b2tlbnMgPSBuZXcgSUNVTWVzc2FnZVRva2VuaXplcigpLnRva2VuaXplKHRleHQpO1xyXG4gICAgICAgIC8vIHRva2Vucy5mb3JFYWNoKCh0b2spID0+IHtcclxuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ1Rva2VuJywgdG9rLnR5cGUsIHRvay52YWx1ZSk7XHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgdGhpcy5fdG9rZW5pemVyID0gbmV3IElDVU1lc3NhZ2VUb2tlbml6ZXIoKTtcclxuICAgICAgICB0aGlzLl90b2tlbml6ZXIuaW5wdXQodGV4dCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5leHBlY3ROZXh0KENVUkxZX0JSQUNFX09QRU4pO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdE5leHQoVEVYVCk7IC8vIHZhcm5hbWUsIG5vdCB1c2VkIGN1cnJlbnRseSwgbmcgYWx3YXlzIHVzZWQgVkFSX1BMVVJBTCBvciBWQVJfU0VMRUNUXHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0TmV4dChDT01NQSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuOiBJQ1VUb2tlbiA9IHRoaXMuX3Rva2VuaXplci5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBQTFVSQUwgJiYgdG9rZW4udHlwZSAhPT0gU0VMRUNUKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5leHBlY3ROZXh0KENPTU1BKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgbmV4dCB0b2tlbiBhbmQgZXhwZWN0LCB0aGF0IGl0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLlxyXG4gICAgICogQHBhcmFtIHRva2VudHlwZSBleHBlY3RlZCB0eXBlLlxyXG4gICAgICogQHJldHVybiBUb2tlblxyXG4gICAgICogQHRocm93cyBlcnJvciwgaWYgbmV4dCB0b2tlbiBoYXMgd3JvbmcgdHlwZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBleHBlY3ROZXh0KHRva2VudHlwZTogc3RyaW5nKTogSUNVVG9rZW4ge1xyXG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5fdG9rZW5pemVyLm5leHQoKTtcclxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gdG9rZW50eXBlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0Vycm9yIHBhcnNpbmcgSUNVIE1lc3NhZ2U6IGV4cGVjdGVkICVzLCBmb3VuZCAlcyAoJXMpIChtZXNzYWdlICVzKScsXHJcbiAgICAgICAgICAgICAgICB0b2tlbnR5cGUsIHRva2VuLnR5cGUsIHRva2VuLnZhbHVlLCB0aGlzLl9tZXNzYWdlVGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBYTUwgdGV4dCB0byBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlIGluIGZvcm1hdCBkZXBlbmRlbnQgeG1sIHN5bnRheC5cclxuICAgICAqIEByZXR1cm4gbm9ybWFsaXplZCBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGFyc2VOYXRpdmVTdWJNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IElOb3JtYWxpemVkTWVzc2FnZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlci5jcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUxTdHJpbmcobWVzc2FnZSwgbnVsbCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydCwgUGFyc2VkTWVzc2FnZVBhcnRUeXBlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQnO1xyXG5pbXBvcnQge05PUk1BTElaQVRJT05fRk9STUFUX05HWFRSQU5TTEFURX0gZnJvbSAnLi4vYXBpL2NvbnN0YW50cyc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwNS4wNS4yMDE3LlxyXG4gKiBBIHJlZmVyZW5jZSB0byBhbiBJQ1UgbWVzc2FnZVxyXG4gKiBpY3UgcmVmZXJlbmNlcyBhcmUgbnVtYmVyZWQgZnJvbSAwIHRvIG4uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZiBleHRlbmRzIFBhcnNlZE1lc3NhZ2VQYXJ0IHtcclxuXHJcbiAgICAvLyBpbmRleCAwIC4uIG5cclxuICAgIHByaXZhdGUgX2luZGV4OiBudW1iZXI7XHJcbiAgICAvLyBvcHRpb25hbCBkaXNwLUF0dHJpYnV0ZSB2YWx1ZSwgY29udGFpbnMgdGhlIG9yaWdpbmFsIGV4cHJlc3Npb24uXHJcbiAgICBwcml2YXRlIF9kaXNwPzogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGluZGV4OiBudW1iZXIsIGRpc3A6IHN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5JQ1VfTUVTU0FHRV9SRUYpO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZGlzcCA9IGRpc3A7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzRGlzcGxheVN0cmluZyhmb3JtYXQ/OiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gJzxJQ1UtTWVzc2FnZS1SZWZfJyArIHRoaXMuX2luZGV4ICsgJy8+JztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaW5kZXgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRpc3AoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0LCBQYXJzZWRNZXNzYWdlUGFydFR5cGV9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxNC4wNi4yMDE3LlxyXG4gKiBBIG1lc3NhZ2UgcGFydCBjb25zaXN0aW5nIG9mIGFuIGVtcHR5IHRhZyBsaWtlIDxici8+LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBQYXJzZWRNZXNzYWdlUGFydEVtcHR5VGFnIGV4dGVuZHMgUGFyc2VkTWVzc2FnZVBhcnQge1xyXG5cclxuICAgIHByaXZhdGUgX3RhZ25hbWU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2lkY291bnRlcjogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRhZ25hbWU6IHN0cmluZywgaWRjb3VudGVyOiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlcihQYXJzZWRNZXNzYWdlUGFydFR5cGUuRU1QVFlfVEFHKTtcclxuICAgICAgICB0aGlzLl90YWduYW1lID0gdGFnbmFtZTtcclxuICAgICAgICB0aGlzLl9pZGNvdW50ZXIgPSBpZGNvdW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzRGlzcGxheVN0cmluZyhmb3JtYXQ/OiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAodGhpcy5faWRjb3VudGVyID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPCcgKyB0aGlzLl90YWduYW1lICsgJz4nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPCcgKyB0aGlzLl90YWduYW1lICsgJyBpZD1cIicgKyB0aGlzLl9pZGNvdW50ZXIudG9TdHJpbmcoKSArICdcIj4nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdGFnTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YWduYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpZENvdW50ZXIoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faWRjb3VudGVyO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnQsIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFRleHR9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC10ZXh0JztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtcGxhY2Vob2xkZXInO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1zdGFydC10YWcnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW5kLXRhZyc7XHJcbmltcG9ydCB7SU5vcm1hbGl6ZWRNZXNzYWdlLCBWYWxpZGF0aW9uRXJyb3JzfSBmcm9tICcuLi9hcGkvaS1ub3JtYWxpemVkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge0RPTVV0aWxpdGllc30gZnJvbSAnLi9kb20tdXRpbGl0aWVzJztcclxuaW1wb3J0IHtJTWVzc2FnZVBhcnNlcn0gZnJvbSAnLi9pLW1lc3NhZ2UtcGFyc2VyJztcclxuaW1wb3J0IHtmb3JtYXQsIGlzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtJSUNVTWVzc2FnZSwgSUlDVU1lc3NhZ2VUcmFuc2xhdGlvbn0gZnJvbSAnLi4vYXBpL2ktaWN1LW1lc3NhZ2UnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LWljdS1tZXNzYWdlJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWZ9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1pY3UtbWVzc2FnZS1yZWYnO1xyXG5pbXBvcnQge0lDVU1lc3NhZ2V9IGZyb20gJy4vaWN1LW1lc3NhZ2UnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1lbXB0eS10YWcnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDUuMDUuMjAxNy5cclxuICogQSBtZXNzYWdlIHRleHQgcmVhZCBmcm9tIGEgdHJhbnNsYXRpb24gZmlsZS5cclxuICogQ2FuIGNvbnRhaW4gcGxhY2Vob2xkZXJzLCB0YWdzLCB0ZXh0LlxyXG4gKiBUaGlzIGNsYXNzIGlzIGEgcmVwcmVzZW50YXRpb24gaW5kZXBlbmRlbnQgb2YgdGhlIGNvbmNyZXRlIGZvcm1hdC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYXJzZWRNZXNzYWdlIGltcGxlbWVudHMgSU5vcm1hbGl6ZWRNZXNzYWdlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlciB0aGF0IGNyZWF0ZWQgdGhpcyBtZXNzYWdlIChkZXRlcm1pbmVzIHRoZSBuYXRpdmUgZm9ybWF0KS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcGFyc2VyOiBJTWVzc2FnZVBhcnNlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtZXNzYWdlIHdoZXJlIHRoaXMgb25lIHN0ZW1zIGZyb20gYXMgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBPcHRpb25hbCwgc2V0IG9ubHkgZm9yIG1lc3NhZ2VzIGNyZWF0ZWQgYnkgY2FsbGluZyB0cmFuc2xhdGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc291cmNlTWVzc2FnZTogUGFyc2VkTWVzc2FnZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwYXJ0cyBvZiB0aGUgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcGFydHM6IFBhcnNlZE1lc3NhZ2VQYXJ0W107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBtZXNzYWdlcyB4bWwgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3htbFJlcHJlc2VudGF0aW9uOiBFbGVtZW50O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBhcnNlcjogSU1lc3NhZ2VQYXJzZXIsIHNvdXJjZU1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLl9wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VNZXNzYWdlID0gc291cmNlTWVzc2FnZTtcclxuICAgICAgICB0aGlzLl9wYXJ0cyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBwYXJzZXIgKGZvciB0ZXN0cyBvbmx5LCBub3QgcGFydCBvZiBBUEkpXHJcbiAgICAgKiBAcmV0dXJuIHBhcnNlclxyXG4gICAgICovXHJcbiAgICBnZXRQYXJzZXIoKTogSU1lc3NhZ2VQYXJzZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9ybWFsaXplZCBtZXNzYWdlIGFzIGEgdHJhbnNsYXRpb24gb2YgdGhpcyBvbmUuXHJcbiAgICAgKiBAcGFyYW0gbm9ybWFsaXplZFN0cmluZyB0aGUgdHJhbnNsYXRpb24gaW4gbm9ybWFsaXplZCBmb3JtLlxyXG4gICAgICogSWYgdGhlIG1lc3NhZ2UgaXMgYW4gSUNVTWVzc2FnZSAoZ2V0SUNVTWVzc2FnZSByZXR1cm5zIGEgdmFsdWUpLCB1c2UgdHJhbnNsYXRlSUNVTWVzc2FnZSBpbnN0ZWFkLlxyXG4gICAgICogQHRocm93cyBhbiBlcnJvciBpZiBub3JtYWxpemVkIHN0cmluZyBpcyBub3Qgd2VsbCBmb3JtZWQuXHJcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgdG9vLCBpZiB0aGlzIGlzIGFuIElDVSBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICB0cmFuc2xhdGUobm9ybWFsaXplZFN0cmluZzogc3RyaW5nKTogSU5vcm1hbGl6ZWRNZXNzYWdlIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5nZXRJQ1VNZXNzYWdlKCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZXIucGFyc2VOb3JtYWxpemVkU3RyaW5nKDxzdHJpbmc+IG5vcm1hbGl6ZWRTdHJpbmcsIHRoaXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ2Nhbm5vdCB0cmFuc2xhdGUgSUNVIG1lc3NhZ2Ugd2l0aCBzaW1wbGUgc3RyaW5nLCB1c2UgdHJhbnNsYXRlSUNVTWVzc2FnZSgpIGluc3RlYWQgKFwiJXNcIiwgXCIlc1wiKScsXHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkU3RyaW5nLCB0aGlzLmFzTmF0aXZlU3RyaW5nKCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9ybWFsaXplZCBpY3UgbWVzc2FnZSBhcyBhIHRyYW5zbGF0aW9uIG9mIHRoaXMgb25lLlxyXG4gICAgICogQHBhcmFtIGljdVRyYW5zbGF0aW9uIHRoZSB0cmFuc2xhdGlvbiwgdGhpcyBpcyB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIElDVSBtZXNzYWdlLFxyXG4gICAgICogd2hpY2ggaXMgbm90IGEgc3RyaW5nLCBidXQgYSBjb2xsZWN0aW9ucyBvZiB0aGUgdHJhbnNsYXRpb25zIG9mIHRoZSBkaWZmZXJlbnQgY2F0ZWdvcmllcy5cclxuICAgICAqIFRoZSBtZXNzYWdlIG11c3QgYmUgYW4gSUNVTWVzc2FnZSAoZ2V0SUNVTWVzc2FnZSByZXR1cm5zIGEgdmFsdWUpXHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yIGlmIG5vcm1hbGl6ZWQgc3RyaW5nIGlzIG5vdCB3ZWxsIGZvcm1lZC5cclxuICAgICAqIFRocm93cyBhbiBlcnJvciB0b28sIGlmIHRoaXMgaXMgbm90IGFuIElDVSBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICB0cmFuc2xhdGVJQ1VNZXNzYWdlKGljdVRyYW5zbGF0aW9uOiBJSUNVTWVzc2FnZVRyYW5zbGF0aW9uKTogSU5vcm1hbGl6ZWRNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCBpY3VNZXNzYWdlOiBJSUNVTWVzc2FnZSA9IHRoaXMuZ2V0SUNVTWVzc2FnZSgpO1xyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChpY3VNZXNzYWdlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCd0aGlzIGlzIG5vdCBhbiBJQ1UgbWVzc2FnZSwgdXNlIHRyYW5zbGF0ZSgpIGluc3RlYWQgKFwiJXNcIiwgXCIlc1wiKScsXHJcbiAgICAgICAgICAgICAgICBpY3VUcmFuc2xhdGlvbiwgIHRoaXMuYXNOYXRpdmVTdHJpbmcoKSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRJQ1VNZXNzYWdlOiBJSUNVTWVzc2FnZSA9IGljdU1lc3NhZ2UudHJhbnNsYXRlKGljdVRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlci5wYXJzZUlDVU1lc3NhZ2UodHJhbnNsYXRlZElDVU1lc3NhZ2UuYXNOYXRpdmVTdHJpbmcoKSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vcm1hbGl6ZWQgbWVzc2FnZSBmcm9tIGEgbmF0aXZlIHhtbCBzdHJpbmcgYXMgYSB0cmFuc2xhdGlvbiBvZiB0aGlzIG9uZS5cclxuICAgICAqIEBwYXJhbSBuYXRpdmVTdHJpbmcgeG1sIHN0cmluZyBpbiB0aGUgZm9ybWF0IG9mIHRoZSB1bmRlcmx5aW5nIGZpbGUgZm9ybWF0LlxyXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIG5hdGl2ZSBzdHJpbmcgaXMgbm90IGFjY2VwdGFibGUuXHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZU5hdGl2ZVN0cmluZyhuYXRpdmVTdHJpbmc6IHN0cmluZyk6IElOb3JtYWxpemVkTWVzc2FnZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlci5jcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUxTdHJpbmcobmF0aXZlU3RyaW5nLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIG5vcm1hbGl6ZWQgbWVzc2FnZSBhcyBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gZGlzcGxheUZvcm1hdCBvcHRpb25hbCB3YXkgdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBzeW50YXguXHJcbiAgICAgKiBBbGxvd2VkIGZvcm1hdHMgYXJlIGRlZmluZWQgYXMgY29uc3RhbnRzIE5PUk1BTElaQVRJT05fRk9STUFULi4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc0Rpc3BsYXlTdHJpbmcoZGlzcGxheUZvcm1hdD86IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQuYXNEaXNwbGF5U3RyaW5nKGRpc3BsYXlGb3JtYXQpKS5qb2luKCcnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1lc3NhZ2UgY29udGVudCBhcyBmb3JtYXQgZGVwZW5kZW50IG5hdGl2ZSBzdHJpbmcuXHJcbiAgICAgKiBJbmNsdWRlcyBhbGwgZm9ybWF0IHNwZWNpZmljIG1hcmt1cCBsaWtlIDxwaCBpZD1cIklOVEVSUE9MQVRJT05cIiAuLi8+IC4uXHJcbiAgICAgKi9cclxuICAgIGFzTmF0aXZlU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuZ2V0SUNVTWVzc2FnZSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFhNTENvbnRlbnQodGhpcy5feG1sUmVwcmVzZW50YXRpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldElDVU1lc3NhZ2UoKS5hc05hdGl2ZVN0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBtZXNzYWdlLlxyXG4gICAgICogQHJldHVybiBudWxsLCBpZiBvaywgZXJyb3Igb2JqZWN0IG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHZhbGlkYXRlKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcclxuICAgICAgICBsZXQgaGFzRXJyb3JzID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JzID0ge307XHJcbiAgICAgICAgbGV0IGU7XHJcbiAgICAgICAgZSA9IHRoaXMuY2hlY2tQbGFjZWhvbGRlckFkZGVkKCk7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChlKSkge1xyXG4gICAgICAgICAgICBlcnJvcnMucGxhY2Vob2xkZXJBZGRlZCA9IGU7XHJcbiAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGUgPSB0aGlzLmNoZWNrSUNVTWVzc2FnZVJlZlJlbW92ZWQoKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGUpKSB7XHJcbiAgICAgICAgICAgIGVycm9ycy5pY3VNZXNzYWdlUmVmUmVtb3ZlZCA9IGU7XHJcbiAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGUgPSB0aGlzLmNoZWNrSUNVTWVzc2FnZVJlZkFkZGVkKCk7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChlKSkge1xyXG4gICAgICAgICAgICBlcnJvcnMuaWN1TWVzc2FnZVJlZkFkZGVkID0gZTtcclxuICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc0Vycm9ycyA/IGVycm9ycyA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSB0aGUgbWVzc2FnZSwgY2hlY2sgZm9yIHdhcm5pbmdzIG9ubHkuXHJcbiAgICAgKiBBIHdhcm5pbmcgc2hvd3MsIHRoYXQgdGhlIG1lc3NhZ2UgaXMgYWNjZXB0YWJsZSwgYnV0IG1pc3NlcyBzb21ldGhpbmcuXHJcbiAgICAgKiBFLmcuIGlmIHlvdSByZW1vdmUgYSBwbGFjZWhvbGRlciBvciBhIHNwZWNpYWwgdGFnIGZyb20gdGhlIG9yaWdpbmFsIG1lc3NhZ2UsIHRoaXMgZ2VuZXJhdGVzIGEgd2FybmluZy5cclxuICAgICAqIEByZXR1cm4gbnVsbCwgaWYgbm8gd2FybmluZywgd2FybmluZ3MgYXMgZXJyb3Igb2JqZWN0IG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVXYXJuaW5ncygpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IGhhc1dhcm5pbmdzID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3Qgd2FybmluZ3M6IFZhbGlkYXRpb25FcnJvcnMgPSB7fTtcclxuICAgICAgICBsZXQgdztcclxuICAgICAgICB3ID0gdGhpcy5jaGVja1BsYWNlaG9sZGVyUmVtb3ZlZCgpO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodykpIHtcclxuICAgICAgICAgICAgd2FybmluZ3MucGxhY2Vob2xkZXJSZW1vdmVkID0gdztcclxuICAgICAgICAgICAgaGFzV2FybmluZ3MgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3ID0gdGhpcy5jaGVja1RhZ1JlbW92ZWQoKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHcpKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmdzLnRhZ1JlbW92ZWQgPSB3O1xyXG4gICAgICAgICAgICBoYXNXYXJuaW5ncyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHcgPSB0aGlzLmNoZWNrVGFnQWRkZWQoKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHcpKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmdzLnRhZ0FkZGVkID0gdztcclxuICAgICAgICAgICAgaGFzV2FybmluZ3MgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzV2FybmluZ3MgPyB3YXJuaW5ncyA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGlzIG1lc3NhZ2UgaXMgYW4gSUNVIG1lc3NhZ2UsIHJldHVybnMgaXRzIHN0cnVjdHVyZS5cclxuICAgICAqIE90aGVyd2lzZSB0aGlzIG1ldGhvZCByZXR1cm5zIG51bGwuXHJcbiAgICAgKiBAcmV0dXJuIElDVU1lc3NhZ2Ugb3IgbnVsbC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldElDVU1lc3NhZ2UoKTogSUlDVU1lc3NhZ2Uge1xyXG4gICAgICAgIGlmICh0aGlzLl9wYXJ0cy5sZW5ndGggPT09IDEgJiYgdGhpcy5fcGFydHNbMF0udHlwZSA9PT0gUGFyc2VkTWVzc2FnZVBhcnRUeXBlLklDVV9NRVNTQUdFKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGljdVBhcnQgPSA8UGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlPiB0aGlzLl9wYXJ0c1swXTtcclxuICAgICAgICAgICAgcmV0dXJuIGljdVBhcnQuZ2V0SUNVTWVzc2FnZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBmb3IgYWRkZWQgcGxhY2Vob2xkZXIuXHJcbiAgICAgKiBAcmV0dXJuIG51bGwgb3IgbWVzc2FnZSwgaWYgZnVsZmlsbGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoZWNrUGxhY2Vob2xkZXJBZGRlZCgpOiBhbnkge1xyXG4gICAgICAgIGxldCBlID0gbnVsbDtcclxuICAgICAgICBjb25zdCBzdXNwaWNpb3VzSW5kZXhlcyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZU1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlUGxhY2Vob2xkZXJzID0gdGhpcy5zb3VyY2VNZXNzYWdlLmFsbFBsYWNlaG9sZGVycygpO1xyXG4gICAgICAgICAgICBjb25zdCBteVBsYWNlaG9sZGVycyA9IHRoaXMuYWxsUGxhY2Vob2xkZXJzKCk7XHJcbiAgICAgICAgICAgIG15UGxhY2Vob2xkZXJzLmZvckVhY2goKGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZVBsYWNlaG9sZGVycy5oYXMoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGljaW91c0luZGV4ZXMucHVzaChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VzcGljaW91c0luZGV4ZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGUgPSAnYWRkZWQgcGxhY2Vob2xkZXIgJyArIHN1c3BpY2lvdXNJbmRleGVzWzBdICsgJywgd2hpY2ggaXMgbm90IGluIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3VzcGljaW91c0luZGV4ZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBsZXQgYWxsU3VzcGljaW91c0luZGV4ZXMgPSAnJztcclxuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3VzcGljaW91c0luZGV4ZXMuZm9yRWFjaCgoaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxTdXNwaWNpb3VzSW5kZXhlcyA9IGFsbFN1c3BpY2lvdXNJbmRleGVzICsgJywgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFsbFN1c3BpY2lvdXNJbmRleGVzID0gYWxsU3VzcGljaW91c0luZGV4ZXMgKyBpbmRleDtcclxuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBlID0gJ2FkZGVkIHBsYWNlaG9sZGVycyAnICsgYWxsU3VzcGljaW91c0luZGV4ZXMgKyAnLCB3aGljaCBhcmUgbm90IGluIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGZvciByZW1vdmVkIHBsYWNlaG9sZGVyLlxyXG4gICAgICogQHJldHVybiBudWxsIG9yIG1lc3NhZ2UsIGlmIGZ1bGZpbGxlZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja1BsYWNlaG9sZGVyUmVtb3ZlZCgpOiBhbnkge1xyXG4gICAgICAgIGxldCB3ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBzdXNwaWNpb3VzSW5kZXhlcyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZU1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlUGxhY2Vob2xkZXJzID0gdGhpcy5zb3VyY2VNZXNzYWdlLmFsbFBsYWNlaG9sZGVycygpO1xyXG4gICAgICAgICAgICBjb25zdCBteVBsYWNlaG9sZGVycyA9IHRoaXMuYWxsUGxhY2Vob2xkZXJzKCk7XHJcbiAgICAgICAgICAgIHNvdXJjZVBsYWNlaG9sZGVycy5mb3JFYWNoKChpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFteVBsYWNlaG9sZGVycy5oYXMoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGljaW91c0luZGV4ZXMucHVzaChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VzcGljaW91c0luZGV4ZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHcgPSAncmVtb3ZlZCBwbGFjZWhvbGRlciAnICsgc3VzcGljaW91c0luZGV4ZXNbMF0gKyAnIGZyb20gb3JpZ2luYWwgbWVzc2FnZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdXNwaWNpb3VzSW5kZXhlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGxldCBhbGxTdXNwaWNpb3VzSW5kZXhlcyA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdXNwaWNpb3VzSW5kZXhlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbFN1c3BpY2lvdXNJbmRleGVzID0gYWxsU3VzcGljaW91c0luZGV4ZXMgKyAnLCAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWxsU3VzcGljaW91c0luZGV4ZXMgPSBhbGxTdXNwaWNpb3VzSW5kZXhlcyArIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHcgPSAncmVtb3ZlZCBwbGFjZWhvbGRlcnMgJyArIGFsbFN1c3BpY2lvdXNJbmRleGVzICsgJyBmcm9tIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGZvciBhZGRlZCBJQ1UgTWVzc2FnZSBSZWZzLlxyXG4gICAgICogQHJldHVybiBudWxsIG9yIG1lc3NhZ2UsIGlmIGZ1bGZpbGxlZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja0lDVU1lc3NhZ2VSZWZBZGRlZCgpOiBhbnkge1xyXG4gICAgICAgIGxldCBlID0gbnVsbDtcclxuICAgICAgICBjb25zdCBzdXNwaWNpb3VzSW5kZXhlcyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZU1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlSUNVUmVmcyA9IHRoaXMuc291cmNlTWVzc2FnZS5hbGxJQ1VNZXNzYWdlUmVmcygpO1xyXG4gICAgICAgICAgICBjb25zdCBteUlDVVJlZnMgPSB0aGlzLmFsbElDVU1lc3NhZ2VSZWZzKCk7XHJcbiAgICAgICAgICAgIG15SUNVUmVmcy5mb3JFYWNoKChpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VJQ1VSZWZzLmhhcyhpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwaWNpb3VzSW5kZXhlcy5wdXNoKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdXNwaWNpb3VzSW5kZXhlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgZSA9ICdhZGRlZCBJQ1UgbWVzc2FnZSByZWZlcmVuY2UgJyArIHN1c3BpY2lvdXNJbmRleGVzWzBdICsgJywgd2hpY2ggaXMgbm90IGluIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3VzcGljaW91c0luZGV4ZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBsZXQgYWxsU3VzcGljaW91c0luZGV4ZXMgPSAnJztcclxuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3VzcGljaW91c0luZGV4ZXMuZm9yRWFjaCgoaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxTdXNwaWNpb3VzSW5kZXhlcyA9IGFsbFN1c3BpY2lvdXNJbmRleGVzICsgJywgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFsbFN1c3BpY2lvdXNJbmRleGVzID0gYWxsU3VzcGljaW91c0luZGV4ZXMgKyBpbmRleDtcclxuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBlID0gJ2FkZGVkIElDVSBtZXNzYWdlIHJlZmVyZW5jZXMgJyArIGFsbFN1c3BpY2lvdXNJbmRleGVzICsgJywgd2hpY2ggYXJlIG5vdCBpbiBvcmlnaW5hbCBtZXNzYWdlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBmb3IgcmVtb3ZlZCBJQ1UgTWVzc2FnZSBSZWZzLlxyXG4gICAgICogQHJldHVybiBudWxsIG9yIG1lc3NhZ2UsIGlmIGZ1bGZpbGxlZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja0lDVU1lc3NhZ2VSZWZSZW1vdmVkKCk6IGFueSB7XHJcbiAgICAgICAgbGV0IGUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHN1c3BpY2lvdXNJbmRleGVzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlTWVzc2FnZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VJQ1VSZWZzID0gdGhpcy5zb3VyY2VNZXNzYWdlLmFsbElDVU1lc3NhZ2VSZWZzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG15SUNVUmVmcyA9IHRoaXMuYWxsSUNVTWVzc2FnZVJlZnMoKTtcclxuICAgICAgICAgICAgc291cmNlSUNVUmVmcy5mb3JFYWNoKChpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFteUlDVVJlZnMuaGFzKGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BpY2lvdXNJbmRleGVzLnB1c2goaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1c3BpY2lvdXNJbmRleGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBlID0gJ3JlbW92ZWQgSUNVIG1lc3NhZ2UgcmVmZXJlbmNlICcgKyBzdXNwaWNpb3VzSW5kZXhlc1swXSArICcgZnJvbSBvcmlnaW5hbCBtZXNzYWdlJztcclxuICAgICAgICB9IGVsc2UgaWYgKHN1c3BpY2lvdXNJbmRleGVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgbGV0IGFsbFN1c3BpY2lvdXNJbmRleGVzID0gJyc7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHN1c3BpY2lvdXNJbmRleGVzLmZvckVhY2goKGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsU3VzcGljaW91c0luZGV4ZXMgPSBhbGxTdXNwaWNpb3VzSW5kZXhlcyArICcsICc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbGxTdXNwaWNpb3VzSW5kZXhlcyA9IGFsbFN1c3BpY2lvdXNJbmRleGVzICsgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZSA9ICdyZW1vdmVkIElDVSBtZXNzYWdlIHJlZmVyZW5jZXMgJyArIGFsbFN1c3BpY2lvdXNJbmRleGVzICsgJyBmcm9tIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgaW5kZXhlcyBvZiBwbGFjZWhvbGRlcnMgdXNlZCBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhbGxQbGFjZWhvbGRlcnMoKTogU2V0PG51bWJlcj4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8bnVtYmVyPigpO1xyXG4gICAgICAgIHRoaXMucGFydHMoKS5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5QTEFDRUhPTERFUikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSAoPFBhcnNlZE1lc3NhZ2VQYXJ0UGxhY2Vob2xkZXI+IHBhcnQpLmluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGRpc3AtQXR0cmlidXRlIG9mIHBsYWNlaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggaW5kZXggb2YgcGxhY2Vob2xkZXJcclxuICAgICAqIEByZXR1cm4gZGlzcCBvciBudWxsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQbGFjZWhvbGRlckRpc3AoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHBsYWNlSG9sZGVyOiBQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcnRzKCkuZm9yRWFjaCgocGFydCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuUExBQ0VIT0xERVIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBoUGFydDogUGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlciA9IDxQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyPiBwYXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHBoUGFydC5pbmRleCgpID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlSG9sZGVyID0gcGhQYXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBsYWNlSG9sZGVyID8gcGxhY2VIb2xkZXIuZGlzcCgpIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgaW5kZXhlcyBvZiBJQ1UgbWVzc2FnZSByZWZzIHVzZWQgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYWxsSUNVTWVzc2FnZVJlZnMoKTogU2V0PG51bWJlcj4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8bnVtYmVyPigpO1xyXG4gICAgICAgIHRoaXMucGFydHMoKS5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5JQ1VfTUVTU0FHRV9SRUYpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gKDxQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWY+IHBhcnQpLmluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGRpc3AtQXR0cmlidXRlIG9mIGljdSBtZXNzYWdlIHJlZlxyXG4gICAgICogQHBhcmFtIGluZGV4IG9mIHJlZlxyXG4gICAgICogQHJldHVybiBkaXNwIG9yIG51bGxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldElDVU1lc3NhZ2VSZWZEaXNwKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBpY3VNZXNzYWdlUmVmUGFydDogUGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlUmVmID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcnRzKCkuZm9yRWFjaCgocGFydCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuSUNVX01FU1NBR0VfUkVGKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWZQYXJ0OiBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWYgPSA8UGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlUmVmPiBwYXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZlBhcnQuaW5kZXgoKSA9PT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpY3VNZXNzYWdlUmVmUGFydCA9IHJlZlBhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaWN1TWVzc2FnZVJlZlBhcnQgPyBpY3VNZXNzYWdlUmVmUGFydC5kaXNwKCkgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgZm9yIGFkZGVkIHRhZ3MuXHJcbiAgICAgKiBAcmV0dXJuIG51bGwgb3IgbWVzc2FnZSwgaWYgZnVsZmlsbGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoZWNrVGFnQWRkZWQoKTogYW55IHtcclxuICAgICAgICBsZXQgZSA9IG51bGw7XHJcbiAgICAgICAgY29uc3Qgc3VzcGljaW91c1RhZ3MgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5zb3VyY2VNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVRhZ3MgPSB0aGlzLnNvdXJjZU1lc3NhZ2UuYWxsVGFncygpO1xyXG4gICAgICAgICAgICBjb25zdCBteVRhZ3MgPSB0aGlzLmFsbFRhZ3MoKTtcclxuICAgICAgICAgICAgbXlUYWdzLmZvckVhY2goKHRhZ05hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghc291cmNlVGFncy5oYXModGFnTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwaWNpb3VzVGFncy5wdXNoKHRhZ05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1c3BpY2lvdXNUYWdzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBlID0gJ2FkZGVkIHRhZyA8JyArIHN1c3BpY2lvdXNUYWdzWzBdICsgJz4sIHdoaWNoIGlzIG5vdCBpbiBvcmlnaW5hbCBtZXNzYWdlJztcclxuICAgICAgICB9IGVsc2UgaWYgKHN1c3BpY2lvdXNUYWdzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgbGV0IGFsbFN1c3BpY2lvdXNUYWdzID0gJyc7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHN1c3BpY2lvdXNUYWdzLmZvckVhY2goKHRhZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbFN1c3BpY2lvdXNUYWdzID0gYWxsU3VzcGljaW91c1RhZ3MgKyAnLCAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWxsU3VzcGljaW91c1RhZ3MgPSBhbGxTdXNwaWNpb3VzVGFncyArICc8JyArIHRhZyArICc+JztcclxuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBlID0gJ2FkZGVkIHRhZ3MgJyArIGFsbFN1c3BpY2lvdXNUYWdzICsgJywgd2hpY2ggYXJlIG5vdCBpbiBvcmlnaW5hbCBtZXNzYWdlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBmb3IgcmVtb3ZlZCB0YWdzLlxyXG4gICAgICogQHJldHVybiBudWxsIG9yIG1lc3NhZ2UsIGlmIGZ1bGZpbGxlZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja1RhZ1JlbW92ZWQoKTogYW55IHtcclxuICAgICAgICBsZXQgdyA9IG51bGw7XHJcbiAgICAgICAgY29uc3Qgc3VzcGljaW91c1RhZ3MgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5zb3VyY2VNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVRhZ3MgPSB0aGlzLnNvdXJjZU1lc3NhZ2UuYWxsVGFncygpO1xyXG4gICAgICAgICAgICBjb25zdCBteVRhZ3MgPSB0aGlzLmFsbFRhZ3MoKTtcclxuICAgICAgICAgICAgc291cmNlVGFncy5mb3JFYWNoKCh0YWdOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW15VGFncy5oYXModGFnTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwaWNpb3VzVGFncy5wdXNoKHRhZ05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1c3BpY2lvdXNUYWdzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICB3ID0gJ3JlbW92ZWQgdGFnIDwnICsgc3VzcGljaW91c1RhZ3NbMF0gKyAnPiBmcm9tIG9yaWdpbmFsIG1lc3NhZ2UnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3VzcGljaW91c1RhZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBsZXQgYWxsU3VzcGljaW91c1RhZ3MgPSAnJztcclxuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3VzcGljaW91c1RhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsU3VzcGljaW91c1RhZ3MgPSBhbGxTdXNwaWNpb3VzVGFncyArICcsICc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbGxTdXNwaWNpb3VzVGFncyA9IGFsbFN1c3BpY2lvdXNUYWdzICsgJzwnICsgdGFnICsgJz4nO1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHcgPSAncmVtb3ZlZCB0YWdzICcgKyBhbGxTdXNwaWNpb3VzVGFncyArICcgZnJvbSBvcmlnaW5hbCBtZXNzYWdlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIHRhZyBuYW1lcyB1c2VkIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFsbFRhZ3MoKTogU2V0PHN0cmluZz4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gICAgICAgIHRoaXMucGFydHMoKS5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5TVEFSVF9UQUcgfHwgcGFydC50eXBlID09PSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuRU1QVFlfVEFHKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gKDxQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnPiBwYXJ0KS50YWdOYW1lKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkKHRhZ05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcGFydHMoKTogUGFyc2VkTWVzc2FnZVBhcnRbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFhtbFJlcHJlc2VudGF0aW9uKHhtbFJlcHJlc2VudGF0aW9uOiBFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5feG1sUmVwcmVzZW50YXRpb24gPSB4bWxSZXByZXNlbnRhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBhZGRUZXh0KHRleHQ6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3BhcnRzLnB1c2gobmV3IFBhcnNlZE1lc3NhZ2VQYXJ0VGV4dCh0ZXh0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUGxhY2Vob2xkZXIoaW5kZXg6IG51bWJlciwgZGlzcDogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fcGFydHMucHVzaChuZXcgUGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlcihpbmRleCwgZGlzcCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFN0YXJ0VGFnKHRhZ25hbWU6IHN0cmluZywgaWRjb3VudGVyOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9wYXJ0cy5wdXNoKG5ldyBQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnKHRhZ25hbWUsIGlkY291bnRlcikpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEVuZFRhZyh0YWduYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBjaGVjayBpZiB3ZWxsIGZvcm1lZFxyXG4gICAgICAgIGNvbnN0IG9wZW5UYWcgPSB0aGlzLmNhbGN1bGF0ZU9wZW5UYWdOYW1lKCk7XHJcbiAgICAgICAgaWYgKCFvcGVuVGFnIHx8IG9wZW5UYWcgIT09IHRhZ25hbWUpIHtcclxuICAgICAgICAgICAgLy8gb29wcywgbm90IHdlbGwgZm9ybWVkXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ3VuZXhwZWN0ZWQgY2xvc2UgdGFnICVzIChjdXJyZW50bHkgb3BlbiBpcyAlcywgbmF0aXZlIHhtbCBpcyBcIiVzXCIpJyxcclxuICAgICAgICAgICAgICAgIHRhZ25hbWUsIG9wZW5UYWcsIHRoaXMuYXNOYXRpdmVTdHJpbmcoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wYXJ0cy5wdXNoKG5ldyBQYXJzZWRNZXNzYWdlUGFydEVuZFRhZyh0YWduYW1lKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRW1wdHlUYWcodGFnbmFtZTogc3RyaW5nLCBpZGNvdW50ZXI6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX3BhcnRzLnB1c2gobmV3IFBhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWcodGFnbmFtZSwgaWRjb3VudGVyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkSUNVTWVzc2FnZVJlZihpbmRleDogbnVtYmVyLCBkaXNwKSB7XHJcbiAgICAgICAgdGhpcy5fcGFydHMucHVzaChuZXcgUGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlUmVmKGluZGV4LCBkaXNwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkSUNVTWVzc2FnZSh0ZXh0OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9wYXJ0cy5wdXNoKG5ldyBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2UodGV4dCwgdGhpcy5fcGFyc2VyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmUsIHdldGhlciB0aGVyZSBpcyBhbiBvcGVuIHRhZywgdGhhdCBpcyBub3QgY2xvc2VkLlxyXG4gICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IG9uZSBvciBudWxsLCBpZiB0aGVyZSBpcyBubyBvcGVuIHRhZy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVPcGVuVGFnTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG9wZW5UYWdzID0gW107XHJcbiAgICAgICAgdGhpcy5fcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuU1RBUlRfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5UYWdzLnB1c2goKDxQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnPiBwYXJ0KS50YWdOYW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuRU5EX1RBRzpcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gKDxQYXJzZWRNZXNzYWdlUGFydEVuZFRhZz4gcGFydCkudGFnTmFtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuVGFncy5sZW5ndGggPT09IDAgfHwgb3BlblRhZ3Nbb3BlblRhZ3MubGVuZ3RoIC0gMV0gIT09IHRhZ05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb29wcywgbm90IHdlbGwgZm9ybWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZW5UYWcgPSAob3BlblRhZ3MubGVuZ3RoID09PSAwKSA/ICdub3RoaW5nJyA6IG9wZW5UYWdzW29wZW5UYWdzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCd1bmV4cGVjdGVkIGNsb3NlIHRhZyAlcyAoY3VycmVudGx5IG9wZW4gaXMgJXMsIG5hdGl2ZSB4bWwgaXMgXCIlc1wiKScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lLCBvcGVuVGFnLCB0aGlzLmFzTmF0aXZlU3RyaW5nKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlblRhZ3MucG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gb3BlblRhZ3MubGVuZ3RoID09PSAwID8gbnVsbCA6IG9wZW5UYWdzW29wZW5UYWdzLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIFRva2VuaXpyIGZyb20gJ3Rva2VuaXpyJztcclxuaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZH0gZnJvbSAndXRpbCc7XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTQuMDUuMjAxNy5cclxuICogQSB0b2tlbml6ZXIgZm9yIG5vcm1hbGl6ZWQgbWVzc2FnZXMuXHJcbiAqL1xyXG5cclxuLy8gVG9rZW5zXHJcbmV4cG9ydCBjb25zdCBURVhUID0gJ1RFWFQnO1xyXG5leHBvcnQgY29uc3QgU1RBUlRfVEFHID0gJ1NUQVJUX1RBRyc7XHJcbmV4cG9ydCBjb25zdCBFTkRfVEFHID0gJ0VORF9UQUcnO1xyXG5leHBvcnQgY29uc3QgRU1QVFlfVEFHID0gJ0VNUFRZX1RBRyc7XHJcbmV4cG9ydCBjb25zdCBQTEFDRUhPTERFUiA9ICdQTEFDRUhPTERFUic7XHJcbmV4cG9ydCBjb25zdCBJQ1VfTUVTU0FHRV9SRUYgPSAnSUNVX01FU1NBR0VfUkVGJztcclxuZXhwb3J0IGNvbnN0IElDVV9NRVNTQUdFID0gJ0lDVV9NRVNTQUdFJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW4ge1xyXG4gICAgdHlwZTogc3RyaW5nO1xyXG4gICAgdmFsdWU6IGFueTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFBhcnNlZE1lc2FnZVRva2VuaXplciB7XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRMZXhlcigpOiBUb2tlbml6ciB7XHJcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgVG9rZW5penIoKTtcclxuICAgICAgICBsZXQgcGxhaW50ZXh0ID0gJyc7XHJcbiAgICAgICAgbGV4ZXIuYmVmb3JlKChjdHgsIG1hdGNoLCBydWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChydWxlLm5hbWUgIT09IFRFWFQgJiYgcGxhaW50ZXh0ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgY3R4LmFjY2VwdChURVhULCB7dGV4dDogcGxhaW50ZXh0fSk7XHJcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxleGVyLmZpbmlzaCgoY3R4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwbGFpbnRleHQgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguYWNjZXB0KFRFWFQsIHt0ZXh0OiBwbGFpbnRleHR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9KTtcclxuICAgICAgICAvLyBlbXB0eSB0YWcsIHRoZXJlIGFyZSBvbmx5IGEgZmV3IGFsbG93ZWQgKHNlZSB0YWctbWFwcGluZ3MpOiBbJ0JSJywgJ0hSJywgJ0lNRycsICdBUkVBJywgJ0xJTksnLCAnV0JSJ11cclxuICAgICAgICAvLyBmb3JtYXQgaXMgPG5hbWUgaWQ9XCJuclwiPiwgbnIgaXN0IG9wdGlvbmFsLCB6LkIuIDxpbWc+IG9kZXIgPGltZyBpZD1cIjJcIj5cclxuICAgICAgICBsZXhlci5ydWxlKC88KGJyfGhyfGltZ3xhcmVhfGxpbmt8d2JyKSggaWQ9XCIoWzAtOV0pKlwiKT9cXD4vLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZGNvdW50ID0gaXNOdWxsT3JVbmRlZmluZWQobWF0Y2hbM10pID8gMCA6IHBhcnNlSW50KG1hdGNoWzNdLCAxMCk7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoRU1QVFlfVEFHLCB7bmFtZTogbWF0Y2hbMV0sIGlkY291bnRlcjogaWRjb3VudH0pO1xyXG4gICAgICAgIH0sIEVNUFRZX1RBRyk7XHJcbiAgICAgICAgLy8gc3RhcnQgdGFnLCBGb3JtYXQgPG5hbWUgaWQ9XCJuclwiPiwgbnIgaXN0IG9wdGlvbmFsLCB6LkIuIDxteXRhZz4gb2RlciA8bXl0YWcgaWQ9XCIyXCI+XHJcbiAgICAgICAgbGV4ZXIucnVsZSgvPChbYS16QS1aXVthLXpBLVotMC05XSopKCBpZD1cIihbMC05XSopXCIpPz4vLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZGNvdW50ID0gaXNOdWxsT3JVbmRlZmluZWQobWF0Y2hbM10pID8gMCA6IHBhcnNlSW50KG1hdGNoWzNdLCAxMCk7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoU1RBUlRfVEFHLCB7bmFtZTogbWF0Y2hbMV0sIGlkY291bnRlcjogaWRjb3VudH0pO1xyXG4gICAgICAgIH0sIFNUQVJUX1RBRyk7XHJcbiAgICAgICAgLy8gZW5kIHRhZ1xyXG4gICAgICAgIGxleGVyLnJ1bGUoLzxcXC8oW2EtekEtWl1bYS16QS1aLTAtOV0qKT4vLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBjdHguYWNjZXB0KEVORF9UQUcsIHtuYW1lOiBtYXRjaFsxXX0pO1xyXG4gICAgICAgIH0sIEVORF9UQUcpO1xyXG4gICAgICAgIC8vIHBsYWNlaG9sZGVyXHJcbiAgICAgICAgbGV4ZXIucnVsZSgve3soWzAtOV0rKX19LywgKGN0eCwgbWF0Y2gpID0+IHtcclxuICAgICAgICAgICAgY3R4LmFjY2VwdChQTEFDRUhPTERFUiwge2lkY291bnRlcjogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKX0pO1xyXG4gICAgICAgIH0sIFBMQUNFSE9MREVSKTtcclxuICAgICAgICAvLyBpY3UgbWVzc2FnZSByZWZcclxuICAgICAgICBsZXhlci5ydWxlKC88SUNVLU1lc3NhZ2UtUmVmXyhbMC05XSspXFwvPi8sIChjdHgsIG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgIGN0eC5hY2NlcHQoSUNVX01FU1NBR0VfUkVGLCB7aWRjb3VudGVyOiBwYXJzZUludChtYXRjaFsxXSwgMTApfSk7XHJcbiAgICAgICAgfSwgSUNVX01FU1NBR0VfUkVGKTtcclxuICAgICAgICAvLyBpY3UgbWVzc2FnZVxyXG4gICAgICAgIGxleGVyLnJ1bGUoLzxJQ1UtTWVzc2FnZVxcLz4vLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBjdHguYWNjZXB0KElDVV9NRVNTQUdFLCB7bWVzc2FnZTogbWF0Y2hbMF19KTtcclxuICAgICAgICB9LCBJQ1VfTUVTU0FHRSk7XHJcbiAgICAgICAgLy8gdGV4dFxyXG4gICAgICAgIGxleGVyLnJ1bGUoLy4vLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBwbGFpbnRleHQgKz0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIGN0eC5pZ25vcmUoKTtcclxuICAgICAgICB9LCBURVhUKTtcclxuICAgICAgICBsZXhlci5ydWxlKC9bXFx0XFxyXFxuXSsvLCAoY3R4LCBtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBwbGFpbnRleHQgKz0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIGN0eC5pZ25vcmUoKTtcclxuICAgICAgICB9LCBURVhUKTtcclxuICAgICAgICByZXR1cm4gbGV4ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgdG9rZW5pemUobm9ybWFsaXplZE1lc3NhZ2U6IHN0cmluZyk6IFRva2VuW10ge1xyXG4gICAgICAgIGNvbnN0IGxleGVyOiBUb2tlbml6ciA9IHRoaXMuZ2V0TGV4ZXIoKTtcclxuICAgICAgICBsZXhlci5yZXNldCgpO1xyXG4gICAgICAgIGxleGVyLmlucHV0KG5vcm1hbGl6ZWRNZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gbGV4ZXIudG9rZW5zKCk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7UGFyc2VkTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7XHJcbiAgICBFTVBUWV9UQUcsXHJcbiAgICBFTkRfVEFHLCBJQ1VfTUVTU0FHRSwgSUNVX01FU1NBR0VfUkVGLCBQYXJzZWRNZXNhZ2VUb2tlbml6ZXIsIFBMQUNFSE9MREVSLCBTVEFSVF9UQUcsIFRFWFQsXHJcbiAgICBUb2tlblxyXG59IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtdG9rZW5pemVyJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFRleHR9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC10ZXh0JztcclxuaW1wb3J0IHtET01QYXJzZXJ9IGZyb20gJ3htbGRvbSc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZ30gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXN0YXJ0LXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlcn0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXBsYWNlaG9sZGVyJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydEVuZFRhZ30gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LWVuZC10YWcnO1xyXG5pbXBvcnQge0lNZXNzYWdlUGFyc2VyfSBmcm9tICcuL2ktbWVzc2FnZS1wYXJzZXInO1xyXG5pbXBvcnQge2Zvcm1hdCwgaXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0RPTVV0aWxpdGllc30gZnJvbSAnLi9kb20tdXRpbGl0aWVzJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydEVtcHR5VGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW1wdHktdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWZ9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1pY3UtbWVzc2FnZS1yZWYnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LWljdS1tZXNzYWdlJztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMTAuMDUuMjAxNy5cclxuICogQSBtZXNzYWdlIHBhcnNlciBjYW4gcGFyc2UgdGhlIHhtbCBjb250ZW50IG9mIGEgdHJhbnNsYXRhYmxlIG1lc3NhZ2UuXHJcbiAqIEl0IGdlbmVyYXRlcyBhIFBhcnNlZE1lc3NhZ2UgZnJvbSBpdC5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdE1lc3NhZ2VQYXJzZXIgaW1wbGVtZW50cyBJTWVzc2FnZVBhcnNlciB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBYTUwgdG8gUGFyc2VkTWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSB4bWxFbGVtZW50IHRoZSB4bWwgcmVwcmVzZW50YXRpb25cclxuICAgICAqIEBwYXJhbSBzb3VyY2VNZXNzYWdlIG9wdGlvbmFsIG9yaWdpbmFsIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIHRyYW5zbGF0ZWQgYnkgbm9ybWFsaXplZCBuZXcgb25lXHJcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm9ybWFsaXplZCB4bWwgaXMgbm90IHdlbGwgZm9ybWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlTm9ybWFsaXplZE1lc3NhZ2VGcm9tWE1MKHhtbEVsZW1lbnQ6IEVsZW1lbnQsIHNvdXJjZU1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlOiBQYXJzZWRNZXNzYWdlID0gbmV3IFBhcnNlZE1lc3NhZ2UodGhpcywgc291cmNlTWVzc2FnZSk7XHJcbiAgICAgICAgaWYgKHhtbEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgbWVzc2FnZS5zZXRYbWxSZXByZXNlbnRhdGlvbih4bWxFbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5hZGRQYXJ0c09mTm9kZVRvTWVzc2FnZSh4bWxFbGVtZW50LCBtZXNzYWdlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgWE1MIHN0cmluZyB0byBQYXJzZWRNZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHhtbFN0cmluZyB0aGUgeG1sIHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgcm9vdCBlbGVtZW50LCBlLmcuIHRoaXMgaXMgPHBoIHg+PC9waD4gYW4gZXhhbXBsZS5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VNZXNzYWdlIG9wdGlvbmFsIG9yaWdpbmFsIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIHRyYW5zbGF0ZWQgYnkgbm9ybWFsaXplZCBuZXcgb25lXHJcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm9ybWFsaXplZCB4bWwgaXMgbm90IHdlbGwgZm9ybWVkLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUxTdHJpbmcoeG1sU3RyaW5nOiBzdHJpbmcsIHNvdXJjZU1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCBkb2M6IERvY3VtZW50ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZygnPGR1bW15PicgKyB4bWxTdHJpbmcgKyAnPC9kdW1teT4nLCAndGV4dC94bWwnKTtcclxuICAgICAgICBjb25zdCB4bWxFbGVtZW50OiBFbGVtZW50ID0gPEVsZW1lbnQ+IGRvYy5jaGlsZE5vZGVzLml0ZW0oMCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTm9ybWFsaXplZE1lc3NhZ2VGcm9tWE1MKHhtbEVsZW1lbnQsIHNvdXJjZU1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVjdXJzaXZlbHkgcnVuIHRocm91Z2ggYSBub2RlIGFuZCBhZGQgYWxsIGlkZW50aWZpZWQgcGFydHMgdG8gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBub2RlXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlIHRvIGJlIGdlbmVyYXRlZC5cclxuICAgICAqIEBwYXJhbSBpbmNsdWRlU2VsZiBpZiB0cnVlLCBhZGQgbm9kZSBieSBpdHNlbGYsIG90aGVyd2lzZSBvbmx5IGNoaWxkcmVuLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFkZFBhcnRzT2ZOb2RlVG9NZXNzYWdlKG5vZGU6IE5vZGUsIG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UsIGluY2x1ZGVTZWxmOiBib29sZWFuKSB7XHJcbiAgICAgICAgbGV0IHByb2Nlc3NDaGlsZHJlbiA9IHRydWU7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVTZWxmKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLlRFWFRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRUZXh0KG5vZGUudGV4dENvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NoaWxkcmVuID0gdGhpcy5wcm9jZXNzU3RhcnRFbGVtZW50KDxFbGVtZW50PiBub2RlLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvY2Vzc0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGljdU1lc3NhZ2VUZXh0ID0gdGhpcy5nZXRJQ1VNZXNzYWdlVGV4dChub2RlKTtcclxuICAgICAgICAgICAgbGV0IGlzSUNVID0gIWlzTnVsbE9yVW5kZWZpbmVkKGljdU1lc3NhZ2VUZXh0KTtcclxuICAgICAgICAgICAgaWYgKGlzSUNVKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkSUNVTWVzc2FnZShpY3VNZXNzYWdlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIG5vdCBwYXJzYWJsZSwgaGFuZGxlIGl0IGFzIG5vbiBJQ1VcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbm9uIElDVSBtZXNzYWdlOiAnLCBpY3VNZXNzYWdlVGV4dCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzSUNVID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0lDVSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXJ0c09mTm9kZVRvTWVzc2FnZShjaGlsZHJlbi5pdGVtKGkpLCBtZXNzYWdlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRW5kRWxlbWVudCg8RWxlbWVudD4gbm9kZSwgbWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBJQ1UgbWVzc2FnZSBjb250ZW50IG9mIHRoZSBub2RlLCBpZiBpdCBpcyBhbiBJQ1UgTWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBub2RlIG5vZGVcclxuICAgICAqIEByZXR1cm4gbWVzc2FnZSBvciBudWxsLCBpZiBpdCBpcyBubyBJQ1UgTWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGdldElDVU1lc3NhZ2VUZXh0KG5vZGU6IE5vZGUpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBjaGlsZHJlbi5pdGVtKDApO1xyXG4gICAgICAgIGlmIChmaXJzdENoaWxkLm5vZGVUeXBlID09PSBmaXJzdENoaWxkLlRFWFRfTk9ERSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lDVU1lc3NhZ2VTdGFydChmaXJzdENoaWxkLnRleHRDb250ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERPTVV0aWxpdGllcy5nZXRYTUxDb250ZW50KDxFbGVtZW50PiBub2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHRleHQgaXMgYmVnaW5uaW5nIG9mIElDVSBNZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHRleHQgdGV4dFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJQ1VNZXNzYWdlU3RhcnQodGV4dDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZS5sb29rc0xpa2VJQ1VNZXNzYWdlKHRleHQpO1xyXG4vLyAgICAgICAgcmV0dXJuIHRleHQuc3RhcnRzV2l0aCgne1ZBUl9QTFVSQUwnKSB8fCB0ZXh0LnN0YXJ0c1dpdGgoJ3tWQVJfU0VMRUNUJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdGhpcyBub2RlLlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSBjaGlsZHJlbiBhcmUgZG9uZS5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50Tm9kZSBlbGVtZW50Tm9kZVxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZSB0byBiZSBhbHRlcmVkXHJcbiAgICAgKiBAcmV0dXJuIHRydWUsIGlmIGNoaWxkcmVuIHNob3VsZCBiZSBwcm9jZXNzZWQgdG9vLCBmYWxzZSBvdGhlcndpc2UgKGNoaWxkcmVuIGlnbm9yZWQgdGhlbilcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHByb2Nlc3NTdGFydEVsZW1lbnQoZWxlbWVudE5vZGU6IEVsZW1lbnQsIG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGVuZCBvZiB0aGlzIG5vZGUuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciBhbGwgY2hpbGRyZW4gYXJlIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50Tm9kZSBlbGVtZW50Tm9kZVxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZSB0byBiZSBhbHRlcmVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBwcm9jZXNzRW5kRWxlbWVudChlbGVtZW50Tm9kZTogRWxlbWVudCwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBub3JtYWxpemVkIHN0cmluZyB0byBQYXJzZWRNZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIG5vcm1hbGl6ZWRTdHJpbmcgbm9ybWFsaXplZCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBzb3VyY2VNZXNzYWdlIG9wdGlvbmFsIG9yaWdpbmFsIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIHRyYW5zbGF0ZWQgYnkgbm9ybWFsaXplZCBuZXcgb25lXHJcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHBhcnNlZCBtZXNzYWdlLlxyXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIG5vcm1hbGl6ZWQgc3RyaW5nIGlzIG5vdCB3ZWxsIGZvcm1lZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHBhcnNlTm9ybWFsaXplZFN0cmluZyhub3JtYWxpemVkU3RyaW5nOiBzdHJpbmcsIHNvdXJjZU1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlOiBQYXJzZWRNZXNzYWdlID0gbmV3IFBhcnNlZE1lc3NhZ2UodGhpcywgc291cmNlTWVzc2FnZSk7XHJcbiAgICAgICAgY29uc3Qgb3BlblRhZ3MgPSBbXTtcclxuICAgICAgICBsZXQgdG9rZW5zOiBUb2tlbltdO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRva2VucyA9IG5ldyBQYXJzZWRNZXNhZ2VUb2tlbml6ZXIoKS50b2tlbml6ZShub3JtYWxpemVkU3RyaW5nKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCd1bmV4cGVjdGVkIGVycm9yIHdoaWxlIHBhcnNpbmcgbWVzc2FnZTogXCIlc1wiIChwYXJzZWQgXCIlXCIpJywgZXJyb3IubWVzc2FnZSwgbm9ybWFsaXplZFN0cmluZykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b2tlbnMuZm9yRWFjaCgodG9rZW46IFRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkaXNwOiBzdHJpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgVEVYVDpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZFRleHQodG9rZW4udmFsdWUudGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFNUQVJUX1RBRzpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZFN0YXJ0VGFnKHRva2VuLnZhbHVlLm5hbWUsIHRva2VuLnZhbHVlLmlkY291bnRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlblRhZ3MucHVzaCh0b2tlbi52YWx1ZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRU5EX1RBRzpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZEVuZFRhZyh0b2tlbi52YWx1ZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BlblRhZ3MubGVuZ3RoID09PSAwIHx8IG9wZW5UYWdzW29wZW5UYWdzLmxlbmd0aCAtIDFdICE9PSB0b2tlbi52YWx1ZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9vcHMsIG5vdCB3ZWxsIGZvcm1lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCd1bmV4cGVjdGVkIGNsb3NlIHRhZyBcIiVzXCIgKHBhcnNlZCBcIiVzXCIpJywgdG9rZW4udmFsdWUubmFtZSwgbm9ybWFsaXplZFN0cmluZykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvcGVuVGFncy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRU1QVFlfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkRW1wdHlUYWcodG9rZW4udmFsdWUubmFtZSwgdG9rZW4udmFsdWUuaWRjb3VudGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUExBQ0VIT0xERVI6XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcCA9IChzb3VyY2VNZXNzYWdlKSA/IHNvdXJjZU1lc3NhZ2UuZ2V0UGxhY2Vob2xkZXJEaXNwKHRva2VuLnZhbHVlLmlkY291bnRlcikgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkUGxhY2Vob2xkZXIodG9rZW4udmFsdWUuaWRjb3VudGVyLCBkaXNwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgSUNVX01FU1NBR0VfUkVGOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3AgPSAoc291cmNlTWVzc2FnZSkgPyBzb3VyY2VNZXNzYWdlLmdldElDVU1lc3NhZ2VSZWZEaXNwKHRva2VuLnZhbHVlLmlkY291bnRlcikgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkSUNVTWVzc2FnZVJlZih0b2tlbi52YWx1ZS5pZGNvdW50ZXIsIGRpc3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBJQ1VfTUVTU0FHRTpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCc8SUNVTWVzc2FnZS8+IG5vdCBhbGxvd2VkIGhlcmUsIHVzZSBwYXJzZUlDVU1lc3NhZ2UgaW5zdGVhZCAocGFyc2VkIFwiJVwiKScsIG5vcm1hbGl6ZWRTdHJpbmcpKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAob3BlblRhZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBvb3BzLCBub3Qgd2VsbCBjbG9zZWQgdGFnc1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdtaXNzaW5nIGNsb3NlIHRhZyBcIiVzXCIgKHBhcnNlZCBcIiVzXCIpJywgb3BlblRhZ3Nbb3BlblRhZ3MubGVuZ3RoIC0gMV0sIG5vcm1hbGl6ZWRTdHJpbmcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVzc2FnZS5zZXRYbWxSZXByZXNlbnRhdGlvbih0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uKG1lc3NhZ2UpKTtcclxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGEgc3RyaW5nLCB0aGF0IGlzIGFuIElDVSBtZXNzYWdlLCB0byBQYXJzZWRNZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIGljdU1lc3NhZ2VTdHJpbmcgdGhlIG1lc3NhZ2UsIGxpa2UgJ3t4LCBwbHVyYWwsID0wIHtub3RoaW5nfSA9MSB7b25lfSBvdGhlciB7bWFueX19Jy5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VNZXNzYWdlIG9wdGlvbmFsIG9yaWdpbmFsIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIHRyYW5zbGF0ZWQgYnkgbm9ybWFsaXplZCBuZXcgb25lXHJcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHBhcnNlZCBtZXNzYWdlLlxyXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIGljdU1lc3NhZ2VTdHJpbmcgaGFzIG5vdCB0aGUgY29ycmVjdCBzeW50YXguXHJcbiAgICAgKi9cclxuICAgIHBhcnNlSUNVTWVzc2FnZShpY3VNZXNzYWdlU3RyaW5nOiBzdHJpbmcsIHNvdXJjZU1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlOiBQYXJzZWRNZXNzYWdlID0gbmV3IFBhcnNlZE1lc3NhZ2UodGhpcywgc291cmNlTWVzc2FnZSk7XHJcbiAgICAgICAgbWVzc2FnZS5hZGRJQ1VNZXNzYWdlKGljdU1lc3NhZ2VTdHJpbmcpO1xyXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uOiBQYXJzZSBJRCBmcm9tIGEgbmFtZS5cclxuICAgICAqIG5hbWUgb3B0aW9uYWxseSBlbmRzIHdpdGggXzxudW1iZXI+LiBUaGlzIGlzIHRoZSBpZGNvdW50LlxyXG4gICAgICogRS5nLiBuYW1lPVwiVEFHX0lNR1wiIHJldHVybnMgMFxyXG4gICAgICogbmFtZSA9IFwiVEFHX0lNR18xXCIgcmV0dXJucyAxXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIGlkIGNvdW50XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwYXJzZUlkQ291bnRGcm9tTmFtZShuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gLy4qXyhbMC05XSopLztcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWMobmFtZSk7XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG1hdGNoKSB8fCBtYXRjaFsxXSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbnVtID0gbWF0Y2hbMV07XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW0sIDEwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGhlIG5hdGl2ZSB4bWwgZm9yIGEgbWVzc2FnZS5cclxuICAgICAqIFBhcnRzIGFyZSBhbHJlYWR5IHNldCBoZXJlLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb24obWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IEVsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0IHJvb3Q6IERvY3VtZW50ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZygnPGR1bW15Lz4nLCAndGV4dC94bWwnKTtcclxuICAgICAgICBjb25zdCByb290RWxlbTogRWxlbWVudCA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2R1bW15JykuaXRlbSgwKTtcclxuICAgICAgICB0aGlzLmFkZFhtbFJlcHJlc2VudGF0aW9uVG9Sb290KG1lc3NhZ2UsIHJvb3RFbGVtKTtcclxuICAgICAgICByZXR1cm4gcm9vdEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGFkZFhtbFJlcHJlc2VudGF0aW9uVG9Sb290KG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UsIHJvb3RFbGVtOiBFbGVtZW50KTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlRleHRQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0VGV4dCwgcm9vdEVsZW06IEVsZW1lbnQpOiBOb2RlIHtcclxuICAgICAgICByZXR1cm4gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXJ0LmFzRGlzcGxheVN0cmluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3Igc3RhcnQgdGFnIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKiBAcGFyYW0gaWQgaWQgbnVtYmVyIGluIHhsaWZmMlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlN0YXJ0VGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnLCByb290RWxlbTogRWxlbWVudCwgaWQ/OiBudW1iZXIpOiBOb2RlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBlbmQgdGFnIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mRW5kVGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydEVuZFRhZywgcm9vdEVsZW06IEVsZW1lbnQpOiBOb2RlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBlbXB0eSB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqIEBwYXJhbSBpZCBpZCBudW1iZXIgaW4geGxpZmYyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mRW1wdHlUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWcsIHJvb3RFbGVtOiBFbGVtZW50LCBpZD86IG51bWJlcik6IE5vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIHBsYWNlaG9sZGVyIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKiBAcGFyYW0gaWQgaWQgbnVtYmVyIGluIHhsaWZmMlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlBsYWNlaG9sZGVyUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyLCByb290RWxlbTogRWxlbWVudCwgaWQ/OiBudW1iZXIpOiBOb2RlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBpY3UgbWVzc2FnZSByZWZzIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mSUNVTWVzc2FnZVJlZlBhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlUmVmLCByb290RWxlbTogRWxlbWVudCk6IE5vZGU7XHJcbn1cclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMTYuMDUuMjAxNy5cclxuICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgdGFnIG5hbWVzIHRvIHBsYWNlaG9sZGVyIG5hbWVzLlxyXG4gKi9cclxuXHJcbi8qXHJcbmNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9tYXN0ZXIvcGFja2FnZXMvY29tcGlsZXIvc3JjL2kxOG4vc2VyaWFsaXplcnMvcGxhY2Vob2xkZXIudHNcclxuICovXHJcbmNvbnN0IFRBR19UT19QTEFDRUhPTERFUl9OQU1FUzoge1trOiBzdHJpbmddOiBzdHJpbmd9ID0ge1xyXG4gICAgJ0EnOiAnTElOSycsXHJcbiAgICAnQic6ICdCT0xEX1RFWFQnLFxyXG4gICAgJ0JSJzogJ0xJTkVfQlJFQUsnLFxyXG4gICAgJ0VNJzogJ0VNUEhBU0lTRURfVEVYVCcsXHJcbiAgICAnSDEnOiAnSEVBRElOR19MRVZFTDEnLFxyXG4gICAgJ0gyJzogJ0hFQURJTkdfTEVWRUwyJyxcclxuICAgICdIMyc6ICdIRUFESU5HX0xFVkVMMycsXHJcbiAgICAnSDQnOiAnSEVBRElOR19MRVZFTDQnLFxyXG4gICAgJ0g1JzogJ0hFQURJTkdfTEVWRUw1JyxcclxuICAgICdINic6ICdIRUFESU5HX0xFVkVMNicsXHJcbiAgICAnSFInOiAnSE9SSVpPTlRBTF9SVUxFJyxcclxuICAgICdJJzogJ0lUQUxJQ19URVhUJyxcclxuICAgICdMSSc6ICdMSVNUX0lURU0nLFxyXG4gICAgJ0xJTksnOiAnTUVESUFfTElOSycsXHJcbiAgICAnT0wnOiAnT1JERVJFRF9MSVNUJyxcclxuICAgICdQJzogJ1BBUkFHUkFQSCcsXHJcbiAgICAnUSc6ICdRVU9UQVRJT04nLFxyXG4gICAgJ1MnOiAnU1RSSUtFVEhST1VHSF9URVhUJyxcclxuICAgICdTTUFMTCc6ICdTTUFMTF9URVhUJyxcclxuICAgICdTVUInOiAnU1VCU1RSSVBUJyxcclxuICAgICdTVVAnOiAnU1VQRVJTQ1JJUFQnLFxyXG4gICAgJ1RCT0RZJzogJ1RBQkxFX0JPRFknLFxyXG4gICAgJ1REJzogJ1RBQkxFX0NFTEwnLFxyXG4gICAgJ1RGT09UJzogJ1RBQkxFX0ZPT1RFUicsXHJcbiAgICAnVEgnOiAnVEFCTEVfSEVBREVSX0NFTEwnLFxyXG4gICAgJ1RIRUFEJzogJ1RBQkxFX0hFQURFUicsXHJcbiAgICAnVFInOiAnVEFCTEVfUk9XJyxcclxuICAgICdUVCc6ICdNT05PU1BBQ0VEX1RFWFQnLFxyXG4gICAgJ1UnOiAnVU5ERVJMSU5FRF9URVhUJyxcclxuICAgICdVTCc6ICdVTk9SREVSRURfTElTVCcsXHJcbn07XHJcblxyXG4vKipcclxuICogSFRNTCBUYWdzIChpbiB1cHBlcmNhc2UpIHRoYXQgYXJlIGVtcHR5LCB0aGV5IGhhdmUgbm8gY29udGVudCwgYnV0IGRvIG5vdCBuZWVkIGEgY2xvc2UgdGFnLCBlLmcuIDxicj4sIDxpbWc+LCA8aHI+LlxyXG4gKi9cclxuY29uc3QgVk9JRF9UQUdTID0gWydCUicsICdIUicsICdJTUcnLCAnQVJFQScsICdMSU5LJywgJ1dCUiddO1xyXG5cclxuZXhwb3J0IGNsYXNzIFRhZ01hcHBpbmcge1xyXG5cclxuICAgIHB1YmxpYyBnZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZSh0YWc6IHN0cmluZywgaWQ6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBiYXNlTmFtZSA9IFRBR19UT19QTEFDRUhPTERFUl9OQU1FU1t1cHBlclRhZ10gfHwgYFRBR18ke3VwcGVyVGFnfWA7XHJcbiAgICAgICAgcmV0dXJuIGBTVEFSVF8ke2Jhc2VOYW1lfWAgKyB0aGlzLmNvdW50ZXJTdHJpbmcoaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSh0YWc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBiYXNlTmFtZSA9IFRBR19UT19QTEFDRUhPTERFUl9OQU1FU1t1cHBlclRhZ10gfHwgYFRBR18ke3VwcGVyVGFnfWA7XHJcbiAgICAgICAgcmV0dXJuIGBDTE9TRV8ke2Jhc2VOYW1lfWA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEVtcHR5VGFnUGxhY2Vob2xkZXJOYW1lKHRhZzogc3RyaW5nLCBpZDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB1cHBlclRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VOYW1lID0gIFRBR19UT19QTEFDRUhPTERFUl9OQU1FU1t1cHBlclRhZ10gfHwgYFRBR18ke3VwcGVyVGFnfWA7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VOYW1lICsgdGhpcy5jb3VudGVyU3RyaW5nKGlkKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q3R5cGVGb3JUYWcodGFnOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSAnYnInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdsYic7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ltZyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2ltYWdlJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgeC0ke3RhZ31gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VGFnbmFtZUZyb21TdGFydFRhZ1BsYWNlaG9sZGVyTmFtZShwbGFjZWhvbGRlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyTmFtZS5zdGFydHNXaXRoKCdTVEFSVF9UQUdfJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaXBDb3VudGVyKHBsYWNlaG9sZGVyTmFtZS5zdWJzdHJpbmcoJ1NUQVJUX1RBR18nLmxlbmd0aCkpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwbGFjZWhvbGRlck5hbWUuc3RhcnRzV2l0aCgnU1RBUlRfJykpIHtcclxuICAgICAgICAgICAgY29uc3QgcGggPSB0aGlzLnN0cmlwQ291bnRlcihwbGFjZWhvbGRlck5hbWUuc3Vic3RyaW5nKCdTVEFSVF8nLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaEtleSA9IE9iamVjdC5rZXlzKFRBR19UT19QTEFDRUhPTERFUl9OQU1FUykuZmluZCgoa2V5KSA9PiBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNba2V5XSA9PT0gcGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hLZXkgPyBtYXRjaEtleS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFRhZ25hbWVGcm9tQ2xvc2VUYWdQbGFjZWhvbGRlck5hbWUocGxhY2Vob2xkZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmIChwbGFjZWhvbGRlck5hbWUuc3RhcnRzV2l0aCgnQ0xPU0VfVEFHXycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmlwQ291bnRlcihwbGFjZWhvbGRlck5hbWUuc3Vic3RyaW5nKCdDTE9TRV9UQUdfJy5sZW5ndGgpKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGxhY2Vob2xkZXJOYW1lLnN0YXJ0c1dpdGgoJ0NMT1NFXycpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBoID0gdGhpcy5zdHJpcENvdW50ZXIocGxhY2Vob2xkZXJOYW1lLnN1YnN0cmluZygnQ0xPU0VfJy5sZW5ndGgpKTtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2hLZXkgPSBPYmplY3Qua2V5cyhUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVMpLmZpbmQoKGtleSkgPT4gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW2tleV0gPT09IHBoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoS2V5ID8gbWF0Y2hLZXkudG9Mb3dlckNhc2UoKSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHBsYWNlaG9sZGVyIG5hbWUgc3RhbmRzIGZvciBlbXB0eSBodG1sIHRhZy5cclxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlck5hbWUgY2FuIGJlIFRBR188bmFtZT4gb3IganVzdCA8bmFtZT5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzRW1wdHlUYWdQbGFjZWhvbGRlck5hbWUocGxhY2Vob2xkZXJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBwaCA9IHRoaXMuc3RyaXBDb3VudGVyKHBsYWNlaG9sZGVyTmFtZSk7XHJcbiAgICAgICAgbGV0IG1hdGNoS2V5O1xyXG4gICAgICAgIGlmIChwaC5zdGFydHNXaXRoKCdUQUdfJykpIHtcclxuICAgICAgICAgICAgbWF0Y2hLZXkgPSBwaC5zdWJzdHJpbmcoNCkudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXRjaEtleSA9IE9iamVjdC5rZXlzKFRBR19UT19QTEFDRUhPTERFUl9OQU1FUykuZmluZCgoa2V5KSA9PiBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNba2V5XSA9PT0gcGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0Y2hLZXkpIHtcclxuICAgICAgICAgICAgaWYgKFZPSURfVEFHUy5pbmRleE9mKG1hdGNoS2V5KSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0YWduYW1lIG9mIGVtcHR5IHRhZyBwbGFjZWhvbGRlci5cclxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlck5hbWUgY2FuIGJlIFRBR188bmFtZT4gb3IganVzdCA8bmFtZT5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFRhZ25hbWVGcm9tRW1wdHlUYWdQbGFjZWhvbGRlck5hbWUocGxhY2Vob2xkZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHBoID0gdGhpcy5zdHJpcENvdW50ZXIocGxhY2Vob2xkZXJOYW1lKTtcclxuICAgICAgICBsZXQgbWF0Y2hLZXk7XHJcbiAgICAgICAgaWYgKHBoLnN0YXJ0c1dpdGgoJ1RBR18nKSkge1xyXG4gICAgICAgICAgICBtYXRjaEtleSA9IHBoLnN1YnN0cmluZyg0KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdGNoS2V5ID0gT2JqZWN0LmtleXMoVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTKS5maW5kKChrZXkpID0+IFRBR19UT19QTEFDRUhPTERFUl9OQU1FU1trZXldID09PSBwaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaEtleSkge1xyXG4gICAgICAgICAgICBpZiAoVk9JRF9UQUdTLmluZGV4T2YobWF0Y2hLZXkpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBwbGFjZWhvbGRlciBlbmRzIHdpdGggX1swLTldKywgc3RyaXAgdGhhdCBudW1iZXIuXHJcbiAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXJOYW1lIHBsYWNlaG9sZGVyTmFtZVxyXG4gICAgICogQHJldHVybiBwbGFjZWhvbGRlck5hbWUgd2l0aG91dCBjb3VudGVyIGF0IGVuZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdHJpcENvdW50ZXIocGxhY2Vob2xkZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmIChwbGFjZWhvbGRlck5hbWUpIHtcclxuICAgICAgICAgICAgY29uc3QgcmUgPSAvKC4qKV9bMC05XSskLztcclxuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyTmFtZS5tYXRjaChyZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlck5hbWUucmVwbGFjZShyZSwgJyQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmluZyBzdWZmaXggZm9yIGNvdW50ZXIuXHJcbiAgICAgKiBJZiBjb3VudGVyIGlzIDAsIGl0IGlzIGVtcHR5LCBvdGhlcndpc2UgXzxpZD4uXHJcbiAgICAgKiBAcGFyYW0gaWQgaWRcclxuICAgICAqIEByZXR1cm4gc3VmZml4IGZvciBjb3VudGVyLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNvdW50ZXJTdHJpbmcoaWQ6IG51bWJlcikge1xyXG4gICAgICAgIGlmIChpZCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdfJyArIGlkLnRvU3RyaW5nKDEwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXInO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2V9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1zdGFydC10YWcnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW5kLXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlcn0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXBsYWNlaG9sZGVyJztcclxuaW1wb3J0IHtUYWdNYXBwaW5nfSBmcm9tICcuL3RhZy1tYXBwaW5nJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydEVtcHR5VGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW1wdHktdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWZ9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1pY3UtbWVzc2FnZS1yZWYnO1xyXG5pbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFR5cGV9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydCc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRUZXh0fSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtdGV4dCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IHJvb2JtIG9uIDEwLjA1LjIwMTcuXHJcbiAqIEEgbWVzc2FnZSBwYXJzZXIgZm9yIFhMSUZGIDEuMlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFhsaWZmTWVzc2FnZVBhcnNlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVBhcnNlciB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdGhpcyBlbGVtZW50IG5vZGUuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGNoaWxkcmVuIGFyZSBkb25lLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnROb2RlIGVsZW1lbnROb2RlXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlIHRvIGJlIGFsdGVyZWRcclxuICAgICAqIEByZXR1cm4gdHJ1ZSwgaWYgY2hpbGRyZW4gc2hvdWxkIGJlIHByb2Nlc3NlZCB0b28sIGZhbHNlIG90aGVyd2lzZSAoY2hpbGRyZW4gaWdub3JlZCB0aGVuKVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcHJvY2Vzc1N0YXJ0RWxlbWVudChlbGVtZW50Tm9kZTogRWxlbWVudCwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50Tm9kZS50YWdOYW1lO1xyXG4gICAgICAgIGNvbnN0IHRhZ01hcHBpbmcgPSBuZXcgVGFnTWFwcGluZygpO1xyXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAneCcpIHtcclxuICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYXJlIGxpa2UgPHggaWQ9XCJJTlRFUlBPTEFUSU9OXCIvPiBvciA8eCBpZD1cIklOVEVSUE9MQVRJT05fMVwiPlxyXG4gICAgICAgICAgICBjb25zdCBpZCA9IGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuICAgICAgICAgICAgaWYgKCFpZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBzaG91bGQgbm90IGhhcHBlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpZC5zdGFydHNXaXRoKCdJTlRFUlBPTEFUSU9OJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVySW5kZXhGcm9tSWQoaWQpO1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRQbGFjZWhvbGRlcihpbmRleCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQuc3RhcnRzV2l0aCgnSUNVJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYXJzZUlDVU1lc3NhZ2VSZWZJbmRleEZyb21JZChpZCk7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZElDVU1lc3NhZ2VSZWYoaW5kZXgsIG51bGwpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkLnN0YXJ0c1dpdGgoJ1NUQVJUXycpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVGFnTmFtZSA9IHRhZ01hcHBpbmcuZ2V0VGFnbmFtZUZyb21TdGFydFRhZ1BsYWNlaG9sZGVyTmFtZShpZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFRhZ05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGNvdW50ID0gdGhpcy5wYXJzZUlkQ291bnRGcm9tTmFtZShpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRTdGFydFRhZyhub3JtYWxpemVkVGFnTmFtZSwgaWRjb3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQuc3RhcnRzV2l0aCgnQ0xPU0VfJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUYWdOYW1lID0gdGFnTWFwcGluZy5nZXRUYWduYW1lRnJvbUNsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKGlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkVGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkRW5kVGFnKG5vcm1hbGl6ZWRUYWdOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdNYXBwaW5nLmlzRW1wdHlUYWdQbGFjZWhvbGRlck5hbWUoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVGFnTmFtZSA9IHRhZ01hcHBpbmcuZ2V0VGFnbmFtZUZyb21FbXB0eVRhZ1BsYWNlaG9sZGVyTmFtZShpZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFRhZ05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGNvdW50ID0gdGhpcy5wYXJzZUlkQ291bnRGcm9tTmFtZShpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRFbXB0eVRhZyhub3JtYWxpemVkVGFnTmFtZSwgaWRjb3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgZW5kIG9mIHRoaXMgZWxlbWVudCBub2RlLlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYWZ0ZXIgYWxsIGNoaWxkcmVuIGFyZSBwcm9jZXNzZWQuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudE5vZGUgZWxlbWVudE5vZGVcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2UgdG8gYmUgYWx0ZXJlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcHJvY2Vzc0VuZEVsZW1lbnQoZWxlbWVudE5vZGU6IEVsZW1lbnQsIG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpIHtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGlkIGF0dHJpYnV0ZSBvZiB4IGVsZW1lbnQgYXMgcGxhY2Vob2xkZXIgaW5kZXguXHJcbiAgICAgKiBpZCBjYW4gYmUgXCJJTlRFUlBPTEFUSU9OXCIgb3IgXCJJTlRFUlBPTEFUSU9OX25cIlxyXG4gICAgICogQHBhcmFtIGlkIGlkXHJcbiAgICAgKiBAcmV0dXJuIGluZGV4XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGFyc2VQbGFjZWhvbGRlckluZGV4RnJvbUlkKGlkOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBpbmRleFN0cmluZyA9ICcnO1xyXG5cclxuICAgICAgICBpZiAoaWQgPT09ICdJTlRFUlBPTEFUSU9OJykge1xyXG4gICAgICAgICAgICBpbmRleFN0cmluZyA9ICcwJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbmRleFN0cmluZyA9IGlkLnN1YnN0cmluZygnSU5URVJQT0xBVElPTl8nLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoaW5kZXhTdHJpbmcsIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGlkIGF0dHJpYnV0ZSBvZiB4IGVsZW1lbnQgYXMgcGxhY2Vob2xkZXIgaW5kZXguXHJcbiAgICAgKiBpZCBjYW4gYmUgXCJJTlRFUlBPTEFUSU9OXCIgb3IgXCJJTlRFUlBPTEFUSU9OX25cIlxyXG4gICAgICogQHBhcmFtIGlkIGlkXHJcbiAgICAgKiBAcmV0dXJuIGlkIGFzIG51bWJlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcnNlSUNVTWVzc2FnZVJlZkluZGV4RnJvbUlkKGlkOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBpbmRleFN0cmluZyA9ICcnO1xyXG5cclxuICAgICAgICBpZiAoaWQgPT09ICdJQ1UnKSB7XHJcbiAgICAgICAgICAgIGluZGV4U3RyaW5nID0gJzAnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZGV4U3RyaW5nID0gaWQuc3Vic3RyaW5nKCdJQ1VfJy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGluZGV4U3RyaW5nLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFkZFhtbFJlcHJlc2VudGF0aW9uVG9Sb290KG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UsIHJvb3RFbGVtOiBFbGVtZW50KSB7XHJcbiAgICAgICAgbWVzc2FnZS5wYXJ0cygpLmZvckVhY2goKHBhcnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGNoaWxkOiBOb2RlO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuVEVYVDpcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlRleHRQYXJ0KDxQYXJzZWRNZXNzYWdlUGFydFRleHQ+IHBhcnQsIHJvb3RFbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLlNUQVJUX1RBRzpcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlN0YXJ0VGFnUGFydCgoPFBhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWc+cGFydCksIHJvb3RFbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLkVORF9UQUc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZFbmRUYWdQYXJ0KCg8UGFyc2VkTWVzc2FnZVBhcnRFbmRUYWc+cGFydCksIHJvb3RFbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLkVNUFRZX1RBRzpcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVtcHR5VGFnUGFydCgoPFBhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWc+cGFydCksIHJvb3RFbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLlBMQUNFSE9MREVSOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mUGxhY2Vob2xkZXJQYXJ0KCg8UGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlcj5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuSUNVX01FU1NBR0VfUkVGOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mSUNVTWVzc2FnZVJlZlBhcnQoKDxQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWY+cGFydCksIHJvb3RFbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJvb3RFbGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBzdGFydCB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IDx4Lz4tRWxlbWVudCB3aXRoIGF0dHJpYnV0ZXMgaWQgYW5kIGN0eXBlXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZTdGFydFRhZ1BhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZywgcm9vdEVsZW06IEVsZW1lbnQpOiBOb2RlIHtcclxuICAgICAgICBjb25zdCB4RWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xyXG4gICAgICAgIGNvbnN0IHRhZ01hcHBpbmcgPSBuZXcgVGFnTWFwcGluZygpO1xyXG4gICAgICAgIGNvbnN0IGlkQXR0cmliID0gdGFnTWFwcGluZy5nZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZShwYXJ0LnRhZ05hbWUoKSwgcGFydC5pZENvdW50ZXIoKSk7XHJcbiAgICAgICAgY29uc3QgY3R5cGVBdHRyaWIgPSB0YWdNYXBwaW5nLmdldEN0eXBlRm9yVGFnKHBhcnQudGFnTmFtZSgpKTtcclxuICAgICAgICBjb25zdCBlcXVpdlRleHRBdHRyID0gJzwnICsgcGFydC50YWdOYW1lKCkgKyAnPic7XHJcbiAgICAgICAgeEVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIGlkQXR0cmliKTtcclxuICAgICAgICB4RWxlbS5zZXRBdHRyaWJ1dGUoJ2N0eXBlJywgY3R5cGVBdHRyaWIpO1xyXG4gICAgICAgIHhFbGVtLnNldEF0dHJpYnV0ZSgnZXF1aXYtdGV4dCcsIGVxdWl2VGV4dEF0dHIpO1xyXG4gICAgICAgIHJldHVybiB4RWxlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgZW5kIHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgPHgvPi1FbGVtZW50IHdpdGggYXR0cmlidXRlcyBpZCBhbmQgY3R5cGVcclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVuZFRhZ1BhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRFbmRUYWcsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgeEVsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3gnKTtcclxuICAgICAgICBjb25zdCB0YWdNYXBwaW5nID0gbmV3IFRhZ01hcHBpbmcoKTtcclxuICAgICAgICBjb25zdCBpZEF0dHJpYiA9IHRhZ01hcHBpbmcuZ2V0Q2xvc2VUYWdQbGFjZWhvbGRlck5hbWUocGFydC50YWdOYW1lKCkpO1xyXG4gICAgICAgIGNvbnN0IGN0eXBlQXR0cmliID0gJ3gtJyArIHBhcnQudGFnTmFtZSgpO1xyXG4gICAgICAgIHhFbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCBpZEF0dHJpYik7XHJcbiAgICAgICAgeEVsZW0uc2V0QXR0cmlidXRlKCdjdHlwZScsIGN0eXBlQXR0cmliKTtcclxuICAgICAgICByZXR1cm4geEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGVtcHR5IHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgPHgvPi1FbGVtZW50IHdpdGggYXR0cmlidXRlcyBpZCBhbmQgY3R5cGVcclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVtcHR5VGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydEVtcHR5VGFnLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4Jyk7XHJcbiAgICAgICAgY29uc3QgdGFnTWFwcGluZyA9IG5ldyBUYWdNYXBwaW5nKCk7XHJcbiAgICAgICAgY29uc3QgaWRBdHRyaWIgPSB0YWdNYXBwaW5nLmdldEVtcHR5VGFnUGxhY2Vob2xkZXJOYW1lKHBhcnQudGFnTmFtZSgpLCBwYXJ0LmlkQ291bnRlcigpKTtcclxuICAgICAgICBjb25zdCBjdHlwZUF0dHJpYiA9IHRhZ01hcHBpbmcuZ2V0Q3R5cGVGb3JUYWcocGFydC50YWdOYW1lKCkpO1xyXG4gICAgICAgIGNvbnN0IGVxdWl2VGV4dEF0dHIgPSAnPCcgKyBwYXJ0LnRhZ05hbWUoKSArICcvPic7XHJcbiAgICAgICAgeEVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIGlkQXR0cmliKTtcclxuICAgICAgICB4RWxlbS5zZXRBdHRyaWJ1dGUoJ2N0eXBlJywgY3R5cGVBdHRyaWIpO1xyXG4gICAgICAgIHhFbGVtLnNldEF0dHJpYnV0ZSgnZXF1aXYtdGV4dCcsIGVxdWl2VGV4dEF0dHIpO1xyXG4gICAgICAgIHJldHVybiB4RWxlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgcGxhY2Vob2xkZXIgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IDx4Lz4tRWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBpZD1cIklOVEVSUE9MQVRJT05cIiBvciBpZD1cIklOVEVSUE9MQVRJT05fblwiXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZQbGFjZWhvbGRlclBhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlciwgcm9vdEVsZW06IEVsZW1lbnQpOiBOb2RlIHtcclxuICAgICAgICBjb25zdCB4RWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xyXG4gICAgICAgIGxldCBpZEF0dHJpYiA9ICdJTlRFUlBPTEFUSU9OJztcclxuICAgICAgICBpZiAocGFydC5pbmRleCgpID4gMCkge1xyXG4gICAgICAgICAgICBpZEF0dHJpYiA9ICdJTlRFUlBPTEFUSU9OXycgKyBwYXJ0LmluZGV4KCkudG9TdHJpbmcoMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlcXVpdlRleHRBdHRyID0gcGFydC5kaXNwKCk7XHJcbiAgICAgICAgeEVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIGlkQXR0cmliKTtcclxuICAgICAgICBpZiAoZXF1aXZUZXh0QXR0cikge1xyXG4gICAgICAgICAgICB4RWxlbS5zZXRBdHRyaWJ1dGUoJ2VxdWl2LXRleHQnLCBlcXVpdlRleHRBdHRyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHhFbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBpY3UgbWVzc2FnZSByZWZzIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mSUNVTWVzc2FnZVJlZlBhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlUmVmLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4Jyk7XHJcbiAgICAgICAgbGV0IGlkQXR0cmliID0gJ0lDVSc7XHJcbiAgICAgICAgaWYgKHBhcnQuaW5kZXgoKSA+IDApIHtcclxuICAgICAgICAgICAgaWRBdHRyaWIgPSAnSUNVXycgKyBwYXJ0LmluZGV4KCkudG9TdHJpbmcoMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB4RWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWRBdHRyaWIpO1xyXG4gICAgICAgIHJldHVybiB4RWxlbTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtTVEFURV9ORVcsIFNUQVRFX1RSQU5TTEFURUQsIFNUQVRFX0ZJTkFMfSBmcm9tICcuLi9hcGkvY29uc3RhbnRzJztcclxuaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4uL2FwaS9pLXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUnO1xyXG5pbXBvcnQge0lOb3JtYWxpemVkTWVzc2FnZX0gZnJvbSAnLi4vYXBpL2ktbm9ybWFsaXplZC1tZXNzYWdlJztcclxuaW1wb3J0IHtJVHJhbnNVbml0fSBmcm9tICcuLi9hcGkvaS10cmFucy11bml0JztcclxuaW1wb3J0IHtJTm90ZX0gZnJvbSAnLi4vYXBpL2ktbm90ZSc7XHJcbmltcG9ydCB7RE9NVXRpbGl0aWVzfSBmcm9tICcuL2RvbS11dGlsaXRpZXMnO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNVbml0fSBmcm9tICcuL2Fic3RyYWN0LXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge1hsaWZmTWVzc2FnZVBhcnNlcn0gZnJvbSAnLi94bGlmZi1tZXNzYWdlLXBhcnNlcic7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7QWJzdHJhY3RNZXNzYWdlUGFyc2VyfSBmcm9tICcuL2Fic3RyYWN0LW1lc3NhZ2UtcGFyc2VyJztcclxuaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZH0gZnJvbSAndXRpbCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwMS4wNS4yMDE3LlxyXG4gKiBBIFRyYW5zbGF0aW9uIFVuaXQgaW4gYW4gWExJRkYgMS4yIGZpbGUuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFhsaWZmVHJhbnNVbml0IGV4dGVuZHMgQWJzdHJhY3RUcmFuc1VuaXQgaW1wbGVtZW50cyBJVHJhbnNVbml0IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudDogRWxlbWVudCwgX2lkOiBzdHJpbmcsIF90cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKSB7XHJcbiAgICAgICAgc3VwZXIoX2VsZW1lbnQsIF9pZCwgX3RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc291cmNlQ29udGVudCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFhNTENvbnRlbnQoc291cmNlRWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbmV3IHNvdXJjZSBjb250ZW50IGluIHRoZSB0cmFuc3VuaXQuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBkb25lIGJ5IG5nLWV4dHJhY3QuXHJcbiAgICAgKiBNZXRob2Qgb25seSBleGlzdHMgdG8gYWxsb3cgeGxpZmZtZXJnZSB0byBtZXJnZSBtaXNzaW5nIGNoYW5nZWQgc291cmNlIGNvbnRlbnQuXHJcbiAgICAgKiBAcGFyYW0gbmV3Q29udGVudCB0aGUgbmV3IGNvbnRlbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTb3VyY2VDb250ZW50KG5ld0NvbnRlbnQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBzb3VyY2UgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICBpZiAoIXNvdXJjZSkge1xyXG4gICAgICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlbiwgdGhlcmUgYWx3YXlzIGhhcyB0byBiZSBhIHNvdXJjZSwgYnV0IHdobyBrbm93cy4uXHJcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQoc291cmNlLCBuZXdDb250ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHBhcnNlciB1c2VkIGZvciBub3JtYWxpemVkIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWVzc2FnZVBhcnNlcigpOiBBYnN0cmFjdE1lc3NhZ2VQYXJzZXIge1xyXG4gICAgICAgIHJldHVybiBuZXcgWGxpZmZNZXNzYWdlUGFyc2VyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCB2YWx1ZSwgdGhhdCBpcyB0byBiZSB0cmFuc2xhdGVkLCBhcyBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVTb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnc291cmNlJyk7XHJcbiAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZVBhcnNlcigpLmNyZWF0ZU5vcm1hbGl6ZWRNZXNzYWdlRnJvbVhNTChzb3VyY2VFbGVtZW50LCBudWxsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgdHJhbnNsYXRlZCB2YWx1ZSAoY29udGFpbmluZyBhbGwgbWFya3VwLCBkZXBlbmRzIG9uIHRoZSBjb25jcmV0ZSBmb3JtYXQgdXNlZCkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRDb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3RhcmdldCcpO1xyXG4gICAgICAgIHJldHVybiBET01VdGlsaXRpZXMuZ2V0WE1MQ29udGVudCh0YXJnZXRFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB0cmFuc2xhdGVkIHZhbHVlLCBidXQgYWxsIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgd2l0aCB7e259fSAoc3RhcnRpbmcgYXQgMClcclxuICAgICAqIGFuZCBhbGwgZW1iZWRkZWQgaHRtbCBpcyByZXBsYWNlZCBieSBkaXJlY3QgaHRtbCBtYXJrdXAuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldENvbnRlbnROb3JtYWxpemVkKCk6IElOb3JtYWxpemVkTWVzc2FnZSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3RhcmdldCcpO1xyXG4gICAgICAgIHJldHVybiBuZXcgWGxpZmZNZXNzYWdlUGFyc2VyKCkuY3JlYXRlTm9ybWFsaXplZE1lc3NhZ2VGcm9tWE1MKHRhcmdldEVsZW1lbnQsIHRoaXMuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0ZSBvZiB0aGUgdHJhbnNsYXRpb24gYXMgc3RvcmVkIGluIHRoZSB4bWwuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuYXRpdmVUYXJnZXRTdGF0ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0YXRlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IHN0YXRlIGluIHhtbC5cclxuICAgICAqIEBwYXJhbSBuYXRpdmVTdGF0ZSBuYXRpdmVTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc2V0TmF0aXZlVGFyZ2V0U3RhdGUobmF0aXZlU3RhdGU6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xyXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3RhdGUnLCBuYXRpdmVTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIGFuIGFic3RyYWN0IHN0YXRlIChuZXcsIHRyYW5zbGF0ZWQsIGZpbmFsKSB0byBhIGNvbmNyZXRlIHN0YXRlIHVzZWQgaW4gdGhlIHhtbC5cclxuICAgICAqIFJldHVybnMgdGhlIHN0YXRlIHRvIGJlIHVzZWQgaW4gdGhlIHhtbC5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSBvbmUgb2YgQ29uc3RhbnRzLlNUQVRFLi4uXHJcbiAgICAgKiBAcmV0dXJucyBhIG5hdGl2ZSBzdGF0ZSAoZGVwZW5kcyBvbiBjb25jcmV0ZSBmb3JtYXQpXHJcbiAgICAgKiBAdGhyb3dzIGVycm9yLCBpZiBzdGF0ZSBpcyBpbnZhbGlkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWFwU3RhdGVUb05hdGl2ZVN0YXRlKHN0YXRlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAoIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfTkVXOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICduZXcnO1xyXG4gICAgICAgICAgICBjYXNlIFNUQVRFX1RSQU5TTEFURUQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZWQnO1xyXG4gICAgICAgICAgICBjYXNlIFNUQVRFX0ZJTkFMOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdmaW5hbCc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc3RhdGUgJyArICBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIGEgbmF0aXZlIHN0YXRlIChmb3VuZCBpbiB0aGUgZG9jdW1lbnQpIHRvIGFuIGFic3RyYWN0IHN0YXRlIChuZXcsIHRyYW5zbGF0ZWQsIGZpbmFsKS5cclxuICAgICAqIFJldHVybnMgdGhlIGFic3RyYWN0IHN0YXRlLlxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0YXRlIG5hdGl2ZVN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBtYXBOYXRpdmVTdGF0ZVRvU3RhdGUobmF0aXZlU3RhdGU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgc3dpdGNoICggbmF0aXZlU3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnbmV3JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9ORVc7XHJcbiAgICAgICAgICAgIGNhc2UgJ25lZWRzLXRyYW5zbGF0aW9uJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9ORVc7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZWQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1RSQU5TTEFURUQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ25lZWRzLWFkYXB0YXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1RSQU5TTEFURUQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ25lZWRzLWwxMG4nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1RSQU5TTEFURUQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ25lZWRzLXJldmlldy1hZGFwdGF0aW9uJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9UUkFOU0xBVEVEO1xyXG4gICAgICAgICAgICBjYXNlICduZWVkcy1yZXZpZXctbDEwbic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVFJBTlNMQVRFRDtcclxuICAgICAgICAgICAgY2FzZSAnbmVlZHMtcmV2aWV3LXRyYW5zbGF0aW9uJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9UUkFOU0xBVEVEO1xyXG4gICAgICAgICAgICBjYXNlICdmaW5hbCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfRklOQUw7XHJcbiAgICAgICAgICAgIGNhc2UgJ3NpZ25lZC1vZmYnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0ZJTkFMO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX05FVztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdGhlIHNvdXJjZSBlbGVtZW50cyBpbiB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqIFRoZSBzb3VyY2UgZWxlbWVudCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUgZmlsZSBhbmQgYSBsaW5lIG51bWJlciB3aXRoIHRoZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHRlbXBsYXRlLlxyXG4gICAgICogSXQgaXMganVzdCBhIGhlbHAgZm9yIHRyYW5zbGF0b3JzIHRvIGZpbmQgdGhlIGNvbnRleHQgZm9yIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIFRoaXMgaXMgc2V0IHdoZW4gdXNpbmcgQW5ndWxhciA0LjAgb3IgZ3JlYXRlci5cclxuICAgICAqIE90aGVyd2lzZSBpdCBqdXN0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VSZWZlcmVuY2VzKCk6IHtzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlcn1bXSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb250ZXh0LWdyb3VwJyk7XHJcbiAgICAgICAgY29uc3Qgc291cmNlUmVmczogeyBzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlciB9W10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBzb3VyY2VFbGVtZW50cy5pdGVtKGkpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbS5nZXRBdHRyaWJ1dGUoJ3B1cnBvc2UnKSA9PT0gJ2xvY2F0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dEVsZW1lbnRzID0gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29udGV4dCcpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZWZpbGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmVudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb250ZXh0RWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0RWxlbSA9IGNvbnRleHRFbGVtZW50cy5pdGVtKGopO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0RWxlbS5nZXRBdHRyaWJ1dGUoJ2NvbnRleHQtdHlwZScpID09PSAnc291cmNlZmlsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlZmlsZSA9IERPTVV0aWxpdGllcy5nZXRQQ0RBVEEoY29udGV4dEVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dEVsZW0uZ2V0QXR0cmlidXRlKCdjb250ZXh0LXR5cGUnKSA9PT0gJ2xpbmVudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVudW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoRE9NVXRpbGl0aWVzLmdldFBDREFUQShjb250ZXh0RWxlbSksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VSZWZzLnB1c2goe3NvdXJjZWZpbGU6IHNvdXJjZWZpbGUsIGxpbmVudW1iZXI6IGxpbmVudW1iZXJ9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc291cmNlUmVmcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBzb3VyY2UgcmVmIGVsZW1lbnRzIGluIHRoZSB0cmFuc3VuaXQuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBkb25lIGJ5IG5nLWV4dHJhY3QuXHJcbiAgICAgKiBNZXRob2Qgb25seSBleGlzdHMgdG8gYWxsb3cgeGxpZmZtZXJnZSB0byBtZXJnZSBtaXNzaW5nIHNvdXJjZSByZWZzLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZVJlZnMgdGhlIHNvdXJjZXJlZnMgdG8gc2V0LiBPbGQgb25lcyBhcmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZVJlZmVyZW5jZXMoc291cmNlUmVmczoge3NvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyfVtdKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxTb3VyY2VSZWZlcmVuY2VzKCk7XHJcbiAgICAgICAgc291cmNlUmVmcy5mb3JFYWNoKChyZWYpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dEdyb3VwID0gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbnRleHQtZ3JvdXAnKTtcclxuICAgICAgICAgICAgY29udGV4dEdyb3VwLnNldEF0dHJpYnV0ZSgncHVycG9zZScsICdsb2NhdGlvbicpO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0U291cmNlID0gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbnRleHQnKTtcclxuICAgICAgICAgICAgY29udGV4dFNvdXJjZS5zZXRBdHRyaWJ1dGUoJ2NvbnRleHQtdHlwZScsICdzb3VyY2VmaWxlJyk7XHJcbiAgICAgICAgICAgIGNvbnRleHRTb3VyY2UuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJlZi5zb3VyY2VmaWxlKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRMaW5lID0gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbnRleHQnKTtcclxuICAgICAgICAgICAgY29udGV4dExpbmUuc2V0QXR0cmlidXRlKCdjb250ZXh0LXR5cGUnLCAnbGluZW51bWJlcicpO1xyXG4gICAgICAgICAgICBjb250ZXh0TGluZS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmVmLmxpbmVudW1iZXIudG9TdHJpbmcoMTApKSk7XHJcbiAgICAgICAgICAgIGNvbnRleHRHcm91cC5hcHBlbmRDaGlsZChjb250ZXh0U291cmNlKTtcclxuICAgICAgICAgICAgY29udGV4dEdyb3VwLmFwcGVuZENoaWxkKGNvbnRleHRMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZXh0R3JvdXApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVtb3ZlQWxsU291cmNlUmVmZXJlbmNlcygpIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NvbnRleHQtZ3JvdXAnKTtcclxuICAgICAgICBjb25zdCB0b0JlUmVtb3ZlZCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHNvdXJjZUVsZW1lbnRzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtLmdldEF0dHJpYnV0ZSgncHVycG9zZScpID09PSAnbG9jYXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0b0JlUmVtb3ZlZC5wdXNoKGVsZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvQmVSZW1vdmVkLmZvckVhY2goKGVsZW0pID0+IHtlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIHNldCBpbiB0aGUgdGVtcGxhdGUgYXMgdmFsdWUgb2YgdGhlIGkxOG4tYXR0cmlidXRlLlxyXG4gICAgICogZS5nLiBpMThuPVwibXlkZXNjcmlwdGlvblwiLlxyXG4gICAgICogSW4geGxpZmYgdGhpcyBpcyBzdG9yZWQgYXMgYSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgZnJvbT1cImRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtID0gdGhpcy5maW5kTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnZGVzY3JpcHRpb24nKTtcclxuICAgICAgICBpZiAobm90ZUVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIERPTVV0aWxpdGllcy5nZXRQQ0RBVEEobm90ZUVsZW0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBkZXNjcmlwdGlvbiBwcm9wZXJ0eSBvZiB0cmFucy11bml0LlxyXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uIGRlc2NyaXB0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXREZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IG5vdGVFbGVtID0gdGhpcy5maW5kTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnZGVzY3JpcHRpb24nKTtcclxuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcclxuICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobm90ZUVsZW0pKSB7XHJcbiAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBpdFxyXG4gICAgICAgICAgICAgICBub3RlRWxlbSA9IHRoaXMuY3JlYXRlTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnZGVzY3JpcHRpb24nLCBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQobm90ZUVsZW0sIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChub3RlRWxlbSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoJ2Rlc2NyaXB0aW9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIGEgbm90ZSBlbGVtZW50IHdpdGggYXR0cmlidXRlIGZyb209JzxhdHRyVmFsdWU+J1xyXG4gICAgICogQHBhcmFtIGF0dHJWYWx1ZSBhdHRyVmFsdWVcclxuICAgICAqIEByZXR1cm4gZWxlbWVudCBvciBudWxsIGlzIGFic2VudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmROb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKGF0dHJWYWx1ZTogc3RyaW5nKTogRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbm90ZScpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm90ZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdGVFbGVtID0gbm90ZUVsZW1lbnRzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChub3RlRWxlbS5nZXRBdHRyaWJ1dGUoJ2Zyb20nKSA9PT0gYXR0clZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90ZUVsZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIG5vdGUgZWxlbWVudHMgd2hlcmUgZnJvbSBhdHRyaWJ1dGUgaXMgbm90IGRlc2NyaXB0aW9uIG9yIG1lYW5pbmdcclxuICAgICAqIEByZXR1cm4gZWxlbWVudHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmaW5kQWxsQWRkaXRpb25hbE5vdGVFbGVtZW50cygpOiBFbGVtZW50W10ge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25vdGUnKTtcclxuICAgICAgICBjb25zdCByZXN1bHQ6IEVsZW1lbnRbXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm90ZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdGVFbGVtID0gbm90ZUVsZW1lbnRzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb21BdHRyaWJ1dGUgPSBub3RlRWxlbS5nZXRBdHRyaWJ1dGUoJ2Zyb20nKTtcclxuICAgICAgICAgICAgaWYgKGZyb21BdHRyaWJ1dGUgIT09ICdkZXNjcmlwdGlvbicgJiYgZnJvbUF0dHJpYnV0ZSAhPT0gJ21lYW5pbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub3RlRWxlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgZnJvbT0nPGF0dHJWYWx1ZT4nXHJcbiAgICAgKiBAcGFyYW0gZnJvbUF0dHJWYWx1ZSB2YWx1ZSBvZiBcImZyb21cIiBhdHRyaWJ1dGVcclxuICAgICAqIEBwYXJhbSBjb250ZW50IHRleHQgdmFsdWUgb2Ygbm90ZSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHRoZSBuZXcgY3JlYXRlZCBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZShmcm9tQXR0clZhbHVlOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IEVsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25vdGUnKTtcclxuICAgICAgICBpZiAoZnJvbUF0dHJWYWx1ZSkge1xyXG4gICAgICAgICAgICBub3RlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Zyb20nLCBmcm9tQXR0clZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm90ZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdwcmlvcml0eScsICcxJyk7XHJcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQobm90ZUVsZW1lbnQsIGNvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKG5vdGVFbGVtZW50KTtcclxuICAgICAgICByZXR1cm4gbm90ZUVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgbm90ZSBlbGVtZW50IHdpdGggYXR0cmlidXRlIGZyb209JzxhdHRyVmFsdWU+J1xyXG4gICAgICogQHBhcmFtIGF0dHJWYWx1ZSBhdHRyVmFsdWVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW1vdmVOb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKGF0dHJWYWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnQgPSB0aGlzLmZpbmROb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKGF0dHJWYWx1ZSk7XHJcbiAgICAgICAgaWYgKG5vdGVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQ2hpbGQobm90ZUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbGwgbm90ZSBlbGVtZW50cyB3aGVyZSBhdHRyaWJ1dGUgXCJmcm9tXCIgaXMgbm90IGRlc2NyaXB0aW9uIG9yIG1lYW5pbmcuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVtb3ZlQWxsQWRkaXRpb25hbE5vdGVFbGVtZW50cygpIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbWVudHMgPSB0aGlzLmZpbmRBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCk7XHJcbiAgICAgICAgbm90ZUVsZW1lbnRzLmZvckVhY2goKG5vdGVFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQ2hpbGQobm90ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1lYW5pbmcgKGludGVudCkgc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBwYXJ0IGluIGZyb250IG9mIHRoZSB8IHN5bWJvbC5cclxuICAgICAqIGUuZy4gaTE4bj1cIm1lYW5pbmd8bXlkZXNjcmlwdGlvblwiLlxyXG4gICAgICogSW4geGxpZmYgdGhpcyBpcyBzdG9yZWQgYXMgYSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgZnJvbT1cIm1lYW5pbmdcIi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1lYW5pbmcoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbSA9IHRoaXMuZmluZE5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoJ21lYW5pbmcnKTtcclxuICAgICAgICBpZiAobm90ZUVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIERPTVV0aWxpdGllcy5nZXRQQ0RBVEEobm90ZUVsZW0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBtZWFuaW5nIHByb3BlcnR5IG9mIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBAcGFyYW0gIG1lYW5pbmcgbWVhbmluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0TWVhbmluZyhtZWFuaW5nOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgbm90ZUVsZW0gPSB0aGlzLmZpbmROb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKCdtZWFuaW5nJyk7XHJcbiAgICAgICAgaWYgKG1lYW5pbmcpIHtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG5vdGVFbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGl0XHJcbiAgICAgICAgICAgICAgICBub3RlRWxlbSA9IHRoaXMuY3JlYXRlTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnbWVhbmluZycsIG1lYW5pbmcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQobm90ZUVsZW0sIG1lYW5pbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChub3RlRWxlbSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoJ21lYW5pbmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbm90ZXMgb2YgdGhlIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBOb3RlcyBhcmUgcmVtYXJrcyBtYWRlIGJ5IGEgdHJhbnNsYXRvci5cclxuICAgICAqIChkZXNjcmlwdGlvbiBhbmQgbWVhbmluZyBhcmUgbm90IGluY2x1ZGVkIGhlcmUhKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbm90ZXMoKTogSU5vdGVbXSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbXRzOiBFbGVtZW50W10gPSB0aGlzLmZpbmRBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCk7XHJcbiAgICAgICAgcmV0dXJuIG5vdGVFbGVtZW10cy5tYXAoZWxlbSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBmcm9tOiBlbGVtLmdldEF0dHJpYnV0ZSgnZnJvbScpLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogRE9NVXRpbGl0aWVzLmdldFBDREFUQShlbGVtKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciBzZXR0aW5nIG9mIG5vdGVzIGlzIHN1cHBvcnRlZC5cclxuICAgICAqIElmIG5vdCwgc2V0Tm90ZXMgd2lsbCBkbyBub3RoaW5nLlxyXG4gICAgICogeHRiIGRvZXMgbm90IHN1cHBvcnQgdGhpcywgYWxsIG90aGVyIGZvcm1hdHMgZG8uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdXBwb3J0c1NldE5vdGVzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIG5vdGVzIHRvIHRyYW5zIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0gbmV3Tm90ZXMgdGhlIG5vdGVzIHRvIGFkZC5cclxuICAgICAqIEB0aHJvd3MgYW4gRXJyb3IgaWYgYW55IG5vdGUgY29udGFpbnMgZGVzY3JpcHRpb24gb3IgbWVhbmluZyBhcyBmcm9tIGF0dHJpYnV0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldE5vdGVzKG5ld05vdGVzOiBJTm90ZVtdKSB7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChuZXdOb3RlcykpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVja05vdGVzKG5ld05vdGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCk7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChuZXdOb3RlcykpIHtcclxuICAgICAgICAgICAgbmV3Tm90ZXMuZm9yRWFjaCgobm90ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSB0aGlzLmNyZWF0ZU5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUobm90ZS5mcm9tLCBub3RlLnRleHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRyYW5zbGF0aW9uIHRvIGEgZ2l2ZW4gc3RyaW5nIChpbmNsdWRpbmcgbWFya3VwKS5cclxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiB0cmFuc2xhdGlvblxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdHJhbnNsYXRlTmF0aXZlKHRyYW5zbGF0aW9uOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAndGFyZ2V0Jyk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnc291cmNlJyk7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IERPTVV0aWxpdGllcy5jcmVhdGVGb2xsb3dpbmdTaWJsaW5nKCd0YXJnZXQnLCBzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudCh0YXJnZXQsIDxzdHJpbmc+IHRyYW5zbGF0aW9uKTtcclxuICAgICAgICB0aGlzLnNldFRhcmdldFN0YXRlKFNUQVRFX1RSQU5TTEFURUQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBzb3VyY2UgdG8gdGFyZ2V0IHRvIHVzZSBpdCBhcyBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqIFJldHVybnMgYSBjaGFuZ2VkIGNvcHkgb2YgdGhpcyB0cmFucyB1bml0LlxyXG4gICAgICogcmVjZWl2ZXIgaXMgbm90IGNoYW5nZWQuXHJcbiAgICAgKiAoaW50ZXJuYWwgdXNhZ2Ugb25seSwgYSBjbGllbnQgc2hvdWxkIGNhbGwgaW1wb3J0TmV3VHJhbnNVbml0IG9uIElUcmFuc2xhdGlvbk1lc3NhZ2VGaWxlKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xvbmVXaXRoU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4sIHRhcmdldEZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSk6IEFic3RyYWN0VHJhbnNVbml0IHtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gPEVsZW1lbnQ+IHRoaXMuX2VsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IFhsaWZmVHJhbnNVbml0KGVsZW1lbnQsIHRoaXMuX2lkLCB0YXJnZXRGaWxlKTtcclxuICAgICAgICBjbG9uZS51c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nLCBjb3B5Q29udGVudCk7XHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBzb3VyY2UgdG8gdGFyZ2V0IHRvIHVzZSBpdCBhcyBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgY2FsbCBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nIG9uIElUcmFuc2xhdGlvbk1lc3NhZ2VGaWxlKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXNlU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4pIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAndGFyZ2V0Jyk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gRE9NVXRpbGl0aWVzLmNyZWF0ZUZvbGxvd2luZ1NpYmxpbmcoJ3RhcmdldCcsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmF1bHRMYW5nIHx8IGNvcHlDb250ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVN0cmluZyA9IERPTVV0aWxpdGllcy5nZXRYTUxDb250ZW50KHNvdXJjZSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdUYXJnZXRTdHJpbmcgPSBzb3VyY2VTdHJpbmc7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0lDVU1lc3NhZ2Uoc291cmNlU3RyaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0U3RyaW5nID0gdGhpcy50cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSgpLmdldE5ld1RyYW5zVW5pdFRhcmdldFByYWVmaXgoKVxyXG4gICAgICAgICAgICAgICAgICAgICsgc291cmNlU3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLnRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKCkuZ2V0TmV3VHJhbnNVbml0VGFyZ2V0U3VmZml4KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQodGFyZ2V0LCBuZXdUYXJnZXRTdHJpbmcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIERPTVV0aWxpdGllcy5yZXBsYWNlQ29udGVudFdpdGhYTUxDb250ZW50KHRhcmdldCwgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWZhdWx0TGFuZykge1xyXG4gICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHRoaXMubWFwU3RhdGVUb05hdGl2ZVN0YXRlKFNUQVRFX0ZJTkFMKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnc3RhdGUnLCB0aGlzLm1hcFN0YXRlVG9OYXRpdmVTdGF0ZShTVEFURV9ORVcpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7SVRyYW5zVW5pdH0gZnJvbSAnLi4vYXBpL2ktdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7Rk9STUFUX1hMSUZGMTIsIEZJTEVUWVBFX1hMSUZGMTJ9IGZyb20gJy4uL2FwaS9jb25zdGFudHMnO1xyXG5pbXBvcnQge0RPTVV0aWxpdGllc30gZnJvbSAnLi9kb20tdXRpbGl0aWVzJztcclxuaW1wb3J0IHtYbGlmZlRyYW5zVW5pdH0gZnJvbSAnLi94bGlmZi10cmFucy11bml0JztcclxuaW1wb3J0IHtBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuL2Fic3RyYWN0LXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUnO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNVbml0fSBmcm9tICcuL2Fic3RyYWN0LXRyYW5zLXVuaXQnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMjMuMDIuMjAxNy5cclxuICogQWIgeGxpZmYgZmlsZSByZWFkIGZyb20gYSBzb3VyY2UgZmlsZS5cclxuICogRGVmaW5lcyBzb21lIHJlbGV2YW50IGdldCBhbmQgc2V0IG1ldGhvZCBmb3IgcmVhZGluZyBhbmQgbW9kaWZ5aW5nIHN1Y2ggYSBmaWxlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZkZpbGUgZXh0ZW5kcyBBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIGltcGxlbWVudHMgSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiB4bGYtRmlsZSBmcm9tIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSB4bWxTdHJpbmcgc291cmNlIHJlYWQgZnJvbSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHBhdGggUGF0aCB0byBmaWxlXHJcbiAgICAgKiBAcGFyYW0gZW5jb2Rpbmcgb3B0aW9uYWwgZW5jb2Rpbmcgb2YgdGhlIHhtbC5cclxuICAgICAqIFRoaXMgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLCBidXQgaWYgeW91IGtub3cgaXQgYmVmb3JlLCB5b3UgY2FuIGF2b2lkIHJlYWRpbmcgdGhlIGZpbGUgdHdpY2UuXHJcbiAgICAgKiBAcmV0dXJuIFhsaWZmRmlsZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih4bWxTdHJpbmc6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl93YXJuaW5ncyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mVHJhbnNVbml0c1dpdGhNaXNzaW5nSWQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZyb21Db250ZW50KHhtbFN0cmluZywgcGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZUZyb21Db250ZW50KHhtbFN0cmluZzogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpOiBYbGlmZkZpbGUge1xyXG4gICAgICAgIHRoaXMucGFyc2VDb250ZW50KHhtbFN0cmluZywgcGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIGNvbnN0IHhsaWZmTGlzdCA9IHRoaXMuX3BhcnNlZERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd4bGlmZicpO1xyXG4gICAgICAgIGlmICh4bGlmZkxpc3QubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0ZpbGUgXCIlc1wiIHNlZW1zIHRvIGJlIG5vIHhsaWZmIGZpbGUgKHNob3VsZCBjb250YWluIGFuIHhsaWZmIGVsZW1lbnQpJywgcGF0aCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB4bGlmZkxpc3QuaXRlbSgwKS5nZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nKTtcclxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWZXJzaW9uID0gJzEuMic7XHJcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uICE9PSBleHBlY3RlZFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0ZpbGUgXCIlc1wiIHNlZW1zIHRvIGJlIG5vIHhsaWZmIDEuMiBmaWxlLCB2ZXJzaW9uIHNob3VsZCBiZSAlcywgZm91bmQgJXMnLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsIGV4cGVjdGVkVmVyc2lvbiwgdmVyc2lvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsZSBmb3JtYXQgYXMgaXQgaXMgdXNlZCBpbiBjb25maWcgZmlsZXMuXHJcbiAgICAgKiBDdXJyZW50bHkgJ3hsZicsICd4bWInLCAneG1iMidcclxuICAgICAqIFJldHVybnMgb25lIG9mIHRoZSBjb25zdGFudHMgRk9STUFUXy4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpMThuRm9ybWF0KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIEZPUk1BVF9YTElGRjEyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsZSB0eXBlLlxyXG4gICAgICogSGVyZSAnWExJRkYgMS4yJ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmlsZVR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gRklMRVRZUEVfWExJRkYxMjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiB0YWcgbmFtZXMgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBtaXhlZCBjb250ZW50LlxyXG4gICAgICogVGhlc2UgZWxlbWVudHMgd2lsbCBub3QgYmUgYmVhdXRpZmllZC5cclxuICAgICAqIFR5cGljYWwgY2FuZGlkYXRlcyBhcmUgc291cmNlIGFuZCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBlbGVtZW50c1dpdGhNaXhlZENvbnRlbnQoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiBbJ3NvdXJjZScsICd0YXJnZXQnLCAndG9vbCcsICdzZWctc291cmNlJywgJ2cnLCAncGgnLCAnYnB0JywgJ2VwdCcsICdpdCcsICdzdWInLCAnbXJrJ107XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVUcmFuc1VuaXRzKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNVbml0cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zVW5pdHNJbkZpbGUgPSB0aGlzLl9wYXJzZWREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHJhbnMtdW5pdCcpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNVbml0c0luRmlsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc3VuaXQgPSB0cmFuc1VuaXRzSW5GaWxlLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdHJhbnN1bml0LmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuICAgICAgICAgICAgaWYgKCFpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2FybmluZ3MucHVzaChmb3JtYXQoJ29vcHMsIHRyYW5zLXVuaXQgd2l0aG91dCBcImlkXCIgZm91bmQgaW4gbWFzdGVyLCBwbGVhc2UgY2hlY2sgZmlsZSAlcycsIHRoaXMuX2ZpbGVuYW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFuc1VuaXRzLnB1c2gobmV3IFhsaWZmVHJhbnNVbml0KHRyYW5zdW5pdCwgaWQsIHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICogQHJldHVybiBzb3VyY2UgbGFuZ3VhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VMYW5ndWFnZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGZpbGVFbGVtID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ2ZpbGUnKTtcclxuICAgICAgICBpZiAoZmlsZUVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbGVFbGVtLmdldEF0dHJpYnV0ZSgnc291cmNlLWxhbmd1YWdlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdCB0aGUgc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlIGxhbmd1YWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTb3VyY2VMYW5ndWFnZShsYW5ndWFnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgZmlsZUVsZW0gPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAnZmlsZScpO1xyXG4gICAgICAgIGlmIChmaWxlRWxlbSkge1xyXG4gICAgICAgICAgICBmaWxlRWxlbS5zZXRBdHRyaWJ1dGUoJ3NvdXJjZS1sYW5ndWFnZScsIGxhbmd1YWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICogQHJldHVybiB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRMYW5ndWFnZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGZpbGVFbGVtID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ2ZpbGUnKTtcclxuICAgICAgICBpZiAoZmlsZUVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbGVFbGVtLmdldEF0dHJpYnV0ZSgndGFyZ2V0LWxhbmd1YWdlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdCB0aGUgdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlIGxhbmd1YWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUYXJnZXRMYW5ndWFnZShsYW5ndWFnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgZmlsZUVsZW0gPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAnZmlsZScpO1xyXG4gICAgICAgIGlmIChmaWxlRWxlbSkge1xyXG4gICAgICAgICAgICBmaWxlRWxlbS5zZXRBdHRyaWJ1dGUoJ3RhcmdldC1sYW5ndWFnZScsIGxhbmd1YWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBuZXcgdHJhbnMtdW5pdCB0byB0aGlzIGZpbGUuXHJcbiAgICAgKiBUaGUgdHJhbnMgdW5pdCBzdGVtcyBmcm9tIGFub3RoZXIgZmlsZS5cclxuICAgICAqIEl0IGNvcGllcyB0aGUgc291cmNlIGNvbnRlbnQgb2YgdGhlIHR1IHRvIHRoZSB0YXJnZXQgY29udGVudCB0b28sXHJcbiAgICAgKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiBpc0RlZmF1bHRMYW5nIGFuZCBjb3B5Q29udGVudC5cclxuICAgICAqIFNvIHRoZSBzb3VyY2UgY2FuIGJlIHVzZWQgYXMgYSBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqICh1c2VkIGJ5IHhsaWZmbWVyZ2UpXHJcbiAgICAgKiBAcGFyYW0gZm9yZWlnblRyYW5zVW5pdCB0aGUgdHJhbnMgdW5pdCB0byBiZSBpbXBvcnRlZC5cclxuICAgICAqIEBwYXJhbSBpc0RlZmF1bHRMYW5nIEZsYWcsIHdldGhlciBmaWxlIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGxhbmd1YWdlLlxyXG4gICAgICogVGhlbiBzb3VyY2UgYW5kIHRhcmdldCBhcmUganVzdCBlcXVhbC5cclxuICAgICAqIFRoZSBjb250ZW50IHdpbGwgYmUgY29waWVkLlxyXG4gICAgICogU3RhdGUgd2lsbCBiZSBmaW5hbC5cclxuICAgICAqIEBwYXJhbSBjb3B5Q29udGVudCBGbGFnLCB3ZXRoZXIgdG8gY29weSBjb250ZW50IG9yIGxlYXZlIGl0IGVtcHR5LlxyXG4gICAgICogV2JlbiB0cnVlLCBjb250ZW50IHdpbGwgYmUgY29waWVkIGZyb20gc291cmNlLlxyXG4gICAgICogV2hlbiBmYWxzZSwgY29udGVudCB3aWxsIGJlIGxlZnQgZW1wdHkgKGlmIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBsYW5ndWFnZSkuXHJcbiAgICAgKiBAcGFyYW0gaW1wb3J0QWZ0ZXJFbGVtZW50IG9wdGlvbmFsIChzaW5jZSAxLjEwKSBvdGhlciB0cmFuc3VuaXQgKHBhcnQgb2YgdGhpcyBmaWxlKSwgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBhbmNlc3Rvci5cclxuICAgICAqIE5ld2x5IGltcG9ydGVkIHRyYW5zIHVuaXQgaXMgdGhlbiBpbnNlcnRlZCBkaXJlY3RseSBhZnRlciB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBJZiBub3Qgc2V0IG9yIG5vdCBwYXJ0IG9mIHRoaXMgZmlsZSwgbmV3IHVuaXQgd2lsbCBiZSBpbXBvcnRlZCBhdCB0aGUgZW5kLlxyXG4gICAgICogSWYgZXhwbGljaXR5IHNldCB0byBudWxsLCBuZXcgdW5pdCB3aWxsIGJlIGltcG9ydGVkIGF0IHRoZSBzdGFydC5cclxuICAgICAqIEByZXR1cm4gdGhlIG5ld2x5IGltcG9ydGVkIHRyYW5zIHVuaXQgKHNpbmNlIHZlcnNpb24gMS43LjApXHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yIGlmIHRyYW5zLXVuaXQgd2l0aCBzYW1lIGlkIGFscmVhZHkgaXMgaW4gdGhlIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIGltcG9ydE5ld1RyYW5zVW5pdChmb3JlaWduVHJhbnNVbml0OiBJVHJhbnNVbml0LCBpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbiwgaW1wb3J0QWZ0ZXJFbGVtZW50PzogSVRyYW5zVW5pdClcclxuICAgICAgICA6IElUcmFuc1VuaXQge1xyXG4gICAgICAgIGlmICh0aGlzLnRyYW5zVW5pdFdpdGhJZChmb3JlaWduVHJhbnNVbml0LmlkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCd0dSB3aXRoIGlkICVzIGFscmVhZHkgZXhpc3RzIGluIGZpbGUsIGNhbm5vdCBpbXBvcnQgaXQnLCBmb3JlaWduVHJhbnNVbml0LmlkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1R1ID0gKDxBYnN0cmFjdFRyYW5zVW5pdD4gZm9yZWlnblRyYW5zVW5pdCkuY2xvbmVXaXRoU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZywgY29weUNvbnRlbnQsIHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IGJvZHlFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ2JvZHknKTtcclxuICAgICAgICBpZiAoIWJvZHlFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0ZpbGUgXCIlc1wiIHNlZW1zIHRvIGJlIG5vIHhsaWZmIDEuMiBmaWxlIChzaG91bGQgY29udGFpbiBhIGJvZHkgZWxlbWVudCknLCB0aGlzLl9maWxlbmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaW5zZXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgaXNBZnRlckVsZW1lbnRQYXJ0T2ZGaWxlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCEhaW1wb3J0QWZ0ZXJFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc2VydGlvblBvaW50ID0gdGhpcy50cmFuc1VuaXRXaXRoSWQoaW1wb3J0QWZ0ZXJFbGVtZW50LmlkKTtcclxuICAgICAgICAgICAgaWYgKCEhaW5zZXJ0aW9uUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIGlzQWZ0ZXJFbGVtZW50UGFydE9mRmlsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGltcG9ydEFmdGVyRWxlbWVudCA9PT0gdW5kZWZpbmVkIHx8IChpbXBvcnRBZnRlckVsZW1lbnQgJiYgIWlzQWZ0ZXJFbGVtZW50UGFydE9mRmlsZSkpIHtcclxuICAgICAgICAgICAgYm9keUVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3VHUuYXNYbWxFbGVtZW50KCkpO1xyXG4gICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRBZnRlckVsZW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3RVbml0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fcGFyc2VkRG9jdW1lbnQsICd0cmFucy11bml0Jyk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdFVuaXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMuaW5zZXJ0QmVmb3JlKG5ld1R1LmFzWG1sRWxlbWVudCgpLCBmaXJzdFVuaXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIHRyYW5zLXVuaXQsIGVtcHR5IGZpbGUsIHNvIGFkZCB0byBib2R5XHJcbiAgICAgICAgICAgICAgICBib2R5RWxlbWVudC5hcHBlbmRDaGlsZChuZXdUdS5hc1htbEVsZW1lbnQoKSk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZWZVbml0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRFbGVtZW50QnlUYWdOYW1lQW5kSWQodGhpcy5fcGFyc2VkRG9jdW1lbnQsICd0cmFucy11bml0JywgaW1wb3J0QWZ0ZXJFbGVtZW50LmlkKTtcclxuICAgICAgICAgICAgaWYgKHJlZlVuaXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMuaW5zZXJ0QWZ0ZXIobmV3VHUuYXNYbWxFbGVtZW50KCksIHJlZlVuaXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zZXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXp5SW5pdGlhbGl6ZVRyYW5zVW5pdHMoKTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc1VuaXRzLnB1c2gobmV3VHUpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50TnVtYmVycygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3VHU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zbGF0aW9uIGZpbGUgZm9yIHRoaXMgZmlsZSBmb3IgYSBnaXZlbiBsYW5ndWFnZS5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGp1c3QgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvbmUuXHJcbiAgICAgKiBCdXQgZm9yIFhNQiB0aGUgdHJhbnNsYXRpb24gZmlsZSBoYXMgZm9ybWF0ICdYVEInLlxyXG4gICAgICogQHBhcmFtIGxhbmcgTGFuZ3VhZ2UgY29kZVxyXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIGV4cGVjdGVkIGZpbGVuYW1lIHRvIHN0b3JlIGZpbGVcclxuICAgICAqIEBwYXJhbSBpc0RlZmF1bHRMYW5nIEZsYWcsIHdldGhlciBmaWxlIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGxhbmd1YWdlLlxyXG4gICAgICogVGhlbiBzb3VyY2UgYW5kIHRhcmdldCBhcmUganVzdCBlcXVhbC5cclxuICAgICAqIFRoZSBjb250ZW50IHdpbGwgYmUgY29waWVkLlxyXG4gICAgICogU3RhdGUgd2lsbCBiZSBmaW5hbC5cclxuICAgICAqIEBwYXJhbSBjb3B5Q29udGVudCBGbGFnLCB3ZXRoZXIgdG8gY29weSBjb250ZW50IG9yIGxlYXZlIGl0IGVtcHR5LlxyXG4gICAgICogV2JlbiB0cnVlLCBjb250ZW50IHdpbGwgYmUgY29waWVkIGZyb20gc291cmNlLlxyXG4gICAgICogV2hlbiBmYWxzZSwgY29udGVudCB3aWxsIGJlIGxlZnQgZW1wdHkgKGlmIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBsYW5ndWFnZSkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nKGxhbmc6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZywgaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4pXHJcbiAgICAgICAgOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uRmlsZSA9IG5ldyBYbGlmZkZpbGUodGhpcy5lZGl0ZWRDb250ZW50KCksIGZpbGVuYW1lLCB0aGlzLmVuY29kaW5nKCkpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRmlsZS5zZXROZXdUcmFuc1VuaXRUYXJnZXRQcmFlZml4KHRoaXMudGFyZ2V0UHJhZWZpeCk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25GaWxlLnNldE5ld1RyYW5zVW5pdFRhcmdldFN1ZmZpeCh0aGlzLnRhcmdldFN1ZmZpeCk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25GaWxlLnNldFRhcmdldExhbmd1YWdlKGxhbmcpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRmlsZS5mb3JFYWNoVHJhbnNVbml0KCh0cmFuc1VuaXQ6IElUcmFuc1VuaXQpID0+IHtcclxuICAgICAgICAgICAgKDxBYnN0cmFjdFRyYW5zVW5pdD4gdHJhbnNVbml0KS51c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nLCBjb3B5Q29udGVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uRmlsZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge0Fic3RyYWN0TWVzc2FnZVBhcnNlcn0gZnJvbSAnLi9hYnN0cmFjdC1tZXNzYWdlLXBhcnNlcic7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7RE9NVXRpbGl0aWVzfSBmcm9tICcuL2RvbS11dGlsaXRpZXMnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1zdGFydC10YWcnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW5kLXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlcn0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXBsYWNlaG9sZGVyJztcclxuaW1wb3J0IHtUYWdNYXBwaW5nfSBmcm9tICcuL3RhZy1tYXBwaW5nJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydEVtcHR5VGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW1wdHktdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWZ9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1pY3UtbWVzc2FnZS1yZWYnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0LCBQYXJzZWRNZXNzYWdlUGFydFR5cGV9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydCc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRUZXh0fSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtdGV4dCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IHJvb2JtIG9uIDEwLjA1LjIwMTcuXHJcbiAqIEEgbWVzc2FnZSBwYXJzZXIgZm9yIFhNQlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFhtYk1lc3NhZ2VQYXJzZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VQYXJzZXIge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHRoaXMgZWxlbWVudCBub2RlLlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSBjaGlsZHJlbiBhcmUgZG9uZS5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50Tm9kZSBlbGVtZW50Tm9kZVxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZSB0byBiZSBhbHRlcmVkXHJcbiAgICAgKiBAcmV0dXJuIHRydWUsIGlmIGNoaWxkcmVuIHNob3VsZCBiZSBwcm9jZXNzZWQgdG9vLCBmYWxzZSBvdGhlcndpc2UgKGNoaWxkcmVuIGlnbm9yZWQgdGhlbilcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHByb2Nlc3NTdGFydEVsZW1lbnQoZWxlbWVudE5vZGU6IEVsZW1lbnQsIG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudE5vZGUudGFnTmFtZTtcclxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3BoJykge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgNCBkaWZmZXJlbnQgdXNhZ2VzIG9mIHBoIGVsZW1lbnQ6XHJcbiAgICAgICAgICAgIC8vIDEuIHBsYWNlaG9sZGVycyBhcmUgbGlrZSA8cGggbmFtZT1cIklOVEVSUE9MQVRJT05cIj48ZXg+SU5URVJQT0xBVElPTjwvZXg+PC9waD5cclxuICAgICAgICAgICAgLy8gb3IgPHBoIG5hbWU9XCJJTlRFUlBPTEFUSU9OXzFcIj48ZXg+SU5URVJQT0xBVElPTl8xPC9leD48L3BoPlxyXG4gICAgICAgICAgICAvLyAyLiBzdGFydCB0YWdzOlxyXG4gICAgICAgICAgICAvLyA8cGggbmFtZT1cIlNUQVJUX0xJTktcIj48ZXg+Jmx0O2EmZ3Q7PC9leD48L3BoPlxyXG4gICAgICAgICAgICAvLyAzLiBlbXB0eSB0YWdzOlxyXG4gICAgICAgICAgICAvLyA8cGggbmFtZT1cIlRBR19JTUdcIj48ZXg+Jmx0O2ltZyZndDs8L2V4PjwvcGg+XHJcbiAgICAgICAgICAgIC8vIDQuIElDVTpcclxuICAgICAgICAgICAgLy8gPHBoIG5hbWU9XCJJQ1VcIj48ZXg+SUNVPC9leD48L3BoPlxyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZWxlbWVudE5vZGUuZ2V0QXR0cmlidXRlKCduYW1lJyk7XHJcbiAgICAgICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHNob3VsZCBub3QgaGFwcGVuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnSU5URVJQT0xBVElPTicpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFyc2VQbGFjZWhvbGRlckluZGV4RnJvbU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZFBsYWNlaG9sZGVyKGluZGV4LCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gaWdub3JlIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdTVEFSVF8nKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFnID0gdGhpcy5wYXJzZVRhZ25hbWVGcm9tUGhFbGVtZW50KGVsZW1lbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkY291bnRlciA9IHRoaXMucGFyc2VJZENvdW50RnJvbU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRTdGFydFRhZyh0YWcsIGlkY291bnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGlnbm9yZSBjaGlsZHJlblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnQ0xPU0VfJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRoaXMucGFyc2VUYWduYW1lRnJvbVBoRWxlbWVudChlbGVtZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRFbmRUYWcodGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gaWdub3JlIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3IFRhZ01hcHBpbmcoKS5pc0VtcHR5VGFnUGxhY2Vob2xkZXJOYW1lKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eVRhZ05hbWUgPSBuZXcgVGFnTWFwcGluZygpLmdldFRhZ25hbWVGcm9tRW1wdHlUYWdQbGFjZWhvbGRlck5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZGNvdW50ZXIgPSB0aGlzLnBhcnNlSWRDb3VudEZyb21OYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRFbXB0eVRhZyhlbXB0eVRhZ05hbWUsIGlkY291bnRlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGlnbm9yZSBjaGlsZHJlblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnSUNVJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYXJzZUlDVU1lc3NhZ2VJbmRleEZyb21OYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRJQ1VNZXNzYWdlUmVmKGluZGV4LCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gaWdub3JlIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdzb3VyY2UnKSB7XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSBzb3VyY2VcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgSUNVIG1lc3NhZ2UgY29udGVudCBvZiB0aGUgbm9kZSwgaWYgaXQgaXMgYW4gSUNVIE1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBub2RlXHJcbiAgICAgKiBAcmV0dXJuIG1lc3NhZ2Ugb3IgbnVsbCwgaWYgaXQgaXMgbm8gSUNVIE1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBnZXRJQ1VNZXNzYWdlVGV4dChub2RlOiBOb2RlKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcclxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZmlyc3RDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgLy8gZmluZCBmaXJzdCBjaGlsZCB0aGF0IGlzIG5vIHNvdXJjZSBlbGVtZW50LlxyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSAhPT0gY2hpbGQuRUxFTUVOVF9OT0RFIHx8ICg8RWxlbWVudD4gY2hpbGQpLnRhZ05hbWUgIT09ICdzb3VyY2UnKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdENoaWxkID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBmaXJzdENoaWxkLlRFWFRfTk9ERSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lDVU1lc3NhZ2VTdGFydChmaXJzdENoaWxkLnRleHRDb250ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVRleHQgPSBET01VdGlsaXRpZXMuZ2V0WE1MQ29udGVudCg8RWxlbWVudD4gbm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkcm9wIDxzb3VyY2U+IGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVTb3VyY2U6IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJzxzb3VyY2VbXj5dKj4uKjwvc291cmNlPicsICdnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VUZXh0LnJlcGxhY2UocmVTb3VyY2UsICcnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VUZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgZW5kIG9mIHRoaXMgZWxlbWVudCBub2RlLlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYWZ0ZXIgYWxsIGNoaWxkcmVuIGFyZSBwcm9jZXNzZWQuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudE5vZGUgZWxlbWVudE5vZGVcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2UgdG8gYmUgYWx0ZXJlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcHJvY2Vzc0VuZEVsZW1lbnQoZWxlbWVudE5vZGU6IEVsZW1lbnQsIG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpIHtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGlkIGF0dHJpYnV0ZSBvZiB4IGVsZW1lbnQgYXMgcGxhY2Vob2xkZXIgaW5kZXguXHJcbiAgICAgKiBpZCBjYW4gYmUgXCJJTlRFUlBPTEFUSU9OXCIgb3IgXCJJTlRFUlBPTEFUSU9OX25cIlxyXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZVxyXG4gICAgICogQHJldHVybiBpZCBhcyBudW1iZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXJzZVBsYWNlaG9sZGVySW5kZXhGcm9tTmFtZShuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBpbmRleFN0cmluZyA9ICcnO1xyXG5cclxuICAgICAgICBpZiAobmFtZSA9PT0gJ0lOVEVSUE9MQVRJT04nKSB7XHJcbiAgICAgICAgICAgIGluZGV4U3RyaW5nID0gJzAnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZGV4U3RyaW5nID0gbmFtZS5zdWJzdHJpbmcoJ0lOVEVSUE9MQVRJT05fJy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGluZGV4U3RyaW5nLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBpZCBhdHRyaWJ1dGUgb2YgeCBlbGVtZW50IGFzIElDVSBtZXNzYWdlIHJlZiBpbmRleC5cclxuICAgICAqIGlkIGNhbiBiZSBcIklDVVwiIG9yIFwiSUNVX25cIlxyXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZVxyXG4gICAgICogQHJldHVybiBpZCBhcyBudW1iZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXJzZUlDVU1lc3NhZ2VJbmRleEZyb21OYW1lKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IGluZGV4U3RyaW5nID0gJyc7XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09PSAnSUNVJykge1xyXG4gICAgICAgICAgICBpbmRleFN0cmluZyA9ICcwJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbmRleFN0cmluZyA9IG5hbWUuc3Vic3RyaW5nKCdJQ1VfJy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGluZGV4U3RyaW5nLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSB0aGUgdGFnIG5hbWUgZnJvbSBhIHBoIGVsZW1lbnQuXHJcbiAgICAgKiBJdCBjb250YWluZWQgaW4gdGhlIDxleD4gc3ViZWxlbWVudHMgdmFsdWUgYW5kIGVuY2xvc2VkIGluIDw+LlxyXG4gICAgICogRXhhbXBsZTogPHBoIG5hbWU9XCJTVEFSVF9CT0xEX1RFWFRcIj48ZXg+Jmx0O2ImZ3Q7PC9leD48L3BoPlxyXG4gICAgICogQHBhcmFtIHBoRWxlbWVudCBwaEVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXJzZVRhZ25hbWVGcm9tUGhFbGVtZW50KHBoRWxlbWVudDogRWxlbWVudCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgZXhFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZShwaEVsZW1lbnQsICdleCcpO1xyXG4gICAgICAgIGlmIChleEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBET01VdGlsaXRpZXMuZ2V0UENEQVRBKGV4RWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmICghdmFsdWUgfHwgIXZhbHVlLnN0YXJ0c1dpdGgoJzwnKSB8fCAhdmFsdWUuZW5kc1dpdGgoJz4nKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gb29wc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgxKSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDIsIHZhbHVlLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWRkWG1sUmVwcmVzZW50YXRpb25Ub1Jvb3QobWVzc2FnZTogUGFyc2VkTWVzc2FnZSwgcm9vdEVsZW06IEVsZW1lbnQpIHtcclxuICAgICAgICBtZXNzYWdlLnBhcnRzKCkuZm9yRWFjaCgocGFydCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlBhcnQocGFydCwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJvb3RFbGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydCwgcm9vdEVsZW06IEVsZW1lbnQpOiBOb2RlIHtcclxuICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5URVhUOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlRleHRQYXJ0KDxQYXJzZWRNZXNzYWdlUGFydFRleHQ+IHBhcnQsIHJvb3RFbGVtKTtcclxuICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuU1RBUlRfVEFHOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlN0YXJ0VGFnUGFydCgoPFBhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWc+cGFydCksIHJvb3RFbGVtKTtcclxuICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuRU5EX1RBRzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZFbmRUYWdQYXJ0KCg8UGFyc2VkTWVzc2FnZVBhcnRFbmRUYWc+cGFydCksIHJvb3RFbGVtKTtcclxuICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuRU1QVFlfVEFHOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVtcHR5VGFnUGFydCgoPFBhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWc+cGFydCksIHJvb3RFbGVtKTtcclxuICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuUExBQ0VIT0xERVI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mUGxhY2Vob2xkZXJQYXJ0KCg8UGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlcj5wYXJ0KSwgcm9vdEVsZW0pO1xyXG4gICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5JQ1VfTUVTU0FHRV9SRUY6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mSUNVTWVzc2FnZVJlZlBhcnQoKDxQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWY+cGFydCksIHJvb3RFbGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIHN0YXJ0IHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gPHBoPi1FbGVtZW50IHdpdGggYXR0cmlidXRlIG5hbWUgYW5kIHN1YmVsZW1lbnQgZXhcclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlN0YXJ0VGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHBoRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGgnKTtcclxuICAgICAgICBjb25zdCB0YWdNYXBwaW5nID0gbmV3IFRhZ01hcHBpbmcoKTtcclxuICAgICAgICBjb25zdCBuYW1lQXR0cmliID0gdGFnTWFwcGluZy5nZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZShwYXJ0LnRhZ05hbWUoKSwgcGFydC5pZENvdW50ZXIoKSk7XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnbmFtZScsIG5hbWVBdHRyaWIpO1xyXG4gICAgICAgIGNvbnN0IGV4RWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZXgnKTtcclxuICAgICAgICBleEVsZW0uYXBwZW5kQ2hpbGQocm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnPCcgKyBwYXJ0LnRhZ05hbWUoKSArICc+JykpO1xyXG4gICAgICAgIHBoRWxlbS5hcHBlbmRDaGlsZChleEVsZW0pO1xyXG4gICAgICAgIHJldHVybiBwaEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGVuZCB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBSZXR1cm5zIGFuIDxwaD4tRWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBuYW1lIGFuZCBzdWJlbGVtZW50IGV4XHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZFbmRUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHBoRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGgnKTtcclxuICAgICAgICBjb25zdCB0YWdNYXBwaW5nID0gbmV3IFRhZ01hcHBpbmcoKTtcclxuICAgICAgICBjb25zdCBuYW1lQXR0cmliID0gdGFnTWFwcGluZy5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZShwYXJ0LnRhZ05hbWUoKSk7XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnbmFtZScsIG5hbWVBdHRyaWIpO1xyXG4gICAgICAgIGNvbnN0IGV4RWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZXgnKTtcclxuICAgICAgICBleEVsZW0uYXBwZW5kQ2hpbGQocm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnPC8nICsgcGFydC50YWdOYW1lKCkgKyAnPicpKTtcclxuICAgICAgICBwaEVsZW0uYXBwZW5kQ2hpbGQoZXhFbGVtKTtcclxuICAgICAgICByZXR1cm4gcGhFbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBlbXB0eSB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBSZXR1cm5zIGFuIDxwaD4tRWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBuYW1lIGFuZCBzdWJlbGVtZW50IGV4XHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZFbXB0eVRhZ1BhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRFbXB0eVRhZywgcm9vdEVsZW06IEVsZW1lbnQpOiBOb2RlIHtcclxuICAgICAgICBjb25zdCBwaEVsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BoJyk7XHJcbiAgICAgICAgY29uc3QgdGFnTWFwcGluZyA9IG5ldyBUYWdNYXBwaW5nKCk7XHJcbiAgICAgICAgY29uc3QgbmFtZUF0dHJpYiA9IHRhZ01hcHBpbmcuZ2V0RW1wdHlUYWdQbGFjZWhvbGRlck5hbWUocGFydC50YWdOYW1lKCksIHBhcnQuaWRDb3VudGVyKCkpO1xyXG4gICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBuYW1lQXR0cmliKTtcclxuICAgICAgICBjb25zdCBleEVsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2V4Jyk7XHJcbiAgICAgICAgZXhFbGVtLmFwcGVuZENoaWxkKHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzwnICsgcGFydC50YWdOYW1lKCkgKyAnPicpKTtcclxuICAgICAgICBwaEVsZW0uYXBwZW5kQ2hpbGQoZXhFbGVtKTtcclxuICAgICAgICByZXR1cm4gcGhFbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBwbGFjZWhvbGRlciBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gPHBoPi1FbGVtZW50IHdpdGggYXR0cmlidXRlIG5hbWUgYW5kIHN1YmVsZW1lbnQgZXhcclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlBsYWNlaG9sZGVyUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHBoRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGgnKTtcclxuICAgICAgICBsZXQgbmFtZUF0dHJpYiA9ICdJTlRFUlBPTEFUSU9OJztcclxuICAgICAgICBpZiAocGFydC5pbmRleCgpID4gMCkge1xyXG4gICAgICAgICAgICBuYW1lQXR0cmliID0gJ0lOVEVSUE9MQVRJT05fJyArIHBhcnQuaW5kZXgoKS50b1N0cmluZygxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBuYW1lQXR0cmliKTtcclxuICAgICAgICBjb25zdCBleEVsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2V4Jyk7XHJcbiAgICAgICAgZXhFbGVtLmFwcGVuZENoaWxkKHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmFtZUF0dHJpYikpO1xyXG4gICAgICAgIHBoRWxlbS5hcHBlbmRDaGlsZChleEVsZW0pO1xyXG4gICAgICAgIHJldHVybiBwaEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGljdSBtZXNzYWdlIHJlZnMgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZJQ1VNZXNzYWdlUmVmUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWYsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgcGhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwaCcpO1xyXG4gICAgICAgIGxldCBuYW1lQXR0cmliID0gJ0lDVSc7XHJcbiAgICAgICAgaWYgKHBhcnQuaW5kZXgoKSA+IDApIHtcclxuICAgICAgICAgICAgbmFtZUF0dHJpYiA9ICdJQ1VfJyArIHBhcnQuaW5kZXgoKS50b1N0cmluZygxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBuYW1lQXR0cmliKTtcclxuICAgICAgICBjb25zdCBleEVsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2V4Jyk7XHJcbiAgICAgICAgZXhFbGVtLmFwcGVuZENoaWxkKHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmFtZUF0dHJpYikpO1xyXG4gICAgICAgIHBoRWxlbS5hcHBlbmRDaGlsZChleEVsZW0pO1xyXG4gICAgICAgIHJldHVybiBwaEVsZW07XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4uL2FwaS9pLXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUnO1xyXG5pbXBvcnQge0lOb3JtYWxpemVkTWVzc2FnZX0gZnJvbSAnLi4vYXBpL2ktbm9ybWFsaXplZC1tZXNzYWdlJztcclxuaW1wb3J0IHtJVHJhbnNVbml0fSBmcm9tICcuLi9hcGkvaS10cmFucy11bml0JztcclxuaW1wb3J0IHtJTm90ZX0gZnJvbSAnLi4vYXBpL2ktbm90ZSc7XHJcbmltcG9ydCB7RE9NVXRpbGl0aWVzfSBmcm9tICcuL2RvbS11dGlsaXRpZXMnO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNVbml0fSBmcm9tICcuL2Fic3RyYWN0LXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge1htYk1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4veG1iLW1lc3NhZ2UtcGFyc2VyJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXInO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMDEuMDUuMjAxNy5cclxuICogQSBUcmFuc2xhdGlvbiBVbml0IGluIGFuIFhNQiBmaWxlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbWJUcmFuc1VuaXQgZXh0ZW5kcyBBYnN0cmFjdFRyYW5zVW5pdCBpbXBsZW1lbnRzIElUcmFuc1VuaXQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50OiBFbGVtZW50LCBfaWQ6IHN0cmluZywgX3RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpIHtcclxuICAgICAgICBzdXBlcihfZWxlbWVudCwgX2lkLCBfdHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHNvbWV0aGluZyBsaWtlICdjOlxceHh4OjcnIGFuZCByZXR1cm5zIHNvdXJjZSBhbmQgbGluZW51bWJlci5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VBbmRQb3Mgc29tZXRoaW5nIGxpa2UgJ2M6XFx4eHg6NycsIGxhc3QgY29sb24gaXMgdGhlIHNlcGFyYXRvclxyXG4gICAgICogQHJldHVybiBzb3VyY2UgYW5kIGxpbmVudW1iZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VTb3VyY2VBbmRQb3Moc291cmNlQW5kUG9zOiBzdHJpbmcpOiB7IHNvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlciB9IHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHNvdXJjZUFuZFBvcy5sYXN0SW5kZXhPZignOicpO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZWZpbGU6IHNvdXJjZUFuZFBvcyxcclxuICAgICAgICAgICAgICAgIGxpbmVudW1iZXI6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc291cmNlZmlsZTogc291cmNlQW5kUG9zLnN1YnN0cmluZygwLCBpbmRleCksXHJcbiAgICAgICAgICAgICAgICBsaW5lbnVtYmVyOiBYbWJUcmFuc1VuaXQucGFyc2VMaW5lTnVtYmVyKHNvdXJjZUFuZFBvcy5zdWJzdHJpbmcoaW5kZXggKyAxKSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VMaW5lTnVtYmVyKGxpbmVOdW1iZXJTdHJpbmc6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChsaW5lTnVtYmVyU3RyaW5nLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgY29udGVudCB0byB0cmFuc2xhdGUuXHJcbiAgICAgKiBTb3VyY2UgcGFydHMgYXJlIGV4Y2x1ZGVkIGhlcmUuXHJcbiAgICAgKiBAcmV0dXJuIHNvdXJjZSBjb250ZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VDb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IG1zZ0NvbnRlbnQgPSBET01VdGlsaXRpZXMuZ2V0WE1MQ29udGVudCh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgICBjb25zdCByZVNvdXJjZUVsZW06IFJlZ0V4cCA9IC88c291cmNlPi4qPFxcL3NvdXJjZT4vZztcclxuICAgICAgICBtc2dDb250ZW50ID0gbXNnQ29udGVudC5yZXBsYWNlKHJlU291cmNlRWxlbSwgJycpO1xyXG4gICAgICAgIHJldHVybiBtc2dDb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2Ygc291cmNlIGNvbnRlbnQgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXRTb3VyY2VDb250ZW50IGluIHRyYW5zLXVuaXQgd2lsbCBkbyBub3RoaW5nLlxyXG4gICAgICogeHRiIGRvZXMgbm90IHN1cHBvcnQgdGhpcywgYWxsIG90aGVyIGZvcm1hdHMgZG8uXHJcbiAgICAgKi9cclxuICAgIHN1cHBvcnRzU2V0U291cmNlQ29udGVudCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbmV3IHNvdXJjZSBjb250ZW50IGluIHRoZSB0cmFuc3VuaXQuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBkb25lIGJ5IG5nLWV4dHJhY3QuXHJcbiAgICAgKiBNZXRob2Qgb25seSBleGlzdHMgdG8gYWxsb3cgeGxpZmZtZXJnZSB0byBtZXJnZSBtaXNzaW5nIGNoYW5nZWQgc291cmNlIGNvbnRlbnQuXHJcbiAgICAgKiBAcGFyYW0gbmV3Q29udGVudCB0aGUgbmV3IGNvbnRlbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTb3VyY2VDb250ZW50KG5ld0NvbnRlbnQ6IHN0cmluZykge1xyXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHBhcnNlciB1c2VkIGZvciBub3JtYWxpemVkIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWVzc2FnZVBhcnNlcigpOiBBYnN0cmFjdE1lc3NhZ2VQYXJzZXIge1xyXG4gICAgICAgIHJldHVybiBuZXcgWG1iTWVzc2FnZVBhcnNlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWdpbmFsIHRleHQgdmFsdWUsIHRoYXQgaXMgdG8gYmUgdHJhbnNsYXRlZCwgYXMgbm9ybWFsaXplZCBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlU291cmNlQ29udGVudE5vcm1hbGl6ZWQoKTogUGFyc2VkTWVzc2FnZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZVBhcnNlcigpLmNyZWF0ZU5vcm1hbGl6ZWRNZXNzYWdlRnJvbVhNTCh0aGlzLl9lbGVtZW50LCBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB0cmFuc2xhdGVkIHZhbHVlIChjb250YWluaW5nIGFsbCBtYXJrdXAsIGRlcGVuZHMgb24gdGhlIGNvbmNyZXRlIGZvcm1hdCB1c2VkKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldENvbnRlbnQoKTogc3RyaW5nIHtcclxuICAgICAgICAvLyBpbiBmYWN0LCB0YXJnZXQgYW5kIHNvdXJjZSBhcmUganVzdCB0aGUgc2FtZSBpbiB4bWJcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VDb250ZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgdHJhbnNsYXRlZCB2YWx1ZSwgYnV0IGFsbCBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGgge3tufX0gKHN0YXJ0aW5nIGF0IDApXHJcbiAgICAgKiBhbmQgYWxsIGVtYmVkZGVkIGh0bWwgaXMgcmVwbGFjZWQgYnkgZGlyZWN0IGh0bWwgbWFya3VwLlxyXG4gICAgICovXHJcbiAgICB0YXJnZXRDb250ZW50Tm9ybWFsaXplZCgpOiBJTm9ybWFsaXplZE1lc3NhZ2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgWG1iTWVzc2FnZVBhcnNlcigpLmNyZWF0ZU5vcm1hbGl6ZWRNZXNzYWdlRnJvbVhNTCh0aGlzLl9lbGVtZW50LCB0aGlzLnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGUgb2YgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogKG5vdCBzdXBwb3J0ZWQgaW4geG1iKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmF0aXZlVGFyZ2V0U3RhdGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gbm90IHN1cHBvcnRlZCBpbiB4bWJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBhbiBhYnN0cmFjdCBzdGF0ZSAobmV3LCB0cmFuc2xhdGVkLCBmaW5hbCkgdG8gYSBjb25jcmV0ZSBzdGF0ZSB1c2VkIGluIHRoZSB4bWwuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSB0byBiZSB1c2VkIGluIHRoZSB4bWwuXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgb25lIG9mIENvbnN0YW50cy5TVEFURS4uLlxyXG4gICAgICogQHJldHVybnMgYSBuYXRpdmUgc3RhdGUgKGRlcGVuZHMgb24gY29uY3JldGUgZm9ybWF0KVxyXG4gICAgICogQHRocm93cyBlcnJvciwgaWYgc3RhdGUgaXMgaW52YWxpZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1hcFN0YXRlVG9OYXRpdmVTdGF0ZShzdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgYSBuYXRpdmUgc3RhdGUgKGZvdW5kIGluIHRoZSBkb2N1bWVudCkgdG8gYW4gYWJzdHJhY3Qgc3RhdGUgKG5ldywgdHJhbnNsYXRlZCwgZmluYWwpLlxyXG4gICAgICogUmV0dXJucyB0aGUgYWJzdHJhY3Qgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gbmF0aXZlU3RhdGUgbmF0aXZlU3RhdGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1hcE5hdGl2ZVN0YXRlVG9TdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gbmF0aXZlU3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgc3RhdGUgaW4geG1sLlxyXG4gICAgICogKG5vdCBzdXBwb3J0ZWQgaW4geG1iKVxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0YXRlIG5hdGl2ZVN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzZXROYXRpdmVUYXJnZXRTdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBmb3IgeG1iXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdGhlIHNvdXJjZSBlbGVtZW50cyBpbiB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqIFRoZSBzb3VyY2UgZWxlbWVudCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUgZmlsZSBhbmQgYSBsaW5lIG51bWJlciB3aXRoIHRoZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHRlbXBsYXRlLlxyXG4gICAgICogSXQgaXMganVzdCBhIGhlbHAgZm9yIHRyYW5zbGF0b3JzIHRvIGZpbmQgdGhlIGNvbnRleHQgZm9yIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIFRoaXMgaXMgc2V0IHdoZW4gdXNpbmcgQW5ndWxhciA0LjAgb3IgZ3JlYXRlci5cclxuICAgICAqIE90aGVyd2lzZSBpdCBqdXN0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VSZWZlcmVuY2VzKCk6IHsgc291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyOiBudW1iZXIgfVtdIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZVJlZnM6IHsgc291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyOiBudW1iZXIgfVtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtID0gc291cmNlRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlQW5kUG9zOiBzdHJpbmcgPSBET01VdGlsaXRpZXMuZ2V0UENEQVRBKGVsZW0pO1xyXG4gICAgICAgICAgICBzb3VyY2VSZWZzLnB1c2goWG1iVHJhbnNVbml0LnBhcnNlU291cmNlQW5kUG9zKHNvdXJjZUFuZFBvcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc291cmNlUmVmcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBzb3VyY2UgcmVmIGVsZW1lbnRzIGluIHRoZSB0cmFuc3VuaXQuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBkb25lIGJ5IG5nLWV4dHJhY3QuXHJcbiAgICAgKiBNZXRob2Qgb25seSBleGlzdHMgdG8gYWxsb3cgeGxpZmZtZXJnZSB0byBtZXJnZSBtaXNzaW5nIHNvdXJjZSByZWZzLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZVJlZnMgdGhlIHNvdXJjZXJlZnMgdG8gc2V0LiBPbGQgb25lcyBhcmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZVJlZmVyZW5jZXMoc291cmNlUmVmczoge3NvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyfVtdKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxTb3VyY2VSZWZlcmVuY2VzKCk7XHJcbiAgICAgICAgbGV0IGluc2VydFBvc2l0aW9uID0gdGhpcy5fZWxlbWVudC5jaGlsZE5vZGVzLml0ZW0oMCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHNvdXJjZVJlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVmID0gc291cmNlUmVmc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xyXG4gICAgICAgICAgICBzb3VyY2UuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJlZi5zb3VyY2VmaWxlICsgJzonICsgcmVmLmxpbmVudW1iZXIudG9TdHJpbmcoMTApKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgaW5zZXJ0UG9zaXRpb24pO1xyXG4gICAgICAgICAgICBpbnNlcnRQb3NpdGlvbiA9IHNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZW1vdmVBbGxTb3VyY2VSZWZlcmVuY2VzKCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcbiAgICAgICAgY29uc3QgdG9CZVJlbW92ZWQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBzb3VyY2VFbGVtZW50cy5pdGVtKGkpO1xyXG4gICAgICAgICAgICB0b0JlUmVtb3ZlZC5wdXNoKGVsZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b0JlUmVtb3ZlZC5mb3JFYWNoKChlbGVtKSA9PiB7ZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBzZXQgaW4gdGhlIHRlbXBsYXRlIGFzIHZhbHVlIG9mIHRoZSBpMThuLWF0dHJpYnV0ZS5cclxuICAgICAqIGUuZy4gaTE4bj1cIm15ZGVzY3JpcHRpb25cIi5cclxuICAgICAqIEluIHhtYiB0aGlzIGlzIHN0b3JlZCBpbiB0aGUgYXR0cmlidXRlIFwiZGVzY1wiLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rlc2MnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtZWFuaW5nIChpbnRlbnQpIHNldCBpbiB0aGUgdGVtcGxhdGUgYXMgdmFsdWUgb2YgdGhlIGkxOG4tYXR0cmlidXRlLlxyXG4gICAgICogVGhpcyBpcyB0aGUgcGFydCBpbiBmcm9udCBvZiB0aGUgfCBzeW1ib2wuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJtZWFuaW5nfG15ZGVzY3JpcHRpb25cIi5cclxuICAgICAqIEluIHhtYiB0aGlzIGlzIHN0b3JlZCBpbiB0aGUgYXR0cmlidXRlIFwibWVhbmluZ1wiLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWVhbmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWVhbmluZycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2YgZGVzY3JpcHRpb24gYW5kIG1lYW5pbmcgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXREZXNjcmlwdGlvbiBhbmQgc2V0TWVhbmluZyB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1cHBvcnRzU2V0RGVzY3JpcHRpb25BbmRNZWFuaW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBkZXNjcmlwdGlvbiBwcm9wZXJ0eSBvZiB0cmFucy11bml0LlxyXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uIGRlc2NyaXB0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXREZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCwgZG8gbm90aGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIG1lYW5pbmcgcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSBtZWFuaW5nIG1lYW5pbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldE1lYW5pbmcobWVhbmluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCwgZG8gbm90aGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBub3RlcyBvZiB0aGUgdHJhbnMtdW5pdC5cclxuICAgICAqIFRoZXJlIGFyZSBOTyBub3RlcyBpbiB4bWIveHRiXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3RlcygpOiBJTm90ZVtdIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBub3RlcyBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldE5vdGVzIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTZXROb3RlcygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgbm90ZXMgdG8gdHJhbnMgdW5pdC5cclxuICAgICAqIEBwYXJhbSBuZXdOb3RlcyB0aGUgbm90ZXMgdG8gYWRkLlxyXG4gICAgICogTk9UIFN1cHBvcnRlZCBpbiB4bWIveHRiXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXROb3RlcyhuZXdOb3RlczogSU5vdGVbXSkge1xyXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQsIGRvIG5vdGhpbmdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcHkgc291cmNlIHRvIHRhcmdldCB0byB1c2UgaXQgYXMgZHVtbXkgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBSZXR1cm5zIGEgY2hhbmdlZCBjb3B5IG9mIHRoaXMgdHJhbnMgdW5pdC5cclxuICAgICAqIHJlY2VpdmVyIGlzIG5vdCBjaGFuZ2VkLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGltcG9ydE5ld1RyYW5zVW5pdCBvbiBJVHJhbnNsYXRpb25NZXNzYWdlRmlsZSlcclxuICAgICAqIEluIHhtYiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvLCBiZWNhdXNlIHRoZXJlIGlzIG9ubHkgYSB0YXJnZXQsIG5vIHNvdXJjZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNsb25lV2l0aFNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuLCB0YXJnZXRGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpOiBBYnN0cmFjdFRyYW5zVW5pdCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbikge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdHJhbnNsYXRpb24gdG8gYSBnaXZlbiBzdHJpbmcgKGluY2x1ZGluZyBtYXJrdXApLlxyXG4gICAgICogSW4gZmFjdCwgeG1iIGNhbm5vdCBiZSB0cmFuc2xhdGVkLlxyXG4gICAgICogU28gdGhpcyB0aHJvd3MgYW4gZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNsYXRpb24gdHJhbnNsYXRpb25cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHRyYW5zbGF0ZU5hdGl2ZSh0cmFuc2xhdGlvbjogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHRyYW5zbGF0ZSB4bWIgZmlsZXMsIHVzZSB4dGIgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5fSBmcm9tICcuLi9hcGkvaS10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlLWZhY3RvcnknO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7SVRyYW5zVW5pdH0gZnJvbSAnLi4vYXBpL2ktdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7Rk9STUFUX1hNQiwgRklMRVRZUEVfWE1CLCBGT1JNQVRfWFRCfSBmcm9tICcuLi9hcGkvY29uc3RhbnRzJztcclxuaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge1htYlRyYW5zVW5pdH0gZnJvbSAnLi94bWItdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi9hYnN0cmFjdC10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxMC4wMy4yMDE3LlxyXG4gKiB4bWItRmlsZSBhY2Nlc3MuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIERvY3R5cGUgb2YgeHRiIHRyYW5zbGF0aW9uIGZpbGUgY29ycmVzcG9uZGluZyB3aXRoIHRob3MgeG1iIGZpbGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgWFRCX0RPQ1RZUEUgPSBgPCFET0NUWVBFIHRyYW5zbGF0aW9uYnVuZGxlIFtcclxuICA8IUVMRU1FTlQgdHJhbnNsYXRpb25idW5kbGUgKHRyYW5zbGF0aW9uKSo+XHJcbiAgPCFBVFRMSVNUIHRyYW5zbGF0aW9uYnVuZGxlIGxhbmcgQ0RBVEEgI1JFUVVJUkVEPlxyXG4gIDwhRUxFTUVOVCB0cmFuc2xhdGlvbiAoI1BDREFUQXxwaCkqPlxyXG4gIDwhQVRUTElTVCB0cmFuc2xhdGlvbiBpZCBDREFUQSAjUkVRVUlSRUQ+XHJcbiAgPCFFTEVNRU5UIHBoIEVNUFRZPlxyXG4gIDwhQVRUTElTVCBwaCBuYW1lIENEQVRBICNSRVFVSVJFRD5cclxuXT5gO1xyXG5cclxuZXhwb3J0IGNsYXNzIFhtYkZpbGUgZXh0ZW5kcyBBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIGltcGxlbWVudHMgSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiB4bWItRmlsZSBmcm9tIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSBfdHJhbnNsYXRpb25NZXNzYWdlRmlsZUZhY3RvcnkgZmFjdG9yeSB0byBjcmVhdGUgYSB0cmFuc2xhdGlvbiBmaWxlICh4dGIpIGZvciB0aGUgeG1iIGZpbGVcclxuICAgICAqIEBwYXJhbSB4bWxTdHJpbmcgZmlsZSBjb250ZW50XHJcbiAgICAgKiBAcGFyYW0gcGF0aCBQYXRoIHRvIGZpbGVcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyBvcHRpb25hbCBlbmNvZGluZyBvZiB0aGUgeG1sLlxyXG4gICAgICogVGhpcyBpcyByZWFkIGZyb20gdGhlIGZpbGUsIGJ1dCBpZiB5b3Uga25vdyBpdCBiZWZvcmUsIHlvdSBjYW4gYXZvaWQgcmVhZGluZyB0aGUgZmlsZSB0d2ljZS5cclxuICAgICAqIEByZXR1cm4gWG1iRmlsZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIF90cmFuc2xhdGlvbk1lc3NhZ2VGaWxlRmFjdG9yeTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeSxcclxuICAgICAgICB4bWxTdHJpbmc6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSB7XHJcblxyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fd2FybmluZ3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkID0gMDtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVGcm9tQ29udGVudCh4bWxTdHJpbmcsIHBhdGgsIGVuY29kaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGluaXRpYWxpemVGcm9tQ29udGVudCh4bWxTdHJpbmc6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKTogWG1iRmlsZSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZUNvbnRlbnQoeG1sU3RyaW5nLCBwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNlZERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdtZXNzYWdlYnVuZGxlJykubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0ZpbGUgXCIlc1wiIHNlZW1zIHRvIGJlIG5vIHhtYiBmaWxlIChzaG91bGQgY29udGFpbiBhIG1lc3NhZ2VidW5kbGUgZWxlbWVudCknLCBwYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBpbml0aWFsaXplVHJhbnNVbml0cygpIHtcclxuICAgICAgICB0aGlzLnRyYW5zVW5pdHMgPSBbXTtcclxuICAgICAgICBjb25zdCB0cmFuc1VuaXRzSW5GaWxlID0gdGhpcy5fcGFyc2VkRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ21zZycpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNVbml0c0luRmlsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0cmFuc1VuaXRzSW5GaWxlLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbXNnLmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuICAgICAgICAgICAgaWYgKCFpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2FybmluZ3MucHVzaChmb3JtYXQoJ29vcHMsIG1zZyB3aXRob3V0IFwiaWRcIiBmb3VuZCBpbiBtYXN0ZXIsIHBsZWFzZSBjaGVjayBmaWxlICVzJywgdGhpcy5fZmlsZW5hbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zVW5pdHMucHVzaChuZXcgWG1iVHJhbnNVbml0KG1zZywgaWQsIHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxlIGZvcm1hdCBhcyBpdCBpcyB1c2VkIGluIGNvbmZpZyBmaWxlcy5cclxuICAgICAqIEN1cnJlbnRseSAneGxmJywgJ3htYicsICd4bWIyJ1xyXG4gICAgICogUmV0dXJucyBvbmUgb2YgdGhlIGNvbnN0YW50cyBGT1JNQVRfLi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGkxOG5Gb3JtYXQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gRk9STUFUX1hNQjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGUgdHlwZS5cclxuICAgICAqIEhlcmUgJ1hNQidcclxuICAgICAqL1xyXG4gICAgcHVibGljIGZpbGVUeXBlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIEZJTEVUWVBFX1hNQjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiB0YWcgbmFtZXMgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBtaXhlZCBjb250ZW50LlxyXG4gICAgICogVGhlc2UgZWxlbWVudHMgd2lsbCBub3QgYmUgYmVhdXRpZmllZC5cclxuICAgICAqIFR5cGljYWwgY2FuZGlkYXRlcyBhcmUgc291cmNlIGFuZCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBlbGVtZW50c1dpdGhNaXhlZENvbnRlbnQoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiBbJ21lc3NhZ2UnXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEd1ZXNzIGxhbmd1YWdlIGZyb20gZmlsZW5hbWUuXHJcbiAgICAgKiBJZiBmaWxlbmFtZSBpcyBmb28ueHkueG1iLCB0aGFuIGxhbmd1YWdlIGlzIGFzc3VtZWQgdG8gYmUgeHkuXHJcbiAgICAgKiBAcmV0dXJuIExhbmd1YWdlIG9yIG51bGxcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBndWVzc0xhbmd1YWdlRnJvbUZpbGVuYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IHRoaXMuX2ZpbGVuYW1lLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAyICYmIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCkgPT09ICd4bWInKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydHNbcGFydHMubGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICogVW5zdXBwb3J0ZWQgaW4geG1iLlxyXG4gICAgICogVHJ5IHRvIGd1ZXNzIGl0IGZyb20gZmlsZW5hbWUgaWYgYW55Li5cclxuICAgICAqIEByZXR1cm4gc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc291cmNlTGFuZ3VhZ2UoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ndWVzc0xhbmd1YWdlRnJvbUZpbGVuYW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFZGl0IHRoZSBzb3VyY2UgbGFuZ3VhZ2UuXHJcbiAgICAgKiBVbnN1cHBvcnRlZCBpbiB4bWIuXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2UgbGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZUxhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nLCB4bWIgaGFzIG5vIG5vdGF0aW9uIGZvciB0aGlzLlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRhcmdldCBsYW5ndWFnZS5cclxuICAgICAqIFVuc3VwcG9ydGVkIGluIHhtYi5cclxuICAgICAqIFRyeSB0byBndWVzcyBpdCBmcm9tIGZpbGVuYW1lIGlmIGFueS4uXHJcbiAgICAgKiBAcmV0dXJuIHRhcmdldCBsYW5ndWFnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldExhbmd1YWdlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3Vlc3NMYW5ndWFnZUZyb21GaWxlbmFtZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdCB0aGUgdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICogVW5zdXBwb3J0ZWQgaW4geG1iLlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlIGxhbmd1YWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUYXJnZXRMYW5ndWFnZShsYW5ndWFnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZywgeG1iIGhhcyBubyBub3RhdGlvbiBmb3IgdGhpcy5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIG5ldyB0cmFucy11bml0IHRvIHRoaXMgZmlsZS5cclxuICAgICAqIFRoZSB0cmFucyB1bml0IHN0ZW1zIGZyb20gYW5vdGhlciBmaWxlLlxyXG4gICAgICogSXQgY29waWVzIHRoZSBzb3VyY2UgY29udGVudCBvZiB0aGUgdHUgdG8gdGhlIHRhcmdldCBjb250ZW50IHRvbyxcclxuICAgICAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIGlzRGVmYXVsdExhbmcgYW5kIGNvcHlDb250ZW50LlxyXG4gICAgICogU28gdGhlIHNvdXJjZSBjYW4gYmUgdXNlZCBhcyBhIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKHVzZWQgYnkgeGxpZmZtZXJnZSlcclxuICAgICAqIEBwYXJhbSBmb3JlaWduVHJhbnNVbml0IHRoZSB0cmFucyB1bml0IHRvIGJlIGltcG9ydGVkLlxyXG4gICAgICogQHBhcmFtIGlzRGVmYXVsdExhbmcgRmxhZywgd2V0aGVyIGZpbGUgY29udGFpbnMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBUaGVuIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBqdXN0IGVxdWFsLlxyXG4gICAgICogVGhlIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQuXHJcbiAgICAgKiBTdGF0ZSB3aWxsIGJlIGZpbmFsLlxyXG4gICAgICogQHBhcmFtIGNvcHlDb250ZW50IEZsYWcsIHdldGhlciB0byBjb3B5IGNvbnRlbnQgb3IgbGVhdmUgaXQgZW1wdHkuXHJcbiAgICAgKiBXYmVuIHRydWUsIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQgZnJvbSBzb3VyY2UuXHJcbiAgICAgKiBXaGVuIGZhbHNlLCBjb250ZW50IHdpbGwgYmUgbGVmdCBlbXB0eSAoaWYgaXQgaXMgbm90IHRoZSBkZWZhdWx0IGxhbmd1YWdlKS5cclxuICAgICAqIEBwYXJhbSBpbXBvcnRBZnRlckVsZW1lbnQgb3B0aW9uYWwgKHNpbmNlIDEuMTApIG90aGVyIHRyYW5zdW5pdCAocGFydCBvZiB0aGlzIGZpbGUpLCB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIGFuY2VzdG9yLlxyXG4gICAgICogTmV3bHkgaW1wb3J0ZWQgdHJhbnMgdW5pdCBpcyB0aGVuIGluc2VydGVkIGRpcmVjdGx5IGFmdGVyIHRoaXMgZWxlbWVudC5cclxuICAgICAqIElmIG5vdCBzZXQgb3Igbm90IHBhcnQgb2YgdGhpcyBmaWxlLCBuZXcgdW5pdCB3aWxsIGJlIGltcG9ydGVkIGF0IHRoZSBlbmQuXHJcbiAgICAgKiBJZiBleHBsaWNpdHkgc2V0IHRvIG51bGwsIG5ldyB1bml0IHdpbGwgYmUgaW1wb3J0ZWQgYXQgdGhlIHN0YXJ0LlxyXG4gICAgICogQHJldHVybiB0aGUgbmV3bHkgaW1wb3J0ZWQgdHJhbnMgdW5pdCAoc2luY2UgdmVyc2lvbiAxLjcuMClcclxuICAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdHJhbnMtdW5pdCB3aXRoIHNhbWUgaWQgYWxyZWFkeSBpcyBpbiB0aGUgZmlsZS5cclxuICAgICAqL1xyXG4gICAgaW1wb3J0TmV3VHJhbnNVbml0KGZvcmVpZ25UcmFuc1VuaXQ6IElUcmFuc1VuaXQsIGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuLCBpbXBvcnRBZnRlckVsZW1lbnQ/OiBJVHJhbnNVbml0KVxyXG4gICAgICAgIDogSVRyYW5zVW5pdCB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3htYiBmaWxlIGNhbm5vdCBiZSB1c2VkIHRvIHN0b3JlIHRyYW5zbGF0aW9ucywgdXNlIHh0YiBmaWxlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNsYXRpb24gZmlsZSBmb3IgdGhpcyBmaWxlIGZvciBhIGdpdmVuIGxhbmd1YWdlLlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMganVzdCBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9uZS5cclxuICAgICAqIEJ1dCBmb3IgWE1CIHRoZSB0cmFuc2xhdGlvbiBmaWxlIGhhcyBmb3JtYXQgJ1hUQicuXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBMYW5ndWFnZSBjb2RlXHJcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgZXhwZWN0ZWQgZmlsZW5hbWUgdG8gc3RvcmUgZmlsZVxyXG4gICAgICogQHBhcmFtIGlzRGVmYXVsdExhbmcgRmxhZywgd2V0aGVyIGZpbGUgY29udGFpbnMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBUaGVuIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBqdXN0IGVxdWFsLlxyXG4gICAgICogVGhlIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQuXHJcbiAgICAgKiBTdGF0ZSB3aWxsIGJlIGZpbmFsLlxyXG4gICAgICogQHBhcmFtIGNvcHlDb250ZW50IEZsYWcsIHdldGhlciB0byBjb3B5IGNvbnRlbnQgb3IgbGVhdmUgaXQgZW1wdHkuXHJcbiAgICAgKiBXYmVuIHRydWUsIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQgZnJvbSBzb3VyY2UuXHJcbiAgICAgKiBXaGVuIGZhbHNlLCBjb250ZW50IHdpbGwgYmUgbGVmdCBlbXB0eSAoaWYgaXQgaXMgbm90IHRoZSBkZWZhdWx0IGxhbmd1YWdlKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcobGFuZzogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nLCBpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbilcclxuICAgICAgICA6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25idW5kbGVYTUxTb3VyY2UgPVxyXG4gICAgICAgICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XFxuJyArIFhUQl9ET0NUWVBFICsgJ1xcbjx0cmFuc2xhdGlvbmJ1bmRsZT5cXG48L3RyYW5zbGF0aW9uYnVuZGxlPlxcbic7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25GaWxlID0gdGhpcy5fdHJhbnNsYXRpb25NZXNzYWdlRmlsZUZhY3RvcnkuY3JlYXRlRmlsZUZyb21GaWxlQ29udGVudChcclxuICAgICAgICAgICAgRk9STUFUX1hUQixcclxuICAgICAgICAgICAgdHJhbnNsYXRpb25idW5kbGVYTUxTb3VyY2UsIGZpbGVuYW1lLCB0aGlzLmVuY29kaW5nKCksXHJcbiAgICAgICAgICAgIHt4bWxDb250ZW50OiB0aGlzLmVkaXRlZENvbnRlbnQoKSwgcGF0aDogdGhpcy5maWxlbmFtZSgpLCBlbmNvZGluZzogdGhpcy5lbmNvZGluZygpfSk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25GaWxlLnNldE5ld1RyYW5zVW5pdFRhcmdldFByYWVmaXgodGhpcy50YXJnZXRQcmFlZml4KTtcclxuICAgICAgICB0cmFuc2xhdGlvbkZpbGUuc2V0TmV3VHJhbnNVbml0VGFyZ2V0U3VmZml4KHRoaXMudGFyZ2V0U3VmZml4KTtcclxuICAgICAgICB0cmFuc2xhdGlvbkZpbGUuc2V0VGFyZ2V0TGFuZ3VhZ2UobGFuZyk7XHJcbiAgICAgICAgdHJhbnNsYXRpb25GaWxlLnNldE5ld1RyYW5zVW5pdFRhcmdldFByYWVmaXgodGhpcy5nZXROZXdUcmFuc1VuaXRUYXJnZXRQcmFlZml4KCkpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRmlsZS5zZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgodGhpcy5nZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgoKSk7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoVHJhbnNVbml0KCh0dSkgPT4ge1xyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbkZpbGUuaW1wb3J0TmV3VHJhbnNVbml0KHR1LCBpc0RlZmF1bHRMYW5nLCBjb3B5Q29udGVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uRmlsZTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXInO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2V9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0U3RhcnRUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1zdGFydC10YWcnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW5kLXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlcn0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXBsYWNlaG9sZGVyJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFRleHR9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC10ZXh0JztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFR5cGV9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydCc7XHJcbmltcG9ydCB7VGFnTWFwcGluZ30gZnJvbSAnLi90YWctbWFwcGluZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRFbXB0eVRhZ30gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LWVtcHR5LXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlUmVmfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtaWN1LW1lc3NhZ2UtcmVmJztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMTAuMDUuMjAxNy5cclxuICogQSBtZXNzYWdlIHBhcnNlciBmb3IgWExJRkYgMi4wXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgWGxpZmYyTWVzc2FnZVBhcnNlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVBhcnNlciB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdGhpcyBlbGVtZW50IG5vZGUuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGNoaWxkcmVuIGFyZSBkb25lLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnROb2RlIGVsZW1lbnROb2RlXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlIHRvIGJlIGFsdGVyZWRcclxuICAgICAqIEByZXR1cm4gdHJ1ZSwgaWYgY2hpbGRyZW4gc2hvdWxkIGJlIHByb2Nlc3NlZCB0b28sIGZhbHNlIG90aGVyd2lzZSAoY2hpbGRyZW4gaWdub3JlZCB0aGVuKVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcHJvY2Vzc1N0YXJ0RWxlbWVudChlbGVtZW50Tm9kZTogRWxlbWVudCwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50Tm9kZS50YWdOYW1lO1xyXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAncGgnKSB7XHJcbiAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIGFyZSBsaWtlIDxwaCBpZD1cIjBcIiBlcXVpdj1cIklOVEVSUE9MQVRJT05cIiBkaXNwPVwie3tudW1iZXIoKX19XCIvPlxyXG4gICAgICAgICAgICAvLyBUaGV5IGNvbnRhaW4gdGhlIGlkIGFuZCBhbHNvIGEgbmFtZSAobnVtYmVyIGluIHRoZSBleGFtcGxlKVxyXG4gICAgICAgICAgICAvLyBUT0RPIG1ha2Ugc29tZSB1c2Ugb2YgdGhlIG5hbWUgKGJ1dCBpdCBpcyBub3QgYXZhaWxhYmxlIGluIFhMSUZGIDEuMilcclxuICAgICAgICAgICAgLy8gSUNVIG1lc3NhZ2UgYXJlIGhhbmRsZWQgd2l0aCB0aGUgc2FtZSB0YWdcclxuICAgICAgICAgICAgLy8gQmVmb3JlIDQuMy4yIHRoZXkgZGlkIG5vdCBoYXZlIGFuIGVxdWl2IGFuZCBkaXNwIChCdWcgIzE3MzQ0KTpcclxuICAgICAgICAgICAgLy8gZS5nLiA8cGggaWQ9XCIwXCIvPlxyXG4gICAgICAgICAgICAvLyBCZWdpbm5pbmcgd2l0aCA0LjMuMiB0aGV5IGRvIGhhdmUgYW4gZXF1aXYgSUNVIGFuZCBkaXNwOlxyXG4gICAgICAgICAgICAvLyBlLmcuIDxwaCBpZD1cIjBcIiBlcXVpdj1cIklDVVwiIGRpc3A9XCJ7Y291bnQsIHBsdXJhbCwgPTAgey4uLn0gPTEgey4uLn0gb3RoZXIgey4uLn19XCIvPlxyXG4gICAgICAgICAgICAvLyBhbmQgZW1wdHkgdGFncyBoYXZlIGVxdWl2IG90aGVyIHRoZW4gSU5URVJQT0xBVElPTjpcclxuICAgICAgICAgICAgLy8gZS5nLiA8cGggaWQ9XCIzXCIgZXF1aXY9XCJUQUdfSU1HXCIgdHlwZT1cImltYWdlXCIgZGlzcD1cIiZsdDtpbWcvPlwiLz5cclxuICAgICAgICAgICAgLy8gb3IgPHBoIGVxdWl2PVwiTElORV9CUkVBS1wiIHR5cGU9XCJsYlwiIGRpc3A9XCImbHQ7YnIvPlwiLz5cclxuICAgICAgICAgICAgbGV0IGlzSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgaXNJQ1UgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGlzRW1wdHlUYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZXF1aXYgPSBlbGVtZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2VxdWl2Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3AgPSBlbGVtZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2Rpc3AnKTtcclxuICAgICAgICAgICAgbGV0IGluZGV4U3RyaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgbGV0IGVtcHR5VGFnTmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghZXF1aXYpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9sZCBJQ1Ugc3ludGF4LCBmaXhlZCB3aXRoICMxNzM0NFxyXG4gICAgICAgICAgICAgICAgaXNJQ1UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhTdHJpbmcgPSBlbGVtZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IE51bWJlci5wYXJzZUludChpbmRleFN0cmluZywgMTApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVxdWl2LnN0YXJ0c1dpdGgoJ0lDVScpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBuZXcgSUNVIHN5bnRheCwgZml4ZWQgd2l0aCAjMTczNDRcclxuICAgICAgICAgICAgICAgIGlzSUNVID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcXVpdiA9PT0gJ0lDVScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleFN0cmluZyA9ICcwJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhTdHJpbmcgPSBlcXVpdi5zdWJzdHJpbmcoJ0lDVV8nLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IE51bWJlci5wYXJzZUludChpbmRleFN0cmluZywgMTApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVxdWl2LnN0YXJ0c1dpdGgoJ0lOVEVSUE9MQVRJT04nKSkge1xyXG4gICAgICAgICAgICAgICAgaXNJbnRlcnBvbGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcXVpdiA9PT0gJ0lOVEVSUE9MQVRJT04nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhTdHJpbmcgPSAnMCc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4U3RyaW5nID0gZXF1aXYuc3Vic3RyaW5nKCdJTlRFUlBPTEFUSU9OXycubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KGluZGV4U3RyaW5nLCAxMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3IFRhZ01hcHBpbmcoKS5pc0VtcHR5VGFnUGxhY2Vob2xkZXJOYW1lKGVxdWl2KSkge1xyXG4gICAgICAgICAgICAgICAgaXNFbXB0eVRhZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBlbXB0eVRhZ05hbWUgPSBuZXcgVGFnTWFwcGluZygpLmdldFRhZ25hbWVGcm9tRW1wdHlUYWdQbGFjZWhvbGRlck5hbWUoZXF1aXYpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRQbGFjZWhvbGRlcihpbmRleCwgZGlzcCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJQ1UpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkSUNVTWVzc2FnZVJlZihpbmRleCwgZGlzcCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNFbXB0eVRhZykge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRFbXB0eVRhZyhlbXB0eVRhZ05hbWUsIHRoaXMucGFyc2VJZENvdW50RnJvbU5hbWUoZXF1aXYpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ3BjJykge1xyXG4gICAgICAgICAgICAvLyBwYyBleGFtcGxlOiA8cGMgaWQ9XCIwXCIgZXF1aXZTdGFydD1cIlNUQVJUX0JPTERfVEVYVFwiIGVxdWl2RW5kPVwiQ0xPU0VfQk9MRF9URVhUXCIgdHlwZT1cImZtdFwiXHJcbiAgICAgICAgICAgIC8vIGRpc3BTdGFydD1cIiZsdDtiJmd0O1wiIGRpc3BFbmQ9XCImbHQ7L2ImZ3Q7XCI+SU1QT1JUQU5UPC9wYz5cclxuICAgICAgICAgICAgY29uc3QgZW1iZWRkZWRUYWdOYW1lID0gdGhpcy50YWdOYW1lRnJvbVBDRWxlbWVudChlbGVtZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChlbWJlZGRlZFRhZ05hbWUpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkU3RhcnRUYWcoZW1iZWRkZWRUYWdOYW1lLCB0aGlzLnBhcnNlSWRDb3VudEZyb21OYW1lKGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnZXF1aXZTdGFydCcpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgZW5kIG9mIHRoaXMgZWxlbWVudCBub2RlLlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYWZ0ZXIgYWxsIGNoaWxkcmVuIGFyZSBwcm9jZXNzZWQuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudE5vZGUgZWxlbWVudE5vZGVcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2UgdG8gYmUgYWx0ZXJlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcHJvY2Vzc0VuZEVsZW1lbnQoZWxlbWVudE5vZGU6IEVsZW1lbnQsIG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudE5vZGUudGFnTmFtZTtcclxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3BjJykge1xyXG4gICAgICAgICAgICAvLyBwYyBleGFtcGxlOiA8cGMgaWQ9XCIwXCIgZXF1aXZTdGFydD1cIlNUQVJUX0JPTERfVEVYVFwiIGVxdWl2RW5kPVwiQ0xPU0VfQk9MRF9URVhUXCIgdHlwZT1cImZtdFwiXHJcbiAgICAgICAgICAgIC8vIGRpc3BTdGFydD1cIiZsdDtiJmd0O1wiIGRpc3BFbmQ9XCImbHQ7L2ImZ3Q7XCI+SU1QT1JUQU5UPC9wYz5cclxuICAgICAgICAgICAgY29uc3QgZW1iZWRkZWRUYWdOYW1lID0gdGhpcy50YWdOYW1lRnJvbVBDRWxlbWVudChlbGVtZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChlbWJlZGRlZFRhZ05hbWUpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkRW5kVGFnKGVtYmVkZGVkVGFnTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRhZ05hbWVGcm9tUENFbGVtZW50KHBjTm9kZTogRWxlbWVudCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGRpc3BTdGFydCA9IHBjTm9kZS5nZXRBdHRyaWJ1dGUoJ2Rpc3BTdGFydCcpO1xyXG4gICAgICAgIGlmIChkaXNwU3RhcnQuc3RhcnRzV2l0aCgnPCcpKSB7XHJcbiAgICAgICAgICAgIGRpc3BTdGFydCA9IGRpc3BTdGFydC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwU3RhcnQuZW5kc1dpdGgoJz4nKSkge1xyXG4gICAgICAgICAgICBkaXNwU3RhcnQgPSBkaXNwU3RhcnQuc3Vic3RyaW5nKDAsIGRpc3BTdGFydC5sZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3BTdGFydDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlaW1wbGVtZW50ZWQgaGVyZSwgYmVjYXVzZSBYTElGRiAyLjAgdXNlcyBhIGRlZXBlciB4bWwgbW9kZWwuXHJcbiAgICAgKiBTbyB3ZSBjYW5ub3Qgc2ltcGx5IHJlcGxhY2UgdGhlIG1lc3NhZ2UgcGFydHMgYnkgeG1sIHBhcnRzLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZVxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhZGRYbWxSZXByZXNlbnRhdGlvblRvUm9vdChtZXNzYWdlOiBQYXJzZWRNZXNzYWdlLCByb290RWxlbTogRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IHN0YWNrID0gW3tlbGVtZW50OiByb290RWxlbSwgdGFnTmFtZTogJ3Jvb3QnfV07XHJcbiAgICAgICAgbGV0IGlkID0gMDtcclxuICAgICAgICBtZXNzYWdlLnBhcnRzKCkuZm9yRWFjaCgocGFydCkgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuVEVYVDpcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5lbGVtZW50LmFwcGVuZENoaWxkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZUZXh0UGFydCg8UGFyc2VkTWVzc2FnZVBhcnRUZXh0PiBwYXJ0LCByb290RWxlbSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuUExBQ0VIT0xERVI6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uZWxlbWVudC5hcHBlbmRDaGlsZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mUGxhY2Vob2xkZXJQYXJ0KDxQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyPiBwYXJ0LCByb290RWxlbSwgaWQrKykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuSUNVX01FU1NBR0VfUkVGOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmVsZW1lbnQuYXBwZW5kQ2hpbGQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZklDVU1lc3NhZ2VSZWZQYXJ0KDxQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWY+IHBhcnQsIHJvb3RFbGVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5TVEFSVF9UQUc6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VGFnRWxlbSA9IHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlN0YXJ0VGFnUGFydCg8UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZz4gcGFydCwgcm9vdEVsZW0sIGlkKyspO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3VGFnRWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7ZWxlbWVudDogPEVsZW1lbnQ+IG5ld1RhZ0VsZW0sIHRhZ05hbWU6ICg8UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZz4gcGFydCkudGFnTmFtZSgpfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5FTkRfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlVGFnTmFtZSA9ICg8UGFyc2VkTWVzc2FnZVBhcnRFbmRUYWc+IHBhcnQpLnRhZ05hbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoIDw9IDEgfHwgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0udGFnTmFtZSAhPT0gY2xvc2VUYWdOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9vcHMsIG5vdCB3ZWxsIGZvcm1lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgY2xvc2UgdGFnICcgKyBjbG9zZVRhZ05hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLkVNUFRZX1RBRzpcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXB0eVRhZ0VsZW0gPSB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZFbXB0eVRhZ1BhcnQoPFBhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWc+IHBhcnQsIHJvb3RFbGVtLCBpZCsrKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5lbGVtZW50LmFwcGVuZENoaWxkKGVtcHR5VGFnRWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIG9vcHMsIG5vdCB3ZWxsIGNsb3NlZCB0YWdzXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjbG9zZSB0YWcgJyArIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnRhZ05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3Igc3RhcnQgdGFnIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSBwYy1FbGVtZW50LlxyXG4gICAgICogZS5nLiA8cGMgaWQ9XCIwXCIgZXF1aXZTdGFydD1cIlNUQVJUX0JPTERfVEVYVFwiIGVxdWl2RW5kPVwiQ0xPU0VfQk9MRF9URVhUXCIgdHlwZT1cImZtdFwiIGRpc3BTdGFydD1cIiZsdDtiJmd0O1wiIGRpc3BFbmQ9XCImbHQ7L2ImZ3Q7XCI+XHJcbiAgICAgKiBUZXh0IGNvbnRlbnQgd2lsbCBiZSBhZGRlZCBsYXRlci5cclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICogQHBhcmFtIGlkIGlkIG51bWJlciBpbiB4bGlmZjJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZTdGFydFRhZ1BhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZywgcm9vdEVsZW06IEVsZW1lbnQsIGlkOiBudW1iZXIpOiBOb2RlIHtcclxuICAgICAgICBjb25zdCB0YWdNYXBwaW5nID0gbmV3IFRhZ01hcHBpbmcoKTtcclxuICAgICAgICBjb25zdCBwY0VsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BjJyk7XHJcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHBhcnQudGFnTmFtZSgpO1xyXG4gICAgICAgIGNvbnN0IGVxdWl2U3RhcnQgPSB0YWdNYXBwaW5nLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lKHRhZ05hbWUsIHBhcnQuaWRDb3VudGVyKCkpO1xyXG4gICAgICAgIGNvbnN0IGVxdWl2RW5kID0gdGFnTWFwcGluZy5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSh0YWdOYW1lKTtcclxuICAgICAgICBjb25zdCBkaXNwU3RhcnQgPSAnPCcgKyB0YWdOYW1lICsgJz4nO1xyXG4gICAgICAgIGNvbnN0IGRpc3BFbmQgPSAnPC8nICsgdGFnTmFtZSArICc+JztcclxuICAgICAgICBwY0VsZW0uc2V0QXR0cmlidXRlKCdpZCcsIGlkLnRvU3RyaW5nKDEwKSk7XHJcbiAgICAgICAgcGNFbGVtLnNldEF0dHJpYnV0ZSgnZXF1aXZTdGFydCcsIGVxdWl2U3RhcnQpO1xyXG4gICAgICAgIHBjRWxlbS5zZXRBdHRyaWJ1dGUoJ2VxdWl2RW5kJywgZXF1aXZFbmQpO1xyXG4gICAgICAgIHBjRWxlbS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCB0aGlzLmdldFR5cGVGb3JUYWcodGFnTmFtZSkpO1xyXG4gICAgICAgIHBjRWxlbS5zZXRBdHRyaWJ1dGUoJ2Rpc3BTdGFydCcsIGRpc3BTdGFydCk7XHJcbiAgICAgICAgcGNFbGVtLnNldEF0dHJpYnV0ZSgnZGlzcEVuZCcsIGRpc3BFbmQpO1xyXG4gICAgICAgIHJldHVybiBwY0VsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGVuZCB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBOb3QgdXNlZCBoZXJlLCBiZWNhdXNlIGNvbnRlbnQgaXMgY2hpbGQgb2Ygc3RhcnQgdGFnLlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mRW5kVGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydEVuZFRhZywgcm9vdEVsZW06IEVsZW1lbnQpOiBOb2RlIHtcclxuICAgICAgICAvLyBub3QgdXNlZFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBlbXB0eSB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IHBoLUVsZW1lbnQuXHJcbiAgICAgKiBlLmcuIDxwaCBpZD1cIjNcIiBlcXVpdj1cIlRBR19JTUdcIiB0eXBlPVwiaW1hZ2VcIiBkaXNwPVwiJmx0O2ltZy8+XCIvPlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKiBAcGFyYW0gaWQgaWQgbnVtYmVyIGluIHhsaWZmMlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVtcHR5VGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydEVtcHR5VGFnLCByb290RWxlbTogRWxlbWVudCwgaWQ6IG51bWJlcik6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHRhZ01hcHBpbmcgPSBuZXcgVGFnTWFwcGluZygpO1xyXG4gICAgICAgIGNvbnN0IHBoRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGgnKTtcclxuICAgICAgICBjb25zdCB0YWdOYW1lID0gcGFydC50YWdOYW1lKCk7XHJcbiAgICAgICAgY29uc3QgZXF1aXYgPSB0YWdNYXBwaW5nLmdldEVtcHR5VGFnUGxhY2Vob2xkZXJOYW1lKHRhZ05hbWUsIHBhcnQuaWRDb3VudGVyKCkpO1xyXG4gICAgICAgIGNvbnN0IGRpc3AgPSAnPCcgKyB0YWdOYW1lICsgJy8+JztcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIGlkLnRvU3RyaW5nKDEwKSk7XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnZXF1aXYnLCBlcXVpdik7XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgndHlwZScsIHRoaXMuZ2V0VHlwZUZvclRhZyh0YWdOYW1lKSk7XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnZGlzcCcsIGRpc3ApO1xyXG4gICAgICAgIHJldHVybiBwaEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRUeXBlRm9yVGFnKHRhZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKHRhZy50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2JyJzpcclxuICAgICAgICAgICAgY2FzZSAnYic6XHJcbiAgICAgICAgICAgIGNhc2UgJ2knOlxyXG4gICAgICAgICAgICBjYXNlICd1JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnZm10JztcclxuICAgICAgICAgICAgY2FzZSAnaW1nJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xyXG4gICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnbGluayc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ290aGVyJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIHBsYWNlaG9sZGVyIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogUmV0dXJucyBlLmcuIDxwaCBpZD1cIjFcIiBlcXVpdj1cIklOVEVSUE9MQVRJT05fMVwiIGRpc3A9XCJ7e3RvdGFsKCl9fVwiLz5cclxuICAgICAqIEBwYXJhbSBwYXJ0IHBhcnRcclxuICAgICAqIEBwYXJhbSByb290RWxlbSByb290RWxlbVxyXG4gICAgICogQHBhcmFtIGlkIGlkIG51bWJlciBpbiB4bGlmZjJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZQbGFjZWhvbGRlclBhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRQbGFjZWhvbGRlciwgcm9vdEVsZW06IEVsZW1lbnQsIGlkOiBudW1iZXIpOiBOb2RlIHtcclxuICAgICAgICBjb25zdCBwaEVsZW0gPSByb290RWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BoJyk7XHJcbiAgICAgICAgbGV0IGVxdWl2QXR0cmliID0gJ0lOVEVSUE9MQVRJT04nO1xyXG4gICAgICAgIGlmIChwYXJ0LmluZGV4KCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGVxdWl2QXR0cmliID0gJ0lOVEVSUE9MQVRJT05fJyArIHBhcnQuaW5kZXgoKS50b1N0cmluZygxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQudG9TdHJpbmcoMTApKTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdlcXVpdicsIGVxdWl2QXR0cmliKTtcclxuICAgICAgICBjb25zdCBkaXNwID0gcGFydC5kaXNwKCk7XHJcbiAgICAgICAgaWYgKGRpc3ApIHtcclxuICAgICAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnZGlzcCcsIGRpc3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGhFbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBpY3UgbWVzc2FnZSByZWZzIGluIHRoZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mSUNVTWVzc2FnZVJlZlBhcnQocGFydDogUGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlUmVmLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHBoRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGgnKTtcclxuICAgICAgICBsZXQgZXF1aXZBdHRyaWIgPSAnSUNVJztcclxuICAgICAgICBpZiAocGFydC5pbmRleCgpID4gMCkge1xyXG4gICAgICAgICAgICBlcXVpdkF0dHJpYiA9ICdJQ1VfJyArIHBhcnQuaW5kZXgoKS50b1N0cmluZygxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgcGFydC5pbmRleCgpLnRvU3RyaW5nKDEwKSk7XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnZXF1aXYnLCBlcXVpdkF0dHJpYik7XHJcbiAgICAgICAgY29uc3QgZGlzcCA9IHBhcnQuZGlzcCgpO1xyXG4gICAgICAgIGlmIChkaXNwKSB7XHJcbiAgICAgICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ2Rpc3AnLCBkaXNwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBoRWxlbTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtTVEFURV9ORVcsIFNUQVRFX1RSQU5TTEFURUQsIFNUQVRFX0ZJTkFMfSBmcm9tICcuLi9hcGkvY29uc3RhbnRzJztcclxuaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4uL2FwaS9pLXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUnO1xyXG5pbXBvcnQge0lOb3JtYWxpemVkTWVzc2FnZX0gZnJvbSAnLi4vYXBpL2ktbm9ybWFsaXplZC1tZXNzYWdlJztcclxuaW1wb3J0IHtJVHJhbnNVbml0fSBmcm9tICcuLi9hcGkvaS10cmFucy11bml0JztcclxuaW1wb3J0IHtJTm90ZX0gZnJvbSAnLi4vYXBpL2ktbm90ZSc7XHJcbmltcG9ydCB7RE9NVXRpbGl0aWVzfSBmcm9tICcuL2RvbS11dGlsaXRpZXMnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2V9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNVbml0fSBmcm9tICcuL2Fic3RyYWN0LXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge1hsaWZmMk1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4veGxpZmYyLW1lc3NhZ2UtcGFyc2VyJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXInO1xyXG5pbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICd1dGlsJztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDA0LjA1LjIwMTcuXHJcbiAqIEEgVHJhbnNsYXRpb24gVW5pdCBpbiBhbiBYTElGRiAyLjAgZmlsZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgWGxpZmYyVHJhbnNVbml0IGV4dGVuZHMgQWJzdHJhY3RUcmFuc1VuaXQgIGltcGxlbWVudHMgSVRyYW5zVW5pdCB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnQ6IEVsZW1lbnQsIF9pZDogc3RyaW5nLCBfdHJhbnNsYXRpb25NZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSkge1xyXG4gICAgICAgIHN1cGVyKF9lbGVtZW50LCBfaWQsIF90cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNvdXJjZUNvbnRlbnQoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnc291cmNlJyk7XHJcbiAgICAgICAgcmV0dXJuIERPTVV0aWxpdGllcy5nZXRYTUxDb250ZW50KHNvdXJjZUVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG5ldyBzb3VyY2UgY29udGVudCBpbiB0aGUgdHJhbnN1bml0LlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMgZG9uZSBieSBuZy1leHRyYWN0LlxyXG4gICAgICogTWV0aG9kIG9ubHkgZXhpc3RzIHRvIGFsbG93IHhsaWZmbWVyZ2UgdG8gbWVyZ2UgbWlzc2luZyBjaGFuZ2VkIHNvdXJjZSBjb250ZW50LlxyXG4gICAgICogQHBhcmFtIG5ld0NvbnRlbnQgdGhlIG5ldyBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U291cmNlQ29udGVudChuZXdDb250ZW50OiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgc291cmNlID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnc291cmNlJyk7XHJcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcclxuICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBoYXBwZW4sIHRoZXJlIGFsd2F5cyBoYXMgdG8gYmUgYSBzb3VyY2UsIGJ1dCB3aG8ga25vd3MuLlxyXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnc2VnbWVudCcpO1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBzZWdtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQoc291cmNlLCBuZXdDb250ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHBhcnNlciB1c2VkIGZvciBub3JtYWxpemVkIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWVzc2FnZVBhcnNlcigpOiBBYnN0cmFjdE1lc3NhZ2VQYXJzZXIge1xyXG4gICAgICAgIHJldHVybiBuZXcgWGxpZmYyTWVzc2FnZVBhcnNlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWdpbmFsIHRleHQgdmFsdWUsIHRoYXQgaXMgdG8gYmUgdHJhbnNsYXRlZCwgYXMgbm9ybWFsaXplZCBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlU291cmNlQ29udGVudE5vcm1hbGl6ZWQoKTogUGFyc2VkTWVzc2FnZSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlRWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NvdXJjZScpO1xyXG4gICAgICAgIGlmIChzb3VyY2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VQYXJzZXIoKS5jcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUwoc291cmNlRWxlbWVudCwgbnVsbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHRyYW5zbGF0ZWQgdmFsdWUgKGNvbnRhaW5pbmcgYWxsIG1hcmt1cCwgZGVwZW5kcyBvbiB0aGUgY29uY3JldGUgZm9ybWF0IHVzZWQpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdGFyZ2V0Q29udGVudCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFhNTENvbnRlbnQodGFyZ2V0RWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgdHJhbnNsYXRlZCB2YWx1ZSwgYnV0IGFsbCBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGgge3tufX0gKHN0YXJ0aW5nIGF0IDApXHJcbiAgICAgKiBhbmQgYWxsIGVtYmVkZGVkIGh0bWwgaXMgcmVwbGFjZWQgYnkgZGlyZWN0IGh0bWwgbWFya3VwLlxyXG4gICAgICovXHJcbiAgICB0YXJnZXRDb250ZW50Tm9ybWFsaXplZCgpOiBJTm9ybWFsaXplZE1lc3NhZ2Uge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICByZXR1cm4gbmV3IFhsaWZmMk1lc3NhZ2VQYXJzZXIoKS5jcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUwodGFyZ2V0RWxlbWVudCwgdGhpcy5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRlIG9mIHRoZSB0cmFuc2xhdGlvbiBhcyBzdG9yZWQgaW4gdGhlIHhtbC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5hdGl2ZVRhcmdldFN0YXRlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudEVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzZWdtZW50Jyk7XHJcbiAgICAgICAgaWYgKHNlZ21lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0YXRlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IHN0YXRlIGluIHhtbC5cclxuICAgICAqIEBwYXJhbSBuYXRpdmVTdGF0ZSBuYXRpdmVTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc2V0TmF0aXZlVGFyZ2V0U3RhdGUobmF0aXZlU3RhdGU6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnc2VnbWVudCcpO1xyXG4gICAgICAgIGlmIChzZWdtZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICBzZWdtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0YXRlJywgbmF0aXZlU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBhbiBhYnN0cmFjdCBzdGF0ZSAobmV3LCB0cmFuc2xhdGVkLCBmaW5hbCkgdG8gYSBjb25jcmV0ZSBzdGF0ZSB1c2VkIGluIHRoZSB4bWwuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSB0byBiZSB1c2VkIGluIHRoZSB4bWwuXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgb25lIG9mIENvbnN0YW50cy5TVEFURS4uLlxyXG4gICAgICogQHJldHVybnMgYSBuYXRpdmUgc3RhdGUgKGRlcGVuZHMgb24gY29uY3JldGUgZm9ybWF0KVxyXG4gICAgICogQHRocm93cyBlcnJvciwgaWYgc3RhdGUgaXMgaW52YWxpZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1hcFN0YXRlVG9OYXRpdmVTdGF0ZShzdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKCBzdGF0ZSkge1xyXG4gICAgICAgICAgICBjYXNlIFNUQVRFX05FVzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnaW5pdGlhbCc7XHJcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfVFJBTlNMQVRFRDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlZCc7XHJcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfRklOQUw6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2ZpbmFsJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBzdGF0ZSAnICsgIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgYSBuYXRpdmUgc3RhdGUgKGZvdW5kIGluIHRoZSBkb2N1bWVudCkgdG8gYW4gYWJzdHJhY3Qgc3RhdGUgKG5ldywgdHJhbnNsYXRlZCwgZmluYWwpLlxyXG4gICAgICogUmV0dXJucyB0aGUgYWJzdHJhY3Qgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gbmF0aXZlU3RhdGUgbmF0aXZlU3RhdGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1hcE5hdGl2ZVN0YXRlVG9TdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKCBuYXRpdmVTdGF0ZSkge1xyXG4gICAgICAgICAgICBjYXNlICdpbml0aWFsJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9ORVc7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZWQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1RSQU5TTEFURUQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ3Jldmlld2VkJzogLy8gc2FtZSBhcyB0cmFuc2xhdGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVFJBTlNMQVRFRDtcclxuICAgICAgICAgICAgY2FzZSAnZmluYWwnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0ZJTkFMO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX05FVztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdGhlIHNvdXJjZSBlbGVtZW50cyBpbiB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqIFRoZSBzb3VyY2UgZWxlbWVudCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUgZmlsZSBhbmQgYSBsaW5lIG51bWJlciB3aXRoIHRoZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHRlbXBsYXRlLlxyXG4gICAgICogSXQgaXMganVzdCBhIGhlbHAgZm9yIHRyYW5zbGF0b3JzIHRvIGZpbmQgdGhlIGNvbnRleHQgZm9yIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIFRoaXMgaXMgc2V0IHdoZW4gdXNpbmcgQW5ndWxhciA0LjAgb3IgZ3JlYXRlci5cclxuICAgICAqIE90aGVyd2lzZSBpdCBqdXN0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VSZWZlcmVuY2VzKCk6IHtzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlcn1bXSB7XHJcbiAgICAgICAgLy8gU291cmNlIGlzIGZvdW5kIGFzIDxmaWxlPjo8bGluZT4gaW4gPG5vdGUgY2F0ZWdvcnk9XCJsb2NhdGlvblwiPi4uLlxyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25vdGUnKTtcclxuICAgICAgICBjb25zdCBzb3VyY2VSZWZzOiB7IHNvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyIH1bXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm90ZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdGVFbGVtID0gbm90ZUVsZW1lbnRzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChub3RlRWxlbS5nZXRBdHRyaWJ1dGUoJ2NhdGVnb3J5JykgPT09ICdsb2NhdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUFuZFBvczogc3RyaW5nID0gRE9NVXRpbGl0aWVzLmdldFBDREFUQShub3RlRWxlbSk7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VSZWZzLnB1c2godGhpcy5wYXJzZVNvdXJjZUFuZFBvcyhzb3VyY2VBbmRQb3MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc291cmNlUmVmcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBzb21ldGhpbmcgbGlrZSAnYzpcXHh4eDo3JyBhbmQgcmV0dXJucyBzb3VyY2UgYW5kIGxpbmVudW1iZXIuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlQW5kUG9zIHNvbWV0aGluZyBsaWtlICdjOlxceHh4OjcnLCBsYXN0IGNvbG9uIGlzIHRoZSBzZXBhcmF0b3JcclxuICAgICAqIEByZXR1cm4gc291cmNlIGFuZCBsaW5lIG51bWJlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcnNlU291cmNlQW5kUG9zKHNvdXJjZUFuZFBvczogc3RyaW5nKTogeyBzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXIgfSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBzb3VyY2VBbmRQb3MubGFzdEluZGV4T2YoJzonKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VmaWxlOiBzb3VyY2VBbmRQb3MsXHJcbiAgICAgICAgICAgICAgICBsaW5lbnVtYmVyOiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZWZpbGU6IHNvdXJjZUFuZFBvcy5zdWJzdHJpbmcoMCwgaW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgbGluZW51bWJlcjogdGhpcy5wYXJzZUxpbmVOdW1iZXIoc291cmNlQW5kUG9zLnN1YnN0cmluZyhpbmRleCArIDEpKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHBhcnNlTGluZU51bWJlcihsaW5lTnVtYmVyU3RyaW5nOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobGluZU51bWJlclN0cmluZywgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNvdXJjZSByZWYgZWxlbWVudHMgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3Npbmcgc291cmNlIHJlZnMuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlUmVmcyB0aGUgc291cmNlcmVmcyB0byBzZXQuIE9sZCBvbmVzIGFyZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U291cmNlUmVmZXJlbmNlcyhzb3VyY2VSZWZzOiB7c291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyOiBudW1iZXJ9W10pIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbFNvdXJjZVJlZmVyZW5jZXMoKTtcclxuICAgICAgICBsZXQgbm90ZXNFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnbm90ZXMnKTtcclxuICAgICAgICBpZiAoc291cmNlUmVmcy5sZW5ndGggPT09IDAgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKG5vdGVzRWxlbWVudCkgJiYgbm90ZXNFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSBub3RlcyBlbGVtZW50XHJcbiAgICAgICAgICAgIG5vdGVzRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vdGVzRWxlbWVudCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG5vdGVzRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgbm90ZXNFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25vdGVzJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuaW5zZXJ0QmVmb3JlKG5vdGVzRWxlbWVudCwgdGhpcy5fZWxlbWVudC5jaGlsZE5vZGVzLml0ZW0oMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2VSZWZzLmZvckVhY2goKHJlZikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub3RlID0gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25vdGUnKTtcclxuICAgICAgICAgICAgbm90ZS5zZXRBdHRyaWJ1dGUoJ2NhdGVnb3J5JywgJ2xvY2F0aW9uJyk7XHJcbiAgICAgICAgICAgIG5vdGUuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJlZi5zb3VyY2VmaWxlICsgJzonICsgcmVmLmxpbmVudW1iZXIudG9TdHJpbmcoMTApKSk7XHJcbiAgICAgICAgICAgIG5vdGVzRWxlbWVudC5hcHBlbmRDaGlsZChub3RlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbW92ZUFsbFNvdXJjZVJlZmVyZW5jZXMoKSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbm90ZScpO1xyXG4gICAgICAgIGNvbnN0IHRvQmVSZW1vdmVkID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3RlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IG5vdGVFbGVtZW50cy5pdGVtKGkpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbS5nZXRBdHRyaWJ1dGUoJ2NhdGVnb3J5JykgPT09ICdsb2NhdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRvQmVSZW1vdmVkLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdG9CZVJlbW92ZWQuZm9yRWFjaCgoZWxlbSkgPT4ge2VsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKiBJbiB4bGlmZiAyLjAgdGhpcyBpcyBzdG9yZWQgYXMgYSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgY2F0ZWdvcnk9XCJkZXNjcmlwdGlvblwiLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbSA9IHRoaXMuZmluZE5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKCdkZXNjcmlwdGlvbicpO1xyXG4gICAgICAgIGlmIChub3RlRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFBDREFUQShub3RlRWxlbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIGRlc2NyaXB0aW9uIHByb3BlcnR5IG9mIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gZGVzY3JpcHRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbSA9IHRoaXMuZmluZE5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKCdkZXNjcmlwdGlvbicpO1xyXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobm90ZUVsZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaXRcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlTm90ZUVsZW1lbnRXaXRoQ2F0ZWdvcnlBdHRyaWJ1dGUoJ2Rlc2NyaXB0aW9uJywgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQobm90ZUVsZW0sIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobm90ZUVsZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbm9kZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZSgnZGVzY3JpcHRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgYSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgY2F0ZWdvcnk9JzxhdHRyVmFsdWU+J1xyXG4gICAgICogQHBhcmFtIGF0dHJWYWx1ZSB2YWx1ZSBvZiBjYXRlZ29yeSBhdHRyaWJ1dGVcclxuICAgICAqIEByZXR1cm4gZWxlbWVudCBvciBudWxsIGlzIGFic2VudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmROb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZShhdHRyVmFsdWU6IHN0cmluZyk6IEVsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25vdGUnKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vdGVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub3RlRWxlbSA9IG5vdGVFbGVtZW50cy5pdGVtKGkpO1xyXG4gICAgICAgICAgICBpZiAobm90ZUVsZW0uZ2V0QXR0cmlidXRlKCdjYXRlZ29yeScpID09PSBhdHRyVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub3RlRWxlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbm90ZSBlbGVtZW50cyB3aGVyZSBmcm9tIGF0dHJpYnV0ZSBpcyBub3QgZGVzY3JpcHRpb24gb3IgbWVhbmluZ1xyXG4gICAgICogQHJldHVybiBlbGVtZW50c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmRBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCk6IEVsZW1lbnRbXSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbm90ZScpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogRWxlbWVudFtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3RlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSBub3RlRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgY29uc3QgZnJvbUF0dHJpYnV0ZSA9IG5vdGVFbGVtLmdldEF0dHJpYnV0ZSgnY2F0ZWdvcnknKTtcclxuICAgICAgICAgICAgaWYgKGZyb21BdHRyaWJ1dGUgIT09ICdkZXNjcmlwdGlvbicgJiYgZnJvbUF0dHJpYnV0ZSAhPT0gJ21lYW5pbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub3RlRWxlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgZnJvbT0nPGF0dHJWYWx1ZT4nXHJcbiAgICAgKiBAcGFyYW0gYXR0clZhbHVlIGNhdGVnb3J5IGF0dHJpYnV0ZSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIGNvbnRlbnQgY29udGVudCBvZiBub3RlIGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gdGhlIG5ldyBjcmVhdGVkIGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVOb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZShhdHRyVmFsdWU6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogRWxlbWVudCB7XHJcbiAgICAgICAgbGV0IG5vdGVzRWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ25vdGVzJyk7XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG5vdGVzRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIGl0XHJcbiAgICAgICAgICAgIG5vdGVzRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdub3RlcycpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKG5vdGVzRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25vdGUnKTtcclxuICAgICAgICBpZiAoYXR0clZhbHVlKSB7XHJcbiAgICAgICAgICAgIG5vdGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2F0ZWdvcnknLCBhdHRyVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGVudCkge1xyXG4gICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChub3RlRWxlbWVudCwgY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vdGVzRWxlbWVudC5hcHBlbmRDaGlsZChub3RlRWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuIG5vdGVFbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVtb3ZlTm90ZXNFbGVtZW50SWZFbXB0eSgpIHtcclxuICAgICAgICBjb25zdCBub3Rlc0VsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdub3RlcycpO1xyXG4gICAgICAgIGlmIChub3Rlc0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGROb3RlID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnbm90ZScpO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkTm90ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vdGVzIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIG5vdGVzRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vdGVzRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgbm90ZSBlbGVtZW50IHdpdGggYXR0cmlidXRlIGZyb209JzxhdHRyVmFsdWU+J1xyXG4gICAgICogQHBhcmFtIGF0dHJWYWx1ZSBhdHRyVmFsdWVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW1vdmVOb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZShhdHRyVmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW50ID0gdGhpcy5maW5kTm90ZUVsZW1lbnRXaXRoQ2F0ZWdvcnlBdHRyaWJ1dGUoYXR0clZhbHVlKTtcclxuICAgICAgICBpZiAobm90ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgbm90ZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub3RlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVtb3ZlTm90ZXNFbGVtZW50SWZFbXB0eSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBub3RlIGVsZW1lbnRzIHdoZXJlIGF0dHJpYnV0ZSBcImZyb21cIiBpcyBub3QgZGVzY3JpcHRpb24gb3IgbWVhbmluZy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW1vdmVBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCkge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW50cyA9IHRoaXMuZmluZEFsbEFkZGl0aW9uYWxOb3RlRWxlbWVudHMoKTtcclxuICAgICAgICBub3RlRWxlbWVudHMuZm9yRWFjaCgobm90ZUVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgbm90ZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub3RlRWxlbWVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVOb3Rlc0VsZW1lbnRJZkVtcHR5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWVhbmluZyAoaW50ZW50KSBzZXQgaW4gdGhlIHRlbXBsYXRlIGFzIHZhbHVlIG9mIHRoZSBpMThuLWF0dHJpYnV0ZS5cclxuICAgICAqIFRoaXMgaXMgdGhlIHBhcnQgaW4gZnJvbnQgb2YgdGhlIHwgc3ltYm9sLlxyXG4gICAgICogZS5nLiBpMThuPVwibWVhbmluZ3xteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKiBJbiB4bGlmZiAyLjAgdGhpcyBpcyBzdG9yZWQgYXMgYSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgY2F0ZWdvcnk9XCJtZWFuaW5nXCIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtZWFuaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSB0aGlzLmZpbmROb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZSgnbWVhbmluZycpO1xyXG4gICAgICAgIGlmIChub3RlRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFBDREFUQShub3RlRWxlbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIG1lYW5pbmcgcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSBtZWFuaW5nIG1lYW5pbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldE1lYW5pbmcobWVhbmluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSB0aGlzLmZpbmROb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZSgnbWVhbmluZycpO1xyXG4gICAgICAgIGlmIChtZWFuaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChub3RlRWxlbSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBpdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVOb3RlRWxlbWVudFdpdGhDYXRlZ29yeUF0dHJpYnV0ZSgnbWVhbmluZycsIG1lYW5pbmcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQobm90ZUVsZW0sIG1lYW5pbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChub3RlRWxlbSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vdGVFbGVtZW50V2l0aENhdGVnb3J5QXR0cmlidXRlKCdtZWFuaW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIG5vdGVzIG9mIHRoZSB0cmFucy11bml0LlxyXG4gICAgICogTm90ZXMgYXJlIHJlbWFya3MgbWFkZSBieSBhIHRyYW5zbGF0b3IuXHJcbiAgICAgKiAoZGVzY3JpcHRpb24gYW5kIG1lYW5pbmcgYXJlIG5vdCBpbmNsdWRlZCBoZXJlISlcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vdGVzKCk6IElOb3RlW10ge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW10czogRWxlbWVudFtdID0gdGhpcy5maW5kQWxsQWRkaXRpb25hbE5vdGVFbGVtZW50cygpO1xyXG4gICAgICAgIHJldHVybiBub3RlRWxlbWVtdHMubWFwKGVsZW0gPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogZWxlbS5nZXRBdHRyaWJ1dGUoJ2NhdGVnb3J5JyksXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBET01VdGlsaXRpZXMuZ2V0UENEQVRBKGVsZW0pXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBub3RlcyBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldE5vdGVzIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTZXROb3RlcygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBub3RlcyB0byB0cmFucyB1bml0LlxyXG4gICAgICogQHBhcmFtIG5ld05vdGVzIHRoZSBub3RlcyB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXROb3RlcyhuZXdOb3RlczogSU5vdGVbXSkge1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobmV3Tm90ZXMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tOb3RlcyhuZXdOb3Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsQWRkaXRpb25hbE5vdGVFbGVtZW50cygpO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobmV3Tm90ZXMpKSB7XHJcbiAgICAgICAgICAgIG5ld05vdGVzLmZvckVhY2goKG5vdGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlTm90ZUVsZW1lbnRXaXRoQ2F0ZWdvcnlBdHRyaWJ1dGUobm90ZS5mcm9tLCBub3RlLnRleHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRyYW5zbGF0aW9uIHRvIGEgZ2l2ZW4gc3RyaW5nIChpbmNsdWRpbmcgbWFya3VwKS5cclxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiB0cmFuc2xhdGlvblxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdHJhbnNsYXRlTmF0aXZlKHRyYW5zbGF0aW9uOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAndGFyZ2V0Jyk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAnc291cmNlJyk7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHNvdXJjZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YXJnZXQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERPTVV0aWxpdGllcy5yZXBsYWNlQ29udGVudFdpdGhYTUxDb250ZW50KHRhcmdldCwgPHN0cmluZz4gdHJhbnNsYXRpb24pO1xyXG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfVFJBTlNMQVRFRCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogUmV0dXJucyBhIGNoYW5nZWQgY29weSBvZiB0aGlzIHRyYW5zIHVuaXQuXHJcbiAgICAgKiByZWNlaXZlciBpcyBub3QgY2hhbmdlZC5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgY2FsbCBpbXBvcnROZXdUcmFuc1VuaXQgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbG9uZVdpdGhTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbiwgdGFyZ2V0RmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTogQWJzdHJhY3RUcmFuc1VuaXQge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSA8RWxlbWVudD4gdGhpcy5fZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgWGxpZmYyVHJhbnNVbml0KGVsZW1lbnQsIHRoaXMuX2lkLCB0YXJnZXRGaWxlKTtcclxuICAgICAgICBjbG9uZS51c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nLCBjb3B5Q29udGVudCk7XHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBzb3VyY2UgdG8gdGFyZ2V0IHRvIHVzZSBpdCBhcyBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgY2FsbCBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nIG9uIElUcmFuc2xhdGlvbk1lc3NhZ2VGaWxlKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXNlU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4pIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAndGFyZ2V0Jyk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gc291cmNlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhcmdldCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVmYXVsdExhbmcgfHwgY29weUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlU3RyaW5nID0gRE9NVXRpbGl0aWVzLmdldFhNTENvbnRlbnQoc291cmNlKTtcclxuICAgICAgICAgICAgbGV0IG5ld1RhcmdldFN0cmluZyA9IHNvdXJjZVN0cmluZztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSUNVTWVzc2FnZShzb3VyY2VTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRTdHJpbmcgPSB0aGlzLnRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKCkuZ2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCgpXHJcbiAgICAgICAgICAgICAgICAgICAgKyBzb3VyY2VTdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICArIHRoaXMudHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUoKS5nZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudCh0YXJnZXQsIG5ld1RhcmdldFN0cmluZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQodGFyZ2V0LCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzZWdtZW50Jyk7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmYXVsdExhbmcpIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnQuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHRoaXMubWFwU3RhdGVUb05hdGl2ZVN0YXRlKFNUQVRFX0ZJTkFMKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50LnNldEF0dHJpYnV0ZSgnc3RhdGUnLCB0aGlzLm1hcFN0YXRlVG9OYXRpdmVTdGF0ZShTVEFURV9ORVcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7SVRyYW5zVW5pdH0gZnJvbSAnLi4vYXBpL2ktdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7Rk9STUFUX1hMSUZGMjAsIEZJTEVUWVBFX1hMSUZGMjB9IGZyb20gJy4uL2FwaS9jb25zdGFudHMnO1xyXG5pbXBvcnQge0RPTVV0aWxpdGllc30gZnJvbSAnLi9kb20tdXRpbGl0aWVzJztcclxuaW1wb3J0IHtYbGlmZjJUcmFuc1VuaXR9IGZyb20gJy4veGxpZmYyLXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc1VuaXR9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnMtdW5pdCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwNC4wNS4yMDE3LlxyXG4gKiBBbiBYTElGRiAyLjAgZmlsZSByZWFkIGZyb20gYSBzb3VyY2UgZmlsZS5cclxuICogRm9ybWF0IGRlZmluaXRpb24gaXM6IGh0dHA6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL3hsaWZmL3hsaWZmLWNvcmUvdjIuMC9vcy94bGlmZi1jb3JlLXYyLjAtb3MuaHRtbFxyXG4gKlxyXG4gKiBEZWZpbmVzIHNvbWUgcmVsZXZhbnQgZ2V0IGFuZCBzZXQgbWV0aG9kIGZvciByZWFkaW5nIGFuZCBtb2RpZnlpbmcgc3VjaCBhIGZpbGUuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFhsaWZmMkZpbGUgZXh0ZW5kcyBBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIGltcGxlbWVudHMgSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBYTElGRiAyLjAtRmlsZSBmcm9tIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSB4bWxTdHJpbmcgc291cmNlIHJlYWQgZnJvbSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHBhdGggUGF0aCB0byBmaWxlXHJcbiAgICAgKiBAcGFyYW0gZW5jb2Rpbmcgb3B0aW9uYWwgZW5jb2Rpbmcgb2YgdGhlIHhtbC5cclxuICAgICAqIFRoaXMgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLCBidXQgaWYgeW91IGtub3cgaXQgYmVmb3JlLCB5b3UgY2FuIGF2b2lkIHJlYWRpbmcgdGhlIGZpbGUgdHdpY2UuXHJcbiAgICAgKiBAcmV0dXJuIHhsaWZmIGZpbGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoeG1sU3RyaW5nOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fd2FybmluZ3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkID0gMDtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVGcm9tQ29udGVudCh4bWxTdHJpbmcsIHBhdGgsIGVuY29kaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGluaXRpYWxpemVGcm9tQ29udGVudCh4bWxTdHJpbmc6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKTogWGxpZmYyRmlsZSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZUNvbnRlbnQoeG1sU3RyaW5nLCBwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgY29uc3QgeGxpZmZMaXN0ID0gdGhpcy5fcGFyc2VkRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3hsaWZmJyk7XHJcbiAgICAgICAgaWYgKHhsaWZmTGlzdC5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRmlsZSBcIiVzXCIgc2VlbXMgdG8gYmUgbm8geGxpZmYgZmlsZSAoc2hvdWxkIGNvbnRhaW4gYW4geGxpZmYgZWxlbWVudCknLCBwYXRoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHhsaWZmTGlzdC5pdGVtKDApLmdldEF0dHJpYnV0ZSgndmVyc2lvbicpO1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZlcnNpb24gPSAnMi4wJztcclxuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09IGV4cGVjdGVkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRmlsZSBcIiVzXCIgc2VlbXMgdG8gYmUgbm8geGxpZmYgMiBmaWxlLCB2ZXJzaW9uIHNob3VsZCBiZSAlcywgZm91bmQgJXMnLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsIGV4cGVjdGVkVmVyc2lvbiwgdmVyc2lvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsZSBmb3JtYXQgYXMgaXQgaXMgdXNlZCBpbiBjb25maWcgZmlsZXMuXHJcbiAgICAgKiBDdXJyZW50bHkgJ3hsZicsICd4bWInLCAneG1iMidcclxuICAgICAqIFJldHVybnMgb25lIG9mIHRoZSBjb25zdGFudHMgRk9STUFUXy4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpMThuRm9ybWF0KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIEZPUk1BVF9YTElGRjIwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsZSB0eXBlLlxyXG4gICAgICogSGVyZSAnWExJRkYgMi4wJ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmlsZVR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gRklMRVRZUEVfWExJRkYyMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiB0YWcgbmFtZXMgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBtaXhlZCBjb250ZW50LlxyXG4gICAgICogVGhlc2UgZWxlbWVudHMgd2lsbCBub3QgYmUgYmVhdXRpZmllZC5cclxuICAgICAqIFR5cGljYWwgY2FuZGlkYXRlcyBhcmUgc291cmNlIGFuZCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBlbGVtZW50c1dpdGhNaXhlZENvbnRlbnQoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiBbJ3NrZWxldG9uJywgJ25vdGUnLCAnZGF0YScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BjJywgJ21yayddO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBpbml0aWFsaXplVHJhbnNVbml0cygpIHtcclxuICAgICAgICB0aGlzLnRyYW5zVW5pdHMgPSBbXTtcclxuICAgICAgICBjb25zdCB0cmFuc1VuaXRzSW5GaWxlID0gdGhpcy5fcGFyc2VkRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3VuaXQnKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zVW5pdHNJbkZpbGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnN1bml0ID0gdHJhbnNVbml0c0luRmlsZS5pdGVtKGkpO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IHRyYW5zdW5pdC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICAgICAgICAgIGlmICghaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dhcm5pbmdzLnB1c2goZm9ybWF0KCdvb3BzLCB0cmFucy11bml0IHdpdGhvdXQgXCJpZFwiIGZvdW5kIGluIG1hc3RlciwgcGxlYXNlIGNoZWNrIGZpbGUgJXMnLCB0aGlzLl9maWxlbmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNVbml0cy5wdXNoKG5ldyBYbGlmZjJUcmFuc1VuaXQodHJhbnN1bml0LCBpZCwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBzb3VyY2UgbGFuZ3VhZ2UuXHJcbiAgICAgKiBAcmV0dXJuIHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNvdXJjZUxhbmd1YWdlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgeGxpZmZFbGVtID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3hsaWZmJyk7XHJcbiAgICAgICAgaWYgKHhsaWZmRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4geGxpZmZFbGVtLmdldEF0dHJpYnV0ZSgnc3JjTGFuZycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXQgdGhlIHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZSBsYW5ndWFnZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U291cmNlTGFuZ3VhZ2UobGFuZ3VhZ2U6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHhsaWZmRWxlbSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fcGFyc2VkRG9jdW1lbnQsICd4bGlmZicpO1xyXG4gICAgICAgIGlmICh4bGlmZkVsZW0pIHtcclxuICAgICAgICAgICAgeGxpZmZFbGVtLnNldEF0dHJpYnV0ZSgnc3JjTGFuZycsIGxhbmd1YWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICogQHJldHVybiB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRMYW5ndWFnZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHhsaWZmRWxlbSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fcGFyc2VkRG9jdW1lbnQsICd4bGlmZicpO1xyXG4gICAgICAgIGlmICh4bGlmZkVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHhsaWZmRWxlbS5nZXRBdHRyaWJ1dGUoJ3RyZ0xhbmcnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFZGl0IHRoZSB0YXJnZXQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2UgbGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRhcmdldExhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCB4bGlmZkVsZW0gPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAneGxpZmYnKTtcclxuICAgICAgICBpZiAoeGxpZmZFbGVtKSB7XHJcbiAgICAgICAgICAgIHhsaWZmRWxlbS5zZXRBdHRyaWJ1dGUoJ3RyZ0xhbmcnLCBsYW5ndWFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgbmV3IHRyYW5zLXVuaXQgdG8gdGhpcyBmaWxlLlxyXG4gICAgICogVGhlIHRyYW5zIHVuaXQgc3RlbXMgZnJvbSBhbm90aGVyIGZpbGUuXHJcbiAgICAgKiBJdCBjb3BpZXMgdGhlIHNvdXJjZSBjb250ZW50IG9mIHRoZSB0dSB0byB0aGUgdGFyZ2V0IGNvbnRlbnQgdG9vLFxyXG4gICAgICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgaXNEZWZhdWx0TGFuZyBhbmQgY29weUNvbnRlbnQuXHJcbiAgICAgKiBTbyB0aGUgc291cmNlIGNhbiBiZSB1c2VkIGFzIGEgZHVtbXkgdHJhbnNsYXRpb24uXHJcbiAgICAgKiAodXNlZCBieSB4bGlmZm1lcmdlKVxyXG4gICAgICogQHBhcmFtIGZvcmVpZ25UcmFuc1VuaXQgdGhlIHRyYW5zIHVuaXQgdG8gYmUgaW1wb3J0ZWQuXHJcbiAgICAgKiBAcGFyYW0gaXNEZWZhdWx0TGFuZyBGbGFnLCB3ZXRoZXIgZmlsZSBjb250YWlucyB0aGUgZGVmYXVsdCBsYW5ndWFnZS5cclxuICAgICAqIFRoZW4gc291cmNlIGFuZCB0YXJnZXQgYXJlIGp1c3QgZXF1YWwuXHJcbiAgICAgKiBUaGUgY29udGVudCB3aWxsIGJlIGNvcGllZC5cclxuICAgICAqIFN0YXRlIHdpbGwgYmUgZmluYWwuXHJcbiAgICAgKiBAcGFyYW0gY29weUNvbnRlbnQgRmxhZywgd2V0aGVyIHRvIGNvcHkgY29udGVudCBvciBsZWF2ZSBpdCBlbXB0eS5cclxuICAgICAqIFdiZW4gdHJ1ZSwgY29udGVudCB3aWxsIGJlIGNvcGllZCBmcm9tIHNvdXJjZS5cclxuICAgICAqIFdoZW4gZmFsc2UsIGNvbnRlbnQgd2lsbCBiZSBsZWZ0IGVtcHR5IChpZiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UpLlxyXG4gICAgICogQHBhcmFtIGltcG9ydEFmdGVyRWxlbWVudCBvcHRpb25hbCAoc2luY2UgMS4xMCkgb3RoZXIgdHJhbnN1bml0IChwYXJ0IG9mIHRoaXMgZmlsZSksIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgYW5jZXN0b3IuXHJcbiAgICAgKiBOZXdseSBpbXBvcnRlZCB0cmFucyB1bml0IGlzIHRoZW4gaW5zZXJ0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhpcyBlbGVtZW50LlxyXG4gICAgICogSWYgbm90IHNldCBvciBub3QgcGFydCBvZiB0aGlzIGZpbGUsIG5ldyB1bml0IHdpbGwgYmUgaW1wb3J0ZWQgYXQgdGhlIGVuZC5cclxuICAgICAqIElmIGV4cGxpY2l0eSBzZXQgdG8gbnVsbCwgbmV3IHVuaXQgd2lsbCBiZSBpbXBvcnRlZCBhdCB0aGUgc3RhcnQuXHJcbiAgICAgKiBAcmV0dXJuIHRoZSBuZXdseSBpbXBvcnRlZCB0cmFucyB1bml0IChzaW5jZSB2ZXJzaW9uIDEuNy4wKVxyXG4gICAgICogQHRocm93cyBhbiBlcnJvciBpZiB0cmFucy11bml0IHdpdGggc2FtZSBpZCBhbHJlYWR5IGlzIGluIHRoZSBmaWxlLlxyXG4gICAgICovXHJcbiAgICBpbXBvcnROZXdUcmFuc1VuaXQoZm9yZWlnblRyYW5zVW5pdDogSVRyYW5zVW5pdCwgaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4sIGltcG9ydEFmdGVyRWxlbWVudD86IElUcmFuc1VuaXQpXHJcbiAgICAgICAgOiBJVHJhbnNVbml0IHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc1VuaXRXaXRoSWQoZm9yZWlnblRyYW5zVW5pdC5pZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgndHUgd2l0aCBpZCAlcyBhbHJlYWR5IGV4aXN0cyBpbiBmaWxlLCBjYW5ub3QgaW1wb3J0IGl0JywgZm9yZWlnblRyYW5zVW5pdC5pZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdUdSA9ICg8QWJzdHJhY3RUcmFuc1VuaXQ+IGZvcmVpZ25UcmFuc1VuaXQpLmNsb25lV2l0aFNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmcsIGNvcHlDb250ZW50LCB0aGlzKTtcclxuICAgICAgICBjb25zdCBmaWxlRWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fcGFyc2VkRG9jdW1lbnQsICdmaWxlJyk7XHJcbiAgICAgICAgaWYgKCFmaWxlRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdGaWxlIFwiJXNcIiBzZWVtcyB0byBiZSBubyB4bGlmZiAyLjAgZmlsZSAoc2hvdWxkIGNvbnRhaW4gYSBmaWxlIGVsZW1lbnQpJywgdGhpcy5fZmlsZW5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGluc2VydGVkID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGlzQWZ0ZXJFbGVtZW50UGFydE9mRmlsZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghIWltcG9ydEFmdGVyRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnNlcnRpb25Qb2ludCA9IHRoaXMudHJhbnNVbml0V2l0aElkKGltcG9ydEFmdGVyRWxlbWVudC5pZCk7XHJcbiAgICAgICAgICAgIGlmICghIWluc2VydGlvblBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICBpc0FmdGVyRWxlbWVudFBhcnRPZkZpbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbXBvcnRBZnRlckVsZW1lbnQgPT09IHVuZGVmaW5lZCB8fCAoaW1wb3J0QWZ0ZXJFbGVtZW50ICYmICFpc0FmdGVyRWxlbWVudFBhcnRPZkZpbGUpKSB7XHJcbiAgICAgICAgICAgIGZpbGVFbGVtZW50LmFwcGVuZENoaWxkKG5ld1R1LmFzWG1sRWxlbWVudCgpKTtcclxuICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW1wb3J0QWZ0ZXJFbGVtZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VW5pdEVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAndW5pdCcpO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3RVbml0RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgRE9NVXRpbGl0aWVzLmluc2VydEJlZm9yZShuZXdUdS5hc1htbEVsZW1lbnQoKSwgZmlyc3RVbml0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyB0cmFucy11bml0LCBlbXB0eSBmaWxlLCBzbyBhZGQgdG8gZmlyc3QgZmlsZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBmaWxlRWxlbWVudC5hcHBlbmRDaGlsZChuZXdUdS5hc1htbEVsZW1lbnQoKSk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZWZVbml0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRFbGVtZW50QnlUYWdOYW1lQW5kSWQodGhpcy5fcGFyc2VkRG9jdW1lbnQsICd1bml0JywgaW1wb3J0QWZ0ZXJFbGVtZW50LmlkKTtcclxuICAgICAgICAgICAgaWYgKHJlZlVuaXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMuaW5zZXJ0QWZ0ZXIobmV3VHUuYXNYbWxFbGVtZW50KCksIHJlZlVuaXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zZXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXp5SW5pdGlhbGl6ZVRyYW5zVW5pdHMoKTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc1VuaXRzLnB1c2gobmV3VHUpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50TnVtYmVycygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3VHU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zbGF0aW9uIGZpbGUgZm9yIHRoaXMgZmlsZSBmb3IgYSBnaXZlbiBsYW5ndWFnZS5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGp1c3QgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvbmUuXHJcbiAgICAgKiBCdXQgZm9yIFhNQiB0aGUgdHJhbnNsYXRpb24gZmlsZSBoYXMgZm9ybWF0ICdYVEInLlxyXG4gICAgICogQHBhcmFtIGxhbmcgTGFuZ3VhZ2UgY29kZVxyXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIGV4cGVjdGVkIGZpbGVuYW1lIHRvIHN0b3JlIGZpbGVcclxuICAgICAqIEBwYXJhbSBpc0RlZmF1bHRMYW5nIEZsYWcsIHdldGhlciBmaWxlIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGxhbmd1YWdlLlxyXG4gICAgICogVGhlbiBzb3VyY2UgYW5kIHRhcmdldCBhcmUganVzdCBlcXVhbC5cclxuICAgICAqIFRoZSBjb250ZW50IHdpbGwgYmUgY29waWVkLlxyXG4gICAgICogU3RhdGUgd2lsbCBiZSBmaW5hbC5cclxuICAgICAqIEBwYXJhbSBjb3B5Q29udGVudCBGbGFnLCB3ZXRoZXIgdG8gY29weSBjb250ZW50IG9yIGxlYXZlIGl0IGVtcHR5LlxyXG4gICAgICogV2JlbiB0cnVlLCBjb250ZW50IHdpbGwgYmUgY29waWVkIGZyb20gc291cmNlLlxyXG4gICAgICogV2hlbiBmYWxzZSwgY29udGVudCB3aWxsIGJlIGxlZnQgZW1wdHkgKGlmIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBsYW5ndWFnZSkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nKGxhbmc6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZywgaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4pXHJcbiAgICAgICAgOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uRmlsZSA9IG5ldyBYbGlmZjJGaWxlKHRoaXMuZWRpdGVkQ29udGVudCgpLCBmaWxlbmFtZSwgdGhpcy5lbmNvZGluZygpKTtcclxuICAgICAgICB0cmFuc2xhdGlvbkZpbGUuc2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCh0aGlzLnRhcmdldFByYWVmaXgpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRmlsZS5zZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgodGhpcy50YXJnZXRTdWZmaXgpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRmlsZS5zZXRUYXJnZXRMYW5ndWFnZShsYW5nKTtcclxuICAgICAgICB0cmFuc2xhdGlvbkZpbGUuZm9yRWFjaFRyYW5zVW5pdCgodHJhbnNVbml0OiBJVHJhbnNVbml0KSA9PiB7XHJcbiAgICAgICAgICAgICg8QWJzdHJhY3RUcmFuc1VuaXQ+IHRyYW5zVW5pdCkudXNlU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZywgY29weUNvbnRlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGlvbkZpbGU7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuLi9hcGkvaS10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuaW1wb3J0IHtJTm9ybWFsaXplZE1lc3NhZ2V9IGZyb20gJy4uL2FwaS9pLW5vcm1hbGl6ZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7SVRyYW5zVW5pdH0gZnJvbSAnLi4vYXBpL2ktdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7SU5vdGV9IGZyb20gJy4uL2FwaS9pLW5vdGUnO1xyXG5pbXBvcnQge0RPTVV0aWxpdGllc30gZnJvbSAnLi9kb20tdXRpbGl0aWVzJztcclxuaW1wb3J0IHtBYnN0cmFjdFRyYW5zVW5pdH0gZnJvbSAnLi9hYnN0cmFjdC10cmFucy11bml0JztcclxuaW1wb3J0IHtYbWJNZXNzYWdlUGFyc2VyfSBmcm9tICcuL3htYi1tZXNzYWdlLXBhcnNlcic7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7QWJzdHJhY3RNZXNzYWdlUGFyc2VyfSBmcm9tICcuL2Fic3RyYWN0LW1lc3NhZ2UtcGFyc2VyJztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDIzLjA1LjIwMTcuXHJcbiAqIEEgVHJhbnNsYXRpb24gVW5pdCBpbiBhbiBYVEIgZmlsZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgWHRiVHJhbnNVbml0IGV4dGVuZHMgQWJzdHJhY3RUcmFuc1VuaXQgaW1wbGVtZW50cyBJVHJhbnNVbml0IHtcclxuXHJcbiAgICBwcml2YXRlIF9zb3VyY2VUcmFuc1VuaXRGcm9tTWFzdGVyOiBBYnN0cmFjdFRyYW5zVW5pdDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudDogRWxlbWVudCwgX2lkOiBzdHJpbmcsIF90cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLFxyXG4gICAgICAgICAgICAgICAgX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXI6IEFic3RyYWN0VHJhbnNVbml0KSB7XHJcbiAgICAgICAgc3VwZXIoX2VsZW1lbnQsIF9pZCwgX3RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTtcclxuICAgICAgICB0aGlzLl9zb3VyY2VUcmFuc1VuaXRGcm9tTWFzdGVyID0gX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgY29udGVudCB0byB0cmFuc2xhdGUuXHJcbiAgICAgKiBTb3VyY2UgcGFydHMgYXJlIGV4Y2x1ZGVkIGhlcmUuXHJcbiAgICAgKiBAcmV0dXJuIGNvbnRlbnQgdG8gdHJhbnNsYXRlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc291cmNlQ29udGVudCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2VUcmFuc1VuaXRGcm9tTWFzdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VUcmFuc1VuaXRGcm9tTWFzdGVyLnNvdXJjZUNvbnRlbnQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBzb3VyY2UgY29udGVudCBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldFNvdXJjZUNvbnRlbnQgaW4gdHJhbnMtdW5pdCB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgc3VwcG9ydHNTZXRTb3VyY2VDb250ZW50KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBuZXcgc291cmNlIGNvbnRlbnQgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3NpbmcgY2hhbmdlZCBzb3VyY2UgY29udGVudC5cclxuICAgICAqIEBwYXJhbSBuZXdDb250ZW50IHRoZSBuZXcgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZUNvbnRlbnQobmV3Q29udGVudDogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8geHRiIGhhcyBubyBzb3VyY2UgY29udGVudCwgdGhleSBhcmUgcGFydCBvZiB0aGUgbWFzdGVyXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBwYXJzZXIgdXNlZCBmb3Igbm9ybWFsaXplZCBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1lc3NhZ2VQYXJzZXIoKTogQWJzdHJhY3RNZXNzYWdlUGFyc2VyIHtcclxuICAgICAgICByZXR1cm4gbmV3IFhtYk1lc3NhZ2VQYXJzZXIoKTsgLy8gbm8gdHlwbyEsIFNhbWUgYXMgZm9yIFhtYlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWdpbmFsIHRleHQgdmFsdWUsIHRoYXQgaXMgdG8gYmUgdHJhbnNsYXRlZCwgYXMgbm9ybWFsaXplZCBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlU291cmNlQ29udGVudE5vcm1hbGl6ZWQoKTogUGFyc2VkTWVzc2FnZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIuY3JlYXRlU291cmNlQ29udGVudE5vcm1hbGl6ZWQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgdHJhbnNsYXRlZCB2YWx1ZSAoY29udGFpbmluZyBhbGwgbWFya3VwLCBkZXBlbmRzIG9uIHRoZSBjb25jcmV0ZSBmb3JtYXQgdXNlZCkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRDb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIERPTVV0aWxpdGllcy5nZXRYTUxDb250ZW50KHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHRyYW5zbGF0ZWQgdmFsdWUsIGJ1dCBhbGwgcGxhY2Vob2xkZXJzIGFyZSByZXBsYWNlZCB3aXRoIHt7bn19IChzdGFydGluZyBhdCAwKVxyXG4gICAgICogYW5kIGFsbCBlbWJlZGRlZCBodG1sIGlzIHJlcGxhY2VkIGJ5IGRpcmVjdCBodG1sIG1hcmt1cC5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0Q29udGVudE5vcm1hbGl6ZWQoKTogSU5vcm1hbGl6ZWRNZXNzYWdlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlUGFyc2VyKCkuY3JlYXRlTm9ybWFsaXplZE1lc3NhZ2VGcm9tWE1MKHRoaXMuX2VsZW1lbnQsIHRoaXMuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0ZSBvZiB0aGUgdHJhbnNsYXRpb24uXHJcbiAgICAgKiAobm90IHN1cHBvcnRlZCBpbiB4bWIpXHJcbiAgICAgKiBJZiB3ZSBoYXZlIGEgbWFzdGVyLCB3ZSBhc3N1bWVkIGl0IGlzIHRyYW5zbGF0ZWQgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBtYXN0ZXJzIG9uZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5hdGl2ZVRhcmdldFN0YXRlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlQ29udGVudCA9IHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIuc291cmNlQ29udGVudCgpO1xyXG4gICAgICAgICAgICBpZiAoIXNvdXJjZUNvbnRlbnQgfHwgc291cmNlQ29udGVudCA9PT0gdGhpcy50YXJnZXRDb250ZW50KCkgfHwgIXRoaXMudGFyZ2V0Q29udGVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25ldyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2ZpbmFsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gbm90IHN1cHBvcnRlZCBpbiB4bWJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBhbiBhYnN0cmFjdCBzdGF0ZSAobmV3LCB0cmFuc2xhdGVkLCBmaW5hbCkgdG8gYSBjb25jcmV0ZSBzdGF0ZSB1c2VkIGluIHRoZSB4bWwuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSB0byBiZSB1c2VkIGluIHRoZSB4bWwuXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgb25lIG9mIENvbnN0YW50cy5TVEFURS4uLlxyXG4gICAgICogQHJldHVybnMgYSBuYXRpdmUgc3RhdGUgKGRlcGVuZHMgb24gY29uY3JldGUgZm9ybWF0KVxyXG4gICAgICogQHRocm93cyBlcnJvciwgaWYgc3RhdGUgaXMgaW52YWxpZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1hcFN0YXRlVG9OYXRpdmVTdGF0ZShzdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgYSBuYXRpdmUgc3RhdGUgKGZvdW5kIGluIHRoZSBkb2N1bWVudCkgdG8gYW4gYWJzdHJhY3Qgc3RhdGUgKG5ldywgdHJhbnNsYXRlZCwgZmluYWwpLlxyXG4gICAgICogUmV0dXJucyB0aGUgYWJzdHJhY3Qgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gbmF0aXZlU3RhdGUgbmF0aXZlU3RhdGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1hcE5hdGl2ZVN0YXRlVG9TdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gbmF0aXZlU3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgc3RhdGUgaW4geG1sLlxyXG4gICAgICogKG5vdCBzdXBwb3J0ZWQgaW4geG1iKVxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0YXRlIG5hdGl2ZVN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzZXROYXRpdmVUYXJnZXRTdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gVE9ETyBzb21lIGxvZ2ljIHRvIHN0b3JlIGl0IGFueXdoZXJlXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdGhlIHNvdXJjZSBlbGVtZW50cyBpbiB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqIFRoZSBzb3VyY2UgZWxlbWVudCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUgZmlsZSBhbmQgYSBsaW5lIG51bWJlciB3aXRoIHRoZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHRlbXBsYXRlLlxyXG4gICAgICogSXQgaXMganVzdCBhIGhlbHAgZm9yIHRyYW5zbGF0b3JzIHRvIGZpbmQgdGhlIGNvbnRleHQgZm9yIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIFRoaXMgaXMgc2V0IHdoZW4gdXNpbmcgQW5ndWxhciA0LjAgb3IgZ3JlYXRlci5cclxuICAgICAqIE90aGVyd2lzZSBpdCBqdXN0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VSZWZlcmVuY2VzKCk6IHsgc291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyOiBudW1iZXIgfVtdIHtcclxuICAgICAgICBpZiAodGhpcy5fc291cmNlVHJhbnNVbml0RnJvbU1hc3Rlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlVHJhbnNVbml0RnJvbU1hc3Rlci5zb3VyY2VSZWZlcmVuY2VzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciBzZXR0aW5nIG9mIHNvdXJjZSByZWZzIGlzIHN1cHBvcnRlZC5cclxuICAgICAqIElmIG5vdCwgc2V0U291cmNlUmVmZXJlbmNlcyB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1cHBvcnRzU2V0U291cmNlUmVmZXJlbmNlcygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc291cmNlIHJlZiBlbGVtZW50cyBpbiB0aGUgdHJhbnN1bml0LlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMgZG9uZSBieSBuZy1leHRyYWN0LlxyXG4gICAgICogTWV0aG9kIG9ubHkgZXhpc3RzIHRvIGFsbG93IHhsaWZmbWVyZ2UgdG8gbWVyZ2UgbWlzc2luZyBzb3VyY2UgcmVmcy5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VSZWZzIHRoZSBzb3VyY2VyZWZzIHRvIHNldC4gT2xkIG9uZXMgYXJlIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTb3VyY2VSZWZlcmVuY2VzKHNvdXJjZVJlZnM6IHtzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlcn1bXSkge1xyXG4gICAgICAgIC8vIHh0YiBoYXMgbm8gc291cmNlIHJlZnMsIHRoZXkgYXJlIHBhcnQgb2YgdGhlIG1hc3RlclxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIHNldCBpbiB0aGUgdGVtcGxhdGUgYXMgdmFsdWUgb2YgdGhlIGkxOG4tYXR0cmlidXRlLlxyXG4gICAgICogZS5nLiBpMThuPVwibXlkZXNjcmlwdGlvblwiLlxyXG4gICAgICogSW4geHRiIG9ubHkgdGhlIG1hc3RlciBzdG9yZXMgaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2VUcmFuc1VuaXRGcm9tTWFzdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VUcmFuc1VuaXRGcm9tTWFzdGVyLmRlc2NyaXB0aW9uKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1lYW5pbmcgKGludGVudCkgc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBwYXJ0IGluIGZyb250IG9mIHRoZSB8IHN5bWJvbC5cclxuICAgICAqIGUuZy4gaTE4bj1cIm1lYW5pbmd8bXlkZXNjcmlwdGlvblwiLlxyXG4gICAgICogSW4geHRiIG9ubHkgdGhlIG1hc3RlciBzdG9yZXMgaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtZWFuaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZVRyYW5zVW5pdEZyb21NYXN0ZXIubWVhbmluZygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciBzZXR0aW5nIG9mIGRlc2NyaXB0aW9uIGFuZCBtZWFuaW5nIGlzIHN1cHBvcnRlZC5cclxuICAgICAqIElmIG5vdCwgc2V0RGVzY3JpcHRpb24gYW5kIHNldE1lYW5pbmcgd2lsbCBkbyBub3RoaW5nLlxyXG4gICAgICogeHRiIGRvZXMgbm90IHN1cHBvcnQgdGhpcywgYWxsIG90aGVyIGZvcm1hdHMgZG8uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdXBwb3J0c1NldERlc2NyaXB0aW9uQW5kTWVhbmluZygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgZGVzY3JpcHRpb24gcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBkZXNjcmlwdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RGVzY3JpcHRpb24oZGVzY3JpcHRpb246IHN0cmluZykge1xyXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQsIGRvIG5vdGhpbmdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBtZWFuaW5nIHByb3BlcnR5IG9mIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBAcGFyYW0gbWVhbmluZyBtZWFuaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRNZWFuaW5nKG1lYW5pbmc6IHN0cmluZykge1xyXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQsIGRvIG5vdGhpbmdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbm90ZXMgb2YgdGhlIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBUaGVyZSBhcmUgTk8gbm90ZXMgaW4geG1iL3h0YlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbm90ZXMoKTogSU5vdGVbXSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2Ygbm90ZXMgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXROb3RlcyB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1cHBvcnRzU2V0Tm90ZXMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIG5vdGVzIHRvIHRyYW5zIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0gbmV3Tm90ZXMgdGhlIG5vdGVzIHRvIGFkZC5cclxuICAgICAqIE5PVCBTdXBwb3J0ZWQgaW4geG1iL3h0YlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Tm90ZXMobmV3Tm90ZXM6IElOb3RlW10pIHtcclxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkLCBkbyBub3RoaW5nXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogUmV0dXJucyBhIGNoYW5nZWQgY29weSBvZiB0aGlzIHRyYW5zIHVuaXQuXHJcbiAgICAgKiByZWNlaXZlciBpcyBub3QgY2hhbmdlZC5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgY2FsbCBpbXBvcnROZXdUcmFuc1VuaXQgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKiBJbiB4dGIgdGhlcmUgaXMgbm90aGluZyB0byBkbywgYmVjYXVzZSB0aGVyZSBpcyBvbmx5IGEgdGFyZ2V0LCBubyBzb3VyY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbG9uZVdpdGhTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbiwgdGFyZ2V0RmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTogQWJzdHJhY3RUcmFuc1VuaXQge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBzb3VyY2UgdG8gdGFyZ2V0IHRvIHVzZSBpdCBhcyBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgY2FsbCBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nIG9uIElUcmFuc2xhdGlvbk1lc3NhZ2VGaWxlKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXNlU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4pIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRyYW5zbGF0aW9uIHRvIGEgZ2l2ZW4gc3RyaW5nIChpbmNsdWRpbmcgbWFya3VwKS5cclxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiB0cmFuc2xhdGlvblxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdHJhbnNsYXRlTmF0aXZlKHRyYW5zbGF0aW9uOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9lbGVtZW50O1xyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh0cmFuc2xhdGlvbikpIHtcclxuICAgICAgICAgICAgdHJhbnNsYXRpb24gPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQodGFyZ2V0LCB0cmFuc2xhdGlvbik7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZS1mYWN0b3J5JztcclxuaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4uL2FwaS9pLXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUnO1xyXG5pbXBvcnQge0lUcmFuc1VuaXR9IGZyb20gJy4uL2FwaS9pLXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge0ZPUk1BVF9YVEIsIEZJTEVUWVBFX1hUQiwgRk9STUFUX1hNQn0gZnJvbSAnLi4vYXBpL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7Zm9ybWF0fSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtET01VdGlsaXRpZXN9IGZyb20gJy4vZG9tLXV0aWxpdGllcyc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi9hYnN0cmFjdC10cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlJztcclxuaW1wb3J0IHtYdGJUcmFuc1VuaXR9IGZyb20gJy4veHRiLXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNVbml0fSBmcm9tICcuL2Fic3RyYWN0LXRyYW5zLXVuaXQnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMjMuMDUuMjAxNy5cclxuICogeHRiLUZpbGUgYWNjZXNzLlxyXG4gKiB4dGIgaXMgdGhlIHRyYW5zbGF0ZWQgY291bnRlcnBhcnQgdG8geG1iLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYdGJGaWxlIGV4dGVuZHMgQWJzdHJhY3RUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSBpbXBsZW1lbnRzIElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcblxyXG4gICAgLy8gYXR0YWNoZWQgbWFzdGVyIGZpbGUsIGlmIGFueVxyXG4gICAgLy8gdXNlZCBhcyBzb3VyY2UgdG8gZGV0ZXJtaW5lIHN0YXRlIC4uLlxyXG4gICAgcHJpdmF0ZSBfbWFzdGVyRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlOyAvLyBhbiB4bWItZmlsZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIHhtYi1GaWxlIGZyb20gc291cmNlLlxyXG4gICAgICogQHBhcmFtIF90cmFuc2xhdGlvbk1lc3NhZ2VGaWxlRmFjdG9yeSBmYWN0b3J5IHRvIGNyZWF0ZSBhIHRyYW5zbGF0aW9uIGZpbGUgKHh0YikgZm9yIHRoZSB4bWIgZmlsZVxyXG4gICAgICogQHBhcmFtIHhtbFN0cmluZyBmaWxlIGNvbnRlbnRcclxuICAgICAqIEBwYXJhbSBwYXRoIFBhdGggdG8gZmlsZVxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIG9wdGlvbmFsIGVuY29kaW5nIG9mIHRoZSB4bWwuXHJcbiAgICAgKiBUaGlzIGlzIHJlYWQgZnJvbSB0aGUgZmlsZSwgYnV0IGlmIHlvdSBrbm93IGl0IGJlZm9yZSwgeW91IGNhbiBhdm9pZCByZWFkaW5nIHRoZSBmaWxlIHR3aWNlLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbmFsTWFzdGVyIGluIGNhc2Ugb2YgeG1iIHRoZSBtYXN0ZXIgZmlsZSwgdGhhdCBjb250YWlucyB0aGUgb3JpZ2luYWwgdGV4dHMuXHJcbiAgICAgKiAodGhpcyBpcyB1c2VkIHRvIHN1cHBvcnQgc3RhdGUgaW5mb3MsIHRoYXQgYXJlIGJhc2VkIG9uIGNvbXBhcmluZyBvcmlnaW5hbCB3aXRoIHRyYW5zbGF0ZWQgdmVyc2lvbilcclxuICAgICAqIEByZXR1cm4gWG1iRmlsZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90cmFuc2xhdGlvbk1lc3NhZ2VGaWxlRmFjdG9yeTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeSxcclxuICAgICAgICAgICAgICAgIHhtbFN0cmluZzogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3Rlcj86IHsgeG1sQ29udGVudDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcgfSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fd2FybmluZ3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkID0gMDtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVGcm9tQ29udGVudCh4bWxTdHJpbmcsIHBhdGgsIGVuY29kaW5nLCBvcHRpb25hbE1hc3Rlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplRnJvbUNvbnRlbnQoeG1sU3RyaW5nOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsTWFzdGVyPzogeyB4bWxDb250ZW50OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyB9KTogWHRiRmlsZSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZUNvbnRlbnQoeG1sU3RyaW5nLCBwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNlZERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0cmFuc2xhdGlvbmJ1bmRsZScpLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdGaWxlIFwiJXNcIiBzZWVtcyB0byBiZSBubyB4dGIgZmlsZSAoc2hvdWxkIGNvbnRhaW4gYSB0cmFuc2xhdGlvbmJ1bmRsZSBlbGVtZW50KScsIHBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbmFsTWFzdGVyKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXN0ZXJGaWxlID0gdGhpcy5fdHJhbnNsYXRpb25NZXNzYWdlRmlsZUZhY3RvcnkuY3JlYXRlRmlsZUZyb21GaWxlQ29udGVudChcclxuICAgICAgICAgICAgICAgICAgICBGT1JNQVRfWE1CLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsTWFzdGVyLnhtbENvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXIucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3Rlci5lbmNvZGluZyk7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjaywgd2V0aGVyIHRoaXMgY2FuIGJlIHRoZSBtYXN0ZXIgLi4uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJJbk1hc3RlciA9IHRoaXMuX21hc3RlckZpbGUubnVtYmVyT2ZUcmFuc1VuaXRzKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBteU51bWJlciA9IHRoaXMubnVtYmVyT2ZUcmFuc1VuaXRzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVySW5NYXN0ZXIgIT09IG15TnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2FybmluZ3MucHVzaChmb3JtYXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICclcyB0cmFucyB1bml0cyBmb3VuZCBpbiBtYXN0ZXIsIGJ1dCB0aGlzIGZpbGUgaGFzICVzLiBDaGVjayBpZiBpdCBpcyB0aGUgY29ycmVjdCBtYXN0ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJJbk1hc3RlciwgbXlOdW1iZXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0ZpbGUgXCIlc1wiIHNlZW1zIHRvIGJlIG5vIHhtYiBmaWxlLiBBbiB4dGIgZmlsZSBuZWVkcyB4bWIgYXMgbWFzdGVyIGZpbGUuJywgb3B0aW9uYWxNYXN0ZXIucGF0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBpbml0aWFsaXplVHJhbnNVbml0cygpIHtcclxuICAgICAgICB0aGlzLnRyYW5zVW5pdHMgPSBbXTtcclxuICAgICAgICBjb25zdCB0cmFuc1VuaXRzSW5GaWxlID0gdGhpcy5fcGFyc2VkRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RyYW5zbGF0aW9uJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc1VuaXRzSW5GaWxlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRyYW5zVW5pdHNJbkZpbGUuaXRlbShpKTtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBtc2cuZ2V0QXR0cmlidXRlKCdpZCcpO1xyXG4gICAgICAgICAgICBpZiAoIWlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93YXJuaW5ncy5wdXNoKGZvcm1hdCgnb29wcywgbXNnIHdpdGhvdXQgXCJpZFwiIGZvdW5kIGluIG1hc3RlciwgcGxlYXNlIGNoZWNrIGZpbGUgJXMnLCB0aGlzLl9maWxlbmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBtYXN0ZXJVbml0OiBJVHJhbnNVbml0ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21hc3RlckZpbGUpIHtcclxuICAgICAgICAgICAgICAgIG1hc3RlclVuaXQgPSB0aGlzLl9tYXN0ZXJGaWxlLnRyYW5zVW5pdFdpdGhJZChpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFuc1VuaXRzLnB1c2gobmV3IFh0YlRyYW5zVW5pdChtc2csIGlkLCB0aGlzLCA8QWJzdHJhY3RUcmFuc1VuaXQ+IG1hc3RlclVuaXQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxlIGZvcm1hdCBhcyBpdCBpcyB1c2VkIGluIGNvbmZpZyBmaWxlcy5cclxuICAgICAqIEN1cnJlbnRseSAneGxmJywgJ3hsZjInLCAneG1iJywgJ3h0YidcclxuICAgICAqIFJldHVybnMgb25lIG9mIHRoZSBjb25zdGFudHMgRk9STUFUXy4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpMThuRm9ybWF0KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIEZPUk1BVF9YVEI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxlIHR5cGUuXHJcbiAgICAgKiBIZXJlICdYVEInXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmaWxlVHlwZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBGSUxFVFlQRV9YVEI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdGFnIG5hbWVzIG9mIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgbWl4ZWQgY29udGVudC5cclxuICAgICAqIFRoZXNlIGVsZW1lbnRzIHdpbGwgbm90IGJlIGJlYXV0aWZpZWQuXHJcbiAgICAgKiBUeXBpY2FsIGNhbmRpZGF0ZXMgYXJlIHNvdXJjZSBhbmQgdGFyZ2V0LlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZWxlbWVudHNXaXRoTWl4ZWRDb250ZW50KCk6IHN0cmluZ1tdIHtcclxuICAgICAgICByZXR1cm4gWyd0cmFuc2xhdGlvbiddO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqIFVuc3VwcG9ydGVkIGluIHhtYi94dGIuXHJcbiAgICAgKiBUcnkgdG8gZ3Vlc3MgaXQgZnJvbSBtYXN0ZXIgZmlsZW5hbWUgaWYgYW55Li5cclxuICAgICAqIEByZXR1cm4gc291cmNlIGxhbmd1YWdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc291cmNlTGFuZ3VhZ2UoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5fbWFzdGVyRmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFzdGVyRmlsZS5zb3VyY2VMYW5ndWFnZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXQgdGhlIHNvdXJjZSBsYW5ndWFnZS5cclxuICAgICAqIFVuc3VwcG9ydGVkIGluIHhtYi94dGIuXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2UgbGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZUxhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nLCB4dGIgaGFzIG5vIG5vdGF0aW9uIGZvciB0aGlzLlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRhcmdldCBsYW5ndWFnZS5cclxuICAgICAqIEByZXR1cm4gdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdGFyZ2V0TGFuZ3VhZ2UoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbmJ1bmRsZUVsZW0gPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX3BhcnNlZERvY3VtZW50LCAndHJhbnNsYXRpb25idW5kbGUnKTtcclxuICAgICAgICBpZiAodHJhbnNsYXRpb25idW5kbGVFbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbmJ1bmRsZUVsZW0uZ2V0QXR0cmlidXRlKCdsYW5nJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdCB0aGUgdGFyZ2V0IGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlIGxhbmd1YWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUYXJnZXRMYW5ndWFnZShsYW5ndWFnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25idW5kbGVFbGVtID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3RyYW5zbGF0aW9uYnVuZGxlJyk7XHJcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uYnVuZGxlRWxlbSkge1xyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbmJ1bmRsZUVsZW0uc2V0QXR0cmlidXRlKCdsYW5nJywgbGFuZ3VhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIG5ldyB0cmFucy11bml0IHRvIHRoaXMgZmlsZS5cclxuICAgICAqIFRoZSB0cmFucyB1bml0IHN0ZW1zIGZyb20gYW5vdGhlciBmaWxlLlxyXG4gICAgICogSXQgY29waWVzIHRoZSBzb3VyY2UgY29udGVudCBvZiB0aGUgdHUgdG8gdGhlIHRhcmdldCBjb250ZW50IHRvbyxcclxuICAgICAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIGlzRGVmYXVsdExhbmcgYW5kIGNvcHlDb250ZW50LlxyXG4gICAgICogU28gdGhlIHNvdXJjZSBjYW4gYmUgdXNlZCBhcyBhIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKHVzZWQgYnkgeGxpZmZtZXJnZSlcclxuICAgICAqIEBwYXJhbSBmb3JlaWduVHJhbnNVbml0IHRoZSB0cmFucyB1bml0IHRvIGJlIGltcG9ydGVkLlxyXG4gICAgICogQHBhcmFtIGlzRGVmYXVsdExhbmcgRmxhZywgd2V0aGVyIGZpbGUgY29udGFpbnMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UuXHJcbiAgICAgKiBUaGVuIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBqdXN0IGVxdWFsLlxyXG4gICAgICogVGhlIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQuXHJcbiAgICAgKiBTdGF0ZSB3aWxsIGJlIGZpbmFsLlxyXG4gICAgICogQHBhcmFtIGNvcHlDb250ZW50IEZsYWcsIHdldGhlciB0byBjb3B5IGNvbnRlbnQgb3IgbGVhdmUgaXQgZW1wdHkuXHJcbiAgICAgKiBXYmVuIHRydWUsIGNvbnRlbnQgd2lsbCBiZSBjb3BpZWQgZnJvbSBzb3VyY2UuXHJcbiAgICAgKiBXaGVuIGZhbHNlLCBjb250ZW50IHdpbGwgYmUgbGVmdCBlbXB0eSAoaWYgaXQgaXMgbm90IHRoZSBkZWZhdWx0IGxhbmd1YWdlKS5cclxuICAgICAqIEBwYXJhbSBpbXBvcnRBZnRlckVsZW1lbnQgb3B0aW9uYWwgKHNpbmNlIDEuMTApIG90aGVyIHRyYW5zdW5pdCAocGFydCBvZiB0aGlzIGZpbGUpLCB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIGFuY2VzdG9yLlxyXG4gICAgICogTmV3bHkgaW1wb3J0ZWQgdHJhbnMgdW5pdCBpcyB0aGVuIGluc2VydGVkIGRpcmVjdGx5IGFmdGVyIHRoaXMgZWxlbWVudC5cclxuICAgICAqIElmIG5vdCBzZXQgb3Igbm90IHBhcnQgb2YgdGhpcyBmaWxlLCBuZXcgdW5pdCB3aWxsIGJlIGltcG9ydGVkIGF0IHRoZSBlbmQuXHJcbiAgICAgKiBJZiBleHBsaWNpdHkgc2V0IHRvIG51bGwsIG5ldyB1bml0IHdpbGwgYmUgaW1wb3J0ZWQgYXQgdGhlIHN0YXJ0LlxyXG4gICAgICogQHJldHVybiB0aGUgbmV3bHkgaW1wb3J0ZWQgdHJhbnMgdW5pdCAoc2luY2UgdmVyc2lvbiAxLjcuMClcclxuICAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdHJhbnMtdW5pdCB3aXRoIHNhbWUgaWQgYWxyZWFkeSBpcyBpbiB0aGUgZmlsZS5cclxuICAgICAqL1xyXG4gICAgaW1wb3J0TmV3VHJhbnNVbml0KGZvcmVpZ25UcmFuc1VuaXQ6IElUcmFuc1VuaXQsIGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuLCBpbXBvcnRBZnRlckVsZW1lbnQ/OiBJVHJhbnNVbml0KVxyXG4gICAgICAgIDogSVRyYW5zVW5pdCB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNVbml0V2l0aElkKGZvcmVpZ25UcmFuc1VuaXQuaWQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ3R1IHdpdGggaWQgJXMgYWxyZWFkeSBleGlzdHMgaW4gZmlsZSwgY2Fubm90IGltcG9ydCBpdCcsIGZvcmVpZ25UcmFuc1VuaXQuaWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3TWFzdGVyVHUgPSAoPEFic3RyYWN0VHJhbnNVbml0PiBmb3JlaWduVHJhbnNVbml0KS5jbG9uZVdpdGhTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nLCBjb3B5Q29udGVudCwgdGhpcyk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25idW5kbGVFbGVtID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3RyYW5zbGF0aW9uYnVuZGxlJyk7XHJcbiAgICAgICAgaWYgKCF0cmFuc2xhdGlvbmJ1bmRsZUVsZW0pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRmlsZSBcIiVzXCIgc2VlbXMgdG8gYmUgbm8geHRiIGZpbGUgKHNob3VsZCBjb250YWluIGEgdHJhbnNsYXRpb25idW5kbGUgZWxlbWVudCknLCB0aGlzLl9maWxlbmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbkVsZW1lbnQgPSB0cmFuc2xhdGlvbmJ1bmRsZUVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFuc2xhdGlvbicpO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgZm9yZWlnblRyYW5zVW5pdC5pZCk7XHJcbiAgICAgICAgbGV0IG5ld0NvbnRlbnQgPSAoY29weUNvbnRlbnQgfHwgaXNEZWZhdWx0TGFuZykgPyBmb3JlaWduVHJhbnNVbml0LnNvdXJjZUNvbnRlbnQoKSA6ICcnO1xyXG4gICAgICAgIGlmICghKDxBYnN0cmFjdFRyYW5zVW5pdD4gZm9yZWlnblRyYW5zVW5pdCkuaXNJQ1VNZXNzYWdlKG5ld0NvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB0aGlzLmdldE5ld1RyYW5zVW5pdFRhcmdldFByYWVmaXgoKSArIG5ld0NvbnRlbnQgKyB0aGlzLmdldE5ld1RyYW5zVW5pdFRhcmdldFN1ZmZpeCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudCh0cmFuc2xhdGlvbkVsZW1lbnQsIG5ld0NvbnRlbnQpO1xyXG4gICAgICAgIGNvbnN0IG5ld1R1ID0gbmV3IFh0YlRyYW5zVW5pdCh0cmFuc2xhdGlvbkVsZW1lbnQsIGZvcmVpZ25UcmFuc1VuaXQuaWQsIHRoaXMsIG5ld01hc3RlclR1KTtcclxuICAgICAgICBsZXQgaW5zZXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgaXNBZnRlckVsZW1lbnRQYXJ0T2ZGaWxlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCEhaW1wb3J0QWZ0ZXJFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc2VydGlvblBvaW50ID0gdGhpcy50cmFuc1VuaXRXaXRoSWQoaW1wb3J0QWZ0ZXJFbGVtZW50LmlkKTtcclxuICAgICAgICAgICAgaWYgKCEhaW5zZXJ0aW9uUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIGlzQWZ0ZXJFbGVtZW50UGFydE9mRmlsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGltcG9ydEFmdGVyRWxlbWVudCA9PT0gdW5kZWZpbmVkIHx8IChpbXBvcnRBZnRlckVsZW1lbnQgJiYgIWlzQWZ0ZXJFbGVtZW50UGFydE9mRmlsZSkpIHtcclxuICAgICAgICAgICAgdHJhbnNsYXRpb25idW5kbGVFbGVtLmFwcGVuZENoaWxkKG5ld1R1LmFzWG1sRWxlbWVudCgpKTtcclxuICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW1wb3J0QWZ0ZXJFbGVtZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VHJhbnNsYXRpb25FbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9wYXJzZWREb2N1bWVudCwgJ3RyYW5zbGF0aW9uJyk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdFRyYW5zbGF0aW9uRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgRE9NVXRpbGl0aWVzLmluc2VydEJlZm9yZShuZXdUdS5hc1htbEVsZW1lbnQoKSwgZmlyc3RUcmFuc2xhdGlvbkVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gdHJhbnMtdW5pdCwgZW1wdHkgZmlsZSwgc28gYWRkIHRvIGJ1bmRsZSBhdCBlbmRcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uYnVuZGxlRWxlbS5hcHBlbmRDaGlsZChuZXdUdS5hc1htbEVsZW1lbnQoKSk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZWZVbml0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRFbGVtZW50QnlUYWdOYW1lQW5kSWQodGhpcy5fcGFyc2VkRG9jdW1lbnQsICd0cmFuc2xhdGlvbicsIGltcG9ydEFmdGVyRWxlbWVudC5pZCk7XHJcbiAgICAgICAgICAgIGlmIChyZWZVbml0RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgRE9NVXRpbGl0aWVzLmluc2VydEFmdGVyKG5ld1R1LmFzWG1sRWxlbWVudCgpLCByZWZVbml0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc2VydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGF6eUluaXRpYWxpemVUcmFuc1VuaXRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNVbml0cy5wdXNoKG5ld1R1KTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudE51bWJlcnMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1R1O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2xhdGlvbiBmaWxlIGZvciB0aGlzIGZpbGUgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UuXHJcbiAgICAgKiBOb3JtYWxseSwgdGhpcyBpcyBqdXN0IGEgY29weSBvZiB0aGUgb3JpZ2luYWwgb25lLlxyXG4gICAgICogQnV0IGZvciBYTUIgdGhlIHRyYW5zbGF0aW9uIGZpbGUgaGFzIGZvcm1hdCAnWFRCJy5cclxuICAgICAqIEBwYXJhbSBsYW5nIExhbmd1YWdlIGNvZGVcclxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBleHBlY3RlZCBmaWxlbmFtZSB0byBzdG9yZSBmaWxlXHJcbiAgICAgKiBAcGFyYW0gaXNEZWZhdWx0TGFuZyBGbGFnLCB3ZXRoZXIgZmlsZSBjb250YWlucyB0aGUgZGVmYXVsdCBsYW5ndWFnZS5cclxuICAgICAqIFRoZW4gc291cmNlIGFuZCB0YXJnZXQgYXJlIGp1c3QgZXF1YWwuXHJcbiAgICAgKiBUaGUgY29udGVudCB3aWxsIGJlIGNvcGllZC5cclxuICAgICAqIFN0YXRlIHdpbGwgYmUgZmluYWwuXHJcbiAgICAgKiBAcGFyYW0gY29weUNvbnRlbnQgRmxhZywgd2V0aGVyIHRvIGNvcHkgY29udGVudCBvciBsZWF2ZSBpdCBlbXB0eS5cclxuICAgICAqIFdiZW4gdHJ1ZSwgY29udGVudCB3aWxsIGJlIGNvcGllZCBmcm9tIHNvdXJjZS5cclxuICAgICAqIFdoZW4gZmFsc2UsIGNvbnRlbnQgd2lsbCBiZSBsZWZ0IGVtcHR5IChpZiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlVHJhbnNsYXRpb25GaWxlRm9yTGFuZyhsYW5nOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcsIGlzRGVmYXVsdExhbmc6IGJvb2xlYW4sIGNvcHlDb250ZW50OiBib29sZWFuKVxyXG4gICAgICAgIDogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdGaWxlIFwiJXNcIiwgeHRiIGZpbGVzIGFyZSBub3QgdHJhbnNsYXRhYmxlLCB0aGV5IGFyZSBhbHJlYWR5IHRyYW5zbGF0aW9ucycsIGZpbGVuYW1lKSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMjEuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7WGxpZmZGaWxlfSBmcm9tICcuLi9pbXBsL3hsaWZmLWZpbGUnO1xyXG5pbXBvcnQge1htYkZpbGV9IGZyb20gJy4uL2ltcGwveG1iLWZpbGUnO1xyXG5pbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7WGxpZmYyRmlsZX0gZnJvbSAnLi4vaW1wbC94bGlmZjItZmlsZSc7XHJcbmltcG9ydCB7Rk9STUFUX1hMSUZGMTIsIEZPUk1BVF9YTElGRjIwLCBGT1JNQVRfWE1CLCBGT1JNQVRfWFRCfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7WHRiRmlsZX0gZnJvbSAnLi4vaW1wbC94dGItZmlsZSc7XHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeX0gZnJvbSAnLi9pLXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUtZmFjdG9yeSc7XHJcblxyXG4vKipcclxuICogSGVscGVyIGNsYXNzIHRvIHJlYWQgdHJhbnNsYXRpb24gZmlsZXMgZGVwZW5kaW5nIG9uIGZvcm1hdC5cclxuICogVGhpcyBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgYXBpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5IGltcGxlbWVudHMgSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGZpbGUgZnVuY3Rpb24sIHJlc3VsdCBkZXBlbmRzIG9uIGZvcm1hdCwgZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlLlxyXG4gICAgICogQHBhcmFtIGkxOG5Gb3JtYXQgY3VycmVudGx5ICd4bGYnIG9yICd4bGYyJyBvciAneG1iJyBvciAneHRiJyBhcmUgc3VwcG9ydGVkXHJcbiAgICAgKiBAcGFyYW0geG1sQ29udGVudCB0aGUgZmlsZSBjb250ZW50XHJcbiAgICAgKiBAcGFyYW0gcGF0aCB0aGUgcGF0aCBvZiB0aGUgZmlsZSAob25seSB1c2VkIHRvIHJlbWVtYmVyIGl0KVxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHV0Zi04LCAuLi4gdXNlZCB0byBwYXJzZSBYTUwuXHJcbiAgICAgKiBUaGlzIGlzIHJlYWQgZnJvbSB0aGUgZmlsZSwgYnV0IGlmIHlvdSBrbm93IGl0IGJlZm9yZSwgeW91IGNhbiBhdm9pZCByZWFkaW5nIHRoZSBmaWxlIHR3aWNlLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbmFsTWFzdGVyIGluIGNhc2Ugb2YgeG1iIHRoZSBtYXN0ZXIgZmlsZSwgdGhhdCBjb250YWlucyB0aGUgb3JpZ2luYWwgdGV4dHMuXHJcbiAgICAgKiAodGhpcyBpcyB1c2VkIHRvIHN1cHBvcnQgc3RhdGUgaW5mb3MsIHRoYXQgYXJlIGJhc2VkIG9uIGNvbXBhcmluZyBvcmlnaW5hbCB3aXRoIHRyYW5zbGF0ZWQgdmVyc2lvbilcclxuICAgICAqIElnbm9yZWQgZm9yIG90aGVyIGZvcm1hdHMuXHJcbiAgICAgKiBAcmV0dXJuIGVpdGhlciBYbGlmZkZpbGUgb3IgWG1iRmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZyb21GaWxlQ29udGVudChpMThuRm9ybWF0OiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWxDb250ZW50OiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXI/OiB7eG1sQ29udGVudDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmd9KTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeSgpLmNyZWF0ZUZpbGVGcm9tRmlsZUNvbnRlbnQoaTE4bkZvcm1hdCwgeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgZmlsZSBmdW5jdGlvbiBmb3IgYW55IGZpbGUgd2l0aCB1bmtub3duIGZvcm1hdC5cclxuICAgICAqIFRoaXMgZnVuY3Rpb25zIHRyaWVzIHRvIGd1ZXNzIHRoZSBmb3JtYXQgYmFzZWQgb24gdGhlIGZpbGVuYW1lIGFuZCB0aGUgY29udGVudCBvZiB0aGUgZmlsZS5cclxuICAgICAqIFJlc3VsdCBkZXBlbmRzIG9uIGRldGVjdGVkIGZvcm1hdCwgZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlLlxyXG4gICAgICogQHBhcmFtIHhtbENvbnRlbnQgdGhlIGZpbGUgY29udGVudFxyXG4gICAgICogQHBhcmFtIHBhdGggdGhlIHBhdGggb2YgdGhlIGZpbGUgKG9ubHkgdXNlZCB0byByZW1lbWJlciBpdClcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB1dGYtOCwgLi4uIHVzZWQgdG8gcGFyc2UgWE1MLlxyXG4gICAgICogVGhpcyBpcyByZWFkIGZyb20gdGhlIGZpbGUsIGJ1dCBpZiB5b3Uga25vdyBpdCBiZWZvcmUsIHlvdSBjYW4gYXZvaWQgcmVhZGluZyB0aGUgZmlsZSB0d2ljZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25hbE1hc3RlciBpbiBjYXNlIG9mIHhtYiB0aGUgbWFzdGVyIGZpbGUsIHRoYXQgY29udGFpbnMgdGhlIG9yaWdpbmFsIHRleHRzLlxyXG4gICAgICogKHRoaXMgaXMgdXNlZCB0byBzdXBwb3J0IHN0YXRlIGluZm9zLCB0aGF0IGFyZSBiYXNlZCBvbiBjb21wYXJpbmcgb3JpZ2luYWwgd2l0aCB0cmFuc2xhdGVkIHZlcnNpb24pXHJcbiAgICAgKiBJZ25vcmVkIGZvciBvdGhlciBmb3JtYXRzLlxyXG4gICAgICogQHJldHVybiBlaXRoZXIgWGxpZmZGaWxlIG9yIFhtYkZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmcm9tVW5rbm93bkZvcm1hdEZpbGVDb250ZW50KHhtbENvbnRlbnQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3Rlcj86IHt4bWxDb250ZW50OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZ30pOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5KCkuY3JlYXRlRmlsZUZyb21Vbmtub3duRm9ybWF0RmlsZUNvbnRlbnQoeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgZmlsZSBmdW5jdGlvbiwgcmVzdWx0IGRlcGVuZHMgb24gZm9ybWF0LCBlaXRoZXIgWGxpZmZGaWxlIG9yIFhtYkZpbGUuXHJcbiAgICAgKiBAcGFyYW0gaTE4bkZvcm1hdCBjdXJyZW50bHkgJ3hsZicgb3IgJ3hsZjInIG9yICd4bWInIG9yICd4dGInIGFyZSBzdXBwb3J0ZWRcclxuICAgICAqIEBwYXJhbSB4bWxDb250ZW50IHRoZSBmaWxlIGNvbnRlbnRcclxuICAgICAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBmaWxlIChvbmx5IHVzZWQgdG8gcmVtZW1iZXIgaXQpXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgdXRmLTgsIC4uLiB1c2VkIHRvIHBhcnNlIFhNTC5cclxuICAgICAqIFRoaXMgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLCBidXQgaWYgeW91IGtub3cgaXQgYmVmb3JlLCB5b3UgY2FuIGF2b2lkIHJlYWRpbmcgdGhlIGZpbGUgdHdpY2UuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXIgaW4gY2FzZSBvZiB4bWIgdGhlIG1hc3RlciBmaWxlLCB0aGF0IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCB0ZXh0cy5cclxuICAgICAqICh0aGlzIGlzIHVzZWQgdG8gc3VwcG9ydCBzdGF0ZSBpbmZvcywgdGhhdCBhcmUgYmFzZWQgb24gY29tcGFyaW5nIG9yaWdpbmFsIHdpdGggdHJhbnNsYXRlZCB2ZXJzaW9uKVxyXG4gICAgICogSWdub3JlZCBmb3Igb3RoZXIgZm9ybWF0cy5cclxuICAgICAqIEByZXR1cm4gZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUZpbGVGcm9tRmlsZUNvbnRlbnQoaTE4bkZvcm1hdDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWxDb250ZW50OiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXI/OiB7IHhtbENvbnRlbnQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nIH0pOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIGlmIChpMThuRm9ybWF0ID09PSBGT1JNQVRfWExJRkYxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmRmlsZSh4bWxDb250ZW50LCBwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpMThuRm9ybWF0ID09PSBGT1JNQVRfWExJRkYyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmMkZpbGUoeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaTE4bkZvcm1hdCA9PT0gRk9STUFUX1hNQikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhtYkZpbGUodGhpcywgeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaTE4bkZvcm1hdCA9PT0gRk9STUFUX1hUQikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFh0YkZpbGUodGhpcywgeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnb29wcywgdW5zdXBwb3J0ZWQgZm9ybWF0IFwiJXNcIicsIGkxOG5Gb3JtYXQpKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGZpbGUgZnVuY3Rpb24gZm9yIGFueSBmaWxlIHdpdGggdW5rbm93biBmb3JtYXQuXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9ucyB0cmllcyB0byBndWVzcyB0aGUgZm9ybWF0IGJhc2VkIG9uIHRoZSBmaWxlbmFtZSBhbmQgdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGUuXHJcbiAgICAgKiBSZXN1bHQgZGVwZW5kcyBvbiBkZXRlY3RlZCBmb3JtYXQsIGVpdGhlciBYbGlmZkZpbGUgb3IgWG1iRmlsZS5cclxuICAgICAqIEBwYXJhbSB4bWxDb250ZW50IHRoZSBmaWxlIGNvbnRlbnRcclxuICAgICAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBmaWxlIChvbmx5IHVzZWQgdG8gcmVtZW1iZXIgaXQpXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgdXRmLTgsIC4uLiB1c2VkIHRvIHBhcnNlIFhNTC5cclxuICAgICAqIFRoaXMgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLCBidXQgaWYgeW91IGtub3cgaXQgYmVmb3JlLCB5b3UgY2FuIGF2b2lkIHJlYWRpbmcgdGhlIGZpbGUgdHdpY2UuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXIgaW4gY2FzZSBvZiB4bWIgdGhlIG1hc3RlciBmaWxlLCB0aGF0IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCB0ZXh0cy5cclxuICAgICAqICh0aGlzIGlzIHVzZWQgdG8gc3VwcG9ydCBzdGF0ZSBpbmZvcywgdGhhdCBhcmUgYmFzZWQgb24gY29tcGFyaW5nIG9yaWdpbmFsIHdpdGggdHJhbnNsYXRlZCB2ZXJzaW9uKVxyXG4gICAgICogSWdub3JlZCBmb3Igb3RoZXIgZm9ybWF0cy5cclxuICAgICAqIEByZXR1cm4gZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUZpbGVGcm9tVW5rbm93bkZvcm1hdEZpbGVDb250ZW50KHhtbENvbnRlbnQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3Rlcj86IHsgeG1sQ29udGVudDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcgfSlcclxuICAgICAgICA6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgbGV0IGZvcm1hdENhbmRpZGF0ZXMgPSBbRk9STUFUX1hMSUZGMTIsIEZPUk1BVF9YTElGRjIwLCBGT1JNQVRfWE1CLCBGT1JNQVRfWFRCXTtcclxuICAgICAgICBpZiAocGF0aCAmJiBwYXRoLmVuZHNXaXRoKCd4bWInKSkge1xyXG4gICAgICAgICAgICBmb3JtYXRDYW5kaWRhdGVzID0gW0ZPUk1BVF9YTUIsIEZPUk1BVF9YVEIsIEZPUk1BVF9YTElGRjEyLCBGT1JNQVRfWExJRkYyMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRoICYmIHBhdGguZW5kc1dpdGgoJ3h0YicpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdENhbmRpZGF0ZXMgPSBbRk9STUFUX1hUQiwgRk9STUFUX1hNQiwgRk9STUFUX1hMSUZGMTIsIEZPUk1BVF9YTElGRjIwXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHJ5IGFsbCBjYW5kaWRhdGUgZm9ybWF0cyB0byBnZXQgdGhlIHJpZ2h0IG9uZVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0Q2FuZGlkYXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXRDYW5kaWRhdGUgPSBmb3JtYXRDYW5kaWRhdGVzW2ldO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRpb25GaWxlID0gVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5LmZyb21GaWxlQ29udGVudChcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRDYW5kaWRhdGUsIHhtbENvbnRlbnQsIHBhdGgsIGVuY29kaW5nLCBvcHRpb25hbE1hc3Rlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb25GaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uRmlsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2VhbXMgdG8gYmUgdGhlIHdyb25nIGZvcm1hdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ2NvdWxkIG5vdCBpZGVudGlmeSBmaWxlIGZvcm1hdCwgaXQgaXMgbmVpdGVyIFhMSUZGICgxLjIgb3IgMi4wKSBub3IgWE1CL1hUQicpKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJOZ01vZHVsZSIsIlhNTFNlcmlhbGl6ZXIiLCJET01QYXJzZXIiLCJpc051bGxPclVuZGVmaW5lZCIsImlzU3RyaW5nIiwidHNsaWJfMS5fX2V4dGVuZHMiLCJmb3JtYXQiLCJURVhUIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7b0JBRUNBLGFBQVEsU0FBQzt3QkFDUixPQUFPLEVBQUUsRUFDUjt3QkFDRCxZQUFZLEVBQUUsRUFBRTt3QkFDaEIsT0FBTyxFQUFFLEVBQUU7cUJBQ1o7O3NDQVBEOzs7Ozs7Ozs7O0FDUUEsUUFBYSxjQUFjLEdBQUcsS0FBSyxDQUFDOztBQUNwQyxRQUFhLGNBQWMsR0FBRyxNQUFNLENBQUM7O0FBQ3JDLFFBQWEsVUFBVSxHQUFHLEtBQUssQ0FBQzs7QUFDaEMsUUFBYSxVQUFVLEdBQUcsS0FBSyxD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