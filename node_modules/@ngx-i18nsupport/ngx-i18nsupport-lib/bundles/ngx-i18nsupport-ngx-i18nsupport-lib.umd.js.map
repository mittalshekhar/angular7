{"version":3,"file":"ngx-i18nsupport-ngx-i18nsupport-lib.umd.js.map","sources":["ng://@ngx-i18nsupport/ngx-i18nsupport-lib/lib/ngx-i18nsupport-lib.module.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/api/constants.ts","../../node_modules/tslib/tslib.es6.js","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/dom-utilities.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xml-serializer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-translation-messages-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-text.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-placeholder.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-start-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-end-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/icu-message-tokenizer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/icu-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-icu-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-icu-message-ref.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-part-empty-tag.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/parsed-message-tokenizer.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/abstract-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/tag-mapping.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xmb-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-message-parser.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xliff2-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xtb-trans-unit.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/impl/xtb-file.ts","ng://@ngx-i18nsupport/ngx-i18nsupport-lib/api/translation-messages-file-factory.ts"],"sourcesContent":["import { NgModule } from '@angular/core';\r\n\r\n@NgModule({\r\n  imports: [\r\n  ],\r\n  declarations: [],\r\n  exports: []\r\n})\r\nexport class NgxI18nsupportLibModule { }\r\n","/**\r\n * Created by roobm on 08.05.2017.\r\n * Some constant values used in the API.\r\n */\r\n\r\n/**\r\n * supported file formats\r\n */\r\nexport const FORMAT_XLIFF12 = 'xlf';\r\nexport const FORMAT_XLIFF20 = 'xlf2';\r\nexport const FORMAT_XMB = 'xmb';\r\nexport const FORMAT_XTB = 'xtb';\r\n\r\n/**\r\n * File types\r\n * (returned by fileType() method)\r\n */\r\nexport const FILETYPE_XLIFF12 = 'XLIFF 1.2';\r\nexport const FILETYPE_XLIFF20 = 'XLIFF 2.0';\r\nexport const FILETYPE_XMB = 'XMB';\r\nexport const FILETYPE_XTB = 'XTB';\r\n\r\n/**\r\n * abstract state value.\r\n * There are only 3 supported state values.\r\n */\r\n\r\n/**\r\n * State NEW.\r\n * Signals an untranslated unit.\r\n */\r\nexport const STATE_NEW = 'new';\r\n/**\r\n * State TRANSLATED.\r\n * Signals a translated unit, that is not reviewed until now.\r\n */\r\nexport const STATE_TRANSLATED = 'translated';\r\n/**\r\n * State FINAL.\r\n * Signals a translated unit, that is reviewed and ready for use.\r\n */\r\nexport const STATE_FINAL = 'final';\r\n\r\n/**\r\n * Normalizaton message formats.\r\n */\r\n\r\n/**\r\n * Default format, contains placeholders, html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_DEFAULT = 'default';\r\n\r\n/**\r\n * Format for usage in ngxtranslate messages.\r\n * Placeholder are in the form {{n}}, no html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {DOMParser, XMLSerializer} from 'xmldom';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\n\r\nexport class DOMUtilities {\r\n\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getFirstElementByTagName(element: Element | Document, tagName: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getElementByTagNameAndId(element: Element | Document, tagName: string, id: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node: Element = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementFollowingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementPrecedingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    public static getXMLContent(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg: RegExp = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg: RegExp = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    public static getPCDATA(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    public static replaceContentWithXMLContent(element: Element, pcdata: string) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment: Document = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    public static getPreviousElementSibling(element: Node): Element {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return <Element> node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    public static createFollowingSibling(elementNameToCreate: string, previousSibling: Node): Element {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return <Element> DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    public static insertAfter(newElement: Node, previousSibling: Node): Node {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        } else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    public static insertBefore(newElement: Node, nextSibling: Node): Node {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\r\n","/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\n\r\ninterface Namespace {\r\n    prefix: string;\r\n    namespace: string;\r\n}\r\n\r\n/**\r\n * Options used to control the formatting\r\n */\r\nexport interface XmlSerializerOptions {\r\n    beautify?: boolean; // set to activate beautify\r\n    indentString?: string; // Sequence uses for indentation, must only contain white space chars, e.g. \"  \" or \"    \" or \"\\t\"\r\n    mixedContentElements?: string[]; // Names of elements containing mixed content (these are not beautified)\r\n}\r\n\r\nconst DEFAULT_INDENT_STRING = '  ';\r\n\r\nexport class XmlSerializer {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document: Document, options?: XmlSerializerOptions): string {\r\n        const buf = [];\r\n        let visibleNamespaces: Namespace[] = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    {namespace: uri, prefix: null}\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    private doSerializeToString(node: Node, options: XmlSerializerOptions, buf: string[],\r\n                                indentLevel: number, partOfMixedContent: boolean, visibleNamespaces: Namespace[]) {\r\n        let child: Node;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode: Element = <Element> node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<' , nodeName);\r\n                } else {\r\n                    this.outputIndented(options, buf, indentLevel, '<' , nodeName);\r\n                }\r\n\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: attr.localName, namespace: attr.value});\r\n                    } else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: '', namespace: attr.value});\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = node.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                }\r\n\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1,\r\n                            partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    } else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                } else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = <Attr> node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = <Text> node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = <CDATASection> node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = <Comment> node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = <DocumentType> node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                } else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                } else {\r\n                    const sub = documenttypeNode.internalSubset;\r\n                    if (sub) {\r\n                        buf.push(' [', sub, ']');\r\n                    }\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = <ProcessingInstruction> node;\r\n                return buf.push( '<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n\r\n    private needNamespaceDefine(node: Element | Attr, visibleNamespaces: Namespace[]): boolean {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _xmlEncoder(c: string): string {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n\r\n    private outputIndented(options: XmlSerializerOptions, buf: string[], indentLevel: number, ...outputParts: string[]) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n\r\n    private indentationString(options: XmlSerializerOptions, indentLevel: number): string {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    private isMixedContentElement(tagName: string, options: XmlSerializerOptions): boolean {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private containsOnlyWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {isNullOrUndefined} from 'util';\r\nimport {DOMParser} from 'xmldom';\r\nimport {XmlSerializer, XmlSerializerOptions} from './xml-serializer';\r\n/**\r\n * Created by roobm on 09.05.2017.\r\n * Abstract superclass for all implementations of ITranslationMessagesFile.\r\n */\r\n\r\nexport abstract class AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    protected _filename: string;\r\n\r\n    protected _encoding: string;\r\n\r\n    protected _parsedDocument: Document;\r\n\r\n    protected _fileEndsWithEOL: boolean;\r\n\r\n    // trans-unit elements and their id from the file\r\n    protected transUnits: ITransUnit[];\r\n\r\n    protected _warnings: string[];\r\n\r\n    protected _numberOfTransUnitsWithMissingId: number;\r\n\r\n    protected _numberOfUntranslatedTransUnits: number;\r\n\r\n    protected _numberOfReviewedTransUnits: number;\r\n\r\n    protected targetPraefix: string;\r\n\r\n    protected targetSuffix: string;\r\n\r\n    protected constructor() {\r\n        this.transUnits = null;\r\n        this._warnings = [];\r\n    }\r\n\r\n    /**\r\n     * Parse file content.\r\n     * Sets _parsedDocument, line ending, encoding, etc.\r\n     * @param xmlString xmlString\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMaster optionalMaster\r\n     */\r\n    protected parseContent(\r\n        xmlString: string,\r\n        path: string, encoding: string,\r\n        optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : void {\r\n        this._filename = path;\r\n        this._encoding = encoding;\r\n        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        this._fileEndsWithEOL = xmlString.endsWith('\\n');\r\n    }\r\n\r\n    abstract i18nFormat(): string;\r\n\r\n    abstract fileType(): string;\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected abstract elementsWithMixedContent(): string[];\r\n\r\n    /**\r\n     * Read all trans units from xml content.\r\n     * Puts the found units into transUnits.\r\n     * Puts warnings for missing ids.\r\n     */\r\n    protected abstract initializeTransUnits();\r\n\r\n    protected lazyInitializeTransUnits() {\r\n        if (isNullOrUndefined(this.transUnits)) {\r\n            this.initializeTransUnits();\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * count units after changes of trans units\r\n     */\r\n    public countNumbers() {\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this._numberOfUntranslatedTransUnits = 0;\r\n        this._numberOfReviewedTransUnits = 0;\r\n        this.forEachTransUnit((tu: ITransUnit) => {\r\n            if (isNullOrUndefined(tu.id) || tu.id === '') {\r\n                this._numberOfTransUnitsWithMissingId++;\r\n            }\r\n            const state = tu.targetState();\r\n            if (isNullOrUndefined(state) || state === STATE_NEW) {\r\n                this._numberOfUntranslatedTransUnits++;\r\n            }\r\n            if (state === STATE_TRANSLATED) {\r\n                this._numberOfReviewedTransUnits++;\r\n            }\r\n        });\r\n    }\r\n\r\n    public warnings(): string[] {\r\n        this.lazyInitializeTransUnits();\r\n        return this._warnings;\r\n    }\r\n\r\n    /**\r\n     * Total number of translation units found in the file.\r\n     */\r\n    public numberOfTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.length;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfUntranslatedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfUntranslatedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units with state 'final'.\r\n     */\r\n    numberOfReviewedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfReviewedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    public numberOfTransUnitsWithMissingId(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfTransUnitsWithMissingId;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    abstract sourceLanguage(): string;\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    abstract targetLanguage(): string;\r\n\r\n    /**\r\n     * Loop over all Translation Units.\r\n     * @param callback callback\r\n     */\r\n    public forEachTransUnit(callback: ((transunit: ITransUnit) => void)) {\r\n        this.lazyInitializeTransUnits();\r\n        this.transUnits.forEach((tu) => callback(tu));\r\n    }\r\n\r\n    /**\r\n     * Get trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    public transUnitWithId(id: string): ITransUnit {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.find((tu) => tu.id === id);\r\n    }\r\n\r\n    /**\r\n     * Edit functions following her\r\n     */\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    abstract setSourceLanguage(language: string);\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    abstract setTargetLanguage(language: string);\r\n\r\n    /**\r\n     * Set the praefix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetPraefix targetPraefix\r\n     */\r\n    public setNewTransUnitTargetPraefix(targetPraefix: string) {\r\n        this.targetPraefix = targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Get the praefix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the praefix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetPraefix(): string {\r\n        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Set the suffix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetSuffix targetSuffix\r\n     */\r\n    public setNewTransUnitTargetSuffix(targetSuffix: string) {\r\n        this.targetSuffix = targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Get the suffix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the suffix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetSuffix(): string {\r\n        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    abstract importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit;\r\n\r\n    /**\r\n     * Remove the trans-unit with the given id.\r\n     * @param id id\r\n     */\r\n    public removeTransUnitWithId(id: string) {\r\n        const tuNode: Node = this._parsedDocument.getElementById(id);\r\n        if (tuNode) {\r\n            tuNode.parentNode.removeChild(tuNode);\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filename where the data is read from.\r\n     */\r\n    public filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    /**\r\n     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)\r\n     */\r\n    public encoding(): string {\r\n        return this._encoding;\r\n    }\r\n\r\n    /**\r\n     * The xml content to be saved after changes are made.\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public editedContent(beautifyOutput?: boolean): string {\r\n        const options: XmlSerializerOptions = {};\r\n        if (beautifyOutput === true) {\r\n           options.beautify = true;\r\n           options.indentString = '  ';\r\n           options.mixedContentElements = this.elementsWithMixedContent();\r\n        }\r\n        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);\r\n        if (this._fileEndsWithEOL) {\r\n            // add eol if there was eol in original source\r\n            return result + '\\n';\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    abstract createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile;\r\n}\r\n","import {STATE_TRANSLATED, ITranslationMessagesFile, INormalizedMessage, ITransUnit, INote} from './internalapi';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {isNullOrUndefined, isString} from 'util';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * Abstract superclass for all implementations of ITransUnit.\r\n */\r\n\r\nexport abstract class AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceContentNormalized: ParsedMessage;\r\n\r\n    protected constructor(protected _element: Element,\r\n                          protected _id: string,\r\n                          protected _translationMessagesFile: ITranslationMessagesFile) {\r\n    }\r\n\r\n    public get id(): string {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * The file the unit belongs to.,\r\n     */\r\n    translationMessagesFile(): ITranslationMessagesFile {\r\n        return this._translationMessagesFile;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract sourceContent(): string;\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    abstract setSourceContent(newContent: string);\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public sourceContentNormalized(): ParsedMessage {\r\n        if (isNullOrUndefined(this._sourceContentNormalized)) {\r\n            this._sourceContentNormalized = this.createSourceContentNormalized();\r\n        }\r\n        return this._sourceContentNormalized;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    abstract createSourceContentNormalized(): ParsedMessage;\r\n\r\n    /**\r\n     * The translated value.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract targetContent(): string;\r\n\r\n    /**\r\n     * The translated value as normalized message.\r\n     * All placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    abstract targetContentNormalized(): INormalizedMessage;\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    abstract nativeTargetState(): string;\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (on of new, translated, final)\r\n     * Return values are defined as Constants STATE_...\r\n     */\r\n    public targetState(): string {\r\n        const nativeState = this.nativeTargetState();\r\n        return this.mapNativeStateToState(nativeState);\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected abstract mapStateToNativeState(state: string): string;\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract mapNativeStateToState(nativeState: string): string;\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract setNativeTargetState(nativeState: string);\r\n\r\n    /**\r\n     * Modify the target state.\r\n     * @param newState one of the 3 allowed target states new, translated, final.\r\n     * Constants STATE_...\r\n     * Invalid states throw an error.\r\n     */\r\n    setTargetState(newState: string) {\r\n        this.setNativeTargetState(this.mapStateToNativeState(newState));\r\n        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {\r\n            (<AbstractTranslationMessagesFile> this.translationMessagesFile()).countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    abstract sourceReferences(): {sourcefile: string, linenumber: number}[];\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    abstract setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]);\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     */\r\n    abstract description(): string;\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     */\r\n    abstract meaning(): string;\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    abstract setDescription(description: string);\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    abstract setMeaning(meaning: string);\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    abstract notes(): INote[];\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    abstract supportsSetNotes(): boolean;\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains descpription or meaning as from attribute.\r\n     */\r\n    abstract setNotes(newNotes: INote[]);\r\n\r\n    /**\r\n     * Check notes\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    protected checkNotes(newNotes: INote[]) {\r\n        // check from values\r\n        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');\r\n        if (!isNullOrUndefined(errorInFromNote)) {\r\n            throw new Error('description or meaning are not allowed as from atttribute');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The real xml element used for the trans unit.\r\n     * (internal usage only, a client should never need this)\r\n     * @return real xml element used for the trans unit.\r\n     */\r\n    public asXmlElement(): Element {\r\n        return this._element;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    abstract cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit;\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    abstract useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean);\r\n\r\n    /**\r\n     * Translate the trans unit.\r\n     * @param translation the translated string or (preferred) a normalized message.\r\n     * The pure string can contain any markup and will not be checked.\r\n     * So it can damage the document.\r\n     * A normalized message prevents this.\r\n     */\r\n    public translate(translation: string | INormalizedMessage) {\r\n        let translationNative: string;\r\n        if (isString(translation)) {\r\n            translationNative = <string> translation;\r\n        } else {\r\n            translationNative = (<INormalizedMessage> translation).asNativeString();\r\n        }\r\n        this.translateNative(translationNative);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected abstract messageParser(): AbstractMessageParser;\r\n\r\n    /**\r\n     * Test, wether message looks like ICU message.\r\n     * @param message message\r\n     * @return wether message looks like ICU message.\r\n     */\r\n    public isICUMessage(message: string): boolean {\r\n        return this.messageParser().isICUMessageStart(message);\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected abstract translateNative(translation: string);\r\n}\r\n","/**\r\n * Created by martin on 05.05.2017.\r\n * A part of a parsed message.\r\n * Can be a text, a placeholder, a tag\r\n */\r\n\r\nexport enum ParsedMessagePartType {\r\n    TEXT,\r\n    PLACEHOLDER,\r\n    START_TAG,\r\n    END_TAG,\r\n    EMPTY_TAG,\r\n    ICU_MESSAGE,\r\n    ICU_MESSAGE_REF\r\n}\r\n\r\nexport abstract class ParsedMessagePart {\r\n\r\n    constructor(public type: ParsedMessagePartType) {\r\n\r\n    }\r\n\r\n    /**\r\n     * String representation of the part.\r\n     * @param format optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public abstract asDisplayString(format?: string): string;\r\n\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of just simple text.\r\n */\r\n\r\nexport class ParsedMessagePartText extends ParsedMessagePart {\r\n\r\n    private text: string;\r\n\r\n    constructor(text: string) {\r\n        super(ParsedMessagePartType.TEXT);\r\n        this.text = text;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return this.text;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a placeholder.\r\n * Placeholders are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartPlaceholder extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.PLACEHOLDER);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {\r\n            return '{{' + this._index + '}}';\r\n        }\r\n        return '{{' + this._index + '}}';\r\n    }\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of an opening tag like <b> or <strange>.\r\n */\r\n\r\nexport class ParsedMessagePartStartTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.START_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a closing tag like </b> or </strange>.\r\n */\r\n\r\nexport class ParsedMessagePartEndTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n\r\n    constructor(tagname: string) {\r\n        super(ParsedMessagePartType.END_TAG);\r\n        this._tagname = tagname;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '</' + this._tagname + '>';\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\n\r\n/**\r\n * Created by martin on 04.06.2017.\r\n * A tokenizer for ICU messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';\r\nexport const CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';\r\nexport const COMMA = 'COMMA';\r\nexport const PLURAL = 'PLURAL';\r\nexport const SELECT = 'SELECT';\r\n\r\nexport interface ICUToken {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\n// states: default normal in_message\r\nconst STATE_DEFAULT = 'default';\r\nconst STATE_NORMAL = 'normal';\r\nconst STATE_IN_MESSAGE = 'in_message';\r\n\r\nexport class ICUMessageTokenizer {\r\n    private lexer: Tokenizr;\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        let openedCurlyBracesInTextCounter = 0;\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT) {\r\n                if (this.containsNonWhiteSpace(plaintext)) {\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                } else {\r\n                    ctx.ignore();\r\n                }\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (this.containsNonWhiteSpace(plaintext)) {\r\n                ctx.accept(TEXT, plaintext);\r\n            }\r\n         });\r\n        // curly brace\r\n        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_NORMAL);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_IN_MESSAGE);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {\r\n            ctx.pop();\r\n            ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n        }, CURLY_BRACE_CLOSE);\r\n        // masked ' { and }\r\n        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {\r\n            if (match[0] === '\\'\\'') {\r\n                plaintext += '\\'';\r\n            } else if (match[0] === '\\'{\\'') {\r\n                plaintext += '{';\r\n            } else if (match[0] === '\\'}\\'') {\r\n                plaintext += '}';\r\n            }\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {\r\n            const char = match[0];\r\n            if (char === '{') {\r\n                openedCurlyBracesInTextCounter++;\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            } else if (char === '}') {\r\n                if (openedCurlyBracesInTextCounter > 0) {\r\n                    openedCurlyBracesInTextCounter--;\r\n                    plaintext += match[0];\r\n                    ctx.ignore();\r\n                } else {\r\n                    ctx.pop();\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n                }\r\n            } else {\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n        }, TEXT);\r\n        // comma\r\n        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {\r\n            ctx.accept(COMMA, match[0]);\r\n        }, COMMA);\r\n        // keywords plural and select\r\n        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {\r\n            ctx.accept(PLURAL, match[0]);\r\n        }, PLURAL);\r\n        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {\r\n            ctx.accept(SELECT, match[0]);\r\n        }, SELECT);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\s]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    private containsNonWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (!/\\s/.test(text.charAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): ICUToken[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n    input(normalizedMessage: string) {\r\n        this.lexer = this.getLexer();\r\n        this.lexer.input(normalizedMessage);\r\n    }\r\n\r\n    next(): ICUToken {\r\n        return this.lexer.token();\r\n    }\r\n\r\n    peek(): ICUToken {\r\n        return this.lexer.peek();\r\n    }\r\n}\r\n","import {IICUMessage, IICUMessageCategory, IICUMessageTranslation, INormalizedMessage} from '../api/index';\r\nimport {format, isNullOrUndefined, isString} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\nclass MessageCategory implements IICUMessageCategory {\r\n\r\n    constructor(private _category: string, private _message: INormalizedMessage) {}\r\n\r\n    public getCategory(): string {\r\n        return this._category;\r\n    }\r\n\r\n    public getMessageNormalized(): INormalizedMessage {\r\n        return this._message;\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nexport class ICUMessage implements IICUMessage {\r\n\r\n    private _isPluralMessage: boolean;\r\n\r\n    private _categories: IICUMessageCategory[];\r\n\r\n    constructor(private _parser: IMessageParser, isPluralMessage: boolean) {\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n\r\n    addCategory(category: string, message: INormalizedMessage) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    public asNativeString(): string {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category: IICUMessageCategory) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage(): boolean {\r\n        return this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage(): boolean {\r\n        return !this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories(): IICUMessageCategory[] {\r\n        return this._categories;\r\n    }\r\n\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation: IICUMessageTranslation): IICUMessage {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories: Set<string> = new Set<string>();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage: INormalizedMessage;\r\n            const translationForCategory: string|IICUMessageTranslation = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            } else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(<string> translationForCategory, null);\r\n            } else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)',\r\n                        categoryName));\r\n                } else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    let translatedMessage = this._parser.parseNormalizedString(<string> translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    private checkValidPluralCategory(categoryName: string) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {IICUMessage, INormalizedMessage} from '../api/index';\r\nimport {\r\n    COMMA, CURLY_BRACE_CLOSE, CURLY_BRACE_OPEN, ICUMessageTokenizer, ICUToken, PLURAL, SELECT,\r\n    TEXT\r\n} from './icu-message-tokenizer';\r\nimport {ICUMessage} from './icu-message';\r\nimport {format} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\n\r\nexport class ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n\r\n    private _message: ICUMessage;\r\n    private _messageText: string;\r\n    private _tokenizer: ICUMessageTokenizer;\r\n\r\n    constructor(icuMessageText: string, private _parser: IMessageParser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText: string): boolean {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n\r\n    public asDisplayString(displayFormat?: string) {\r\n        return '<ICU-Message/>';\r\n    }\r\n\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        return this._message;\r\n    }\r\n\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    private parseICUMessage(text: string) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token: ICUToken = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        } else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    private looksLikeICUMessage(text: string): boolean {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token: ICUToken = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    private expectNext(tokentype: string): ICUToken {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)',\r\n                tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    private parseNativeSubMessage(message: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A reference to an ICU message\r\n * icu references are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartICUMessageRef extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE_REF);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '<ICU-Message-Ref_' + this._index + '/>';\r\n    }\r\n\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 14.06.2017.\r\n * A message part consisting of an empty tag like <br/>.\r\n */\r\n\r\nexport class ParsedMessagePartEmptyTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.EMPTY_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {INormalizedMessage, ValidationErrors} from '../api/i-normalized-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {IICUMessage, IICUMessageTranslation} from '../api/i-icu-message';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ICUMessage} from './icu-message';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message text read from a translation file.\r\n * Can contain placeholders, tags, text.\r\n * This class is a representation independent of the concrete format.\r\n */\r\nexport class ParsedMessage implements INormalizedMessage {\r\n\r\n    /**\r\n     * Parser that created this message (determines the native format).\r\n     */\r\n    private _parser: IMessageParser;\r\n\r\n    /**\r\n     * The message where this one stems from as translation.\r\n     * Optional, set only for messages created by calling translate.\r\n     */\r\n    private sourceMessage: ParsedMessage;\r\n\r\n    /**\r\n     * The parts of the message.\r\n     */\r\n    private _parts: ParsedMessagePart[];\r\n\r\n    /**\r\n     * messages xml representation.\r\n     */\r\n    private _xmlRepresentation: Element;\r\n\r\n    constructor(parser: IMessageParser, sourceMessage: ParsedMessage) {\r\n        this._parser = parser;\r\n        this.sourceMessage = sourceMessage;\r\n        this._parts = [];\r\n    }\r\n\r\n    /**\r\n     * Get the parser (for tests only, not part of API)\r\n     * @return parser\r\n     */\r\n    getParser(): IMessageParser {\r\n        return this._parser;\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message as a translation of this one.\r\n     * @param normalizedString the translation in normalized form.\r\n     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is an ICU message.\r\n     */\r\n    translate(normalizedString: string): INormalizedMessage {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return this._parser.parseNormalizedString(<string> normalizedString, this);\r\n        } else {\r\n            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead (\"%s\", \"%s\")',\r\n                normalizedString, this.asNativeString()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized icu message as a translation of this one.\r\n     * @param icuTranslation the translation, this is the translation of the ICU message,\r\n     * which is not a string, but a collections of the translations of the different categories.\r\n     * The message must be an ICUMessage (getICUMessage returns a value)\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is not an ICU message.\r\n     */\r\n    translateICUMessage(icuTranslation: IICUMessageTranslation): INormalizedMessage {\r\n        const icuMessage: IICUMessage = this.getICUMessage();\r\n        if (isNullOrUndefined(icuMessage)) {\r\n            throw new Error(format('this is not an ICU message, use translate() instead (\"%s\", \"%s\")',\r\n                icuTranslation,  this.asNativeString()));\r\n        } else {\r\n            const translatedICUMessage: IICUMessage = icuMessage.translate(icuTranslation);\r\n            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message from a native xml string as a translation of this one.\r\n     * @param nativeString xml string in the format of the underlying file format.\r\n     * Throws an error if native string is not acceptable.\r\n     */\r\n    translateNativeString(nativeString: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);\r\n    }\r\n\r\n    /**\r\n     * normalized message as string.\r\n     * @param displayFormat optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public asDisplayString(displayFormat?: string) {\r\n        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');\r\n    }\r\n\r\n    /**\r\n     * Returns the message content as format dependent native string.\r\n     * Includes all format specific markup like <ph id=\"INTERPOLATION\" ../> ..\r\n     */\r\n    asNativeString(): string {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return DOMUtilities.getXMLContent(this._xmlRepresentation);\r\n        } else {\r\n            return this.getICUMessage().asNativeString();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate the message.\r\n     * @return null, if ok, error object otherwise.\r\n     */\r\n    public validate(): ValidationErrors | null {\r\n        let hasErrors = false;\r\n        const errors: ValidationErrors = {};\r\n        let e;\r\n        e = this.checkPlaceholderAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.placeholderAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefRemoved();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefRemoved = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        return hasErrors ? errors : null;\r\n    }\r\n\r\n    /**\r\n     * Validate the message, check for warnings only.\r\n     * A warning shows, that the message is acceptable, but misses something.\r\n     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.\r\n     * @return null, if no warning, warnings as error object otherwise.\r\n     */\r\n    validateWarnings(): ValidationErrors | null {\r\n        let hasWarnings = false;\r\n        const warnings: ValidationErrors = {};\r\n        let w;\r\n        w = this.checkPlaceholderRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.placeholderRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagAdded();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagAdded = w;\r\n            hasWarnings = true;\r\n        }\r\n        return hasWarnings ? warnings : null;\r\n    }\r\n\r\n    /**\r\n     * If this message is an ICU message, returns its structure.\r\n     * Otherwise this method returns null.\r\n     * @return ICUMessage or null.\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {\r\n            const icuPart = <ParsedMessagePartICUMessage> this._parts[0];\r\n            return icuPart.getICUMessage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for added placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            myPlaceholders.forEach((index) => {\r\n                if (!sourcePlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderRemoved(): any {\r\n        let w = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            sourcePlaceholders.forEach((index) => {\r\n                if (!myPlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Check for added ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            myICURefs.forEach((index) => {\r\n                if (!sourceICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefRemoved(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            sourceICURefs.forEach((index) => {\r\n                if (!myICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of placeholders used in the message.\r\n     */\r\n    private allPlaceholders(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const index = (<ParsedMessagePartPlaceholder> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of placeholder\r\n     * @param index index of placeholder\r\n     * @return disp or null\r\n     */\r\n    public getPlaceholderDisp(index: number): string {\r\n        let placeHolder: ParsedMessagePartPlaceholder = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const phPart: ParsedMessagePartPlaceholder = <ParsedMessagePartPlaceholder> part;\r\n                if (phPart.index() === index) {\r\n                    placeHolder = phPart;\r\n                }\r\n            }\r\n        });\r\n        return placeHolder ? placeHolder.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of ICU message refs used in the message.\r\n     */\r\n    private allICUMessageRefs(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const index = (<ParsedMessagePartICUMessageRef> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of icu message ref\r\n     * @param index of ref\r\n     * @return disp or null\r\n     */\r\n    public getICUMessageRefDisp(index: number): string {\r\n        let icuMessageRefPart: ParsedMessagePartICUMessageRef = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const refPart: ParsedMessagePartICUMessageRef = <ParsedMessagePartICUMessageRef> part;\r\n                if (refPart.index() === index) {\r\n                    icuMessageRefPart = refPart;\r\n                }\r\n            }\r\n        });\r\n        return icuMessageRefPart ? icuMessageRefPart.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Check for added tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagAdded(): any {\r\n        let e = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            myTags.forEach((tagName) => {\r\n                if (!sourceTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagRemoved(): any {\r\n        let w = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            sourceTags.forEach((tagName) => {\r\n                if (!myTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            w = 'removed tag <' + suspiciousTags[0] + '> from original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            w = 'removed tags ' + allSuspiciousTags + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Get all tag names used in the message.\r\n     */\r\n    private allTags(): Set<string> {\r\n        const result = new Set<string>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {\r\n                const tagName = (<ParsedMessagePartStartTag> part).tagName();\r\n                result.add(tagName);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    public parts(): ParsedMessagePart[] {\r\n        return this._parts;\r\n    }\r\n\r\n    setXmlRepresentation(xmlRepresentation: Element) {\r\n        this._xmlRepresentation = xmlRepresentation;\r\n    }\r\n\r\n    addText(text: string) {\r\n        this._parts.push(new ParsedMessagePartText(text));\r\n    }\r\n\r\n    addPlaceholder(index: number, disp: string) {\r\n        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));\r\n    }\r\n\r\n    addStartTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));\r\n    }\r\n\r\n    addEndTag(tagname: string) {\r\n        // check if well formed\r\n        const openTag = this.calculateOpenTagName();\r\n        if (!openTag || openTag !== tagname) {\r\n            // oops, not well formed\r\n            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                tagname, openTag, this.asNativeString()));\r\n        }\r\n        this._parts.push(new ParsedMessagePartEndTag(tagname));\r\n    }\r\n\r\n    addEmptyTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));\r\n    }\r\n\r\n    addICUMessageRef(index: number, disp) {\r\n        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));\r\n    }\r\n\r\n    addICUMessage(text: string) {\r\n        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));\r\n    }\r\n\r\n    /**\r\n     * Determine, wether there is an open tag, that is not closed.\r\n     * Returns the latest one or null, if there is no open tag.\r\n     */\r\n    private calculateOpenTagName(): string {\r\n        const openTags = [];\r\n        this._parts.forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.START_TAG:\r\n                    openTags.push((<ParsedMessagePartStartTag> part).tagName());\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const tagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {\r\n                        // oops, not well formed\r\n                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];\r\n                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                            tagName, openTag, this.asNativeString()));\r\n                    }\r\n                    openTags.pop();\r\n            }\r\n        });\r\n        return openTags.length === 0 ? null : openTags[openTags.length - 1];\r\n    }\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\nimport {isNullOrUndefined} from 'util';\r\n\r\n/**\r\n * Created by martin on 14.05.2017.\r\n * A tokenizer for normalized messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const START_TAG = 'START_TAG';\r\nexport const END_TAG = 'END_TAG';\r\nexport const EMPTY_TAG = 'EMPTY_TAG';\r\nexport const PLACEHOLDER = 'PLACEHOLDER';\r\nexport const ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';\r\nexport const ICU_MESSAGE = 'ICU_MESSAGE';\r\n\r\nexport interface Token {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\nexport class ParsedMesageTokenizer {\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT && plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n                plaintext = '';\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n            }\r\n         });\r\n        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']\r\n        // format is <name id=\"nr\">, nr ist optional, z.B. <img> oder <img id=\"2\">\r\n        lexer.rule(/<(br|hr|img|area|link|wbr)( id=\"([0-9])*\")?\\>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(EMPTY_TAG, {name: match[1], idcounter: idcount});\r\n        }, EMPTY_TAG);\r\n        // start tag, Format <name id=\"nr\">, nr ist optional, z.B. <mytag> oder <mytag id=\"2\">\r\n        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id=\"([0-9]*)\")?>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(START_TAG, {name: match[1], idcounter: idcount});\r\n        }, START_TAG);\r\n        // end tag\r\n        lexer.rule(/<\\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {\r\n            ctx.accept(END_TAG, {name: match[1]});\r\n        }, END_TAG);\r\n        // placeholder\r\n        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {\r\n            ctx.accept(PLACEHOLDER, {idcounter: parseInt(match[1], 10)});\r\n        }, PLACEHOLDER);\r\n        // icu message ref\r\n        lexer.rule(/<ICU-Message-Ref_([0-9]+)\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE_REF, {idcounter: parseInt(match[1], 10)});\r\n        }, ICU_MESSAGE_REF);\r\n        // icu message\r\n        lexer.rule(/<ICU-Message\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE, {message: match[0]});\r\n        }, ICU_MESSAGE);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\t\\r\\n]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): Token[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.reset();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n}\r\n","import {ParsedMessage} from './parsed-message';\r\nimport {\r\n    EMPTY_TAG,\r\n    END_TAG, ICU_MESSAGE, ICU_MESSAGE_REF, ParsedMesageTokenizer, PLACEHOLDER, START_TAG, TEXT,\r\n    Token\r\n} from './parsed-message-tokenizer';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {DOMParser} from 'xmldom';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser can parse the xml content of a translatable message.\r\n * It generates a ParsedMessage from it.\r\n */\r\nexport abstract class AbstractMessageParser implements IMessageParser {\r\n\r\n    /**\r\n     * Parse XML to ParsedMessage.\r\n     * @param xmlElement the xml representation\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    public createNormalizedMessageFromXML(xmlElement: Element, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        if (xmlElement) {\r\n            message.setXmlRepresentation(xmlElement);\r\n            this.addPartsOfNodeToMessage(xmlElement, message, false);\r\n        }\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse XML string to ParsedMessage.\r\n     * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXMLString(xmlString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const doc: Document = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');\r\n        const xmlElement: Element = <Element> doc.childNodes.item(0);\r\n        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * recursively run through a node and add all identified parts to the message.\r\n     * @param node node\r\n     * @param message message to be generated.\r\n     * @param includeSelf if true, add node by itself, otherwise only children.\r\n     */\r\n    private addPartsOfNodeToMessage(node: Node, message: ParsedMessage, includeSelf: boolean) {\r\n        let processChildren = true;\r\n        if (includeSelf) {\r\n            if (node.nodeType === node.TEXT_NODE) {\r\n                message.addText(node.textContent);\r\n                return;\r\n            }\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                processChildren = this.processStartElement(<Element> node, message);\r\n            }\r\n        }\r\n        if (processChildren) {\r\n            const icuMessageText = this.getICUMessageText(node);\r\n            let isICU = !isNullOrUndefined(icuMessageText);\r\n            if (isICU) {\r\n                try {\r\n                    message.addICUMessage(icuMessageText);\r\n                } catch (error) {\r\n                    // if it is not parsable, handle it as non ICU\r\n                    console.log('non ICU message: ', icuMessageText, error);\r\n                    isICU = false;\r\n                }\r\n            }\r\n            if (!isICU) {\r\n                const children = node.childNodes;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    this.addPartsOfNodeToMessage(children.item(i), message, true);\r\n                }\r\n            }\r\n        }\r\n        if (node.nodeType === node.ELEMENT_NODE) {\r\n            this.processEndElement(<Element> node, message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        const firstChild = children.item(0);\r\n        if (firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                return DOMUtilities.getXMLContent(<Element> node);\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether text is beginning of ICU Message.\r\n     * @param text text\r\n     */\r\n    public isICUMessageStart(text: string): boolean {\r\n        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);\r\n//        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');\r\n    }\r\n\r\n    /**\r\n     * Handle this node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected abstract processStartElement(elementNode: Element, message: ParsedMessage): boolean;\r\n\r\n    /**\r\n     * Handle end of this node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected abstract processEndElement(elementNode: Element, message: ParsedMessage);\r\n\r\n    /**\r\n     * Parse normalized string to ParsedMessage.\r\n     * @param normalizedString normalized string\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if normalized string is not well formed.\r\n     */\r\n    public parseNormalizedString(normalizedString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        const openTags = [];\r\n        let tokens: Token[];\r\n        try {\r\n            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);\r\n        } catch (error) {\r\n            throw new Error(format('unexpected error while parsing message: \"%s\" (parsed \"%\")', error.message, normalizedString));\r\n        }\r\n        tokens.forEach((token: Token) => {\r\n            let disp: string = null;\r\n            switch (token.type) {\r\n                case TEXT:\r\n                    message.addText(token.value.text);\r\n                    break;\r\n                case START_TAG:\r\n                    message.addStartTag(token.value.name, token.value.idcounter);\r\n                    openTags.push(token.value.name);\r\n                    break;\r\n                case END_TAG:\r\n                    message.addEndTag(token.value.name);\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {\r\n                        // oops, not well formed\r\n                        throw new Error(format('unexpected close tag \"%s\" (parsed \"%s\")', token.value.name, normalizedString));\r\n                    }\r\n                    openTags.pop();\r\n                    break;\r\n                case EMPTY_TAG:\r\n                    message.addEmptyTag(token.value.name, token.value.idcounter);\r\n                    break;\r\n                case PLACEHOLDER:\r\n                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;\r\n                    message.addPlaceholder(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE_REF:\r\n                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;\r\n                    message.addICUMessageRef(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE:\r\n                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed \"%\")', normalizedString));\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        if (openTags.length > 0) {\r\n            // oops, not well closed tags\r\n            throw new Error(format('missing close tag \"%s\" (parsed \"%s\")', openTags[openTags.length - 1], normalizedString));\r\n        }\r\n        message.setXmlRepresentation(this.createXmlRepresentation(message));\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse a string, that is an ICU message, to ParsedMessage.\r\n     * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if icuMessageString has not the correct syntax.\r\n     */\r\n    parseICUMessage(icuMessageString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        message.addICUMessage(icuMessageString);\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Helper function: Parse ID from a name.\r\n     * name optionally ends with _<number>. This is the idcount.\r\n     * E.g. name=\"TAG_IMG\" returns 0\r\n     * name = \"TAG_IMG_1\" returns 1\r\n     * @param name name\r\n     * @return id count\r\n     */\r\n    protected parseIdCountFromName(name: string): number {\r\n        const regex = /.*_([0-9]*)/;\r\n        const match = regex.exec(name);\r\n        if (isNullOrUndefined(match) || match[1] === '') {\r\n            return 0;\r\n        } else {\r\n            const num = match[1];\r\n            return parseInt(num, 10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the native xml for a message.\r\n     * Parts are already set here.\r\n     * @param message message\r\n     */\r\n    protected createXmlRepresentation(message: ParsedMessage): Element {\r\n        const root: Document = new DOMParser().parseFromString('<dummy/>', 'text/xml');\r\n        const rootElem: Element = root.getElementsByTagName('dummy').item(0);\r\n        this.addXmlRepresentationToRoot(message, rootElem);\r\n        return rootElem;\r\n    }\r\n\r\n    protected abstract addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element);\r\n\r\n    protected createXmlRepresentationOfTextPart(part: ParsedMessagePartText, rootElem: Element): Node {\r\n        return rootElem.ownerDocument.createTextNode(part.asDisplayString());\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node;\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node;\r\n}\r\n","/**\r\n * Created by roobm on 16.05.2017.\r\n * Mapping from normalized tag names to placeholder names.\r\n */\r\n\r\n/*\r\ncopied from https://github.com/angular/angular/blob/master/packages/compiler/src/i18n/serializers/placeholder.ts\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n\r\n/**\r\n * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.\r\n */\r\nconst VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];\r\n\r\nexport class TagMapping {\r\n\r\n    public getStartTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `START_${baseName}` + this.counterString(id);\r\n    }\r\n\r\n    public getCloseTagPlaceholderName(tag: string): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `CLOSE_${baseName}`;\r\n    }\r\n\r\n    public getEmptyTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName =  TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return baseName + this.counterString(id);\r\n    }\r\n\r\n    public getCtypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n                return 'lb';\r\n            case 'img':\r\n                return 'image';\r\n            default:\r\n                return `x-${tag}`;\r\n        }\r\n    }\r\n\r\n    public getTagnameFromStartTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('START_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('START_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('START_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public getTagnameFromCloseTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('CLOSE_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('CLOSE_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Test, wether placeholder name stands for empty html tag.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public isEmptyTagPlaceholderName(placeholderName: string): boolean {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * tagname of empty tag placeholder.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public getTagnameFromEmptyTagPlaceholderName(placeholderName: string): string {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return matchKey.toLowerCase();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * If placeholder ends with _[0-9]+, strip that number.\r\n     * @param placeholderName placeholderName\r\n     * @return placeholderName without counter at end.\r\n     */\r\n    private stripCounter(placeholderName: string): string {\r\n        if (placeholderName) {\r\n            const re = /(.*)_[0-9]+$/;\r\n            if (placeholderName.match(re)) {\r\n                return placeholderName.replace(re, '$1');\r\n            }\r\n        }\r\n        return placeholderName;\r\n    }\r\n\r\n    /**\r\n     * String suffix for counter.\r\n     * If counter is 0, it is empty, otherwise _<id>.\r\n     * @param id id\r\n     * @return suffix for counter.\r\n     */\r\n    private counterString(id: number) {\r\n        if (id === 0) {\r\n            return '';\r\n        } else {\r\n            return '_' + id.toString(10);\r\n        }\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {isNullOrUndefined} from 'util';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 1.2\r\n */\r\nexport class XliffMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        const tagMapping = new TagMapping();\r\n        if (tagName === 'x') {\r\n            // placeholder are like <x id=\"INTERPOLATION\"/> or <x id=\"INTERPOLATION_1\">\r\n            const id = elementNode.getAttribute('id');\r\n            if (!id) {\r\n                return; // should not happen\r\n            }\r\n            if (id.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromId(id);\r\n                message.addPlaceholder(index, null);\r\n            } else if (id.startsWith('ICU')) {\r\n                const index = this.parseICUMessageRefIndexFromId(id);\r\n                message.addICUMessageRef(index, null);\r\n            } else if (id.startsWith('START_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addStartTag(normalizedTagName, idcount);\r\n                }\r\n            } else if (id.startsWith('CLOSE_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    message.addEndTag(normalizedTagName);\r\n                }\r\n            } else if (tagMapping.isEmptyTagPlaceholderName(id)) {\r\n                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addEmptyTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return index\r\n     */\r\n    private parsePlaceholderIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageRefIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            let child: Node;\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    child = this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    child = this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    child = this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    child = this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    child = this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    child = this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n                    break;\r\n            }\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        const ctypeAttrib = 'x-' + part.tagName();\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '/>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an empty <x/>-Element with attribute id=\"INTERPOLATION\" or id=\"INTERPOLATION_n\"\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        const equivTextAttr = part.disp();\r\n        xElem.setAttribute('id', idAttrib);\r\n        if (equivTextAttr) {\r\n            xElem.setAttribute('equiv-text', equivTextAttr);\r\n        }\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        xElem.setAttribute('id', idAttrib);\r\n        return xElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XliffMessageParser} from './xliff-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XLIFF 1.2 file.\r\n */\r\n\r\nexport class XliffTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XliffMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            return targetElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            targetElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'new';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'new':\r\n                return STATE_NEW;\r\n            case 'needs-translation':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-translation':\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            case 'signed-off':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                const contextElements = elem.getElementsByTagName('context');\r\n                let sourcefile = null;\r\n                let linenumber = 0;\r\n                for (let j = 0; j < contextElements.length; j++) {\r\n                    const contextElem = contextElements.item(j);\r\n                    if (contextElem.getAttribute('context-type') === 'sourcefile') {\r\n                        sourcefile = DOMUtilities.getPCDATA(contextElem);\r\n                    }\r\n                    if (contextElem.getAttribute('context-type') === 'linenumber') {\r\n                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);\r\n                    }\r\n                }\r\n                sourceRefs.push({sourcefile: sourcefile, linenumber: linenumber});\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        sourceRefs.forEach((ref) => {\r\n            const contextGroup = this._element.ownerDocument.createElement('context-group');\r\n            contextGroup.setAttribute('purpose', 'location');\r\n            const contextSource = this._element.ownerDocument.createElement('context');\r\n            contextSource.setAttribute('context-type', 'sourcefile');\r\n            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));\r\n            const contextLine = this._element.ownerDocument.createElement('context');\r\n            contextLine.setAttribute('context-type', 'linenumber');\r\n            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));\r\n            contextGroup.appendChild(contextSource);\r\n            contextGroup.appendChild(contextLine);\r\n            this._element.appendChild(contextGroup);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (description) {\r\n           if (isNullOrUndefined(noteElem)) {\r\n               // create it\r\n               noteElem = this.createNoteElementWithFromAttribute('description', description);\r\n           } else {\r\n               DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n           }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithFromAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('from') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('from');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param fromAttrValue value of \"from\" attribute\r\n     * @param content text value of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithFromAttribute(fromAttrValue: string, content: string): Element {\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (fromAttrValue) {\r\n            noteElement.setAttribute('from', fromAttrValue);\r\n        }\r\n        noteElement.setAttribute('priority', '1');\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        this._element.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithFromAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithFromAttribute(attrValue);\r\n        if (noteElement) {\r\n            this._element.removeChild(noteElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            this._element.removeChild(noteElement);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param  meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('from'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n     }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new XliffTransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        if (isDefaultLang) {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n        } else {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n        }\r\n    }\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF12, FILETYPE_XLIFF12} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {XliffTransUnit} from './xliff-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.02.2017.\r\n * Ab xliff file read from a source file.\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class XliffFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xlf-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XliffFile\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): XliffFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '1.2';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 1.2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 1.2'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XliffTransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('source-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('source-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('target-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('target-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');\r\n        if (!bodyElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 1.2 file (should contain a body element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            bodyElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to body\r\n                bodyElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n         return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XMB\r\n */\r\nexport class XmbMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // There are 4 different usages of ph element:\r\n            // 1. placeholders are like <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>\r\n            // or <ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>\r\n            // 2. start tags:\r\n            // <ph name=\"START_LINK\"><ex>&lt;a&gt;</ex></ph>\r\n            // 3. empty tags:\r\n            // <ph name=\"TAG_IMG\"><ex>&lt;img&gt;</ex></ph>\r\n            // 4. ICU:\r\n            // <ph name=\"ICU\"><ex>ICU</ex></ph>\r\n            const name = elementNode.getAttribute('name');\r\n            if (!name) {\r\n                return true; // should not happen\r\n            }\r\n            if (name.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromName(name);\r\n                message.addPlaceholder(index, null);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('START_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                if (tag) {\r\n                    message.addStartTag(tag, idcounter);\r\n                }\r\n                return false; // ignore children\r\n            } else if (name.startsWith('CLOSE_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                if (tag) {\r\n                    message.addEndTag(tag);\r\n                }\r\n                return false; // ignore children\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(name)) {\r\n                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                message.addEmptyTag(emptyTagName, idcounter);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('ICU')) {\r\n                const index = this.parseICUMessageIndexFromName(name);\r\n                message.addICUMessageRef(index, null);\r\n                return false; // ignore children\r\n            }\r\n        } else if (tagName === 'source') {\r\n            // ignore source\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        let firstChild = null;\r\n        // find first child that is no source element.\r\n        let i;\r\n        for (i = 0; i < children.length; i++) {\r\n            const child = children.item(i);\r\n            if (child.nodeType !== child.ELEMENT_NODE || (<Element> child).tagName !== 'source') {\r\n                firstChild = child;\r\n                break;\r\n            }\r\n        }\r\n        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                const messageText = DOMUtilities.getXMLContent(<Element> node);\r\n                if (i > 0) {\r\n                    // drop <source> elements\r\n                    const reSource: RegExp = new RegExp('<source[^>]*>.*</source>', 'g');\r\n                    return messageText.replace(reSource, '');\r\n                } else {\r\n                    return messageText;\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parsePlaceholderIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as ICU message ref index.\r\n     * id can be \"ICU\" or \"ICU_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse the tag name from a ph element.\r\n     * It contained in the <ex> subelements value and enclosed in <>.\r\n     * Example: <ph name=\"START_BOLD_TEXT\"><ex>&lt;b&gt;</ex></ph>\r\n     * @param phElement phElement\r\n     */\r\n    private parseTagnameFromPhElement(phElement: Element): string {\r\n        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');\r\n        if (exElement) {\r\n            const value = DOMUtilities.getPCDATA(exElement);\r\n            if (!value || !value.startsWith('<') || !value.endsWith('>')) {\r\n                // oops\r\n                return null;\r\n            }\r\n            if (value.charAt(1) === '/') {\r\n                return value.substring(2, value.length - 1);\r\n            } else {\r\n                return value.substring(1, value.length - 1);\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            const child = this.createXmlRepresentationOfPart(part, rootElem);\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected createXmlRepresentationOfPart(part: ParsedMessagePart, rootElem: Element): Node {\r\n        switch (part.type) {\r\n            case ParsedMessagePartType.TEXT:\r\n                return this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n            case ParsedMessagePartType.START_TAG:\r\n                return this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n            case ParsedMessagePartType.END_TAG:\r\n                return this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n            case ParsedMessagePartType.EMPTY_TAG:\r\n                return this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n            case ParsedMessagePartType.PLACEHOLDER:\r\n                return this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n            case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                return this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n}\r\n","import {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XMB file.\r\n */\r\n\r\nexport class XmbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and linenumber\r\n     */\r\n    private static parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private static parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return source content\r\n     */\r\n    public sourceContent(): string {\r\n        let msgContent = DOMUtilities.getXMLContent(this._element);\r\n        const reSourceElem: RegExp = /<source>.*<\\/source>/g;\r\n        msgContent = msgContent.replace(reSourceElem, '');\r\n        return msgContent;\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // not supported\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, null);\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        // in fact, target and source are just the same in xmb\r\n        return this.sourceContent();\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     */\r\n    public nativeTargetState(): string {\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // not supported for xmb\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            const sourceAndPos: string = DOMUtilities.getPCDATA(elem);\r\n            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let insertPosition = this._element.childNodes.item(0);\r\n        for (let i = sourceRefs.length - 1; i >= 0; i--) {\r\n            const ref = sourceRefs[i];\r\n            const source = this._element.ownerDocument.createElement('source');\r\n            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            this._element.insertBefore(source, insertPosition);\r\n            insertPosition = source;\r\n        }\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            toBeRemoved.push(elem);\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xmb this is stored in the attribute \"desc\".\r\n     */\r\n    public description(): string {\r\n        return this._element.getAttribute('desc');\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xmb this is stored in the attribute \"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        return this._element.getAttribute('meaning');\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xmb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * In fact, xmb cannot be translated.\r\n     * So this throws an error.\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        throw new Error('You cannot translate xmb files, use xtb instead.');\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XMB, FILETYPE_XMB, FORMAT_XTB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {XmbTransUnit} from './xmb-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\n\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * xmb-File access.\r\n */\r\n\r\n/**\r\n * Doctype of xtb translation file corresponding with thos xmb file.\r\n */\r\nexport const XTB_DOCTYPE = `<!DOCTYPE translationbundle [\r\n  <!ELEMENT translationbundle (translation)*>\r\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n  <!ELEMENT translation (#PCDATA|ph)*>\r\n  <!ATTLIST translation id CDATA #REQUIRED>\r\n  <!ELEMENT ph EMPTY>\r\n  <!ATTLIST ph name CDATA #REQUIRED>\r\n]>`;\r\n\r\nexport class XmbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XmbFile\r\n     */\r\n    constructor(\r\n        private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n        xmlString: string, path: string, encoding: string) {\r\n\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): XmbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xmb file (should contain a messagebundle element)', path));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XmbTransUnit(msg, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XMB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XMB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XMB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['message'];\r\n    }\r\n\r\n    /**\r\n     * Guess language from filename.\r\n     * If filename is foo.xy.xmb, than language is assumed to be xy.\r\n     * @return Language or null\r\n     */\r\n    private guessLanguageFromFilename(): string {\r\n        if (this._filename) {\r\n            const parts: string[] = this._filename.split('.');\r\n            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {\r\n                return parts[parts.length - 2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        throw Error('xmb file cannot be used to store translations, use xtb file');\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationbundleXMLSource =\r\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + XTB_DOCTYPE + '\\n<translationbundle>\\n</translationbundle>\\n';\r\n        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n            FORMAT_XTB,\r\n            translationbundleXMLSource, filename, this.encoding(),\r\n            {xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding()});\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());\r\n        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());\r\n        this.forEachTransUnit((tu) => {\r\n            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nexport class Xliff2MessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            } else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            } else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            } else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        } else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    private tagNameFromPCElement(pcNode: Element): string {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        const stack = [{element: rootElem, tagName: 'root'}];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfPlaceholderPart(<ParsedMessagePartPlaceholder> part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfICUMessageRefPart(<ParsedMessagePartICUMessageRef> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(<ParsedMessagePartStartTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({element: <Element> newTagElem, tagName: (<ParsedMessagePartStartTag> part).tagName()});\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(<ParsedMessagePartEmptyTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        // not used\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n\r\n    private getTypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id: number): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {Xliff2MessageParser} from './xliff2-message-parser';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\n\r\nexport class Xliff2TransUnit extends AbstractTransUnit  implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new Xliff2MessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos: string = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    private parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithCategoryAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithCategoryAttribute(attrValue: string, content: string): Element {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    private removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithCategoryAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            } else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF20, FILETYPE_XLIFF20} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {Xliff2TransUnit} from './xliff2-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * An XLIFF 2.0 file read from a source file.\r\n * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\n *\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class Xliff2File extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an XLIFF 2.0-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return xliff file\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): Xliff2File {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '2.0';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 2.0'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('srcLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('srcLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('trgLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('trgLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (!fileElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 2.0 file (should contain a file element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            fileElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to first file element\r\n                fileElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {isNullOrUndefined} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\n\r\nexport class XtbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceTransUnitFromMaster: AbstractTransUnit;\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile,\r\n                _sourceTransUnitFromMaster: AbstractTransUnit) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    public sourceContent(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    public nativeTargetState(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            } else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public description(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public meaning(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XTB, FILETYPE_XTB, FORMAT_XMB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {XtbTransUnit} from './xtb-trans-unit';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * xtb-File access.\r\n * xtb is the translated counterpart to xmb.\r\n */\r\n\r\nexport class XtbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    // attached master file, if any\r\n    // used as source to determine state ...\r\n    private _masterFile: ITranslationMessagesFile; // an xmb-file\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * @return XmbFile\r\n     */\r\n    constructor(private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n                xmlString: string, path: string, encoding: string,\r\n                optionalMaster?: { xmlContent: string, path: string, encoding: string }) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string,\r\n                                  optionalMaster?: { xmlContent: string, path: string, encoding: string }): XtbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', path));\r\n        }\r\n        if (optionalMaster) {\r\n            try {\r\n                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n                    FORMAT_XMB,\r\n                    optionalMaster.xmlContent,\r\n                    optionalMaster.path,\r\n                    optionalMaster.encoding);\r\n                // check, wether this can be the master ...\r\n                const numberInMaster = this._masterFile.numberOfTransUnits();\r\n                const myNumber = this.numberOfTransUnits();\r\n                if (numberInMaster !== myNumber) {\r\n                    this._warnings.push(format(\r\n                        '%s trans units found in master, but this file has %s. Check if it is the correct master',\r\n                        numberInMaster, myNumber));\r\n                }\r\n            } catch (error) {\r\n                throw new Error(format('File \"%s\" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            let masterUnit: ITransUnit = null;\r\n            if (this._masterFile) {\r\n                masterUnit = this._masterFile.transUnitWithId(id);\r\n            }\r\n            this.transUnits.push(new XtbTransUnit(msg, id, this, <AbstractTransUnit> masterUnit));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XTB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XTB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XTB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['translation'];\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb/xtb.\r\n     * Try to guess it from master filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        if (this._masterFile) {\r\n            return this._masterFile.sourceLanguage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb/xtb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xtb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            return translationbundleElem.getAttribute('lang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            translationbundleElem.setAttribute('lang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newMasterTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (!translationbundleElem) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', this._filename));\r\n        }\r\n        const translationElement = translationbundleElem.ownerDocument.createElement('translation');\r\n        translationElement.setAttribute('id', foreignTransUnit.id);\r\n        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';\r\n        if (!(<AbstractTransUnit> foreignTransUnit).isICUMessage(newContent)) {\r\n            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);\r\n        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            translationbundleElem.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');\r\n            if (firstTranslationElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to bundle at end\r\n                translationbundleElem.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        throw new Error(format('File \"%s\", xtb files are not translatable, they are already translations', filename));\r\n    }\r\n}\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile} from './i-translation-messages-file';\r\nimport {XliffFile} from '../impl/xliff-file';\r\nimport {XmbFile} from '../impl/xmb-file';\r\nimport {format} from 'util';\r\nimport {Xliff2File} from '../impl/xliff2-file';\r\nimport {FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB} from './constants';\r\nimport {XtbFile} from '../impl/xtb-file';\r\nimport {ITranslationMessagesFileFactory} from './i-translation-messages-file-factory';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nexport class TranslationMessagesFileFactory implements ITranslationMessagesFileFactory {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromFileContent(i18nFormat: string,\r\n                                  xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromUnknownFormatFileContent(xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat: string,\r\n                              xmlContent: string,\r\n                              path: string,\r\n                              encoding: string,\r\n                              optionalMaster?: { xmlContent: string, path: string, encoding: string }): ITranslationMessagesFile {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent: string,\r\n                                           path: string,\r\n                                           encoding: string,\r\n                                           optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : ITranslationMessagesFile {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(\r\n                    formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            } catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n\r\n}\r\n\r\n"],"names":["NgModule","XMLSerializer","DOMParser","isNullOrUndefined","isString","tslib_1.__extends","format","TEXT"],"mappings":"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"}
