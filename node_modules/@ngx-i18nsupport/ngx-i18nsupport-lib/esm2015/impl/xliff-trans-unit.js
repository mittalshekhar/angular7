/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { STATE_NEW, STATE_TRANSLATED, STATE_FINAL } from '../api/constants';
import { DOMUtilities } from './dom-utilities';
import { AbstractTransUnit } from './abstract-trans-unit';
import { XliffMessageParser } from './xliff-message-parser';
import { isNullOrUndefined } from 'util';
/**
 * Created by martin on 01.05.2017.
 * A Translation Unit in an XLIFF 1.2 file.
 */
export class XliffTransUnit extends AbstractTransUnit {
    /**
     * @param {?} _element
     * @param {?} _id
     * @param {?} _translationMessagesFile
     */
    constructor(_element, _id, _translationMessagesFile) {
        super(_element, _id, _translationMessagesFile);
    }
    /**
     * @return {?}
     */
    sourceContent() {
        /** @type {?} */
        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        return DOMUtilities.getXMLContent(sourceElement);
    }
    /**
     * Set new source content in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing changed source content.
     * @param {?} newContent the new content.
     * @return {?}
     */
    setSourceContent(newContent) {
        /** @type {?} */
        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        if (!source) {
            // should not happen, there always has to be a source, but who knows..
            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));
        }
        DOMUtilities.replaceContentWithXMLContent(source, newContent);
    }
    /**
     * Return a parser used for normalized messages.
     * @return {?}
     */
    messageParser() {
        return new XliffMessageParser();
    }
    /**
     * The original text value, that is to be translated, as normalized message.
     * @return {?}
     */
    createSourceContentNormalized() {
        /** @type {?} */
        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        if (sourceElement) {
            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);
        }
        else {
            return null;
        }
    }
    /**
     * the translated value (containing all markup, depends on the concrete format used).
     * @return {?}
     */
    targetContent() {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        return DOMUtilities.getXMLContent(targetElement);
    }
    /**
     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)
     * and all embedded html is replaced by direct html markup.
     * @return {?}
     */
    targetContentNormalized() {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());
    }
    /**
     * State of the translation as stored in the xml.
     * @return {?}
     */
    nativeTargetState() {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (targetElement) {
            return targetElement.getAttribute('state');
        }
        else {
            return null;
        }
    }
    /**
     * set state in xml.
     * @param {?} nativeState nativeState
     * @return {?}
     */
    setNativeTargetState(nativeState) {
        /** @type {?} */
        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (targetElement) {
            targetElement.setAttribute('state', nativeState);
        }
    }
    /**
     * Map an abstract state (new, translated, final) to a concrete state used in the xml.
     * Returns the state to be used in the xml.
     * @throws error, if state is invalid.
     * @param {?} state one of Constants.STATE...
     * @return {?} a native state (depends on concrete format)
     */
    mapStateToNativeState(state) {
        switch (state) {
            case STATE_NEW:
                return 'new';
            case STATE_TRANSLATED:
                return 'translated';
            case STATE_FINAL:
                return 'final';
            default:
                throw new Error('unknown state ' + state);
        }
    }
    /**
     * Map a native state (found in the document) to an abstract state (new, translated, final).
     * Returns the abstract state.
     * @param {?} nativeState nativeState
     * @return {?}
     */
    mapNativeStateToState(nativeState) {
        switch (nativeState) {
            case 'new':
                return STATE_NEW;
            case 'needs-translation':
                return STATE_NEW;
            case 'translated':
                return STATE_TRANSLATED;
            case 'needs-adaptation':
                return STATE_TRANSLATED;
            case 'needs-l10n':
                return STATE_TRANSLATED;
            case 'needs-review-adaptation':
                return STATE_TRANSLATED;
            case 'needs-review-l10n':
                return STATE_TRANSLATED;
            case 'needs-review-translation':
                return STATE_TRANSLATED;
            case 'final':
                return STATE_FINAL;
            case 'signed-off':
                return STATE_FINAL;
            default:
                return STATE_NEW;
        }
    }
    /**
     * All the source elements in the trans unit.
     * The source element is a reference to the original template.
     * It contains the name of the template file and a line number with the position inside the template.
     * It is just a help for translators to find the context for the translation.
     * This is set when using Angular 4.0 or greater.
     * Otherwise it just returns an empty array.
     * @return {?}
     */
    sourceReferences() {
        /** @type {?} */
        const sourceElements = this._element.getElementsByTagName('context-group');
        /** @type {?} */
        const sourceRefs = [];
        for (let i = 0; i < sourceElements.length; i++) {
            /** @type {?} */
            const elem = sourceElements.item(i);
            if (elem.getAttribute('purpose') === 'location') {
                /** @type {?} */
                const contextElements = elem.getElementsByTagName('context');
                /** @type {?} */
                let sourcefile = null;
                /** @type {?} */
                let linenumber = 0;
                for (let j = 0; j < contextElements.length; j++) {
                    /** @type {?} */
                    const contextElem = contextElements.item(j);
                    if (contextElem.getAttribute('context-type') === 'sourcefile') {
                        sourcefile = DOMUtilities.getPCDATA(contextElem);
                    }
                    if (contextElem.getAttribute('context-type') === 'linenumber') {
                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);
                    }
                }
                sourceRefs.push({ sourcefile: sourcefile, linenumber: linenumber });
            }
        }
        return sourceRefs;
    }
    /**
     * Set source ref elements in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing source refs.
     * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
     * @return {?}
     */
    setSourceReferences(sourceRefs) {
        this.removeAllSourceReferences();
        sourceRefs.forEach((ref) => {
            /** @type {?} */
            const contextGroup = this._element.ownerDocument.createElement('context-group');
            contextGroup.setAttribute('purpose', 'location');
            /** @type {?} */
            const contextSource = this._element.ownerDocument.createElement('context');
            contextSource.setAttribute('context-type', 'sourcefile');
            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));
            /** @type {?} */
            const contextLine = this._element.ownerDocument.createElement('context');
            contextLine.setAttribute('context-type', 'linenumber');
            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));
            contextGroup.appendChild(contextSource);
            contextGroup.appendChild(contextLine);
            this._element.appendChild(contextGroup);
        });
    }
    /**
     * @return {?}
     */
    removeAllSourceReferences() {
        /** @type {?} */
        const sourceElements = this._element.getElementsByTagName('context-group');
        /** @type {?} */
        const toBeRemoved = [];
        for (let i = 0; i < sourceElements.length; i++) {
            /** @type {?} */
            const elem = sourceElements.item(i);
            if (elem.getAttribute('purpose') === 'location') {
                toBeRemoved.push(elem);
            }
        }
        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });
    }
    /**
     * The description set in the template as value of the i18n-attribute.
     * e.g. i18n="mydescription".
     * In xliff this is stored as a note element with attribute from="description".
     * @return {?}
     */
    description() {
        /** @type {?} */
        const noteElem = this.findNoteElementWithFromAttribute('description');
        if (noteElem) {
            return DOMUtilities.getPCDATA(noteElem);
        }
        else {
            return null;
        }
    }
    /**
     * Change description property of trans-unit.
     * @param {?} description description
     * @return {?}
     */
    setDescription(description) {
        /** @type {?} */
        let noteElem = this.findNoteElementWithFromAttribute('description');
        if (description) {
            if (isNullOrUndefined(noteElem)) {
                // create it
                noteElem = this.createNoteElementWithFromAttribute('description', description);
            }
            else {
                DOMUtilities.replaceContentWithXMLContent(noteElem, description);
            }
        }
        else {
            if (!isNullOrUndefined(noteElem)) {
                // remove node
                this.removeNoteElementWithFromAttribute('description');
            }
        }
    }
    /**
     * Find a note element with attribute from='<attrValue>'
     * @param {?} attrValue attrValue
     * @return {?} element or null is absent
     */
    findNoteElementWithFromAttribute(attrValue) {
        /** @type {?} */
        const noteElements = this._element.getElementsByTagName('note');
        for (let i = 0; i < noteElements.length; i++) {
            /** @type {?} */
            const noteElem = noteElements.item(i);
            if (noteElem.getAttribute('from') === attrValue) {
                return noteElem;
            }
        }
        return null;
    }
    /**
     * Get all note elements where from attribute is not description or meaning
     * @return {?} elements
     */
    findAllAdditionalNoteElements() {
        /** @type {?} */
        const noteElements = this._element.getElementsByTagName('note');
        /** @type {?} */
        const result = [];
        for (let i = 0; i < noteElements.length; i++) {
            /** @type {?} */
            const noteElem = noteElements.item(i);
            /** @type {?} */
            const fromAttribute = noteElem.getAttribute('from');
            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {
                result.push(noteElem);
            }
        }
        return result;
    }
    /**
     * Create a new note element with attribute from='<attrValue>'
     * @param {?} fromAttrValue value of "from" attribute
     * @param {?} content text value of note element
     * @return {?} the new created element
     */
    createNoteElementWithFromAttribute(fromAttrValue, content) {
        /** @type {?} */
        const noteElement = this._element.ownerDocument.createElement('note');
        if (fromAttrValue) {
            noteElement.setAttribute('from', fromAttrValue);
        }
        noteElement.setAttribute('priority', '1');
        if (content) {
            DOMUtilities.replaceContentWithXMLContent(noteElement, content);
        }
        this._element.appendChild(noteElement);
        return noteElement;
    }
    /**
     * Remove note element with attribute from='<attrValue>'
     * @param {?} attrValue attrValue
     * @return {?}
     */
    removeNoteElementWithFromAttribute(attrValue) {
        /** @type {?} */
        const noteElement = this.findNoteElementWithFromAttribute(attrValue);
        if (noteElement) {
            this._element.removeChild(noteElement);
        }
    }
    /**
     * Remove all note elements where attribute "from" is not description or meaning.
     * @return {?}
     */
    removeAllAdditionalNoteElements() {
        /** @type {?} */
        const noteElements = this.findAllAdditionalNoteElements();
        noteElements.forEach((noteElement) => {
            this._element.removeChild(noteElement);
        });
    }
    /**
     * The meaning (intent) set in the template as value of the i18n-attribute.
     * This is the part in front of the | symbol.
     * e.g. i18n="meaning|mydescription".
     * In xliff this is stored as a note element with attribute from="meaning".
     * @return {?}
     */
    meaning() {
        /** @type {?} */
        const noteElem = this.findNoteElementWithFromAttribute('meaning');
        if (noteElem) {
            return DOMUtilities.getPCDATA(noteElem);
        }
        else {
            return null;
        }
    }
    /**
     * Change meaning property of trans-unit.
     * @param {?} meaning meaning
     * @return {?}
     */
    setMeaning(meaning) {
        /** @type {?} */
        let noteElem = this.findNoteElementWithFromAttribute('meaning');
        if (meaning) {
            if (isNullOrUndefined(noteElem)) {
                // create it
                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);
            }
            else {
                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);
            }
        }
        else {
            if (!isNullOrUndefined(noteElem)) {
                // remove node
                this.removeNoteElementWithFromAttribute('meaning');
            }
        }
    }
    /**
     * Get all notes of the trans-unit.
     * Notes are remarks made by a translator.
     * (description and meaning are not included here!)
     * @return {?}
     */
    notes() {
        /** @type {?} */
        const noteElememts = this.findAllAdditionalNoteElements();
        return noteElememts.map(elem => {
            return {
                from: elem.getAttribute('from'),
                text: DOMUtilities.getPCDATA(elem)
            };
        });
    }
    /**
     * Test, wether setting of notes is supported.
     * If not, setNotes will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    supportsSetNotes() {
        return true;
    }
    /**
     * Add notes to trans unit.
     * @throws an Error if any note contains description or meaning as from attribute.
     * @param {?} newNotes the notes to add.
     * @return {?}
     */
    setNotes(newNotes) {
        if (!isNullOrUndefined(newNotes)) {
            this.checkNotes(newNotes);
        }
        this.removeAllAdditionalNoteElements();
        if (!isNullOrUndefined(newNotes)) {
            newNotes.forEach((note) => {
                /** @type {?} */
                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);
            });
        }
    }
    /**
     * Set the translation to a given string (including markup).
     * @param {?} translation translation
     * @return {?}
     */
    translateNative(translation) {
        /** @type {?} */
        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (!target) {
            /** @type {?} */
            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
            target = DOMUtilities.createFollowingSibling('target', source);
        }
        DOMUtilities.replaceContentWithXMLContent(target, /** @type {?} */ (translation));
        this.setTargetState(STATE_TRANSLATED);
    }
    /**
     * Copy source to target to use it as dummy translation.
     * Returns a changed copy of this trans unit.
     * receiver is not changed.
     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @param {?} targetFile
     * @return {?}
     */
    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {
        /** @type {?} */
        const element = /** @type {?} */ (this._element.cloneNode(true));
        /** @type {?} */
        const clone = new XliffTransUnit(element, this._id, targetFile);
        clone.useSourceAsTarget(isDefaultLang, copyContent);
        return clone;
    }
    /**
     * Copy source to target to use it as dummy translation.
     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @return {?}
     */
    useSourceAsTarget(isDefaultLang, copyContent) {
        /** @type {?} */
        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');
        /** @type {?} */
        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');
        if (!target) {
            target = DOMUtilities.createFollowingSibling('target', source);
        }
        if (isDefaultLang || copyContent) {
            /** @type {?} */
            const sourceString = DOMUtilities.getXMLContent(source);
            /** @type {?} */
            let newTargetString = sourceString;
            if (!this.isICUMessage(sourceString)) {
                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()
                    + sourceString
                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();
            }
            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);
        }
        else {
            DOMUtilities.replaceContentWithXMLContent(target, '');
        }
        if (isDefaultLang) {
            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));
        }
        else {
            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));
        }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxpZmYtdHJhbnMtdW5pdC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi8iLCJzb3VyY2VzIjpbImltcGwveGxpZmYtdHJhbnMtdW5pdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSxXQUFXLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUsxRSxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDN0MsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDeEQsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFHMUQsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sTUFBTSxDQUFDOzs7OztBQU12QyxNQUFNLHFCQUFzQixTQUFRLGlCQUFpQjs7Ozs7O0lBRWpELFlBQVksUUFBaUIsRUFBRSxHQUFXLEVBQUUsd0JBQWtEO1FBQzFGLEtBQUssQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLHdCQUF3QixDQUFDLENBQUM7S0FDbEQ7Ozs7SUFFTSxhQUFhOztRQUNoQixNQUFNLGFBQWEsR0FBRyxZQUFZLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNyRixPQUFPLFlBQVksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUM7Ozs7Ozs7OztJQVM5QyxnQkFBZ0IsQ0FBQyxVQUFrQjs7UUFDdEMsSUFBSSxNQUFNLEdBQUcsWUFBWSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDNUUsSUFBSSxDQUFDLE1BQU0sRUFBRTs7WUFFVCxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsYUFBYSxD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RCwgU1RBVEVfRklOQUx9IGZyb20gJy4uL2FwaS9jb25zdGFudHMnO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnLi4vYXBpL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7SU5vcm1hbGl6ZWRNZXNzYWdlfSBmcm9tICcuLi9hcGkvaS1ub3JtYWxpemVkLW1lc3NhZ2UnO1xyXG5pbXBvcnQge0lUcmFuc1VuaXR9IGZyb20gJy4uL2FwaS9pLXRyYW5zLXVuaXQnO1xyXG5pbXBvcnQge0lOb3RlfSBmcm9tICcuLi9hcGkvaS1ub3RlJztcclxuaW1wb3J0IHtET01VdGlsaXRpZXN9IGZyb20gJy4vZG9tLXV0aWxpdGllcyc7XHJcbmltcG9ydCB7QWJzdHJhY3RUcmFuc1VuaXR9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnMtdW5pdCc7XHJcbmltcG9ydCB7WGxpZmZNZXNzYWdlUGFyc2VyfSBmcm9tICcuL3hsaWZmLW1lc3NhZ2UtcGFyc2VyJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXInO1xyXG5pbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICd1dGlsJztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDAxLjA1LjIwMTcuXHJcbiAqIEEgVHJhbnNsYXRpb24gVW5pdCBpbiBhbiBYTElGRiAxLjIgZmlsZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgWGxpZmZUcmFuc1VuaXQgZXh0ZW5kcyBBYnN0cmFjdFRyYW5zVW5pdCBpbXBsZW1lbnRzIElUcmFuc1VuaXQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50OiBFbGVtZW50LCBfaWQ6IHN0cmluZywgX3RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpIHtcclxuICAgICAgICBzdXBlcihfZWxlbWVudCwgX2lkLCBfdHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzb3VyY2VDb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlRWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NvdXJjZScpO1xyXG4gICAgICAgIHJldHVybiBET01VdGlsaXRpZXMuZ2V0WE1MQ29udGVudChzb3VyY2VFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBuZXcgc291cmNlIGNvbnRlbnQgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3NpbmcgY2hhbmdlZCBzb3VyY2UgY29udGVudC5cclxuICAgICAqIEBwYXJhbSBuZXdDb250ZW50IHRoZSBuZXcgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNvdXJjZUNvbnRlbnQobmV3Q29udGVudDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IHNvdXJjZSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NvdXJjZScpO1xyXG4gICAgICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuLCB0aGVyZSBhbHdheXMgaGFzIHRvIGJlIGEgc291cmNlLCBidXQgd2hvIGtub3dzLi5cclxuICAgICAgICAgICAgc291cmNlID0gdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChzb3VyY2UsIG5ld0NvbnRlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcGFyc2VyIHVzZWQgZm9yIG5vcm1hbGl6ZWQgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBtZXNzYWdlUGFyc2VyKCk6IEFic3RyYWN0TWVzc2FnZVBhcnNlciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBYbGlmZk1lc3NhZ2VQYXJzZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHZhbHVlLCB0aGF0IGlzIHRvIGJlIHRyYW5zbGF0ZWQsIGFzIG5vcm1hbGl6ZWQgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCk6IFBhcnNlZE1lc3NhZ2Uge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICBpZiAoc291cmNlRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlUGFyc2VyKCkuY3JlYXRlTm9ybWFsaXplZE1lc3NhZ2VGcm9tWE1MKHNvdXJjZUVsZW1lbnQsIG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB0cmFuc2xhdGVkIHZhbHVlIChjb250YWluaW5nIGFsbCBtYXJrdXAsIGRlcGVuZHMgb24gdGhlIGNvbmNyZXRlIGZvcm1hdCB1c2VkKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldENvbnRlbnQoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAndGFyZ2V0Jyk7XHJcbiAgICAgICAgcmV0dXJuIERPTVV0aWxpdGllcy5nZXRYTUxDb250ZW50KHRhcmdldEVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHRyYW5zbGF0ZWQgdmFsdWUsIGJ1dCBhbGwgcGxhY2Vob2xkZXJzIGFyZSByZXBsYWNlZCB3aXRoIHt7bn19IChzdGFydGluZyBhdCAwKVxyXG4gICAgICogYW5kIGFsbCBlbWJlZGRlZCBodG1sIGlzIHJlcGxhY2VkIGJ5IGRpcmVjdCBodG1sIG1hcmt1cC5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0Q29udGVudE5vcm1hbGl6ZWQoKTogSU5vcm1hbGl6ZWRNZXNzYWdlIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gRE9NVXRpbGl0aWVzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSh0aGlzLl9lbGVtZW50LCAndGFyZ2V0Jyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBYbGlmZk1lc3NhZ2VQYXJzZXIoKS5jcmVhdGVOb3JtYWxpemVkTWVzc2FnZUZyb21YTUwodGFyZ2V0RWxlbWVudCwgdGhpcy5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRlIG9mIHRoZSB0cmFuc2xhdGlvbiBhcyBzdG9yZWQgaW4gdGhlIHhtbC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5hdGl2ZVRhcmdldFN0YXRlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3RhcmdldCcpO1xyXG4gICAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRFbGVtZW50LmdldEF0dHJpYnV0ZSgnc3RhdGUnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgc3RhdGUgaW4geG1sLlxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0YXRlIG5hdGl2ZVN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzZXROYXRpdmVUYXJnZXRTdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3RhcmdldCcpO1xyXG4gICAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdGF0ZScsIG5hdGl2ZVN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgYW4gYWJzdHJhY3Qgc3RhdGUgKG5ldywgdHJhbnNsYXRlZCwgZmluYWwpIHRvIGEgY29uY3JldGUgc3RhdGUgdXNlZCBpbiB0aGUgeG1sLlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdG8gYmUgdXNlZCBpbiB0aGUgeG1sLlxyXG4gICAgICogQHBhcmFtIHN0YXRlIG9uZSBvZiBDb25zdGFudHMuU1RBVEUuLi5cclxuICAgICAqIEByZXR1cm5zIGEgbmF0aXZlIHN0YXRlIChkZXBlbmRzIG9uIGNvbmNyZXRlIGZvcm1hdClcclxuICAgICAqIEB0aHJvd3MgZXJyb3IsIGlmIHN0YXRlIGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBtYXBTdGF0ZVRvTmF0aXZlU3RhdGUoc3RhdGU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgc3dpdGNoICggc3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSBTVEFURV9ORVc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25ldyc7XHJcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfVFJBTlNMQVRFRDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlZCc7XHJcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfRklOQUw6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2ZpbmFsJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBzdGF0ZSAnICsgIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgYSBuYXRpdmUgc3RhdGUgKGZvdW5kIGluIHRoZSBkb2N1bWVudCkgdG8gYW4gYWJzdHJhY3Qgc3RhdGUgKG5ldywgdHJhbnNsYXRlZCwgZmluYWwpLlxyXG4gICAgICogUmV0dXJucyB0aGUgYWJzdHJhY3Qgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gbmF0aXZlU3RhdGUgbmF0aXZlU3RhdGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1hcE5hdGl2ZVN0YXRlVG9TdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKCBuYXRpdmVTdGF0ZSkge1xyXG4gICAgICAgICAgICBjYXNlICduZXcnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX05FVztcclxuICAgICAgICAgICAgY2FzZSAnbmVlZHMtdHJhbnNsYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX05FVztcclxuICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlZCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVFJBTlNMQVRFRDtcclxuICAgICAgICAgICAgY2FzZSAnbmVlZHMtYWRhcHRhdGlvbic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVFJBTlNMQVRFRDtcclxuICAgICAgICAgICAgY2FzZSAnbmVlZHMtbDEwbic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVFJBTlNMQVRFRDtcclxuICAgICAgICAgICAgY2FzZSAnbmVlZHMtcmV2aWV3LWFkYXB0YXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1RSQU5TTEFURUQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ25lZWRzLXJldmlldy1sMTBuJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9UUkFOU0xBVEVEO1xyXG4gICAgICAgICAgICBjYXNlICduZWVkcy1yZXZpZXctdHJhbnNsYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1RSQU5TTEFURUQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmFsJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9GSU5BTDtcclxuICAgICAgICAgICAgY2FzZSAnc2lnbmVkLW9mZic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfRklOQUw7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfTkVXO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgc291cmNlIGVsZW1lbnRzIGluIHRoZSB0cmFucyB1bml0LlxyXG4gICAgICogVGhlIHNvdXJjZSBlbGVtZW50IGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cclxuICAgICAqIEl0IGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmaWxlIGFuZCBhIGxpbmUgbnVtYmVyIHdpdGggdGhlIHBvc2l0aW9uIGluc2lkZSB0aGUgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBpcyBqdXN0IGEgaGVscCBmb3IgdHJhbnNsYXRvcnMgdG8gZmluZCB0aGUgY29udGV4dCBmb3IgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogVGhpcyBpcyBzZXQgd2hlbiB1c2luZyBBbmd1bGFyIDQuMCBvciBncmVhdGVyLlxyXG4gICAgICogT3RoZXJ3aXNlIGl0IGp1c3QgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNvdXJjZVJlZmVyZW5jZXMoKToge3NvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyfVtdIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NvbnRleHQtZ3JvdXAnKTtcclxuICAgICAgICBjb25zdCBzb3VyY2VSZWZzOiB7IHNvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyIH1bXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHNvdXJjZUVsZW1lbnRzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtLmdldEF0dHJpYnV0ZSgncHVycG9zZScpID09PSAnbG9jYXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0RWxlbWVudHMgPSBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb250ZXh0Jyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlZmlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGluZW51bWJlciA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbnRleHRFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRFbGVtID0gY29udGV4dEVsZW1lbnRzLml0ZW0oaik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRFbGVtLmdldEF0dHJpYnV0ZSgnY29udGV4dC10eXBlJykgPT09ICdzb3VyY2VmaWxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VmaWxlID0gRE9NVXRpbGl0aWVzLmdldFBDREFUQShjb250ZXh0RWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0RWxlbS5nZXRBdHRyaWJ1dGUoJ2NvbnRleHQtdHlwZScpID09PSAnbGluZW51bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZW51bWJlciA9IE51bWJlci5wYXJzZUludChET01VdGlsaXRpZXMuZ2V0UENEQVRBKGNvbnRleHRFbGVtKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNvdXJjZVJlZnMucHVzaCh7c291cmNlZmlsZTogc291cmNlZmlsZSwgbGluZW51bWJlcjogbGluZW51bWJlcn0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzb3VyY2VSZWZzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNvdXJjZSByZWYgZWxlbWVudHMgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3Npbmcgc291cmNlIHJlZnMuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlUmVmcyB0aGUgc291cmNlcmVmcyB0byBzZXQuIE9sZCBvbmVzIGFyZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U291cmNlUmVmZXJlbmNlcyhzb3VyY2VSZWZzOiB7c291cmNlZmlsZTogc3RyaW5nLCBsaW5lbnVtYmVyOiBudW1iZXJ9W10pIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbFNvdXJjZVJlZmVyZW5jZXMoKTtcclxuICAgICAgICBzb3VyY2VSZWZzLmZvckVhY2goKHJlZikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0R3JvdXAgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29udGV4dC1ncm91cCcpO1xyXG4gICAgICAgICAgICBjb250ZXh0R3JvdXAuc2V0QXR0cmlidXRlKCdwdXJwb3NlJywgJ2xvY2F0aW9uJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRTb3VyY2UgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29udGV4dCcpO1xyXG4gICAgICAgICAgICBjb250ZXh0U291cmNlLnNldEF0dHJpYnV0ZSgnY29udGV4dC10eXBlJywgJ3NvdXJjZWZpbGUnKTtcclxuICAgICAgICAgICAgY29udGV4dFNvdXJjZS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmVmLnNvdXJjZWZpbGUpKTtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dExpbmUgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29udGV4dCcpO1xyXG4gICAgICAgICAgICBjb250ZXh0TGluZS5zZXRBdHRyaWJ1dGUoJ2NvbnRleHQtdHlwZScsICdsaW5lbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGNvbnRleHRMaW5lLmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyZWYubGluZW51bWJlci50b1N0cmluZygxMCkpKTtcclxuICAgICAgICAgICAgY29udGV4dEdyb3VwLmFwcGVuZENoaWxkKGNvbnRleHRTb3VyY2UpO1xyXG4gICAgICAgICAgICBjb250ZXh0R3JvdXAuYXBwZW5kQ2hpbGQoY29udGV4dExpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRleHRHcm91cCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZW1vdmVBbGxTb3VyY2VSZWZlcmVuY2VzKCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29udGV4dC1ncm91cCcpO1xyXG4gICAgICAgIGNvbnN0IHRvQmVSZW1vdmVkID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtID0gc291cmNlRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgaWYgKGVsZW0uZ2V0QXR0cmlidXRlKCdwdXJwb3NlJykgPT09ICdsb2NhdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRvQmVSZW1vdmVkLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdG9CZVJlbW92ZWQuZm9yRWFjaCgoZWxlbSkgPT4ge2VsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKiBJbiB4bGlmZiB0aGlzIGlzIHN0b3JlZCBhcyBhIG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBmcm9tPVwiZGVzY3JpcHRpb25cIi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlc2NyaXB0aW9uKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSB0aGlzLmZpbmROb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKCdkZXNjcmlwdGlvbicpO1xyXG4gICAgICAgIGlmIChub3RlRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFBDREFUQShub3RlRWxlbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIGRlc2NyaXB0aW9uIHByb3BlcnR5IG9mIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gZGVzY3JpcHRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgbm90ZUVsZW0gPSB0aGlzLmZpbmROb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKCdkZXNjcmlwdGlvbicpO1xyXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xyXG4gICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChub3RlRWxlbSkpIHtcclxuICAgICAgICAgICAgICAgLy8gY3JlYXRlIGl0XHJcbiAgICAgICAgICAgICAgIG5vdGVFbGVtID0gdGhpcy5jcmVhdGVOb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKCdkZXNjcmlwdGlvbicsIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChub3RlRWxlbSwgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5vdGVFbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnZGVzY3JpcHRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgYSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgZnJvbT0nPGF0dHJWYWx1ZT4nXHJcbiAgICAgKiBAcGFyYW0gYXR0clZhbHVlIGF0dHJWYWx1ZVxyXG4gICAgICogQHJldHVybiBlbGVtZW50IG9yIG51bGwgaXMgYWJzZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluZE5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoYXR0clZhbHVlOiBzdHJpbmcpOiBFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdub3RlJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3RlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSBub3RlRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgaWYgKG5vdGVFbGVtLmdldEF0dHJpYnV0ZSgnZnJvbScpID09PSBhdHRyVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub3RlRWxlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbm90ZSBlbGVtZW50cyB3aGVyZSBmcm9tIGF0dHJpYnV0ZSBpcyBub3QgZGVzY3JpcHRpb24gb3IgbWVhbmluZ1xyXG4gICAgICogQHJldHVybiBlbGVtZW50c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmRBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCk6IEVsZW1lbnRbXSB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnRzID0gdGhpcy5fZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbm90ZScpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogRWxlbWVudFtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3RlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm90ZUVsZW0gPSBub3RlRWxlbWVudHMuaXRlbShpKTtcclxuICAgICAgICAgICAgY29uc3QgZnJvbUF0dHJpYnV0ZSA9IG5vdGVFbGVtLmdldEF0dHJpYnV0ZSgnZnJvbScpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbUF0dHJpYnV0ZSAhPT0gJ2Rlc2NyaXB0aW9uJyAmJiBmcm9tQXR0cmlidXRlICE9PSAnbWVhbmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vdGVFbGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBmcm9tPSc8YXR0clZhbHVlPidcclxuICAgICAqIEBwYXJhbSBmcm9tQXR0clZhbHVlIHZhbHVlIG9mIFwiZnJvbVwiIGF0dHJpYnV0ZVxyXG4gICAgICogQHBhcmFtIGNvbnRlbnQgdGV4dCB2YWx1ZSBvZiBub3RlIGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gdGhlIG5ldyBjcmVhdGVkIGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVOb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKGZyb21BdHRyVmFsdWU6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3Qgbm90ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbm90ZScpO1xyXG4gICAgICAgIGlmIChmcm9tQXR0clZhbHVlKSB7XHJcbiAgICAgICAgICAgIG5vdGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnZnJvbScsIGZyb21BdHRyVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub3RlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ByaW9yaXR5JywgJzEnKTtcclxuICAgICAgICBpZiAoY29udGVudCkge1xyXG4gICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChub3RlRWxlbWVudCwgY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQobm90ZUVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiBub3RlRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBub3RlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgZnJvbT0nPGF0dHJWYWx1ZT4nXHJcbiAgICAgKiBAcGFyYW0gYXR0clZhbHVlIGF0dHJWYWx1ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlbW92ZU5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoYXR0clZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbWVudCA9IHRoaXMuZmluZE5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoYXR0clZhbHVlKTtcclxuICAgICAgICBpZiAobm90ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZChub3RlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBub3RlIGVsZW1lbnRzIHdoZXJlIGF0dHJpYnV0ZSBcImZyb21cIiBpcyBub3QgZGVzY3JpcHRpb24gb3IgbWVhbmluZy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW1vdmVBbGxBZGRpdGlvbmFsTm90ZUVsZW1lbnRzKCkge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtZW50cyA9IHRoaXMuZmluZEFsbEFkZGl0aW9uYWxOb3RlRWxlbWVudHMoKTtcclxuICAgICAgICBub3RlRWxlbWVudHMuZm9yRWFjaCgobm90ZUVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZChub3RlRWxlbWVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWVhbmluZyAoaW50ZW50KSBzZXQgaW4gdGhlIHRlbXBsYXRlIGFzIHZhbHVlIG9mIHRoZSBpMThuLWF0dHJpYnV0ZS5cclxuICAgICAqIFRoaXMgaXMgdGhlIHBhcnQgaW4gZnJvbnQgb2YgdGhlIHwgc3ltYm9sLlxyXG4gICAgICogZS5nLiBpMThuPVwibWVhbmluZ3xteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKiBJbiB4bGlmZiB0aGlzIGlzIHN0b3JlZCBhcyBhIG5vdGUgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBmcm9tPVwibWVhbmluZ1wiLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWVhbmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG5vdGVFbGVtID0gdGhpcy5maW5kTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnbWVhbmluZycpO1xyXG4gICAgICAgIGlmIChub3RlRWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRE9NVXRpbGl0aWVzLmdldFBDREFUQShub3RlRWxlbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIG1lYW5pbmcgcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSAgbWVhbmluZyBtZWFuaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRNZWFuaW5nKG1lYW5pbmc6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBub3RlRWxlbSA9IHRoaXMuZmluZE5vdGVFbGVtZW50V2l0aEZyb21BdHRyaWJ1dGUoJ21lYW5pbmcnKTtcclxuICAgICAgICBpZiAobWVhbmluZykge1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobm90ZUVsZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaXRcclxuICAgICAgICAgICAgICAgIG5vdGVFbGVtID0gdGhpcy5jcmVhdGVOb3RlRWxlbWVudFdpdGhGcm9tQXR0cmlidXRlKCdtZWFuaW5nJywgbWVhbmluZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudChub3RlRWxlbSwgbWVhbmluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5vdGVFbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZSgnbWVhbmluZycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBub3RlcyBvZiB0aGUgdHJhbnMtdW5pdC5cclxuICAgICAqIE5vdGVzIGFyZSByZW1hcmtzIG1hZGUgYnkgYSB0cmFuc2xhdG9yLlxyXG4gICAgICogKGRlc2NyaXB0aW9uIGFuZCBtZWFuaW5nIGFyZSBub3QgaW5jbHVkZWQgaGVyZSEpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3RlcygpOiBJTm90ZVtdIHtcclxuICAgICAgICBjb25zdCBub3RlRWxlbWVtdHM6IEVsZW1lbnRbXSA9IHRoaXMuZmluZEFsbEFkZGl0aW9uYWxOb3RlRWxlbWVudHMoKTtcclxuICAgICAgICByZXR1cm4gbm90ZUVsZW1lbXRzLm1hcChlbGVtID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGZyb206IGVsZW0uZ2V0QXR0cmlidXRlKCdmcm9tJyksXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBET01VdGlsaXRpZXMuZ2V0UENEQVRBKGVsZW0pXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2Ygbm90ZXMgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXROb3RlcyB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1cHBvcnRzU2V0Tm90ZXMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgbm90ZXMgdG8gdHJhbnMgdW5pdC5cclxuICAgICAqIEBwYXJhbSBuZXdOb3RlcyB0aGUgbm90ZXMgdG8gYWRkLlxyXG4gICAgICogQHRocm93cyBhbiBFcnJvciBpZiBhbnkgbm90ZSBjb250YWlucyBkZXNjcmlwdGlvbiBvciBtZWFuaW5nIGFzIGZyb20gYXR0cmlidXRlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Tm90ZXMobmV3Tm90ZXM6IElOb3RlW10pIHtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5ld05vdGVzKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrTm90ZXMobmV3Tm90ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbW92ZUFsbEFkZGl0aW9uYWxOb3RlRWxlbWVudHMoKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5ld05vdGVzKSkge1xyXG4gICAgICAgICAgICBuZXdOb3Rlcy5mb3JFYWNoKChub3RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3RlRWxlbSA9IHRoaXMuY3JlYXRlTm90ZUVsZW1lbnRXaXRoRnJvbUF0dHJpYnV0ZShub3RlLmZyb20sIG5vdGUudGV4dCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdHJhbnNsYXRpb24gdG8gYSBnaXZlbiBzdHJpbmcgKGluY2x1ZGluZyBtYXJrdXApLlxyXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uIHRyYW5zbGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCB0cmFuc2xhdGVOYXRpdmUodHJhbnNsYXRpb246IHN0cmluZykge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICdzb3VyY2UnKTtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gRE9NVXRpbGl0aWVzLmNyZWF0ZUZvbGxvd2luZ1NpYmxpbmcoJ3RhcmdldCcsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERPTVV0aWxpdGllcy5yZXBsYWNlQ29udGVudFdpdGhYTUxDb250ZW50KHRhcmdldCwgPHN0cmluZz4gdHJhbnNsYXRpb24pO1xyXG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfVFJBTlNMQVRFRCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogUmV0dXJucyBhIGNoYW5nZWQgY29weSBvZiB0aGlzIHRyYW5zIHVuaXQuXHJcbiAgICAgKiByZWNlaXZlciBpcyBub3QgY2hhbmdlZC5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgY2FsbCBpbXBvcnROZXdUcmFuc1VuaXQgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbG9uZVdpdGhTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbiwgdGFyZ2V0RmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTogQWJzdHJhY3RUcmFuc1VuaXQge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSA8RWxlbWVudD4gdGhpcy5fZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgWGxpZmZUcmFuc1VuaXQoZWxlbWVudCwgdGhpcy5faWQsIHRhcmdldEZpbGUpO1xyXG4gICAgICAgIGNsb25lLnVzZVNvdXJjZUFzVGFyZ2V0KGlzRGVmYXVsdExhbmcsIGNvcHlDb250ZW50KTtcclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHNvdXJjZSB0byB0YXJnZXQgdG8gdXNlIGl0IGFzIGR1bW15IHRyYW5zbGF0aW9uLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcgb24gSVRyYW5zbGF0aW9uTWVzc2FnZUZpbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbikge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IERPTVV0aWxpdGllcy5nZXRGaXJzdEVsZW1lbnRCeVRhZ05hbWUodGhpcy5fZWxlbWVudCwgJ3NvdXJjZScpO1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBET01VdGlsaXRpZXMuZ2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lKHRoaXMuX2VsZW1lbnQsICd0YXJnZXQnKTtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBET01VdGlsaXRpZXMuY3JlYXRlRm9sbG93aW5nU2libGluZygndGFyZ2V0Jywgc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVmYXVsdExhbmcgfHwgY29weUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlU3RyaW5nID0gRE9NVXRpbGl0aWVzLmdldFhNTENvbnRlbnQoc291cmNlKTtcclxuICAgICAgICAgICAgbGV0IG5ld1RhcmdldFN0cmluZyA9IHNvdXJjZVN0cmluZztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSUNVTWVzc2FnZShzb3VyY2VTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRTdHJpbmcgPSB0aGlzLnRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKCkuZ2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCgpXHJcbiAgICAgICAgICAgICAgICAgICAgKyBzb3VyY2VTdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICArIHRoaXMudHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUoKS5nZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBET01VdGlsaXRpZXMucmVwbGFjZUNvbnRlbnRXaXRoWE1MQ29udGVudCh0YXJnZXQsIG5ld1RhcmdldFN0cmluZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgRE9NVXRpbGl0aWVzLnJlcGxhY2VDb250ZW50V2l0aFhNTENvbnRlbnQodGFyZ2V0LCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmF1bHRMYW5nKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ3N0YXRlJywgdGhpcy5tYXBTdGF0ZVRvTmF0aXZlU3RhdGUoU1RBVEVfRklOQUwpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHRoaXMubWFwU3RhdGVUb05hdGl2ZVN0YXRlKFNUQVRFX05FVykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=