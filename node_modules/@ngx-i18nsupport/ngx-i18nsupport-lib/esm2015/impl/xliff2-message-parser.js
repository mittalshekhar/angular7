/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { AbstractMessageParser } from './abstract-message-parser';
import { ParsedMessagePartType } from './parsed-message-part';
import { TagMapping } from './tag-mapping';
/**
 * Created by roobm on 10.05.2017.
 * A message parser for XLIFF 2.0
 */
export class Xliff2MessageParser extends AbstractMessageParser {
    /**
     * Handle this element node.
     * This is called before the children are done.
     * @param {?} elementNode elementNode
     * @param {?} message message to be altered
     * @return {?} true, if children should be processed too, false otherwise (children ignored then)
     */
    processStartElement(elementNode, message) {
        /** @type {?} */
        const tagName = elementNode.tagName;
        if (tagName === 'ph') {
            /** @type {?} */
            let isInterpolation = false;
            /** @type {?} */
            let isICU = false;
            /** @type {?} */
            let isEmptyTag = false;
            /** @type {?} */
            const equiv = elementNode.getAttribute('equiv');
            /** @type {?} */
            const disp = elementNode.getAttribute('disp');
            /** @type {?} */
            let indexString = null;
            /** @type {?} */
            let index = 0;
            /** @type {?} */
            let emptyTagName = null;
            if (!equiv) {
                // old ICU syntax, fixed with #17344
                isICU = true;
                indexString = elementNode.getAttribute('id');
                index = Number.parseInt(indexString, 10);
            }
            else if (equiv.startsWith('ICU')) {
                // new ICU syntax, fixed with #17344
                isICU = true;
                if (equiv === 'ICU') {
                    indexString = '0';
                }
                else {
                    indexString = equiv.substring('ICU_'.length);
                }
                index = Number.parseInt(indexString, 10);
            }
            else if (equiv.startsWith('INTERPOLATION')) {
                isInterpolation = true;
                if (equiv === 'INTERPOLATION') {
                    indexString = '0';
                }
                else {
                    indexString = equiv.substring('INTERPOLATION_'.length);
                }
                index = Number.parseInt(indexString, 10);
            }
            else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {
                isEmptyTag = true;
                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);
            }
            else {
                return true;
            }
            if (isInterpolation) {
                message.addPlaceholder(index, disp);
            }
            else if (isICU) {
                message.addICUMessageRef(index, disp);
            }
            else if (isEmptyTag) {
                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));
            }
        }
        else if (tagName === 'pc') {
            /** @type {?} */
            const embeddedTagName = this.tagNameFromPCElement(elementNode);
            if (embeddedTagName) {
                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));
            }
        }
        return true;
    }
    /**
     * Handle end of this element node.
     * This is called after all children are processed.
     * @param {?} elementNode elementNode
     * @param {?} message message to be altered
     * @return {?}
     */
    processEndElement(elementNode, message) {
        /** @type {?} */
        const tagName = elementNode.tagName;
        if (tagName === 'pc') {
            /** @type {?} */
            const embeddedTagName = this.tagNameFromPCElement(elementNode);
            if (embeddedTagName) {
                message.addEndTag(embeddedTagName);
            }
            return;
        }
    }
    /**
     * @param {?} pcNode
     * @return {?}
     */
    tagNameFromPCElement(pcNode) {
        /** @type {?} */
        let dispStart = pcNode.getAttribute('dispStart');
        if (dispStart.startsWith('<')) {
            dispStart = dispStart.substring(1);
        }
        if (dispStart.endsWith('>')) {
            dispStart = dispStart.substring(0, dispStart.length - 1);
        }
        return dispStart;
    }
    /**
     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.
     * So we cannot simply replace the message parts by xml parts.
     * @param {?} message message
     * @param {?} rootElem rootElem
     * @return {?}
     */
    addXmlRepresentationToRoot(message, rootElem) {
        /** @type {?} */
        const stack = [{ element: rootElem, tagName: 'root' }];
        /** @type {?} */
        let id = 0;
        message.parts().forEach((part) => {
            switch (part.type) {
                case ParsedMessagePartType.TEXT:
                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfTextPart(/** @type {?} */ (part), rootElem));
                    break;
                case ParsedMessagePartType.PLACEHOLDER:
                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfPlaceholderPart(/** @type {?} */ (part), rootElem, id++));
                    break;
                case ParsedMessagePartType.ICU_MESSAGE_REF:
                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfICUMessageRefPart(/** @type {?} */ (part), rootElem));
                    break;
                case ParsedMessagePartType.START_TAG:
                    /** @type {?} */
                    const newTagElem = this.createXmlRepresentationOfStartTagPart(/** @type {?} */ (part), rootElem, id++);
                    stack[stack.length - 1].element.appendChild(newTagElem);
                    stack.push({ element: /** @type {?} */ (newTagElem), tagName: (/** @type {?} */ (part)).tagName() });
                    break;
                case ParsedMessagePartType.END_TAG:
                    /** @type {?} */
                    const closeTagName = (/** @type {?} */ (part)).tagName();
                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {
                        // oops, not well formed
                        throw new Error('unexpected close tag ' + closeTagName);
                    }
                    stack.pop();
                    break;
                case ParsedMessagePartType.EMPTY_TAG:
                    /** @type {?} */
                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(/** @type {?} */ (part), rootElem, id++);
                    stack[stack.length - 1].element.appendChild(emptyTagElem);
                    break;
            }
        });
        if (stack.length !== 1) {
            // oops, not well closed tags
            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);
        }
    }
    /**
     * the xml used for start tag in the message.
     * Returns an empty pc-Element.
     * e.g. <pc id="0" equivStart="START_BOLD_TEXT" equivEnd="CLOSE_BOLD_TEXT" type="fmt" dispStart="&lt;b&gt;" dispEnd="&lt;/b&gt;">
     * Text content will be added later.
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @param {?} id id number in xliff2
     * @return {?}
     */
    createXmlRepresentationOfStartTagPart(part, rootElem, id) {
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const pcElem = rootElem.ownerDocument.createElement('pc');
        /** @type {?} */
        const tagName = part.tagName();
        /** @type {?} */
        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());
        /** @type {?} */
        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);
        /** @type {?} */
        const dispStart = '<' + tagName + '>';
        /** @type {?} */
        const dispEnd = '</' + tagName + '>';
        pcElem.setAttribute('id', id.toString(10));
        pcElem.setAttribute('equivStart', equivStart);
        pcElem.setAttribute('equivEnd', equivEnd);
        pcElem.setAttribute('type', this.getTypeForTag(tagName));
        pcElem.setAttribute('dispStart', dispStart);
        pcElem.setAttribute('dispEnd', dispEnd);
        return pcElem;
    }
    /**
     * the xml used for end tag in the message.
     * Not used here, because content is child of start tag.
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfEndTagPart(part, rootElem) {
        // not used
        return null;
    }
    /**
     * the xml used for empty tag in the message.
     * Returns an empty ph-Element.
     * e.g. <ph id="3" equiv="TAG_IMG" type="image" disp="&lt;img/>"/>
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @param {?} id id number in xliff2
     * @return {?}
     */
    createXmlRepresentationOfEmptyTagPart(part, rootElem, id) {
        /** @type {?} */
        const tagMapping = new TagMapping();
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        const tagName = part.tagName();
        /** @type {?} */
        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());
        /** @type {?} */
        const disp = '<' + tagName + '/>';
        phElem.setAttribute('id', id.toString(10));
        phElem.setAttribute('equiv', equiv);
        phElem.setAttribute('type', this.getTypeForTag(tagName));
        phElem.setAttribute('disp', disp);
        return phElem;
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    getTypeForTag(tag) {
        switch (tag.toLowerCase()) {
            case 'br':
            case 'b':
            case 'i':
            case 'u':
                return 'fmt';
            case 'img':
                return 'image';
            case 'a':
                return 'link';
            default:
                return 'other';
        }
    }
    /**
     * the xml used for placeholder in the message.
     * Returns e.g. <ph id="1" equiv="INTERPOLATION_1" disp="{{total()}}"/>
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @param {?} id id number in xliff2
     * @return {?}
     */
    createXmlRepresentationOfPlaceholderPart(part, rootElem, id) {
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        let equivAttrib = 'INTERPOLATION';
        if (part.index() > 0) {
            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);
        }
        phElem.setAttribute('id', id.toString(10));
        phElem.setAttribute('equiv', equivAttrib);
        /** @type {?} */
        const disp = part.disp();
        if (disp) {
            phElem.setAttribute('disp', disp);
        }
        return phElem;
    }
    /**
     * the xml used for icu message refs in the message.
     * @param {?} part part
     * @param {?} rootElem rootElem
     * @return {?}
     */
    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {
        /** @type {?} */
        const phElem = rootElem.ownerDocument.createElement('ph');
        /** @type {?} */
        let equivAttrib = 'ICU';
        if (part.index() > 0) {
            equivAttrib = 'ICU_' + part.index().toString(10);
        }
        phElem.setAttribute('id', part.index().toString(10));
        phElem.setAttribute('equiv', equivAttrib);
        /** @type {?} */
        const disp = part.disp();
        if (disp) {
            phElem.setAttribute('disp', disp);
        }
        return phElem;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxpZmYyLW1lc3NhZ2UtcGFyc2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliLyIsInNvdXJjZXMiOlsiaW1wbC94bGlmZjItbWVzc2FnZS1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBTWhFLE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQzVELE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7Ozs7O0FBT3pDLE1BQU0sMEJBQTJCLFNBQVEscUJBQXFCOzs7Ozs7OztJQVNoRCxtQkFBbUIsQ0FBQyxXQUFvQixFQUFFLE9BQXNCOztRQUN0RSxNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDO1FBQ3BDLElBQUksT0FBTyxLQUFLLElBQUksRUFBRTs7WUFZbEIsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDOztZQUM1QixJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7O1lBQ2xCLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQzs7WUFDdkIsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7WUFDaEQsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQzs7WUFDOUMsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDOztZQUN2QixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7O1lBQ2QsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxLQUFLLEVBQUU7O2dCQUVSLEtBQUssR0FBRyxJQUFJLENBQUM7Z0JBQ2IsV0FBVyxHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzdDLEtBQUssR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFD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Q0QsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDOztRQUMxQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDekIsSUFBSSxJQUFJLEVBQUU7WUFDTixNQUFNLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNyQztRQUNELE9BQU8sTUFBTSxDQUFDO0tBQ2pCO0NBRUoiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0Fic3RyYWN0TWVzc2FnZVBhcnNlcn0gZnJvbSAnLi9hYnN0cmFjdC1tZXNzYWdlLXBhcnNlcic7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZSc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRTdGFydFRhZ30gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXN0YXJ0LXRhZyc7XHJcbmltcG9ydCB7UGFyc2VkTWVzc2FnZVBhcnRFbmRUYWd9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1lbmQtdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtcGxhY2Vob2xkZXInO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0VGV4dH0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0LXRleHQnO1xyXG5pbXBvcnQge1BhcnNlZE1lc3NhZ2VQYXJ0VHlwZX0gZnJvbSAnLi9wYXJzZWQtbWVzc2FnZS1wYXJ0JztcclxuaW1wb3J0IHtUYWdNYXBwaW5nfSBmcm9tICcuL3RhZy1tYXBwaW5nJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydEVtcHR5VGFnfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQtZW1wdHktdGFnJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWZ9IGZyb20gJy4vcGFyc2VkLW1lc3NhZ2UtcGFydC1pY3UtbWVzc2FnZS1yZWYnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAxMC4wNS4yMDE3LlxyXG4gKiBBIG1lc3NhZ2UgcGFyc2VyIGZvciBYTElGRiAyLjBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBYbGlmZjJNZXNzYWdlUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlUGFyc2VyIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSB0aGlzIGVsZW1lbnQgbm9kZS5cclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgY2hpbGRyZW4gYXJlIGRvbmUuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudE5vZGUgZWxlbWVudE5vZGVcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2UgdG8gYmUgYWx0ZXJlZFxyXG4gICAgICogQHJldHVybiB0cnVlLCBpZiBjaGlsZHJlbiBzaG91bGQgYmUgcHJvY2Vzc2VkIHRvbywgZmFsc2Ugb3RoZXJ3aXNlIChjaGlsZHJlbiBpZ25vcmVkIHRoZW4pXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwcm9jZXNzU3RhcnRFbGVtZW50KGVsZW1lbnROb2RlOiBFbGVtZW50LCBtZXNzYWdlOiBQYXJzZWRNZXNzYWdlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnROb2RlLnRhZ05hbWU7XHJcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdwaCcpIHtcclxuICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYXJlIGxpa2UgPHBoIGlkPVwiMFwiIGVxdWl2PVwiSU5URVJQT0xBVElPTlwiIGRpc3A9XCJ7e251bWJlcigpfX1cIi8+XHJcbiAgICAgICAgICAgIC8vIFRoZXkgY29udGFpbiB0aGUgaWQgYW5kIGFsc28gYSBuYW1lIChudW1iZXIgaW4gdGhlIGV4YW1wbGUpXHJcbiAgICAgICAgICAgIC8vIFRPRE8gbWFrZSBzb21lIHVzZSBvZiB0aGUgbmFtZSAoYnV0IGl0IGlzIG5vdCBhdmFpbGFibGUgaW4gWExJRkYgMS4yKVxyXG4gICAgICAgICAgICAvLyBJQ1UgbWVzc2FnZSBhcmUgaGFuZGxlZCB3aXRoIHRoZSBzYW1lIHRhZ1xyXG4gICAgICAgICAgICAvLyBCZWZvcmUgNC4zLjIgdGhleSBkaWQgbm90IGhhdmUgYW4gZXF1aXYgYW5kIGRpc3AgKEJ1ZyAjMTczNDQpOlxyXG4gICAgICAgICAgICAvLyBlLmcuIDxwaCBpZD1cIjBcIi8+XHJcbiAgICAgICAgICAgIC8vIEJlZ2lubmluZyB3aXRoIDQuMy4yIHRoZXkgZG8gaGF2ZSBhbiBlcXVpdiBJQ1UgYW5kIGRpc3A6XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPHBoIGlkPVwiMFwiIGVxdWl2PVwiSUNVXCIgZGlzcD1cIntjb3VudCwgcGx1cmFsLCA9MCB7Li4ufSA9MSB7Li4ufSBvdGhlciB7Li4ufX1cIi8+XHJcbiAgICAgICAgICAgIC8vIGFuZCBlbXB0eSB0YWdzIGhhdmUgZXF1aXYgb3RoZXIgdGhlbiBJTlRFUlBPTEFUSU9OOlxyXG4gICAgICAgICAgICAvLyBlLmcuIDxwaCBpZD1cIjNcIiBlcXVpdj1cIlRBR19JTUdcIiB0eXBlPVwiaW1hZ2VcIiBkaXNwPVwiJmx0O2ltZy8+XCIvPlxyXG4gICAgICAgICAgICAvLyBvciA8cGggZXF1aXY9XCJMSU5FX0JSRUFLXCIgdHlwZT1cImxiXCIgZGlzcD1cIiZsdDtici8+XCIvPlxyXG4gICAgICAgICAgICBsZXQgaXNJbnRlcnBvbGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBpc0lDVSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgaXNFbXB0eVRhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBlcXVpdiA9IGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnZXF1aXYnKTtcclxuICAgICAgICAgICAgY29uc3QgZGlzcCA9IGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnZGlzcCcpO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXhTdHJpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBsZXQgZW1wdHlUYWdOYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFlcXVpdikge1xyXG4gICAgICAgICAgICAgICAgLy8gb2xkIElDVSBzeW50YXgsIGZpeGVkIHdpdGggIzE3MzQ0XHJcbiAgICAgICAgICAgICAgICBpc0lDVSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpbmRleFN0cmluZyA9IGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KGluZGV4U3RyaW5nLCAxMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXF1aXYuc3RhcnRzV2l0aCgnSUNVJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBJQ1Ugc3ludGF4LCBmaXhlZCB3aXRoICMxNzM0NFxyXG4gICAgICAgICAgICAgICAgaXNJQ1UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVxdWl2ID09PSAnSUNVJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4U3RyaW5nID0gJzAnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleFN0cmluZyA9IGVxdWl2LnN1YnN0cmluZygnSUNVXycubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KGluZGV4U3RyaW5nLCAxMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXF1aXYuc3RhcnRzV2l0aCgnSU5URVJQT0xBVElPTicpKSB7XHJcbiAgICAgICAgICAgICAgICBpc0ludGVycG9sYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVxdWl2ID09PSAnSU5URVJQT0xBVElPTicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleFN0cmluZyA9ICcwJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhTdHJpbmcgPSBlcXVpdi5zdWJzdHJpbmcoJ0lOVEVSUE9MQVRJT05fJy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBOdW1iZXIucGFyc2VJbnQoaW5kZXhTdHJpbmcsIDEwKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXcgVGFnTWFwcGluZygpLmlzRW1wdHlUYWdQbGFjZWhvbGRlck5hbWUoZXF1aXYpKSB7XHJcbiAgICAgICAgICAgICAgICBpc0VtcHR5VGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGVtcHR5VGFnTmFtZSA9IG5ldyBUYWdNYXBwaW5nKCkuZ2V0VGFnbmFtZUZyb21FbXB0eVRhZ1BsYWNlaG9sZGVyTmFtZShlcXVpdik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZFBsYWNlaG9sZGVyKGluZGV4LCBkaXNwKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0lDVSkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRJQ1VNZXNzYWdlUmVmKGluZGV4LCBkaXNwKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0VtcHR5VGFnKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZEVtcHR5VGFnKGVtcHR5VGFnTmFtZSwgdGhpcy5wYXJzZUlkQ291bnRGcm9tTmFtZShlcXVpdikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAncGMnKSB7XHJcbiAgICAgICAgICAgIC8vIHBjIGV4YW1wbGU6IDxwYyBpZD1cIjBcIiBlcXVpdlN0YXJ0PVwiU1RBUlRfQk9MRF9URVhUXCIgZXF1aXZFbmQ9XCJDTE9TRV9CT0xEX1RFWFRcIiB0eXBlPVwiZm10XCJcclxuICAgICAgICAgICAgLy8gZGlzcFN0YXJ0PVwiJmx0O2ImZ3Q7XCIgZGlzcEVuZD1cIiZsdDsvYiZndDtcIj5JTVBPUlRBTlQ8L3BjPlxyXG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFRhZ05hbWUgPSB0aGlzLnRhZ05hbWVGcm9tUENFbGVtZW50KGVsZW1lbnROb2RlKTtcclxuICAgICAgICAgICAgaWYgKGVtYmVkZGVkVGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRTdGFydFRhZyhlbWJlZGRlZFRhZ05hbWUsIHRoaXMucGFyc2VJZENvdW50RnJvbU5hbWUoZWxlbWVudE5vZGUuZ2V0QXR0cmlidXRlKCdlcXVpdlN0YXJ0JykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBlbmQgb2YgdGhpcyBlbGVtZW50IG5vZGUuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciBhbGwgY2hpbGRyZW4gYXJlIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50Tm9kZSBlbGVtZW50Tm9kZVxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZSB0byBiZSBhbHRlcmVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwcm9jZXNzRW5kRWxlbWVudChlbGVtZW50Tm9kZTogRWxlbWVudCwgbWVzc2FnZTogUGFyc2VkTWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50Tm9kZS50YWdOYW1lO1xyXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAncGMnKSB7XHJcbiAgICAgICAgICAgIC8vIHBjIGV4YW1wbGU6IDxwYyBpZD1cIjBcIiBlcXVpdlN0YXJ0PVwiU1RBUlRfQk9MRF9URVhUXCIgZXF1aXZFbmQ9XCJDTE9TRV9CT0xEX1RFWFRcIiB0eXBlPVwiZm10XCJcclxuICAgICAgICAgICAgLy8gZGlzcFN0YXJ0PVwiJmx0O2ImZ3Q7XCIgZGlzcEVuZD1cIiZsdDsvYiZndDtcIj5JTVBPUlRBTlQ8L3BjPlxyXG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFRhZ05hbWUgPSB0aGlzLnRhZ05hbWVGcm9tUENFbGVtZW50KGVsZW1lbnROb2RlKTtcclxuICAgICAgICAgICAgaWYgKGVtYmVkZGVkVGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRFbmRUYWcoZW1iZWRkZWRUYWdOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFnTmFtZUZyb21QQ0VsZW1lbnQocGNOb2RlOiBFbGVtZW50KTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgZGlzcFN0YXJ0ID0gcGNOb2RlLmdldEF0dHJpYnV0ZSgnZGlzcFN0YXJ0Jyk7XHJcbiAgICAgICAgaWYgKGRpc3BTdGFydC5zdGFydHNXaXRoKCc8JykpIHtcclxuICAgICAgICAgICAgZGlzcFN0YXJ0ID0gZGlzcFN0YXJ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3BTdGFydC5lbmRzV2l0aCgnPicpKSB7XHJcbiAgICAgICAgICAgIGRpc3BTdGFydCA9IGRpc3BTdGFydC5zdWJzdHJpbmcoMCwgZGlzcFN0YXJ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlzcFN0YXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVpbXBsZW1lbnRlZCBoZXJlLCBiZWNhdXNlIFhMSUZGIDIuMCB1c2VzIGEgZGVlcGVyIHhtbCBtb2RlbC5cclxuICAgICAqIFNvIHdlIGNhbm5vdCBzaW1wbHkgcmVwbGFjZSB0aGUgbWVzc2FnZSBwYXJ0cyBieSB4bWwgcGFydHMuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBtZXNzYWdlXHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFkZFhtbFJlcHJlc2VudGF0aW9uVG9Sb290KG1lc3NhZ2U6IFBhcnNlZE1lc3NhZ2UsIHJvb3RFbGVtOiBFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbe2VsZW1lbnQ6IHJvb3RFbGVtLCB0YWdOYW1lOiAncm9vdCd9XTtcclxuICAgICAgICBsZXQgaWQgPSAwO1xyXG4gICAgICAgIG1lc3NhZ2UucGFydHMoKS5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5URVhUOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmVsZW1lbnQuYXBwZW5kQ2hpbGQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlRleHRQYXJ0KDxQYXJzZWRNZXNzYWdlUGFydFRleHQ+IHBhcnQsIHJvb3RFbGVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5QTEFDRUhPTERFUjpcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5lbGVtZW50LmFwcGVuZENoaWxkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZQbGFjZWhvbGRlclBhcnQoPFBhcnNlZE1lc3NhZ2VQYXJ0UGxhY2Vob2xkZXI+IHBhcnQsIHJvb3RFbGVtLCBpZCsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnNlZE1lc3NhZ2VQYXJ0VHlwZS5JQ1VfTUVTU0FHRV9SRUY6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uZWxlbWVudC5hcHBlbmRDaGlsZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mSUNVTWVzc2FnZVJlZlBhcnQoPFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZVJlZj4gcGFydCwgcm9vdEVsZW0pKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLlNUQVJUX1RBRzpcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUYWdFbGVtID0gdGhpcy5jcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mU3RhcnRUYWdQYXJ0KDxQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnPiBwYXJ0LCByb290RWxlbSwgaWQrKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uZWxlbWVudC5hcHBlbmRDaGlsZChuZXdUYWdFbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHtlbGVtZW50OiA8RWxlbWVudD4gbmV3VGFnRWxlbSwgdGFnTmFtZTogKDxQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnPiBwYXJ0KS50YWdOYW1lKCl9KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUGFyc2VkTWVzc2FnZVBhcnRUeXBlLkVORF9UQUc6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvc2VUYWdOYW1lID0gKDxQYXJzZWRNZXNzYWdlUGFydEVuZFRhZz4gcGFydCkudGFnTmFtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPD0gMSB8fCBzdGFja1tzdGFjay5sZW5ndGggLSAxXS50YWdOYW1lICE9PSBjbG9zZVRhZ05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb29wcywgbm90IHdlbGwgZm9ybWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBjbG9zZSB0YWcgJyArIGNsb3NlVGFnTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQYXJzZWRNZXNzYWdlUGFydFR5cGUuRU1QVFlfVEFHOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5VGFnRWxlbSA9IHRoaXMuY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZkVtcHR5VGFnUGFydCg8UGFyc2VkTWVzc2FnZVBhcnRFbXB0eVRhZz4gcGFydCwgcm9vdEVsZW0sIGlkKyspO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZW1wdHlUYWdFbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgLy8gb29wcywgbm90IHdlbGwgY2xvc2VkIHRhZ3NcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNsb3NlIHRhZyAnICsgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0udGFnTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIHhtbCB1c2VkIGZvciBzdGFydCB0YWcgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IHBjLUVsZW1lbnQuXHJcbiAgICAgKiBlLmcuIDxwYyBpZD1cIjBcIiBlcXVpdlN0YXJ0PVwiU1RBUlRfQk9MRF9URVhUXCIgZXF1aXZFbmQ9XCJDTE9TRV9CT0xEX1RFWFRcIiB0eXBlPVwiZm10XCIgZGlzcFN0YXJ0PVwiJmx0O2ImZ3Q7XCIgZGlzcEVuZD1cIiZsdDsvYiZndDtcIj5cclxuICAgICAqIFRleHQgY29udGVudCB3aWxsIGJlIGFkZGVkIGxhdGVyLlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKiBAcGFyYW0gaWQgaWQgbnVtYmVyIGluIHhsaWZmMlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlN0YXJ0VGFnUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFN0YXJ0VGFnLCByb290RWxlbTogRWxlbWVudCwgaWQ6IG51bWJlcik6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHRhZ01hcHBpbmcgPSBuZXcgVGFnTWFwcGluZygpO1xyXG4gICAgICAgIGNvbnN0IHBjRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGMnKTtcclxuICAgICAgICBjb25zdCB0YWdOYW1lID0gcGFydC50YWdOYW1lKCk7XHJcbiAgICAgICAgY29uc3QgZXF1aXZTdGFydCA9IHRhZ01hcHBpbmcuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUodGFnTmFtZSwgcGFydC5pZENvdW50ZXIoKSk7XHJcbiAgICAgICAgY29uc3QgZXF1aXZFbmQgPSB0YWdNYXBwaW5nLmdldENsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKHRhZ05hbWUpO1xyXG4gICAgICAgIGNvbnN0IGRpc3BTdGFydCA9ICc8JyArIHRhZ05hbWUgKyAnPic7XHJcbiAgICAgICAgY29uc3QgZGlzcEVuZCA9ICc8LycgKyB0YWdOYW1lICsgJz4nO1xyXG4gICAgICAgIHBjRWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQudG9TdHJpbmcoMTApKTtcclxuICAgICAgICBwY0VsZW0uc2V0QXR0cmlidXRlKCdlcXVpdlN0YXJ0JywgZXF1aXZTdGFydCk7XHJcbiAgICAgICAgcGNFbGVtLnNldEF0dHJpYnV0ZSgnZXF1aXZFbmQnLCBlcXVpdkVuZCk7XHJcbiAgICAgICAgcGNFbGVtLnNldEF0dHJpYnV0ZSgndHlwZScsIHRoaXMuZ2V0VHlwZUZvclRhZyh0YWdOYW1lKSk7XHJcbiAgICAgICAgcGNFbGVtLnNldEF0dHJpYnV0ZSgnZGlzcFN0YXJ0JywgZGlzcFN0YXJ0KTtcclxuICAgICAgICBwY0VsZW0uc2V0QXR0cmlidXRlKCdkaXNwRW5kJywgZGlzcEVuZCk7XHJcbiAgICAgICAgcmV0dXJuIHBjRWxlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgZW5kIHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIE5vdCB1c2VkIGhlcmUsIGJlY2F1c2UgY29udGVudCBpcyBjaGlsZCBvZiBzdGFydCB0YWcuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZFbmRUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0RW5kVGFnLCByb290RWxlbTogRWxlbWVudCk6IE5vZGUge1xyXG4gICAgICAgIC8vIG5vdCB1c2VkXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGVtcHR5IHRhZyBpbiB0aGUgbWVzc2FnZS5cclxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgcGgtRWxlbWVudC5cclxuICAgICAqIGUuZy4gPHBoIGlkPVwiM1wiIGVxdWl2PVwiVEFHX0lNR1wiIHR5cGU9XCJpbWFnZVwiIGRpc3A9XCImbHQ7aW1nLz5cIi8+XHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqIEBwYXJhbSBpZCBpZCBudW1iZXIgaW4geGxpZmYyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVYbWxSZXByZXNlbnRhdGlvbk9mRW1wdHlUYWdQYXJ0KHBhcnQ6IFBhcnNlZE1lc3NhZ2VQYXJ0RW1wdHlUYWcsIHJvb3RFbGVtOiBFbGVtZW50LCBpZDogbnVtYmVyKTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgdGFnTWFwcGluZyA9IG5ldyBUYWdNYXBwaW5nKCk7XHJcbiAgICAgICAgY29uc3QgcGhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwaCcpO1xyXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBwYXJ0LnRhZ05hbWUoKTtcclxuICAgICAgICBjb25zdCBlcXVpdiA9IHRhZ01hcHBpbmcuZ2V0RW1wdHlUYWdQbGFjZWhvbGRlck5hbWUodGFnTmFtZSwgcGFydC5pZENvdW50ZXIoKSk7XHJcbiAgICAgICAgY29uc3QgZGlzcCA9ICc8JyArIHRhZ05hbWUgKyAnLz4nO1xyXG4gICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQudG9TdHJpbmcoMTApKTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdlcXVpdicsIGVxdWl2KTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCd0eXBlJywgdGhpcy5nZXRUeXBlRm9yVGFnKHRhZ05hbWUpKTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdkaXNwJywgZGlzcCk7XHJcbiAgICAgICAgcmV0dXJuIHBoRWxlbTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFR5cGVGb3JUYWcodGFnOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSAnYnInOlxyXG4gICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgY2FzZSAnaSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3UnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbXQnO1xyXG4gICAgICAgICAgICBjYXNlICdpbWcnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XHJcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnb3RoZXInO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSB4bWwgdXNlZCBmb3IgcGxhY2Vob2xkZXIgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBSZXR1cm5zIGUuZy4gPHBoIGlkPVwiMVwiIGVxdWl2PVwiSU5URVJQT0xBVElPTl8xXCIgZGlzcD1cInt7dG90YWwoKX19XCIvPlxyXG4gICAgICogQHBhcmFtIHBhcnQgcGFydFxyXG4gICAgICogQHBhcmFtIHJvb3RFbGVtIHJvb3RFbGVtXHJcbiAgICAgKiBAcGFyYW0gaWQgaWQgbnVtYmVyIGluIHhsaWZmMlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlWG1sUmVwcmVzZW50YXRpb25PZlBsYWNlaG9sZGVyUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydFBsYWNlaG9sZGVyLCByb290RWxlbTogRWxlbWVudCwgaWQ6IG51bWJlcik6IE5vZGUge1xyXG4gICAgICAgIGNvbnN0IHBoRWxlbSA9IHJvb3RFbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGgnKTtcclxuICAgICAgICBsZXQgZXF1aXZBdHRyaWIgPSAnSU5URVJQT0xBVElPTic7XHJcbiAgICAgICAgaWYgKHBhcnQuaW5kZXgoKSA+IDApIHtcclxuICAgICAgICAgICAgZXF1aXZBdHRyaWIgPSAnSU5URVJQT0xBVElPTl8nICsgcGFydC5pbmRleCgpLnRvU3RyaW5nKDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCBpZC50b1N0cmluZygxMCkpO1xyXG4gICAgICAgIHBoRWxlbS5zZXRBdHRyaWJ1dGUoJ2VxdWl2JywgZXF1aXZBdHRyaWIpO1xyXG4gICAgICAgIGNvbnN0IGRpc3AgPSBwYXJ0LmRpc3AoKTtcclxuICAgICAgICBpZiAoZGlzcCkge1xyXG4gICAgICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdkaXNwJywgZGlzcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwaEVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgeG1sIHVzZWQgZm9yIGljdSBtZXNzYWdlIHJlZnMgaW4gdGhlIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBwYXJ0XHJcbiAgICAgKiBAcGFyYW0gcm9vdEVsZW0gcm9vdEVsZW1cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVhtbFJlcHJlc2VudGF0aW9uT2ZJQ1VNZXNzYWdlUmVmUGFydChwYXJ0OiBQYXJzZWRNZXNzYWdlUGFydElDVU1lc3NhZ2VSZWYsIHJvb3RFbGVtOiBFbGVtZW50KTogTm9kZSB7XHJcbiAgICAgICAgY29uc3QgcGhFbGVtID0gcm9vdEVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwaCcpO1xyXG4gICAgICAgIGxldCBlcXVpdkF0dHJpYiA9ICdJQ1UnO1xyXG4gICAgICAgIGlmIChwYXJ0LmluZGV4KCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGVxdWl2QXR0cmliID0gJ0lDVV8nICsgcGFydC5pbmRleCgpLnRvU3RyaW5nKDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCBwYXJ0LmluZGV4KCkudG9TdHJpbmcoMTApKTtcclxuICAgICAgICBwaEVsZW0uc2V0QXR0cmlidXRlKCdlcXVpdicsIGVxdWl2QXR0cmliKTtcclxuICAgICAgICBjb25zdCBkaXNwID0gcGFydC5kaXNwKCk7XHJcbiAgICAgICAgaWYgKGRpc3ApIHtcclxuICAgICAgICAgICAgcGhFbGVtLnNldEF0dHJpYnV0ZSgnZGlzcCcsIGRpc3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGhFbGVtO1xyXG4gICAgfVxyXG5cclxufVxyXG4iXX0=