/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { ParsedMessagePart, ParsedMessagePartType } from './parsed-message-part';
import { COMMA, CURLY_BRACE_CLOSE, CURLY_BRACE_OPEN, ICUMessageTokenizer, PLURAL, SELECT, TEXT } from './icu-message-tokenizer';
import { ICUMessage } from './icu-message';
import { format } from 'util';
/**
 * Created by martin on 02.06.2017.
 * A message part consisting of an icu message.
 * There can only be one icu message in a parsed message.
 * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'
 */
export class ParsedMessagePartICUMessage extends ParsedMessagePart {
    /**
     * @param {?} icuMessageText
     * @param {?} _parser
     */
    constructor(icuMessageText, _parser) {
        super(ParsedMessagePartType.ICU_MESSAGE);
        this._parser = _parser;
        if (icuMessageText) {
            this.parseICUMessage(icuMessageText);
        }
    }
    /**
     * Test wether text might be an ICU message.
     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'
     * @param {?} icuMessageText icuMessageText
     * @return {?} wether text might be an ICU message.
     */
    static looksLikeICUMessage(icuMessageText) {
        /** @type {?} */
        const part = new ParsedMessagePartICUMessage(null, null);
        return part.looksLikeICUMessage(icuMessageText);
    }
    /**
     * @param {?=} displayFormat
     * @return {?}
     */
    asDisplayString(displayFormat) {
        return '<ICU-Message/>';
    }
    /**
     * return the parsed message.
     * @return {?} parsed message
     */
    getICUMessage() {
        return this._message;
    }
    /**
     * Parse the message.
     * @throws an error if the syntax is not ok in any way.
     * @param {?} text message text to parse
     * @return {?}
     */
    parseICUMessage(text) {
        // console.log('message ', text);
        // const tokens = new ICUMessageTokenizer().tokenize(text);
        // tokens.forEach((tok) => {
        //     console.log('Token', tok.type, tok.value);
        // });
        this._messageText = text;
        this._tokenizer = new ICUMessageTokenizer();
        this._tokenizer.input(text);
        this.expectNext(CURLY_BRACE_OPEN);
        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT
        this.expectNext(COMMA);
        /** @type {?} */
        let token = this._tokenizer.next();
        if (token.type === PLURAL) {
            this._message = new ICUMessage(this._parser, true);
        }
        else if (token.type === SELECT) {
            this._message = new ICUMessage(this._parser, false);
        }
        this.expectNext(COMMA);
        token = this._tokenizer.peek();
        while (token.type !== CURLY_BRACE_CLOSE) {
            /** @type {?} */
            const category = this.expectNext(TEXT).value.trim();
            this.expectNext(CURLY_BRACE_OPEN);
            /** @type {?} */
            const message = this.expectNext(TEXT).value;
            this._message.addCategory(category, this.parseNativeSubMessage(message));
            this.expectNext(CURLY_BRACE_CLOSE);
            token = this._tokenizer.peek();
        }
        this.expectNext(CURLY_BRACE_CLOSE);
        this.expectNext('EOF');
    }
    /**
     * Parse the message to check, wether it might be an ICU message.
     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'
     * @param {?} text message text to parse
     * @return {?}
     */
    looksLikeICUMessage(text) {
        // console.log('message ', text);
        // const tokens = new ICUMessageTokenizer().tokenize(text);
        // tokens.forEach((tok) => {
        //     console.log('Token', tok.type, tok.value);
        // });
        this._tokenizer = new ICUMessageTokenizer();
        this._tokenizer.input(text);
        try {
            this.expectNext(CURLY_BRACE_OPEN);
            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT
            this.expectNext(COMMA);
            /** @type {?} */
            const token = this._tokenizer.next();
            if (token.type !== PLURAL && token.type !== SELECT) {
                return false;
            }
            this.expectNext(COMMA);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Read next token and expect, that it is of the given type.
     * @throws error, if next token has wrong type.
     * @param {?} tokentype expected type.
     * @return {?} Token
     */
    expectNext(tokentype) {
        /** @type {?} */
        const token = this._tokenizer.next();
        if (token.type !== tokentype) {
            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)', tokentype, token.type, token.value, this._messageText));
        }
        return token;
    }
    /**
     * Parse XML text to normalized message.
     * @param {?} message message in format dependent xml syntax.
     * @return {?} normalized message
     */
    parseNativeSubMessage(message) {
        return this._parser.createNormalizedMessageFromXMLString(message, null);
    }
}
if (false) {
    /** @type {?} */
    ParsedMessagePartICUMessage.prototype._message;
    /** @type {?} */
    ParsedMessagePartICUMessage.prototype._messageText;
    /** @type {?} */
    ParsedMessagePartICUMessage.prototype._tokenizer;
    /** @type {?} */
    ParsedMessagePartICUMessage.prototype._parser;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VkLW1lc3NhZ2UtcGFydC1pY3UtbWVzc2FnZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi8iLCJzb3VyY2VzIjpbImltcGwvcGFyc2VkLW1lc3NhZ2UtcGFydC1pY3UtbWVzc2FnZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLGlCQUFpQixFQUFFLHFCQUFxQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFL0UsT0FBTyxFQUNILEtBQUssRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxtQkFBbUIsRUFBWSxNQUFNLEVBQUUsTUFBTSxFQUN6RixJQUFJLEVBQ1AsTUFBTSx5QkFBeUIsQ0FBQztBQUNqQyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxNQUFNLENBQUM7Ozs7Ozs7QUFVNUIsTUFBTSxrQ0FBbUMsU0FBUSxpQkFBaUI7Ozs7O0lBTTlELFlBQVksY0FBc0IsRUFBVSxPQUF1QjtRQUMvRCxLQUFLLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFERCxZQUFPLEdBQVAsT0FBTyxDQUFnQjtRQUUvRCxJQUFJLGNBQWMsRUFBRTtZQUNoQixJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQ3hDO0tBQ0o7Ozs7Ozs7SUFRRCxNQUFNLENBQUMsbUJBQW1CLENBQUMsY0FBc0I7O1FBQzdDLE1BQU0sSUFBSSxHQUFHLElBQUksMkJBQTJCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3pELE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQ25EOzs7OztJQUVNLGVBQWUsQ0FBQyxhQUFzQjtRQUN6QyxPQUFPLGdCQUFnQixDQUFDOzs7Ozs7SUFPckIsYUFBYTtRQUNoQixPQUFPLElBQUksQ0FBQyxRQUFR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Q0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyQyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLG9FQUFvRSxFQUN2RixTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1NBQy9EO1FBQ0QsT0FBTyxLQUFLLENBQUM7Ozs7Ozs7SUFRVCxxQkFBcUIsQ0FBQyxPQUFlO1FBQ3pDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxvQ0FBb0MsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7O0NBRS9FIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtQYXJzZWRNZXNzYWdlUGFydCwgUGFyc2VkTWVzc2FnZVBhcnRUeXBlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlLXBhcnQnO1xyXG5pbXBvcnQge0lJQ1VNZXNzYWdlLCBJTm9ybWFsaXplZE1lc3NhZ2V9IGZyb20gJy4uL2FwaS9pbmRleCc7XHJcbmltcG9ydCB7XHJcbiAgICBDT01NQSwgQ1VSTFlfQlJBQ0VfQ0xPU0UsIENVUkxZX0JSQUNFX09QRU4sIElDVU1lc3NhZ2VUb2tlbml6ZXIsIElDVVRva2VuLCBQTFVSQUwsIFNFTEVDVCxcclxuICAgIFRFWFRcclxufSBmcm9tICcuL2ljdS1tZXNzYWdlLXRva2VuaXplcic7XHJcbmltcG9ydCB7SUNVTWVzc2FnZX0gZnJvbSAnLi9pY3UtbWVzc2FnZSc7XHJcbmltcG9ydCB7Zm9ybWF0fSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtJTWVzc2FnZVBhcnNlcn0gZnJvbSAnLi9pLW1lc3NhZ2UtcGFyc2VyJztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwMi4wNi4yMDE3LlxyXG4gKiBBIG1lc3NhZ2UgcGFydCBjb25zaXN0aW5nIG9mIGFuIGljdSBtZXNzYWdlLlxyXG4gKiBUaGVyZSBjYW4gb25seSBiZSBvbmUgaWN1IG1lc3NhZ2UgaW4gYSBwYXJzZWQgbWVzc2FnZS5cclxuICogU3ludGF4IG9mIElDVSBtZXNzYWdlIGlzICd7JyA8a2V5bmFtZT4gJywnICdzZWxlY3QnfCdwbHVyYWwnICcsJyAoPGNhdGVnb3J5PiAneycgdGV4dCAnfScpKyAnfSdcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgUGFyc2VkTWVzc2FnZVBhcnRJQ1VNZXNzYWdlIGV4dGVuZHMgUGFyc2VkTWVzc2FnZVBhcnQge1xyXG5cclxuICAgIHByaXZhdGUgX21lc3NhZ2U6IElDVU1lc3NhZ2U7XHJcbiAgICBwcml2YXRlIF9tZXNzYWdlVGV4dDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfdG9rZW5pemVyOiBJQ1VNZXNzYWdlVG9rZW5pemVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGljdU1lc3NhZ2VUZXh0OiBzdHJpbmcsIHByaXZhdGUgX3BhcnNlcjogSU1lc3NhZ2VQYXJzZXIpIHtcclxuICAgICAgICBzdXBlcihQYXJzZWRNZXNzYWdlUGFydFR5cGUuSUNVX01FU1NBR0UpO1xyXG4gICAgICAgIGlmIChpY3VNZXNzYWdlVGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlSUNVTWVzc2FnZShpY3VNZXNzYWdlVGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCB3ZXRoZXIgdGV4dCBtaWdodCBiZSBhbiBJQ1UgbWVzc2FnZS5cclxuICAgICAqIFNob3VsZCBhdCBsZWFzdCBzdGFydCB3aXRoIHNvbWV0aGluZyBsaWtlICd7PG5hbWU+LCBzZWxlY3QsIC4uJyBvciAnezxuYW1lPiwgcGx1cmFsLCAuLi4nXHJcbiAgICAgKiBAcGFyYW0gaWN1TWVzc2FnZVRleHQgaWN1TWVzc2FnZVRleHRcclxuICAgICAqIEByZXR1cm4gd2V0aGVyIHRleHQgbWlnaHQgYmUgYW4gSUNVIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBsb29rc0xpa2VJQ1VNZXNzYWdlKGljdU1lc3NhZ2VUZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBwYXJ0ID0gbmV3IFBhcnNlZE1lc3NhZ2VQYXJ0SUNVTWVzc2FnZShudWxsLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gcGFydC5sb29rc0xpa2VJQ1VNZXNzYWdlKGljdU1lc3NhZ2VUZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXNEaXNwbGF5U3RyaW5nKGRpc3BsYXlGb3JtYXQ/OiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gJzxJQ1UtTWVzc2FnZS8+JztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiB0aGUgcGFyc2VkIG1lc3NhZ2UuXHJcbiAgICAgKiBAcmV0dXJuIHBhcnNlZCBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRJQ1VNZXNzYWdlKCk6IElJQ1VNZXNzYWdlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIHRoZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHRleHQgbWVzc2FnZSB0ZXh0IHRvIHBhcnNlXHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzeW50YXggaXMgbm90IG9rIGluIGFueSB3YXkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGFyc2VJQ1VNZXNzYWdlKHRleHQ6IHN0cmluZykge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdtZXNzYWdlICcsIHRleHQpO1xyXG4gICAgICAgIC8vIGNvbnN0IHRva2VucyA9IG5ldyBJQ1VNZXNzYWdlVG9rZW5pemVyKCkudG9rZW5pemUodGV4dCk7XHJcbiAgICAgICAgLy8gdG9rZW5zLmZvckVhY2goKHRvaykgPT4ge1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZygnVG9rZW4nLCB0b2sudHlwZSwgdG9rLnZhbHVlKTtcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICB0aGlzLl9tZXNzYWdlVGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5fdG9rZW5pemVyID0gbmV3IElDVU1lc3NhZ2VUb2tlbml6ZXIoKTtcclxuICAgICAgICB0aGlzLl90b2tlbml6ZXIuaW5wdXQodGV4dCk7XHJcbiAgICAgICAgdGhpcy5leHBlY3ROZXh0KENVUkxZX0JSQUNFX09QRU4pO1xyXG4gICAgICAgIHRoaXMuZXhwZWN0TmV4dChURVhUKTsgLy8gdmFybmFtZSwgbm90IHVzZWQgY3VycmVudGx5LCBuZyBhbHdheXMgdXNlZCBWQVJfUExVUkFMIG9yIFZBUl9TRUxFQ1RcclxuICAgICAgICB0aGlzLmV4cGVjdE5leHQoQ09NTUEpO1xyXG4gICAgICAgIGxldCB0b2tlbjogSUNVVG9rZW4gPSB0aGlzLl90b2tlbml6ZXIubmV4dCgpO1xyXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBQTFVSQUwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZSA9IG5ldyBJQ1VNZXNzYWdlKHRoaXMuX3BhcnNlciwgdHJ1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBTRUxFQ1QpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZSA9IG5ldyBJQ1VNZXNzYWdlKHRoaXMuX3BhcnNlciwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV4cGVjdE5leHQoQ09NTUEpO1xyXG4gICAgICAgIHRva2VuID0gdGhpcy5fdG9rZW5pemVyLnBlZWsoKTtcclxuICAgICAgICB3aGlsZSAodG9rZW4udHlwZSAhPT0gQ1VSTFlfQlJBQ0VfQ0xPU0UpIHtcclxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLmV4cGVjdE5leHQoVEVYVCkudmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdE5leHQoQ1VSTFlfQlJBQ0VfT1BFTik7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmV4cGVjdE5leHQoVEVYVCkudmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2UuYWRkQ2F0ZWdvcnkoY2F0ZWdvcnksIHRoaXMucGFyc2VOYXRpdmVTdWJNZXNzYWdlKG1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgdGhpcy5leHBlY3ROZXh0KENVUkxZX0JSQUNFX0NMT1NFKTtcclxuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl90b2tlbml6ZXIucGVlaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV4cGVjdE5leHQoQ1VSTFlfQlJBQ0VfQ0xPU0UpO1xyXG4gICAgICAgIHRoaXMuZXhwZWN0TmV4dCgnRU9GJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSB0aGUgbWVzc2FnZSB0byBjaGVjaywgd2V0aGVyIGl0IG1pZ2h0IGJlIGFuIElDVSBtZXNzYWdlLlxyXG4gICAgICogU2hvdWxkIGF0IGxlYXN0IHN0YXJ0IHdpdGggc29tZXRoaW5nIGxpa2UgJ3s8bmFtZT4sIHNlbGVjdCwgLi4nIG9yICd7PG5hbWU+LCBwbHVyYWwsIC4uLidcclxuICAgICAqIEBwYXJhbSB0ZXh0IG1lc3NhZ2UgdGV4dCB0byBwYXJzZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvb2tzTGlrZUlDVU1lc3NhZ2UodGV4dDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ21lc3NhZ2UgJywgdGV4dCk7XHJcbiAgICAgICAgLy8gY29uc3QgdG9rZW5zID0gbmV3IElDVU1lc3NhZ2VUb2tlbml6ZXIoKS50b2tlbml6ZSh0ZXh0KTtcclxuICAgICAgICAvLyB0b2tlbnMuZm9yRWFjaCgodG9rKSA9PiB7XHJcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdUb2tlbicsIHRvay50eXBlLCB0b2sudmFsdWUpO1xyXG4gICAgICAgIC8vIH0pO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuaXplciA9IG5ldyBJQ1VNZXNzYWdlVG9rZW5pemVyKCk7XHJcbiAgICAgICAgdGhpcy5fdG9rZW5pemVyLmlucHV0KHRleHQpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0TmV4dChDVVJMWV9CUkFDRV9PUEVOKTtcclxuICAgICAgICAgICAgdGhpcy5leHBlY3ROZXh0KFRFWFQpOyAvLyB2YXJuYW1lLCBub3QgdXNlZCBjdXJyZW50bHksIG5nIGFsd2F5cyB1c2VkIFZBUl9QTFVSQUwgb3IgVkFSX1NFTEVDVFxyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdE5leHQoQ09NTUEpO1xyXG4gICAgICAgICAgICBjb25zdCB0b2tlbjogSUNVVG9rZW4gPSB0aGlzLl90b2tlbml6ZXIubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gUExVUkFMICYmIHRva2VuLnR5cGUgIT09IFNFTEVDVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0TmV4dChDT01NQSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIG5leHQgdG9rZW4gYW5kIGV4cGVjdCwgdGhhdCBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS5cclxuICAgICAqIEBwYXJhbSB0b2tlbnR5cGUgZXhwZWN0ZWQgdHlwZS5cclxuICAgICAqIEByZXR1cm4gVG9rZW5cclxuICAgICAqIEB0aHJvd3MgZXJyb3IsIGlmIG5leHQgdG9rZW4gaGFzIHdyb25nIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZXhwZWN0TmV4dCh0b2tlbnR5cGU6IHN0cmluZyk6IElDVVRva2VuIHtcclxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuX3Rva2VuaXplci5uZXh0KCk7XHJcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IHRva2VudHlwZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdFcnJvciBwYXJzaW5nIElDVSBNZXNzYWdlOiBleHBlY3RlZCAlcywgZm91bmQgJXMgKCVzKSAobWVzc2FnZSAlcyknLFxyXG4gICAgICAgICAgICAgICAgdG9rZW50eXBlLCB0b2tlbi50eXBlLCB0b2tlbi52YWx1ZSwgdGhpcy5fbWVzc2FnZVRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgWE1MIHRleHQgdG8gbm9ybWFsaXplZCBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZSBpbiBmb3JtYXQgZGVwZW5kZW50IHhtbCBzeW50YXguXHJcbiAgICAgKiBAcmV0dXJuIG5vcm1hbGl6ZWQgbWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcnNlTmF0aXZlU3ViTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBJTm9ybWFsaXplZE1lc3NhZ2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZXIuY3JlYXRlTm9ybWFsaXplZE1lc3NhZ2VGcm9tWE1MU3RyaW5nKG1lc3NhZ2UsIG51bGwpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==