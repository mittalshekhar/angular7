/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { XliffFile } from '../impl/xliff-file';
import { XmbFile } from '../impl/xmb-file';
import { format } from 'util';
import { Xliff2File } from '../impl/xliff2-file';
import { FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB } from './constants';
import { XtbFile } from '../impl/xtb-file';
/**
 * Helper class to read translation files depending on format.
 * This is part of the public api
 */
var /**
 * Helper class to read translation files depending on format.
 * This is part of the public api
 */
TranslationMessagesFileFactory = /** @class */ (function () {
    function TranslationMessagesFileFactory() {
    }
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    TranslationMessagesFileFactory.fromFileContent = /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    function (i18nFormat, xmlContent, path, encoding, optionalMaster) {
        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);
    };
    /**
     * Read file function for any file with unknown format.
     * This functions tries to guess the format based on the filename and the content of the file.
     * Result depends on detected format, either XliffFile or XmbFile.
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    TranslationMessagesFileFactory.fromUnknownFormatFileContent = /**
     * Read file function for any file with unknown format.
     * This functions tries to guess the format based on the filename and the content of the file.
     * Result depends on detected format, either XliffFile or XmbFile.
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    function (xmlContent, path, encoding, optionalMaster) {
        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);
    };
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
     * @param xmlContent the file content
     * @param path the path of the file (only used to remember it)
     * @param encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return either XliffFile or XmbFile
     */
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    TranslationMessagesFileFactory.prototype.createFileFromFileContent = /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    function (i18nFormat, xmlContent, path, encoding, optionalMaster) {
        if (i18nFormat === FORMAT_XLIFF12) {
            return new XliffFile(xmlContent, path, encoding);
        }
        if (i18nFormat === FORMAT_XLIFF20) {
            return new Xliff2File(xmlContent, path, encoding);
        }
        if (i18nFormat === FORMAT_XMB) {
            return new XmbFile(this, xmlContent, path, encoding);
        }
        if (i18nFormat === FORMAT_XTB) {
            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);
        }
        throw new Error(format('oops, unsupported format "%s"', i18nFormat));
    };
    /**
     * Read file function for any file with unknown format.
     * This functions tries to guess the format based on the filename and the content of the file.
     * Result depends on detected format, either XliffFile or XmbFile.
     * @param xmlContent the file content
     * @param path the path of the file (only used to remember it)
     * @param encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return either XliffFile or XmbFile
     */
    /**
     * Read file function for any file with unknown format.
     * This functions tries to guess the format based on the filename and the content of the file.
     * Result depends on detected format, either XliffFile or XmbFile.
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    TranslationMessagesFileFactory.prototype.createFileFromUnknownFormatFileContent = /**
     * Read file function for any file with unknown format.
     * This functions tries to guess the format based on the filename and the content of the file.
     * Result depends on detected format, either XliffFile or XmbFile.
     * @param {?} xmlContent the file content
     * @param {?} path the path of the file (only used to remember it)
     * @param {?} encoding utf-8, ... used to parse XML.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @param {?=} optionalMaster in case of xmb the master file, that contains the original texts.
     * (this is used to support state infos, that are based on comparing original with translated version)
     * Ignored for other formats.
     * @return {?} either XliffFile or XmbFile
     */
    function (xmlContent, path, encoding, optionalMaster) {
        /** @type {?} */
        var formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];
        if (path && path.endsWith('xmb')) {
            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];
        }
        if (path && path.endsWith('xtb')) {
            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];
        }
        // try all candidate formats to get the right one
        for (var i = 0; i < formatCandidates.length; i++) {
            /** @type {?} */
            var formatCandidate = formatCandidates[i];
            try {
                /** @type {?} */
                var translationFile = TranslationMessagesFileFactory.fromFileContent(formatCandidate, xmlContent, path, encoding, optionalMaster);
                if (translationFile) {
                    return translationFile;
                }
            }
            catch (e) {
                // seams to be the wrong format
            }
        }
        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));
    };
    return TranslationMessagesFileFactory;
}());
/**
 * Helper class to read translation files depending on format.
 * This is part of the public api
 */
export { TranslationMessagesFileFactory };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZS1mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliLyIsInNvdXJjZXMiOlsiYXBpL3RyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUtZmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBSUEsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBQzdDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUN6QyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzVCLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUMvQyxPQUFPLEVBQUMsY0FBYyxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQ25GLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQzs7Ozs7QUFPekM7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0lBY2tCLDhDQUFlOzs7Ozs7Ozs7Ozs7Y0FBQyxVQUFrQixFQUNsQixVQUFrQixFQUNsQixJQUFZLEVBQ1osUUFBZ0IsRUFDaEIsY0FBcUU7UUFDL0YsT0FBTyxJQUFJLDhCQUE4QixFQUFFLENBQUMseUJBQXlCLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLGNBQWMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7SUFnQnBILDJEQUE0Qjs7Ozs7Ozs7Ozs7OztjQUFDLFVBQWtCLEVBQy9CLElBQVksRUFDWixRQUFnQixFQUNoQixjQUFxRTtRQUMvRixPQUFPLElBQUksOEJBQThCLEVBQUUsQ0FBQyxzQ0FBc0MsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxjQUFjLENBQUMsQ0FBQzs7SUFHbkk7Ozs7Ozs7Ozs7O09BV0c7Ozs7Ozs7Ozs7Ozs7SUFDSCxrRUFBeUI7Ozs7Ozs7Ozs7OztJQUF6QixVQUEwQixVQUFrQixFQUNsQixVQUFrQixFQUNsQixJQUFZLEVBQ1osUUFBZ0IsRUFDaEIsY0FBdUU7UUFDN0YsSUFBSSxVQUFVLEtBQUssY0FBYyxFQUFFO1lBQy9CLE9BQU8sSUFBSSxTQUFTLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztTQUNwRDtRQUNELElBQUksVUFBVSxLQUFLLGNBQWMsRUFBRTtZQUMvQixPQUFPLElBQUksVUFBVSxDQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDckQ7UUFDRCxJQUFJLFVBQVUsS0FBSyxVQUFVLEVBQUU7WUFDM0IsT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztTQUN4RDtRQUNELElBQUksVUFBVSxLQUFLLFVBQVUsRUFBRTtZQUMzQixPQUFPLElBQUksT0FBTyxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUN4RTtRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLCtCQUErQixFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7S0FFeEU7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7Ozs7Ozs7Ozs7Ozs7O0lBQ0gsK0VBQXNDOzs7Ozs7Ozs7Ozs7O0lBQXRDLFVBQXVDLFVBQWtCLEVBQ2xCLElBQVksRUFDWixRQUFnQixFQUNoQixjQUF1RTs7UUFFMUcsSUFBSSxnQkFBZ0IsR0FBRyxDQUFDLGNBQWMsRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ2hGLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDOUIsZ0JBQWdCLEdBQUcsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUMvRTtRQUNELElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDOUIsZ0JBQWdCLEdBQUcsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUMvRTs7UUFFRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFOztZQUM5QyxJQUFNLGVBQWUsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJOztnQkFDQSxJQUFNLGVBQWUsR0FBRyw4QkFBOEIsQ0FBQyxlQUFlLENBQ2xFLGVBQWUsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxjQUFjLENBQUMsQ0FBQztnQkFDakUsSUFBSSxlQUFlLEVBQUU7b0JBQ2pCLE9BQU8sZUFBZSxDQUFDO2lCQUMxQjthQUNKO1lBQUMsT0FBTyxDQUFDLEVBQUU7O2FBRVg7U0FDSjtRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLDZFQUE2RSxDQUFDLENBQUMsQ0FBQztLQUMxRzt5Q0FsSUw7SUFvSUMsQ0FBQTs7Ozs7QUFwSEQsMENBb0hDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMjEuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlfSBmcm9tICcuL2ktdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7WGxpZmZGaWxlfSBmcm9tICcuLi9pbXBsL3hsaWZmLWZpbGUnO1xyXG5pbXBvcnQge1htYkZpbGV9IGZyb20gJy4uL2ltcGwveG1iLWZpbGUnO1xyXG5pbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7WGxpZmYyRmlsZX0gZnJvbSAnLi4vaW1wbC94bGlmZjItZmlsZSc7XHJcbmltcG9ydCB7Rk9STUFUX1hMSUZGMTIsIEZPUk1BVF9YTElGRjIwLCBGT1JNQVRfWE1CLCBGT1JNQVRfWFRCfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7WHRiRmlsZX0gZnJvbSAnLi4vaW1wbC94dGItZmlsZSc7XHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeX0gZnJvbSAnLi9pLXRyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUtZmFjdG9yeSc7XHJcblxyXG4vKipcclxuICogSGVscGVyIGNsYXNzIHRvIHJlYWQgdHJhbnNsYXRpb24gZmlsZXMgZGVwZW5kaW5nIG9uIGZvcm1hdC5cclxuICogVGhpcyBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgYXBpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5IGltcGxlbWVudHMgSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGZpbGUgZnVuY3Rpb24sIHJlc3VsdCBkZXBlbmRzIG9uIGZvcm1hdCwgZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlLlxyXG4gICAgICogQHBhcmFtIGkxOG5Gb3JtYXQgY3VycmVudGx5ICd4bGYnIG9yICd4bGYyJyBvciAneG1iJyBvciAneHRiJyBhcmUgc3VwcG9ydGVkXHJcbiAgICAgKiBAcGFyYW0geG1sQ29udGVudCB0aGUgZmlsZSBjb250ZW50XHJcbiAgICAgKiBAcGFyYW0gcGF0aCB0aGUgcGF0aCBvZiB0aGUgZmlsZSAob25seSB1c2VkIHRvIHJlbWVtYmVyIGl0KVxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHV0Zi04LCAuLi4gdXNlZCB0byBwYXJzZSBYTUwuXHJcbiAgICAgKiBUaGlzIGlzIHJlYWQgZnJvbSB0aGUgZmlsZSwgYnV0IGlmIHlvdSBrbm93IGl0IGJlZm9yZSwgeW91IGNhbiBhdm9pZCByZWFkaW5nIHRoZSBmaWxlIHR3aWNlLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbmFsTWFzdGVyIGluIGNhc2Ugb2YgeG1iIHRoZSBtYXN0ZXIgZmlsZSwgdGhhdCBjb250YWlucyB0aGUgb3JpZ2luYWwgdGV4dHMuXHJcbiAgICAgKiAodGhpcyBpcyB1c2VkIHRvIHN1cHBvcnQgc3RhdGUgaW5mb3MsIHRoYXQgYXJlIGJhc2VkIG9uIGNvbXBhcmluZyBvcmlnaW5hbCB3aXRoIHRyYW5zbGF0ZWQgdmVyc2lvbilcclxuICAgICAqIElnbm9yZWQgZm9yIG90aGVyIGZvcm1hdHMuXHJcbiAgICAgKiBAcmV0dXJuIGVpdGhlciBYbGlmZkZpbGUgb3IgWG1iRmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZyb21GaWxlQ29udGVudChpMThuRm9ybWF0OiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWxDb250ZW50OiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXI/OiB7eG1sQ29udGVudDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmd9KTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeSgpLmNyZWF0ZUZpbGVGcm9tRmlsZUNvbnRlbnQoaTE4bkZvcm1hdCwgeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgZmlsZSBmdW5jdGlvbiBmb3IgYW55IGZpbGUgd2l0aCB1bmtub3duIGZvcm1hdC5cclxuICAgICAqIFRoaXMgZnVuY3Rpb25zIHRyaWVzIHRvIGd1ZXNzIHRoZSBmb3JtYXQgYmFzZWQgb24gdGhlIGZpbGVuYW1lIGFuZCB0aGUgY29udGVudCBvZiB0aGUgZmlsZS5cclxuICAgICAqIFJlc3VsdCBkZXBlbmRzIG9uIGRldGVjdGVkIGZvcm1hdCwgZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlLlxyXG4gICAgICogQHBhcmFtIHhtbENvbnRlbnQgdGhlIGZpbGUgY29udGVudFxyXG4gICAgICogQHBhcmFtIHBhdGggdGhlIHBhdGggb2YgdGhlIGZpbGUgKG9ubHkgdXNlZCB0byByZW1lbWJlciBpdClcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB1dGYtOCwgLi4uIHVzZWQgdG8gcGFyc2UgWE1MLlxyXG4gICAgICogVGhpcyBpcyByZWFkIGZyb20gdGhlIGZpbGUsIGJ1dCBpZiB5b3Uga25vdyBpdCBiZWZvcmUsIHlvdSBjYW4gYXZvaWQgcmVhZGluZyB0aGUgZmlsZSB0d2ljZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25hbE1hc3RlciBpbiBjYXNlIG9mIHhtYiB0aGUgbWFzdGVyIGZpbGUsIHRoYXQgY29udGFpbnMgdGhlIG9yaWdpbmFsIHRleHRzLlxyXG4gICAgICogKHRoaXMgaXMgdXNlZCB0byBzdXBwb3J0IHN0YXRlIGluZm9zLCB0aGF0IGFyZSBiYXNlZCBvbiBjb21wYXJpbmcgb3JpZ2luYWwgd2l0aCB0cmFuc2xhdGVkIHZlcnNpb24pXHJcbiAgICAgKiBJZ25vcmVkIGZvciBvdGhlciBmb3JtYXRzLlxyXG4gICAgICogQHJldHVybiBlaXRoZXIgWGxpZmZGaWxlIG9yIFhtYkZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmcm9tVW5rbm93bkZvcm1hdEZpbGVDb250ZW50KHhtbENvbnRlbnQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3Rlcj86IHt4bWxDb250ZW50OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZ30pOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5KCkuY3JlYXRlRmlsZUZyb21Vbmtub3duRm9ybWF0RmlsZUNvbnRlbnQoeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgZmlsZSBmdW5jdGlvbiwgcmVzdWx0IGRlcGVuZHMgb24gZm9ybWF0LCBlaXRoZXIgWGxpZmZGaWxlIG9yIFhtYkZpbGUuXHJcbiAgICAgKiBAcGFyYW0gaTE4bkZvcm1hdCBjdXJyZW50bHkgJ3hsZicgb3IgJ3hsZjInIG9yICd4bWInIG9yICd4dGInIGFyZSBzdXBwb3J0ZWRcclxuICAgICAqIEBwYXJhbSB4bWxDb250ZW50IHRoZSBmaWxlIGNvbnRlbnRcclxuICAgICAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBmaWxlIChvbmx5IHVzZWQgdG8gcmVtZW1iZXIgaXQpXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgdXRmLTgsIC4uLiB1c2VkIHRvIHBhcnNlIFhNTC5cclxuICAgICAqIFRoaXMgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLCBidXQgaWYgeW91IGtub3cgaXQgYmVmb3JlLCB5b3UgY2FuIGF2b2lkIHJlYWRpbmcgdGhlIGZpbGUgdHdpY2UuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXIgaW4gY2FzZSBvZiB4bWIgdGhlIG1hc3RlciBmaWxlLCB0aGF0IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCB0ZXh0cy5cclxuICAgICAqICh0aGlzIGlzIHVzZWQgdG8gc3VwcG9ydCBzdGF0ZSBpbmZvcywgdGhhdCBhcmUgYmFzZWQgb24gY29tcGFyaW5nIG9yaWdpbmFsIHdpdGggdHJhbnNsYXRlZCB2ZXJzaW9uKVxyXG4gICAgICogSWdub3JlZCBmb3Igb3RoZXIgZm9ybWF0cy5cclxuICAgICAqIEByZXR1cm4gZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUZpbGVGcm9tRmlsZUNvbnRlbnQoaTE4bkZvcm1hdDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWxDb250ZW50OiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXI/OiB7IHhtbENvbnRlbnQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nIH0pOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIGlmIChpMThuRm9ybWF0ID09PSBGT1JNQVRfWExJRkYxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmRmlsZSh4bWxDb250ZW50LCBwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpMThuRm9ybWF0ID09PSBGT1JNQVRfWExJRkYyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmMkZpbGUoeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaTE4bkZvcm1hdCA9PT0gRk9STUFUX1hNQikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhtYkZpbGUodGhpcywgeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaTE4bkZvcm1hdCA9PT0gRk9STUFUX1hUQikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFh0YkZpbGUodGhpcywgeG1sQ29udGVudCwgcGF0aCwgZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnb29wcywgdW5zdXBwb3J0ZWQgZm9ybWF0IFwiJXNcIicsIGkxOG5Gb3JtYXQpKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGZpbGUgZnVuY3Rpb24gZm9yIGFueSBmaWxlIHdpdGggdW5rbm93biBmb3JtYXQuXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9ucyB0cmllcyB0byBndWVzcyB0aGUgZm9ybWF0IGJhc2VkIG9uIHRoZSBmaWxlbmFtZSBhbmQgdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGUuXHJcbiAgICAgKiBSZXN1bHQgZGVwZW5kcyBvbiBkZXRlY3RlZCBmb3JtYXQsIGVpdGhlciBYbGlmZkZpbGUgb3IgWG1iRmlsZS5cclxuICAgICAqIEBwYXJhbSB4bWxDb250ZW50IHRoZSBmaWxlIGNvbnRlbnRcclxuICAgICAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBmaWxlIChvbmx5IHVzZWQgdG8gcmVtZW1iZXIgaXQpXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgdXRmLTgsIC4uLiB1c2VkIHRvIHBhcnNlIFhNTC5cclxuICAgICAqIFRoaXMgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLCBidXQgaWYgeW91IGtub3cgaXQgYmVmb3JlLCB5b3UgY2FuIGF2b2lkIHJlYWRpbmcgdGhlIGZpbGUgdHdpY2UuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXIgaW4gY2FzZSBvZiB4bWIgdGhlIG1hc3RlciBmaWxlLCB0aGF0IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCB0ZXh0cy5cclxuICAgICAqICh0aGlzIGlzIHVzZWQgdG8gc3VwcG9ydCBzdGF0ZSBpbmZvcywgdGhhdCBhcmUgYmFzZWQgb24gY29tcGFyaW5nIG9yaWdpbmFsIHdpdGggdHJhbnNsYXRlZCB2ZXJzaW9uKVxyXG4gICAgICogSWdub3JlZCBmb3Igb3RoZXIgZm9ybWF0cy5cclxuICAgICAqIEByZXR1cm4gZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUZpbGVGcm9tVW5rbm93bkZvcm1hdEZpbGVDb250ZW50KHhtbENvbnRlbnQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3Rlcj86IHsgeG1sQ29udGVudDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcgfSlcclxuICAgICAgICA6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgbGV0IGZvcm1hdENhbmRpZGF0ZXMgPSBbRk9STUFUX1hMSUZGMTIsIEZPUk1BVF9YTElGRjIwLCBGT1JNQVRfWE1CLCBGT1JNQVRfWFRCXTtcclxuICAgICAgICBpZiAocGF0aCAmJiBwYXRoLmVuZHNXaXRoKCd4bWInKSkge1xyXG4gICAgICAgICAgICBmb3JtYXRDYW5kaWRhdGVzID0gW0ZPUk1BVF9YTUIsIEZPUk1BVF9YVEIsIEZPUk1BVF9YTElGRjEyLCBGT1JNQVRfWExJRkYyMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRoICYmIHBhdGguZW5kc1dpdGgoJ3h0YicpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdENhbmRpZGF0ZXMgPSBbRk9STUFUX1hUQiwgRk9STUFUX1hNQiwgRk9STUFUX1hMSUZGMTIsIEZPUk1BVF9YTElGRjIwXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHJ5IGFsbCBjYW5kaWRhdGUgZm9ybWF0cyB0byBnZXQgdGhlIHJpZ2h0IG9uZVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0Q2FuZGlkYXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXRDYW5kaWRhdGUgPSBmb3JtYXRDYW5kaWRhdGVzW2ldO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRpb25GaWxlID0gVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5LmZyb21GaWxlQ29udGVudChcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRDYW5kaWRhdGUsIHhtbENvbnRlbnQsIHBhdGgsIGVuY29kaW5nLCBvcHRpb25hbE1hc3Rlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb25GaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uRmlsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2VhbXMgdG8gYmUgdGhlIHdyb25nIGZvcm1hdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ2NvdWxkIG5vdCBpZGVudGlmeSBmaWxlIGZvcm1hdCwgaXQgaXMgbmVpdGVyIFhMSUZGICgxLjIgb3IgMi4wKSBub3IgWE1CL1hUQicpKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbiJdfQ==