/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { STATE_TRANSLATED } from './internalapi';
import { AbstractTranslationMessagesFile } from './abstract-translation-messages-file';
import { isNullOrUndefined, isString } from 'util';
/**
 * Created by roobm on 10.05.2017.
 * Abstract superclass for all implementations of ITransUnit.
 * @abstract
 */
var /**
 * Created by roobm on 10.05.2017.
 * Abstract superclass for all implementations of ITransUnit.
 * @abstract
 */
AbstractTransUnit = /** @class */ (function () {
    function AbstractTransUnit(_element, _id, _translationMessagesFile) {
        this._element = _element;
        this._id = _id;
        this._translationMessagesFile = _translationMessagesFile;
    }
    Object.defineProperty(AbstractTransUnit.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * The file the unit belongs to.,
     */
    /**
     * The file the unit belongs to.,
     * @return {?}
     */
    AbstractTransUnit.prototype.translationMessagesFile = /**
     * The file the unit belongs to.,
     * @return {?}
     */
    function () {
        return this._translationMessagesFile;
    };
    /**
     * Test, wether setting of source content is supported.
     * If not, setSourceContent in trans-unit will do nothing.
     * xtb does not support this, all other formats do.
     */
    /**
     * Test, wether setting of source content is supported.
     * If not, setSourceContent in trans-unit will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    AbstractTransUnit.prototype.supportsSetSourceContent = /**
     * Test, wether setting of source content is supported.
     * If not, setSourceContent in trans-unit will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    function () {
        return true;
    };
    /**
     * The original text value, that is to be translated, as normalized message.
     * @return {?}
     */
    AbstractTransUnit.prototype.sourceContentNormalized = /**
     * The original text value, that is to be translated, as normalized message.
     * @return {?}
     */
    function () {
        if (isNullOrUndefined(this._sourceContentNormalized)) {
            this._sourceContentNormalized = this.createSourceContentNormalized();
        }
        return this._sourceContentNormalized;
    };
    /**
     * State of the translation.
     * (on of new, translated, final)
     * Return values are defined as Constants STATE_...
     * @return {?}
     */
    AbstractTransUnit.prototype.targetState = /**
     * State of the translation.
     * (on of new, translated, final)
     * Return values are defined as Constants STATE_...
     * @return {?}
     */
    function () {
        /** @type {?} */
        var nativeState = this.nativeTargetState();
        return this.mapNativeStateToState(nativeState);
    };
    /**
     * Modify the target state.
     * @param newState one of the 3 allowed target states new, translated, final.
     * Constants STATE_...
     * Invalid states throw an error.
     */
    /**
     * Modify the target state.
     * @param {?} newState one of the 3 allowed target states new, translated, final.
     * Constants STATE_...
     * Invalid states throw an error.
     * @return {?}
     */
    AbstractTransUnit.prototype.setTargetState = /**
     * Modify the target state.
     * @param {?} newState one of the 3 allowed target states new, translated, final.
     * Constants STATE_...
     * Invalid states throw an error.
     * @return {?}
     */
    function (newState) {
        this.setNativeTargetState(this.mapStateToNativeState(newState));
        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {
            (/** @type {?} */ (this.translationMessagesFile())).countNumbers();
        }
    };
    /**
     * Test, wether setting of source refs is supported.
     * If not, setSourceReferences will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    AbstractTransUnit.prototype.supportsSetSourceReferences = /**
     * Test, wether setting of source refs is supported.
     * If not, setSourceReferences will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    function () {
        return true;
    };
    /**
     * Test, wether setting of description and meaning is supported.
     * If not, setDescription and setMeaning will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    AbstractTransUnit.prototype.supportsSetDescriptionAndMeaning = /**
     * Test, wether setting of description and meaning is supported.
     * If not, setDescription and setMeaning will do nothing.
     * xtb does not support this, all other formats do.
     * @return {?}
     */
    function () {
        return true;
    };
    /**
     * Check notes
     * @param newNotes the notes to add.
     * @throws an Error if any note contains description or meaning as from attribute.
     */
    /**
     * Check notes
     * @throws an Error if any note contains description or meaning as from attribute.
     * @param {?} newNotes the notes to add.
     * @return {?}
     */
    AbstractTransUnit.prototype.checkNotes = /**
     * Check notes
     * @throws an Error if any note contains description or meaning as from attribute.
     * @param {?} newNotes the notes to add.
     * @return {?}
     */
    function (newNotes) {
        /** @type {?} */
        var errorInFromNote = newNotes.find(function (note) { return note.from === 'description' || note.from === 'meaning'; });
        if (!isNullOrUndefined(errorInFromNote)) {
            throw new Error('description or meaning are not allowed as from atttribute');
        }
    };
    /**
     * The real xml element used for the trans unit.
     * (internal usage only, a client should never need this)
     * @return {?} real xml element used for the trans unit.
     */
    AbstractTransUnit.prototype.asXmlElement = /**
     * The real xml element used for the trans unit.
     * (internal usage only, a client should never need this)
     * @return {?} real xml element used for the trans unit.
     */
    function () {
        return this._element;
    };
    /**
     * Translate the trans unit.
     * @param {?} translation the translated string or (preferred) a normalized message.
     * The pure string can contain any markup and will not be checked.
     * So it can damage the document.
     * A normalized message prevents this.
     * @return {?}
     */
    AbstractTransUnit.prototype.translate = /**
     * Translate the trans unit.
     * @param {?} translation the translated string or (preferred) a normalized message.
     * The pure string can contain any markup and will not be checked.
     * So it can damage the document.
     * A normalized message prevents this.
     * @return {?}
     */
    function (translation) {
        /** @type {?} */
        var translationNative;
        if (isString(translation)) {
            translationNative = /** @type {?} */ (translation);
        }
        else {
            translationNative = (/** @type {?} */ (translation)).asNativeString();
        }
        this.translateNative(translationNative);
        this.setTargetState(STATE_TRANSLATED);
    };
    /**
     * Test, wether message looks like ICU message.
     * @param {?} message message
     * @return {?} wether message looks like ICU message.
     */
    AbstractTransUnit.prototype.isICUMessage = /**
     * Test, wether message looks like ICU message.
     * @param {?} message message
     * @return {?} wether message looks like ICU message.
     */
    function (message) {
        return this.messageParser().isICUMessageStart(message);
    };
    return AbstractTransUnit;
}());
/**
 * Created by roobm on 10.05.2017.
 * Abstract superclass for all implementations of ITransUnit.
 * @abstract
 */
export { AbstractTransUnit };
if (false) {
    /** @type {?} */
    AbstractTransUnit.prototype._sourceContentNormalized;
    /** @type {?} */
    AbstractTransUnit.prototype._element;
    /** @type {?} */
    AbstractTransUnit.prototype._id;
    /** @type {?} */
    AbstractTransUnit.prototype._translationMessagesFile;
    /**
     * The original text value, that is to be translated.
     * Contains all markup, depends on the concrete format used.
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.sourceContent = function () { };
    /**
     * Set new source content in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing changed source content.
     * @abstract
     * @param {?} newContent the new content.
     * @return {?}
     */
    AbstractTransUnit.prototype.setSourceContent = function (newContent) { };
    /**
     * The original text value, that is to be translated, as normalized message.
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.createSourceContentNormalized = function () { };
    /**
     * The translated value.
     * Contains all markup, depends on the concrete format used.
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.targetContent = function () { };
    /**
     * The translated value as normalized message.
     * All placeholders are replaced with {{n}} (starting at 0)
     * and all embedded html is replaced by direct html markup.
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.targetContentNormalized = function () { };
    /**
     * State of the translation as stored in the xml.
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.nativeTargetState = function () { };
    /**
     * Map an abstract state (new, translated, final) to a concrete state used in the xml.
     * Returns the state to be used in the xml.
     * @throws error, if state is invalid.
     * @abstract
     * @param {?} state one of Constants.STATE...
     * @return {?} a native state (depends on concrete format)
     */
    AbstractTransUnit.prototype.mapStateToNativeState = function (state) { };
    /**
     * Map a native state (found in the document) to an abstract state (new, translated, final).
     * Returns the abstract state.
     * @abstract
     * @param {?} nativeState nativeState
     * @return {?}
     */
    AbstractTransUnit.prototype.mapNativeStateToState = function (nativeState) { };
    /**
     * set state in xml.
     * @abstract
     * @param {?} nativeState nativeState
     * @return {?}
     */
    AbstractTransUnit.prototype.setNativeTargetState = function (nativeState) { };
    /**
     * All the source elements in the trans unit.
     * The source element is a reference to the original template.
     * It contains the name of the template file and a line number with the position inside the template.
     * It is just a help for translators to find the context for the translation.
     * This is set when using Angular 4.0 or greater.
     * Otherwise it just returns an empty array.
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.sourceReferences = function () { };
    /**
     * Set source ref elements in the transunit.
     * Normally, this is done by ng-extract.
     * Method only exists to allow xliffmerge to merge missing source refs.
     * @abstract
     * @param {?} sourceRefs the sourcerefs to set. Old ones are removed.
     * @return {?}
     */
    AbstractTransUnit.prototype.setSourceReferences = function (sourceRefs) { };
    /**
     * The description set in the template as value of the i18n-attribute.
     * e.g. i18n="mydescription".
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.description = function () { };
    /**
     * The meaning (intent) set in the template as value of the i18n-attribute.
     * This is the part in front of the | symbol.
     * e.g. i18n="meaning|mydescription".
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.meaning = function () { };
    /**
     * Change description property of trans-unit.
     * @abstract
     * @param {?} description description
     * @return {?}
     */
    AbstractTransUnit.prototype.setDescription = function (description) { };
    /**
     * Change meaning property of trans-unit.
     * @abstract
     * @param {?} meaning meaning
     * @return {?}
     */
    AbstractTransUnit.prototype.setMeaning = function (meaning) { };
    /**
     * Get all notes of the trans-unit.
     * Notes are remarks made by a translator.
     * (description and meaning are not included here!)
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.notes = function () { };
    /**
     * Test, wether setting of notes is supported.
     * If not, setNotes will do nothing.
     * xtb does not support this, all other formats do.
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.supportsSetNotes = function () { };
    /**
     * Add notes to trans unit.
     * @throws an Error if any note contains descpription or meaning as from attribute.
     * @abstract
     * @param {?} newNotes the notes to add.
     * @return {?}
     */
    AbstractTransUnit.prototype.setNotes = function (newNotes) { };
    /**
     * Copy source to target to use it as dummy translation.
     * Returns a changed copy of this trans unit.
     * receiver is not changed.
     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)
     * @abstract
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @param {?} targetFile
     * @return {?}
     */
    AbstractTransUnit.prototype.cloneWithSourceAsTarget = function (isDefaultLang, copyContent, targetFile) { };
    /**
     * Copy source to target to use it as dummy translation.
     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)
     * @abstract
     * @param {?} isDefaultLang
     * @param {?} copyContent
     * @return {?}
     */
    AbstractTransUnit.prototype.useSourceAsTarget = function (isDefaultLang, copyContent) { };
    /**
     * Return a parser used for normalized messages.
     * @abstract
     * @return {?}
     */
    AbstractTransUnit.prototype.messageParser = function () { };
    /**
     * Set the translation to a given string (including markup).
     * @abstract
     * @param {?} translation translation
     * @return {?}
     */
    AbstractTransUnit.prototype.translateNative = function (translation) { };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3QtdHJhbnMtdW5pdC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYi8iLCJzb3VyY2VzIjpbImltcGwvYWJzdHJhY3QtdHJhbnMtdW5pdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLGdCQUFnQixFQUFrRSxNQUFNLGVBQWUsQ0FBQztBQUNoSCxPQUFPLEVBQUMsK0JBQStCLEVBQUMsTUFBTSxzQ0FBc0MsQ0FBQztBQUNyRixPQUFPLEVBQUMsaUJBQWlCLEVBQUUsUUFBUSxFQUFDLE1BQU0sTUFBTSxDQUFDOzs7Ozs7QUFRakQ7Ozs7O0FBQUE7SUFJSSwyQkFBZ0MsUUFBaUIsRUFDakIsR0FBVyxFQUNYLHdCQUFrRDtRQUZsRCxhQUFRLEdBQVIsUUFBUSxDQUFTO1FBQ2pCLFFBQUcsR0FBSCxHQUFHLENBQVE7UUFDWCw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQTBCO0tBQ2pGOzBCQUVVLGlDQUFFOzs7OztZQUNULE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQzs7Ozs7SUFHcEI7O09BRUc7Ozs7O0lBQ0gsbURBQXVCOzs7O0lBQXZCO1FBQ0ksT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUM7S0FDeEM7SUFRRDs7OztPQUlHOzs7Ozs7O0lBQ0gsb0RBQXdCOzs7Ozs7SUFBeEI7UUFDSSxPQUFPLElBQUksQ0FBQztLQUNmOzs7OztJQWFNLG1EQUF1Qjs7Ozs7UUFDMUIsSUFBSSxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsRUFBRTtZQUNsRCxJQUFJLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxDQUFDLDZCQUE2QixFQUFFLENBQUM7U0FDeEU7UUFDRCxPQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FBQzs7Ozs7Ozs7SUErQmxDLHVDQUFXOzs7Ozs7OztRQUNkLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQzdDLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxDQUFDOztJQXlCbkQ7Ozs7O09BS0c7Ozs7Ozs7O0lBQ0gsMENBQWM7Ozs7Ozs7SUFBZCxVQUFlLFFBQWdCO1FBQzNCLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNoRSxJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxZQUFZLCtCQUErQixFQUFFO1lBQzNFLG1CQUFtQyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsRUFBQyxDQUFDLFlBQVksRUFBRSxDQUFDO1NBQ3JGO0tBQ0o7Ozs7Ozs7SUFpQk0sdURBQTJCOzs7Ozs7O1FBQzlCLE9BQU8sSUFBSSxDQUFDOzs7Ozs7OztJQTZCVCw0REFBZ0M7Ozs7Ozs7UUFDbkMsT0FBTyxJQUFJLENBQUM7O0lBb0NoQjs7OztPQUlHOzs7Ozs7O0lBQ08sc0NBQVU7Ozs7OztJQUFwQixVQUFxQixRQUFpQjs7UUFFbEMsSUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFDLElBQUksSUFBSyxPQUFBLElBQUksQ0FBQyxJQUFJLEtBQUssYUFBYSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUF0RCxDQUFzRCxDQUFDLENBQUM7UUFDeEcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkRBQTJELENBQUMsQ0FBQztTQUNoRjtLQUNKOzs7Ozs7SUFPTSx3Q0FBWTs7Ozs7O1FBQ2YsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDOzs7Ozs7Ozs7O0lBd0JsQixxQ0FBUzs7Ozs7Ozs7Y0FBQyxXQUF3Qzs7UUFDckQsSUFBSSxpQkFBaUIsQ0FBUztRQUM5QixJQUFJLFFBQVEsQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUN2QixpQkFBaUIscUJBQVksV0FBVyxDQUFBLENBQUM7U0FDNUM7YUFBTTtZQUNILGlCQUFpQixHQUFHLG1CQUFzQixXQUFXLEVBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztTQUMzRTtRQUNELElBQUksQ0FBQyxlQUFlLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUM7Ozs7Ozs7SUFhbkMsd0NBQVk7Ozs7O2NBQUMsT0FBZTtRQUMvQixPQUFPLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7NEJBdFIvRDtJQThSQyxDQUFBOzs7Ozs7QUFwUkQsNkJBb1JDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTVEFURV9UUkFOU0xBVEVELCBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsIElOb3JtYWxpemVkTWVzc2FnZSwgSVRyYW5zVW5pdCwgSU5vdGV9IGZyb20gJy4vaW50ZXJuYWxhcGknO1xyXG5pbXBvcnQge0Fic3RyYWN0VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJy4vYWJzdHJhY3QtdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZSc7XHJcbmltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWQsIGlzU3RyaW5nfSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtQYXJzZWRNZXNzYWdlfSBmcm9tICcuL3BhcnNlZC1tZXNzYWdlJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VQYXJzZXJ9IGZyb20gJy4vYWJzdHJhY3QtbWVzc2FnZS1wYXJzZXInO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAxMC4wNS4yMDE3LlxyXG4gKiBBYnN0cmFjdCBzdXBlcmNsYXNzIGZvciBhbGwgaW1wbGVtZW50YXRpb25zIG9mIElUcmFuc1VuaXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0VHJhbnNVbml0IGltcGxlbWVudHMgSVRyYW5zVW5pdCB7XHJcblxyXG4gICAgcHJpdmF0ZSBfc291cmNlQ29udGVudE5vcm1hbGl6ZWQ6IFBhcnNlZE1lc3NhZ2U7XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfZWxlbWVudDogRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgX2lkOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIF90cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKSB7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmaWxlIHRoZSB1bml0IGJlbG9uZ3MgdG8uLFxyXG4gICAgICovXHJcbiAgICB0cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSgpOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHZhbHVlLCB0aGF0IGlzIHRvIGJlIHRyYW5zbGF0ZWQuXHJcbiAgICAgKiBDb250YWlucyBhbGwgbWFya3VwLCBkZXBlbmRzIG9uIHRoZSBjb25jcmV0ZSBmb3JtYXQgdXNlZC5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc291cmNlQ29udGVudCgpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBzb3VyY2UgY29udGVudCBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldFNvdXJjZUNvbnRlbnQgaW4gdHJhbnMtdW5pdCB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgc3VwcG9ydHNTZXRTb3VyY2VDb250ZW50KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG5ldyBzb3VyY2UgY29udGVudCBpbiB0aGUgdHJhbnN1bml0LlxyXG4gICAgICogTm9ybWFsbHksIHRoaXMgaXMgZG9uZSBieSBuZy1leHRyYWN0LlxyXG4gICAgICogTWV0aG9kIG9ubHkgZXhpc3RzIHRvIGFsbG93IHhsaWZmbWVyZ2UgdG8gbWVyZ2UgbWlzc2luZyBjaGFuZ2VkIHNvdXJjZSBjb250ZW50LlxyXG4gICAgICogQHBhcmFtIG5ld0NvbnRlbnQgdGhlIG5ldyBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzZXRTb3VyY2VDb250ZW50KG5ld0NvbnRlbnQ6IHN0cmluZyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCB2YWx1ZSwgdGhhdCBpcyB0byBiZSB0cmFuc2xhdGVkLCBhcyBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpOiBQYXJzZWRNZXNzYWdlIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fc291cmNlQ29udGVudE5vcm1hbGl6ZWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZUNvbnRlbnROb3JtYWxpemVkID0gdGhpcy5jcmVhdGVTb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlQ29udGVudE5vcm1hbGl6ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCB2YWx1ZSwgdGhhdCBpcyB0byBiZSB0cmFuc2xhdGVkLCBhcyBub3JtYWxpemVkIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGNyZWF0ZVNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCk6IFBhcnNlZE1lc3NhZ2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHJhbnNsYXRlZCB2YWx1ZS5cclxuICAgICAqIENvbnRhaW5zIGFsbCBtYXJrdXAsIGRlcGVuZHMgb24gdGhlIGNvbmNyZXRlIGZvcm1hdCB1c2VkLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCB0YXJnZXRDb250ZW50KCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0cmFuc2xhdGVkIHZhbHVlIGFzIG5vcm1hbGl6ZWQgbWVzc2FnZS5cclxuICAgICAqIEFsbCBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGgge3tufX0gKHN0YXJ0aW5nIGF0IDApXHJcbiAgICAgKiBhbmQgYWxsIGVtYmVkZGVkIGh0bWwgaXMgcmVwbGFjZWQgYnkgZGlyZWN0IGh0bWwgbWFya3VwLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCB0YXJnZXRDb250ZW50Tm9ybWFsaXplZCgpOiBJTm9ybWFsaXplZE1lc3NhZ2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0ZSBvZiB0aGUgdHJhbnNsYXRpb24gYXMgc3RvcmVkIGluIHRoZSB4bWwuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IG5hdGl2ZVRhcmdldFN0YXRlKCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRlIG9mIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIChvbiBvZiBuZXcsIHRyYW5zbGF0ZWQsIGZpbmFsKVxyXG4gICAgICogUmV0dXJuIHZhbHVlcyBhcmUgZGVmaW5lZCBhcyBDb25zdGFudHMgU1RBVEVfLi4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRTdGF0ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG5hdGl2ZVN0YXRlID0gdGhpcy5uYXRpdmVUYXJnZXRTdGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcE5hdGl2ZVN0YXRlVG9TdGF0ZShuYXRpdmVTdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgYW4gYWJzdHJhY3Qgc3RhdGUgKG5ldywgdHJhbnNsYXRlZCwgZmluYWwpIHRvIGEgY29uY3JldGUgc3RhdGUgdXNlZCBpbiB0aGUgeG1sLlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdG8gYmUgdXNlZCBpbiB0aGUgeG1sLlxyXG4gICAgICogQHBhcmFtIHN0YXRlIG9uZSBvZiBDb25zdGFudHMuU1RBVEUuLi5cclxuICAgICAqIEByZXR1cm5zIGEgbmF0aXZlIHN0YXRlIChkZXBlbmRzIG9uIGNvbmNyZXRlIGZvcm1hdClcclxuICAgICAqIEB0aHJvd3MgZXJyb3IsIGlmIHN0YXRlIGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBtYXBTdGF0ZVRvTmF0aXZlU3RhdGUoc3RhdGU6IHN0cmluZyk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBhIG5hdGl2ZSBzdGF0ZSAoZm91bmQgaW4gdGhlIGRvY3VtZW50KSB0byBhbiBhYnN0cmFjdCBzdGF0ZSAobmV3LCB0cmFuc2xhdGVkLCBmaW5hbCkuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhYnN0cmFjdCBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSBuYXRpdmVTdGF0ZSBuYXRpdmVTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgbWFwTmF0aXZlU3RhdGVUb1N0YXRlKG5hdGl2ZVN0YXRlOiBzdHJpbmcpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgc3RhdGUgaW4geG1sLlxyXG4gICAgICogQHBhcmFtIG5hdGl2ZVN0YXRlIG5hdGl2ZVN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBzZXROYXRpdmVUYXJnZXRTdGF0ZShuYXRpdmVTdGF0ZTogc3RyaW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmeSB0aGUgdGFyZ2V0IHN0YXRlLlxyXG4gICAgICogQHBhcmFtIG5ld1N0YXRlIG9uZSBvZiB0aGUgMyBhbGxvd2VkIHRhcmdldCBzdGF0ZXMgbmV3LCB0cmFuc2xhdGVkLCBmaW5hbC5cclxuICAgICAqIENvbnN0YW50cyBTVEFURV8uLi5cclxuICAgICAqIEludmFsaWQgc3RhdGVzIHRocm93IGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBzZXRUYXJnZXRTdGF0ZShuZXdTdGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5zZXROYXRpdmVUYXJnZXRTdGF0ZSh0aGlzLm1hcFN0YXRlVG9OYXRpdmVTdGF0ZShuZXdTdGF0ZSkpO1xyXG4gICAgICAgIGlmICh0aGlzLnRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKCkgaW5zdGFuY2VvZiBBYnN0cmFjdFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKSB7XHJcbiAgICAgICAgICAgICg8QWJzdHJhY3RUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZT4gdGhpcy50cmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSgpKS5jb3VudE51bWJlcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdGhlIHNvdXJjZSBlbGVtZW50cyBpbiB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqIFRoZSBzb3VyY2UgZWxlbWVudCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXHJcbiAgICAgKiBJdCBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUgZmlsZSBhbmQgYSBsaW5lIG51bWJlciB3aXRoIHRoZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHRlbXBsYXRlLlxyXG4gICAgICogSXQgaXMganVzdCBhIGhlbHAgZm9yIHRyYW5zbGF0b3JzIHRvIGZpbmQgdGhlIGNvbnRleHQgZm9yIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIFRoaXMgaXMgc2V0IHdoZW4gdXNpbmcgQW5ndWxhciA0LjAgb3IgZ3JlYXRlci5cclxuICAgICAqIE90aGVyd2lzZSBpdCBqdXN0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNvdXJjZVJlZmVyZW5jZXMoKToge3NvdXJjZWZpbGU6IHN0cmluZywgbGluZW51bWJlcjogbnVtYmVyfVtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2Ygc291cmNlIHJlZnMgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXRTb3VyY2VSZWZlcmVuY2VzIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTZXRTb3VyY2VSZWZlcmVuY2VzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNvdXJjZSByZWYgZWxlbWVudHMgaW4gdGhlIHRyYW5zdW5pdC5cclxuICAgICAqIE5vcm1hbGx5LCB0aGlzIGlzIGRvbmUgYnkgbmctZXh0cmFjdC5cclxuICAgICAqIE1ldGhvZCBvbmx5IGV4aXN0cyB0byBhbGxvdyB4bGlmZm1lcmdlIHRvIG1lcmdlIG1pc3Npbmcgc291cmNlIHJlZnMuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlUmVmcyB0aGUgc291cmNlcmVmcyB0byBzZXQuIE9sZCBvbmVzIGFyZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzZXRTb3VyY2VSZWZlcmVuY2VzKHNvdXJjZVJlZnM6IHtzb3VyY2VmaWxlOiBzdHJpbmcsIGxpbmVudW1iZXI6IG51bWJlcn1bXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gc2V0IGluIHRoZSB0ZW1wbGF0ZSBhcyB2YWx1ZSBvZiB0aGUgaTE4bi1hdHRyaWJ1dGUuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJteWRlc2NyaXB0aW9uXCIuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGRlc2NyaXB0aW9uKCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtZWFuaW5nIChpbnRlbnQpIHNldCBpbiB0aGUgdGVtcGxhdGUgYXMgdmFsdWUgb2YgdGhlIGkxOG4tYXR0cmlidXRlLlxyXG4gICAgICogVGhpcyBpcyB0aGUgcGFydCBpbiBmcm9udCBvZiB0aGUgfCBzeW1ib2wuXHJcbiAgICAgKiBlLmcuIGkxOG49XCJtZWFuaW5nfG15ZGVzY3JpcHRpb25cIi5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgbWVhbmluZygpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgc2V0dGluZyBvZiBkZXNjcmlwdGlvbiBhbmQgbWVhbmluZyBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBJZiBub3QsIHNldERlc2NyaXB0aW9uIGFuZCBzZXRNZWFuaW5nIHdpbGwgZG8gbm90aGluZy5cclxuICAgICAqIHh0YiBkb2VzIG5vdCBzdXBwb3J0IHRoaXMsIGFsbCBvdGhlciBmb3JtYXRzIGRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTZXREZXNjcmlwdGlvbkFuZE1lYW5pbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgZGVzY3JpcHRpb24gcHJvcGVydHkgb2YgdHJhbnMtdW5pdC5cclxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBkZXNjcmlwdGlvblxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzZXREZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogc3RyaW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBtZWFuaW5nIHByb3BlcnR5IG9mIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBAcGFyYW0gbWVhbmluZyBtZWFuaW5nXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldE1lYW5pbmcobWVhbmluZzogc3RyaW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbm90ZXMgb2YgdGhlIHRyYW5zLXVuaXQuXHJcbiAgICAgKiBOb3RlcyBhcmUgcmVtYXJrcyBtYWRlIGJ5IGEgdHJhbnNsYXRvci5cclxuICAgICAqIChkZXNjcmlwdGlvbiBhbmQgbWVhbmluZyBhcmUgbm90IGluY2x1ZGVkIGhlcmUhKVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBub3RlcygpOiBJTm90ZVtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHNldHRpbmcgb2Ygbm90ZXMgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogSWYgbm90LCBzZXROb3RlcyB3aWxsIGRvIG5vdGhpbmcuXHJcbiAgICAgKiB4dGIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzLCBhbGwgb3RoZXIgZm9ybWF0cyBkby5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc3VwcG9ydHNTZXROb3RlcygpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIG5vdGVzIHRvIHRyYW5zIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0gbmV3Tm90ZXMgdGhlIG5vdGVzIHRvIGFkZC5cclxuICAgICAqIEB0aHJvd3MgYW4gRXJyb3IgaWYgYW55IG5vdGUgY29udGFpbnMgZGVzY3ByaXB0aW9uIG9yIG1lYW5pbmcgYXMgZnJvbSBhdHRyaWJ1dGUuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldE5vdGVzKG5ld05vdGVzOiBJTm90ZVtdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIG5vdGVzXHJcbiAgICAgKiBAcGFyYW0gbmV3Tm90ZXMgdGhlIG5vdGVzIHRvIGFkZC5cclxuICAgICAqIEB0aHJvd3MgYW4gRXJyb3IgaWYgYW55IG5vdGUgY29udGFpbnMgZGVzY3JpcHRpb24gb3IgbWVhbmluZyBhcyBmcm9tIGF0dHJpYnV0ZS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNoZWNrTm90ZXMobmV3Tm90ZXM6IElOb3RlW10pIHtcclxuICAgICAgICAvLyBjaGVjayBmcm9tIHZhbHVlc1xyXG4gICAgICAgIGNvbnN0IGVycm9ySW5Gcm9tTm90ZSA9IG5ld05vdGVzLmZpbmQoKG5vdGUpID0+IG5vdGUuZnJvbSA9PT0gJ2Rlc2NyaXB0aW9uJyB8fCBub3RlLmZyb20gPT09ICdtZWFuaW5nJyk7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChlcnJvckluRnJvbU5vdGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpcHRpb24gb3IgbWVhbmluZyBhcmUgbm90IGFsbG93ZWQgYXMgZnJvbSBhdHR0cmlidXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlYWwgeG1sIGVsZW1lbnQgdXNlZCBmb3IgdGhlIHRyYW5zIHVuaXQuXHJcbiAgICAgKiAoaW50ZXJuYWwgdXNhZ2Ugb25seSwgYSBjbGllbnQgc2hvdWxkIG5ldmVyIG5lZWQgdGhpcylcclxuICAgICAqIEByZXR1cm4gcmVhbCB4bWwgZWxlbWVudCB1c2VkIGZvciB0aGUgdHJhbnMgdW5pdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzWG1sRWxlbWVudCgpOiBFbGVtZW50IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcHkgc291cmNlIHRvIHRhcmdldCB0byB1c2UgaXQgYXMgZHVtbXkgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBSZXR1cm5zIGEgY2hhbmdlZCBjb3B5IG9mIHRoaXMgdHJhbnMgdW5pdC5cclxuICAgICAqIHJlY2VpdmVyIGlzIG5vdCBjaGFuZ2VkLlxyXG4gICAgICogKGludGVybmFsIHVzYWdlIG9ubHksIGEgY2xpZW50IHNob3VsZCBjYWxsIGltcG9ydE5ld1RyYW5zVW5pdCBvbiBJVHJhbnNsYXRpb25NZXNzYWdlRmlsZSlcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgY2xvbmVXaXRoU291cmNlQXNUYXJnZXQoaXNEZWZhdWx0TGFuZzogYm9vbGVhbiwgY29weUNvbnRlbnQ6IGJvb2xlYW4sIHRhcmdldEZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSk6IEFic3RyYWN0VHJhbnNVbml0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBzb3VyY2UgdG8gdGFyZ2V0IHRvIHVzZSBpdCBhcyBkdW1teSB0cmFuc2xhdGlvbi5cclxuICAgICAqIChpbnRlcm5hbCB1c2FnZSBvbmx5LCBhIGNsaWVudCBzaG91bGQgY2FsbCBjcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nIG9uIElUcmFuc2xhdGlvbk1lc3NhZ2VGaWxlKVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCB1c2VTb3VyY2VBc1RhcmdldChpc0RlZmF1bHRMYW5nOiBib29sZWFuLCBjb3B5Q29udGVudDogYm9vbGVhbik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGUgdGhlIHRyYW5zIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNsYXRpb24gdGhlIHRyYW5zbGF0ZWQgc3RyaW5nIG9yIChwcmVmZXJyZWQpIGEgbm9ybWFsaXplZCBtZXNzYWdlLlxyXG4gICAgICogVGhlIHB1cmUgc3RyaW5nIGNhbiBjb250YWluIGFueSBtYXJrdXAgYW5kIHdpbGwgbm90IGJlIGNoZWNrZWQuXHJcbiAgICAgKiBTbyBpdCBjYW4gZGFtYWdlIHRoZSBkb2N1bWVudC5cclxuICAgICAqIEEgbm9ybWFsaXplZCBtZXNzYWdlIHByZXZlbnRzIHRoaXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGUodHJhbnNsYXRpb246IHN0cmluZyB8IElOb3JtYWxpemVkTWVzc2FnZSkge1xyXG4gICAgICAgIGxldCB0cmFuc2xhdGlvbk5hdGl2ZTogc3RyaW5nO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyh0cmFuc2xhdGlvbikpIHtcclxuICAgICAgICAgICAgdHJhbnNsYXRpb25OYXRpdmUgPSA8c3RyaW5nPiB0cmFuc2xhdGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbk5hdGl2ZSA9ICg8SU5vcm1hbGl6ZWRNZXNzYWdlPiB0cmFuc2xhdGlvbikuYXNOYXRpdmVTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVOYXRpdmUodHJhbnNsYXRpb25OYXRpdmUpO1xyXG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfVFJBTlNMQVRFRCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBwYXJzZXIgdXNlZCBmb3Igbm9ybWFsaXplZCBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IG1lc3NhZ2VQYXJzZXIoKTogQWJzdHJhY3RNZXNzYWdlUGFyc2VyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIG1lc3NhZ2UgbG9va3MgbGlrZSBJQ1UgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2VcclxuICAgICAqIEByZXR1cm4gd2V0aGVyIG1lc3NhZ2UgbG9va3MgbGlrZSBJQ1UgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSUNVTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlUGFyc2VyKCkuaXNJQ1VNZXNzYWdlU3RhcnQobWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRyYW5zbGF0aW9uIHRvIGEgZ2l2ZW4gc3RyaW5nIChpbmNsdWRpbmcgbWFya3VwKS5cclxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiB0cmFuc2xhdGlvblxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgdHJhbnNsYXRlTmF0aXZlKHRyYW5zbGF0aW9uOiBzdHJpbmcpO1xyXG59XHJcbiJdfQ==