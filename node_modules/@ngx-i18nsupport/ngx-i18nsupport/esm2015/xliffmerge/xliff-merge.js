/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { CommandOutput } from '../common/command-output';
import { XliffMergeParameters } from './xliff-merge-parameters';
import { XliffMergeError } from './xliff-merge-error';
import { FileUtil } from '../common/file-util';
import { VERSION } from './version';
import { format } from 'util';
import { isNullOrUndefined } from '../common/util';
import { FORMAT_XMB, FORMAT_XTB, NORMALIZATION_FORMAT_DEFAULT, STATE_FINAL, STATE_TRANSLATED } from '@ngx-i18nsupport/ngx-i18nsupport-lib';
import { NgxTranslateExtractor } from './ngx-translate-extractor';
import { TranslationMessagesFileReader } from './translation-messages-file-reader';
import { of, forkJoin } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { XliffMergeAutoTranslateService } from '../autotranslate/xliff-merge-auto-translate-service';
import { AutoTranslateSummaryReport } from '../autotranslate/auto-translate-summary-report';
/**
 * Created by martin on 17.02.2017.
 * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.
 *
 */
export class XliffMerge {
    /**
     * @param {?} argv
     * @return {?}
     */
    static main(argv) {
        /** @type {?} */
        const options = XliffMerge.parseArgs(argv);
        if (options) {
            new XliffMerge(new CommandOutput(process.stdout), options).run((result) => {
                process.exit(result);
            });
        }
    }
    /**
     * @param {?} argv
     * @return {?}
     */
    static parseArgs(argv) {
        /** @type {?} */
        const options = {
            languages: []
        };
        for (let i = 1; i < argv.length; i++) {
            /** @type {?} */
            const arg = argv[i];
            if (arg === '--version' || arg === '-version') {
                console.log('xliffmerge ' + VERSION);
            }
            else if (arg === '--verbose' || arg === '-v') {
                options.verbose = true;
            }
            else if (arg === '--profile' || arg === '-p') {
                i++;
                if (i >= argv.length) {
                    console.log('missing config file');
                    XliffMerge.showUsage();
                    return null;
                }
                else {
                    options.profilePath = argv[i];
                }
            }
            else if (arg === '--quiet' || arg === '-q') {
                options.quiet = true;
            }
            else if (arg === '--help' || arg === '-help' || arg === '-h') {
                XliffMerge.showUsage();
            }
            else if (arg.length > 0 && arg.charAt(0) === '-') {
                console.log('unknown option');
                return null;
            }
            else {
                options.languages.push(arg);
            }
        }
        return options;
    }
    /**
     * @return {?}
     */
    static showUsage() {
        console.log('usage: xliffmerge <option>* <language>*');
        console.log('Options');
        console.log('\t-p|--profile a json configuration file containing all relevant parameters.');
        console.log('\t\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');
        console.log('\t-v|--verbose show some output for debugging purposes');
        console.log('\t-q|--quiet only show errors, nothing else');
        console.log('\t-version|--version show version string');
        console.log('');
        console.log('\t<language> has to be a valid language short string, e,g. "en", "de", "de-ch"');
    }
    /**
     * For Tests, create instance with given profile
     * @param {?} commandOutput commandOutput
     * @param {?} options options
     * @param {?=} profileContent profileContent
     * @return {?}
     */
    static createFromOptions(commandOutput, options, profileContent) {
        /** @type {?} */
        const instance = new XliffMerge(commandOutput, options);
        instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);
        return instance;
    }
    /**
     * @param {?} commandOutput
     * @param {?} options
     */
    constructor(commandOutput, options) {
        this.commandOutput = commandOutput;
        this.options = options;
        this.parameters = null;
    }
    /**
     * Run the command.
     * This runs async.
     * @param {?=} callbackFunction when command is executed, called with the return code (0 for ok), if given.
     * @param {?=} errorFunction callbackFunction for error handling
     * @return {?}
     */
    run(callbackFunction, errorFunction) {
        this.runAsync()
            .subscribe((retcode) => {
            if (!isNullOrUndefined(callbackFunction)) {
                callbackFunction(retcode);
            }
        }, (error) => {
            if (!isNullOrUndefined(errorFunction)) {
                errorFunction(error);
            }
        });
    }
    /**
     * Execute merge-Process.
     * @return {?} Async operation, on completion returns retcode 0=ok, other = error.
     */
    runAsync() {
        if (this.options && this.options.quiet) {
            this.commandOutput.setQuiet();
        }
        if (this.options && this.options.verbose) {
            this.commandOutput.setVerbose();
        }
        if (!this.parameters) {
            this.parameters = XliffMergeParameters.createFromOptions(this.options);
        }
        this.commandOutput.info('xliffmerge version %s', VERSION);
        if (this.parameters.verbose()) {
            this.parameters.showAllParameters(this.commandOutput);
        }
        if (this.parameters.errorsFound.length > 0) {
            for (const err of this.parameters.errorsFound) {
                this.commandOutput.error(err.message);
            }
            return of(-1);
        }
        if (this.parameters.warningsFound.length > 0) {
            for (const warn of this.parameters.warningsFound) {
                this.commandOutput.warn(warn);
            }
        }
        this.readMaster();
        if (this.parameters.autotranslate()) {
            this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());
        }
        /** @type {?} */
        const executionForAllLanguages = [];
        this.parameters.languages().forEach((lang) => {
            executionForAllLanguages.push(this.processLanguage(lang));
        });
        return forkJoin(executionForAllLanguages).pipe(map((retcodes) => this.totalRetcode(retcodes)));
    }
    /**
     * Give an array of retcodes for the different languages, return the total retcode.
     * If all are 0, it is 0, otherwise the first non zero.
     * @param {?} retcodes retcodes
     * @return {?} number
     */
    totalRetcode(retcodes) {
        for (let i = 0; i < retcodes.length; i++) {
            if (retcodes[i] !== 0) {
                return retcodes[i];
            }
        }
        return 0;
    }
    /**
     * Return the name of the generated file for given lang.
     * @param {?} lang language
     * @return {?} name of generated file
     */
    generatedI18nFile(lang) {
        return this.parameters.generatedI18nFile(lang);
    }
    /**
     * Return the name of the generated ngx-translation file for given lang.
     * @param {?} lang language
     * @return {?} name of translate file
     */
    generatedNgxTranslateFile(lang) {
        return this.parameters.generatedNgxTranslateFile(lang);
    }
    /**
     * Warnings found during the run.
     * @return {?} warnings
     */
    warnings() {
        return this.parameters.warningsFound;
    }
    /**
     * @return {?}
     */
    readMaster() {
        try {
            this.master = TranslationMessagesFileReader.fromFile(this.parameters.i18nFormat(), this.parameters.i18nFile(), this.parameters.encoding());
            this.master.warnings().forEach((warning) => {
                this.commandOutput.warn(warning);
            });
            /** @type {?} */
            const count = this.master.numberOfTransUnits();
            /** @type {?} */
            const missingIdCount = this.master.numberOfTransUnitsWithMissingId();
            this.commandOutput.info('master contains %s trans-units', count);
            if (missingIdCount > 0) {
                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);
            }
            /** @type {?} */
            const sourceLang = this.master.sourceLanguage();
            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {
                this.commandOutput.warn('master says to have source-language="%s", should be "%s" (your defaultLanguage)', sourceLang, this.parameters.defaultLanguage());
                this.master.setSourceLanguage(this.parameters.defaultLanguage());
                TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());
                this.commandOutput.warn('changed master source-language="%s" to "%s"', sourceLang, this.parameters.defaultLanguage());
            }
        }
        catch (err) {
            if (err instanceof XliffMergeError) {
                this.commandOutput.error(err.message);
                return of(-1);
            }
            else {
                // unhandled
                /** @type {?} */
                const currentFilename = this.parameters.i18nFile();
                /** @type {?} */
                const filenameString = (currentFilename) ? format('file "%s", ', currentFilename) : '';
                this.commandOutput.error(filenameString + 'oops ' + err);
                throw err;
            }
        }
    }
    /**
     * Process the given language.
     * Async operation.
     * @param {?} lang language
     * @return {?} on completion 0 for ok, other for error
     */
    processLanguage(lang) {
        this.commandOutput.debug('processing language %s', lang);
        /** @type {?} */
        const languageXliffFile = this.parameters.generatedI18nFile(lang);
        /** @type {?} */
        const currentFilename = languageXliffFile;
        /** @type {?} */
        let result;
        if (!FileUtil.exists(languageXliffFile)) {
            result = this.createUntranslatedXliff(lang, languageXliffFile);
        }
        else {
            result = this.mergeMasterTo(lang, languageXliffFile);
        }
        return result
            .pipe(map(() => {
            if (this.parameters.supportNgxTranslate()) {
                /** @type {?} */
                const languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFile, this.parameters.encoding(), this.master.filename());
                NgxTranslateExtractor.extract(languageSpecificMessagesFile, this.parameters.ngxTranslateExtractionPattern(), this.parameters.generatedNgxTranslateFile(lang));
            }
            return 0;
        }), catchError((err) => {
            if (err instanceof XliffMergeError) {
                this.commandOutput.error(err.message);
                return of(-1);
            }
            else {
                // unhandled
                /** @type {?} */
                const filenameString = (currentFilename) ? format('file "%s", ', currentFilename) : '';
                this.commandOutput.error(filenameString + 'oops ' + err);
                throw err;
            }
        }));
    }
    /**
     * create a new file for the language, which contains no translations, but all keys.
     * in principle, this is just a copy of the master with target-language set.
     * @param {?} lang language
     * @param {?} languageXliffFilePath name of file
     * @return {?}
     */
    createUntranslatedXliff(lang, languageXliffFilePath) {
        // copy master ...
        // and set target-language
        // and copy source to target if necessary
        /** @type {?} */
        const isDefaultLang = (lang === this.parameters.defaultLanguage());
        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
        /** @type {?} */
        const languageSpecificMessagesFile = this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());
        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(map((summary) => {
            // write it to file
            TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());
            this.commandOutput.info('created new file "%s" for target-language="%s"', languageXliffFilePath, lang);
            if (!isDefaultLang) {
                this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
            }
            return null;
        }));
    }
    /**
     * Map the input format to the format of the translation.
     * Normally they are the same but for xmb the translation format is xtb.
     * @param {?} i18nFormat format
     * @return {?}
     */
    translationFormat(i18nFormat) {
        if (i18nFormat === FORMAT_XMB) {
            return FORMAT_XTB;
        }
        else {
            return i18nFormat;
        }
    }
    /**
     * Merge all
     * @param {?} lang language
     * @param {?} languageXliffFilePath filename
     * @return {?}
     */
    mergeMasterTo(lang, languageXliffFilePath) {
        // read lang specific file
        /** @type {?} */
        const languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFilePath, this.parameters.encoding());
        /** @type {?} */
        const isDefaultLang = (lang === this.parameters.defaultLanguage());
        /** @type {?} */
        let newCount = 0;
        /** @type {?} */
        let correctSourceContentCount = 0;
        /** @type {?} */
        let correctSourceRefCount = 0;
        /** @type {?} */
        let correctDescriptionOrMeaningCount = 0;
        /** @type {?} */
        let idChangedCount = 0;
        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
        /** @type {?} */
        let lastProcessedUnit = null;
        this.master.forEachTransUnit((masterTransUnit) => {
            /** @type {?} */
            const transUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);
            if (!transUnit) {
                // oops, no translation, must be a new key, so add it
                /** @type {?} */
                let newUnit;
                if (this.parameters.allowIdChange()
                    && (newUnit = this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {
                    lastProcessedUnit = newUnit;
                    idChangedCount++;
                }
                else {
                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, isDefaultLang, this.parameters.useSourceAsTarget(), (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);
                    newCount++;
                }
            }
            else {
                // check for changed source content and change it if needed
                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.
                if (transUnit.supportsSetSourceContent() && masterTransUnit.sourceContent() !== transUnit.sourceContent()) {
                    transUnit.setSourceContent(masterTransUnit.sourceContent());
                    if (isDefaultLang) {
                        // #81 changed source must be copied to target for default lang
                        transUnit.translate(masterTransUnit.sourceContent());
                        transUnit.setTargetState(STATE_FINAL);
                    }
                    else {
                        if (transUnit.targetState() === STATE_FINAL) {
                            // source is changed, so translation has to be checked again
                            transUnit.setTargetState(STATE_TRANSLATED);
                        }
                    }
                    correctSourceContentCount++;
                }
                // check for missing or changed source ref and add it if needed
                if (transUnit.supportsSetSourceReferences()
                    && !this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {
                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());
                    correctSourceRefCount++;
                }
                // check for changed description or meaning
                if (transUnit.supportsSetDescriptionAndMeaning()) {
                    /** @type {?} */
                    let changed = false;
                    if (transUnit.description() !== masterTransUnit.description()) {
                        transUnit.setDescription(masterTransUnit.description());
                        changed = true;
                    }
                    if (transUnit.meaning() !== masterTransUnit.meaning()) {
                        transUnit.setMeaning(masterTransUnit.meaning());
                        changed = true;
                    }
                    if (changed) {
                        correctDescriptionOrMeaningCount++;
                    }
                }
                lastProcessedUnit = transUnit;
            }
        });
        if (newCount > 0) {
            this.commandOutput.warn('merged %s trans-units from master to "%s"', newCount, lang);
        }
        if (correctSourceContentCount > 0) {
            this.commandOutput.warn('transferred %s changed source content from master to "%s"', correctSourceContentCount, lang);
        }
        if (correctSourceRefCount > 0) {
            this.commandOutput.warn('transferred %s source references from master to "%s"', correctSourceRefCount, lang);
        }
        if (idChangedCount > 0) {
            this.commandOutput.warn('found %s changed id\'s in "%s"', idChangedCount, lang);
        }
        if (correctDescriptionOrMeaningCount > 0) {
            this.commandOutput.warn('transferred %s changed descriptions/meanings from master to "%s"', correctDescriptionOrMeaningCount, lang);
        }
        // remove all elements that are no longer used
        /** @type {?} */
        let removeCount = 0;
        languageSpecificMessagesFile.forEachTransUnit((transUnit) => {
            /** @type {?} */
            const existsInMaster = !isNullOrUndefined(this.master.transUnitWithId(transUnit.id));
            if (!existsInMaster) {
                if (this.parameters.removeUnusedIds()) {
                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);
                }
                removeCount++;
            }
        });
        if (removeCount > 0) {
            if (this.parameters.removeUnusedIds()) {
                this.commandOutput.warn('removed %s unused trans-units in "%s"', removeCount, lang);
            }
            else {
                this.commandOutput.warn('keeping %s unused trans-units in "%s", because removeUnused is disabled', removeCount, lang);
            }
        }
        if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0
            && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {
            this.commandOutput.info('file for "%s" was up to date', lang);
            return of(null);
        }
        else {
            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)
                .pipe(map(() => {
                // write it to file
                TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());
                this.commandOutput.info('updated file "%s" for target-language="%s"', languageXliffFilePath, lang);
                if (newCount > 0 && !isDefaultLang) {
                    this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
                }
                return null;
            }));
        }
    }
    /**
     * Handle the case of changed id due to small white space changes.
     * @param {?} masterTransUnit unit in master file
     * @param {?} languageSpecificMessagesFile translation file
     * @param {?} lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.
     * @return {?} processed unit, if done, null if no changed unit found
     */
    processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit) {
        /** @type {?} */
        const masterSourceString = masterTransUnit.sourceContentNormalized().asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();
        /** @type {?} */
        let changedTransUnit = null;
        languageSpecificMessagesFile.forEachTransUnit((languageTransUnit) => {
            if (languageTransUnit.sourceContentNormalized().asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim() === masterSourceString) {
                changedTransUnit = languageTransUnit;
            }
        });
        if (!changedTransUnit) {
            return null;
        }
        /** @type {?} */
        const mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, false, false, (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);
        /** @type {?} */
        const translatedContent = changedTransUnit.targetContent();
        if (translatedContent) { // issue #68 set translated only, if it is really translated
            mergedTransUnit.translate(translatedContent);
            mergedTransUnit.setTargetState(STATE_TRANSLATED);
        }
        return mergedTransUnit;
    }
    /**
     * @param {?} ref1
     * @param {?} ref2
     * @return {?}
     */
    areSourceReferencesEqual(ref1, ref2) {
        if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {
            return false;
        }
        if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {
            return true;
        }
        // bot refs are set now, convert to set to compare them
        /** @type {?} */
        const set1 = new Set();
        ref1.forEach((ref) => { set1.add(ref.sourcefile + ':' + ref.linenumber); });
        /** @type {?} */
        const set2 = new Set();
        ref2.forEach((ref) => { set2.add(ref.sourcefile + ':' + ref.linenumber); });
        if (set1.size !== set2.size) {
            return false;
        }
        /** @type {?} */
        let match = true;
        set2.forEach((ref) => {
            if (!set1.has(ref)) {
                match = false;
            }
        });
        return match;
    }
    /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param {?} from from
     * @param {?} to to
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} a promise with the execution result as a summary report.
     */
    autoTranslate(from, to, languageSpecificMessagesFile) {
        /** @type {?} */
        let serviceCall;
        /** @type {?} */
        const autotranslateEnabled = this.parameters.autotranslateLanguage(to);
        if (autotranslateEnabled) {
            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);
        }
        else {
            serviceCall = of(new AutoTranslateSummaryReport(from, to));
        }
        return serviceCall.pipe(map((summary) => {
            if (autotranslateEnabled) {
                if (summary.error() || summary.failed() > 0) {
                    this.commandOutput.error(summary.content());
                }
                else {
                    this.commandOutput.warn(summary.content());
                }
            }
            return summary;
        }));
    }
}
if (false) {
    /** @type {?} */
    XliffMerge.prototype.commandOutput;
    /** @type {?} */
    XliffMerge.prototype.options;
    /** @type {?} */
    XliffMerge.prototype.parameters;
    /**
     * The read master xlf file.
     * @type {?}
     */
    XliffMerge.prototype.master;
    /** @type {?} */
    XliffMerge.prototype.autoTranslateService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxpZmYtbWVyZ2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC8iLCJzb3VyY2VzIjpbInhsaWZmbWVyZ2UveGxpZmYtbWVyZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN2RCxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUM5RCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDcEQsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQzdDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDbEMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUM1QixPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRCxPQUFPLEVBQ0gsVUFBVSxFQUFFLFVBQVUsRUFDdEIsNEJBQTRCLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFDLE1BQU0sc0NBQXNDLENBQUM7QUFFN0csT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDaEUsT0FBTyxFQUFDLDZCQUE2QixFQUFDLE1BQU0sb0NBQW9DLENBQUM7QUFDakYsT0FBTyxFQUFhLEVBQUUsRUFBRSxRQUFRLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDOUMsT0FBTyxFQUFDLEdBQUcsRUFBRSxVQUFVLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvQyxPQUFPLEVBQUMsOEJBQThCLEVBQUMsTUFBTSxxREFBcUQsQ0FBQztBQUNuRyxPQUFPLEVBQUMsMEJBQTBCLEVBQUMsTUFBTSxnREFBZ0QsQ0FBQzs7Ozs7O0FBUTFGLE1BQU0sT0FBTyxVQUFVOzs7OztJQWVuQixNQUFNLENBQUMsSUFBSSxDQUFDLElBQWM7O2NBQ2hCLE9B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T0FBTyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ3BDLElBQUksb0JBQW9CLEVBQUU7Z0JBQ3RCLElBQUksT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUU7b0JBQ3pDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2lCQUMvQztxQkFBTTtvQkFDSCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztpQkFDOUM7YUFDSjtZQUNELE9BQU8sT0FBTyxDQUFDO1FBQ25CLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDUixDQUFDO0NBRUo7OztJQXpoQkcsbUNBQXFDOztJQUVyQyw2QkFBZ0M7O0lBRWhDLGdDQUF5Qzs7Ozs7SUFLekMsNEJBQXlDOztJQUV6QywwQ0FBNkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbW1hbmRPdXRwdXR9IGZyb20gJy4uL2NvbW1vbi9jb21tYW5kLW91dHB1dCc7XHJcbmltcG9ydCB7WGxpZmZNZXJnZVBhcmFtZXRlcnN9IGZyb20gJy4veGxpZmYtbWVyZ2UtcGFyYW1ldGVycyc7XHJcbmltcG9ydCB7WGxpZmZNZXJnZUVycm9yfSBmcm9tICcuL3hsaWZmLW1lcmdlLWVycm9yJztcclxuaW1wb3J0IHtGaWxlVXRpbH0gZnJvbSAnLi4vY29tbW9uL2ZpbGUtdXRpbCc7XHJcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi92ZXJzaW9uJztcclxuaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICcuLi9jb21tb24vdXRpbCc7XHJcbmltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLCBJVHJhbnNVbml0LFxyXG4gICAgRk9STUFUX1hNQiwgRk9STUFUX1hUQixcclxuICAgIE5PUk1BTElaQVRJT05fRk9STUFUX0RFRkFVTFQsIFNUQVRFX0ZJTkFMLCBTVEFURV9UUkFOU0xBVEVEfSBmcm9tICdAbmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWInO1xyXG5pbXBvcnQge1Byb2dyYW1PcHRpb25zLCBJQ29uZmlnRmlsZX0gZnJvbSAnLi9pLXhsaWZmLW1lcmdlLW9wdGlvbnMnO1xyXG5pbXBvcnQge05neFRyYW5zbGF0ZUV4dHJhY3Rvcn0gZnJvbSAnLi9uZ3gtdHJhbnNsYXRlLWV4dHJhY3Rvcic7XHJcbmltcG9ydCB7VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXJ9IGZyb20gJy4vdHJhbnNsYXRpb24tbWVzc2FnZXMtZmlsZS1yZWFkZXInO1xyXG5pbXBvcnQge09ic2VydmFibGUsIG9mLCBmb3JrSm9pbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7bWFwLCBjYXRjaEVycm9yfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7WGxpZmZNZXJnZUF1dG9UcmFuc2xhdGVTZXJ2aWNlfSBmcm9tICcuLi9hdXRvdHJhbnNsYXRlL3hsaWZmLW1lcmdlLWF1dG8tdHJhbnNsYXRlLXNlcnZpY2UnO1xyXG5pbXBvcnQge0F1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0fSBmcm9tICcuLi9hdXRvdHJhbnNsYXRlL2F1dG8tdHJhbnNsYXRlLXN1bW1hcnktcmVwb3J0JztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxNy4wMi4yMDE3LlxyXG4gKiBYbGlmZk1lcmdlIC0gcmVhZCB4bGlmZiBvciB4bWIgZmlsZSBhbmQgcHV0IHVudHJhbnNsYXRlZCBwYXJ0cyBpbiBsYW5ndWFnZSBzcGVjaWZpYyB4bGlmZiBvciB4bWIgZmlsZXMuXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFhsaWZmTWVyZ2Uge1xyXG5cclxuICAgIHByaXZhdGUgY29tbWFuZE91dHB1dDogQ29tbWFuZE91dHB1dDtcclxuXHJcbiAgICBwcml2YXRlIG9wdGlvbnM6IFByb2dyYW1PcHRpb25zO1xyXG5cclxuICAgIHByaXZhdGUgcGFyYW1ldGVyczogWGxpZmZNZXJnZVBhcmFtZXRlcnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVhZCBtYXN0ZXIgeGxmIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbWFzdGVyOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGU7IC8vIFhsaWZmRmlsZSBvciBYbGlmZjJGaWxlIG9yIFhtYkZpbGVcclxuXHJcbiAgICBwcml2YXRlIGF1dG9UcmFuc2xhdGVTZXJ2aWNlOiBYbGlmZk1lcmdlQXV0b1RyYW5zbGF0ZVNlcnZpY2U7XHJcblxyXG4gICAgc3RhdGljIG1haW4oYXJndjogc3RyaW5nW10pIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gWGxpZmZNZXJnZS5wYXJzZUFyZ3MoYXJndik7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgbmV3IFhsaWZmTWVyZ2UobmV3IENvbW1hbmRPdXRwdXQocHJvY2Vzcy5zdGRvdXQpLCBvcHRpb25zKS5ydW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5leGl0KHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcGFyc2VBcmdzKGFyZ3Y6IHN0cmluZ1tdKTogUHJvZ3JhbU9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IFByb2dyYW1PcHRpb25zID0ge1xyXG4gICAgICAgICAgICBsYW5ndWFnZXM6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3YubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYXJnID0gYXJndltpXTtcclxuICAgICAgICAgICAgaWYgKGFyZyA9PT0gJy0tdmVyc2lvbicgfHwgYXJnID09PSAnLXZlcnNpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygneGxpZmZtZXJnZSAnICsgVkVSU0lPTik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnID09PSAnLS12ZXJib3NlJyB8fCBhcmcgPT09ICctdicpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMudmVyYm9zZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnID09PSAnLS1wcm9maWxlJyB8fCBhcmcgPT09ICctcCcpIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIGlmIChpID49IGFyZ3YubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ21pc3NpbmcgY29uZmlnIGZpbGUnKTtcclxuICAgICAgICAgICAgICAgICAgICBYbGlmZk1lcmdlLnNob3dVc2FnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnByb2ZpbGVQYXRoID0gYXJndltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09ICctLXF1aWV0JyB8fCBhcmcgPT09ICctcScpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMucXVpZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyA9PT0gJy0taGVscCcgfHwgYXJnID09PSAnLWhlbHAnIHx8IGFyZyA9PT0gJy1oJykge1xyXG4gICAgICAgICAgICAgICAgWGxpZmZNZXJnZS5zaG93VXNhZ2UoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcubGVuZ3RoID4gMCAmJiBhcmcuY2hhckF0KDApID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1bmtub3duIG9wdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxhbmd1YWdlcy5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHNob3dVc2FnZSgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygndXNhZ2U6IHhsaWZmbWVyZ2UgPG9wdGlvbj4qIDxsYW5ndWFnZT4qJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ09wdGlvbnMnKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnXFx0LXB8LS1wcm9maWxlIGEganNvbiBjb25maWd1cmF0aW9uIGZpbGUgY29udGFpbmluZyBhbGwgcmVsZXZhbnQgcGFyYW1ldGVycy4nKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnXFx0XFx0Zm9yIGRldGFpbHMgcGxlYXNlIGNvbnN1bHQgdGhlIGhvbWUgcGFnZSBodHRwczovL2dpdGh1Yi5jb20vbWFydGlucm9vYi9uZ3gtaTE4bnN1cHBvcnQnKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnXFx0LXZ8LS12ZXJib3NlIHNob3cgc29tZSBvdXRwdXQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcycpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXHQtcXwtLXF1aWV0IG9ubHkgc2hvdyBlcnJvcnMsIG5vdGhpbmcgZWxzZScpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXHQtdmVyc2lvbnwtLXZlcnNpb24gc2hvdyB2ZXJzaW9uIHN0cmluZycpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCcnKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnXFx0PGxhbmd1YWdlPiBoYXMgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBzaG9ydCBzdHJpbmcsIGUsZy4gXCJlblwiLCBcImRlXCIsIFwiZGUtY2hcIicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIFRlc3RzLCBjcmVhdGUgaW5zdGFuY2Ugd2l0aCBnaXZlbiBwcm9maWxlXHJcbiAgICAgKiBAcGFyYW0gY29tbWFuZE91dHB1dCBjb21tYW5kT3V0cHV0XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gcHJvZmlsZUNvbnRlbnQgcHJvZmlsZUNvbnRlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVGcm9tT3B0aW9ucyhjb21tYW5kT3V0cHV0OiBDb21tYW5kT3V0cHV0LCBvcHRpb25zOiBQcm9ncmFtT3B0aW9ucywgcHJvZmlsZUNvbnRlbnQ/OiBJQ29uZmlnRmlsZSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFhsaWZmTWVyZ2UoY29tbWFuZE91dHB1dCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaW5zdGFuY2UucGFyYW1ldGVycyA9IFhsaWZmTWVyZ2VQYXJhbWV0ZXJzLmNyZWF0ZUZyb21PcHRpb25zKG9wdGlvbnMsIHByb2ZpbGVDb250ZW50KTtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZE91dHB1dDogQ29tbWFuZE91dHB1dCwgb3B0aW9uczogUHJvZ3JhbU9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQgPSBjb21tYW5kT3V0cHV0O1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1biB0aGUgY29tbWFuZC5cclxuICAgICAqIFRoaXMgcnVucyBhc3luYy5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0Z1bmN0aW9uIHdoZW4gY29tbWFuZCBpcyBleGVjdXRlZCwgY2FsbGVkIHdpdGggdGhlIHJldHVybiBjb2RlICgwIGZvciBvayksIGlmIGdpdmVuLlxyXG4gICAgICogQHBhcmFtIGVycm9yRnVuY3Rpb24gY2FsbGJhY2tGdW5jdGlvbiBmb3IgZXJyb3IgaGFuZGxpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJ1bihjYWxsYmFja0Z1bmN0aW9uPzogKChyZXRjb2RlOiBudW1iZXIpID0+IGFueSksIGVycm9yRnVuY3Rpb24/OiAoKGVycm9yOiBhbnkpID0+IGFueSkpIHtcclxuICAgICAgICB0aGlzLnJ1bkFzeW5jKClcclxuICAgICAgICAgICAgLnN1YnNjcmliZSgocmV0Y29kZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGNhbGxiYWNrRnVuY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tGdW5jdGlvbihyZXRjb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGVycm9yRnVuY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JGdW5jdGlvbihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZSBtZXJnZS1Qcm9jZXNzLlxyXG4gICAgICogQHJldHVybiBBc3luYyBvcGVyYXRpb24sIG9uIGNvbXBsZXRpb24gcmV0dXJucyByZXRjb2RlIDA9b2ssIG90aGVyID0gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBydW5Bc3luYygpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnF1aWV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5zZXRRdWlldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy52ZXJib3NlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5zZXRWZXJib3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5wYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycyA9IFhsaWZmTWVyZ2VQYXJhbWV0ZXJzLmNyZWF0ZUZyb21PcHRpb25zKHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5pbmZvKCd4bGlmZm1lcmdlIHZlcnNpb24gJXMnLCBWRVJTSU9OKTtcclxuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnZlcmJvc2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuc2hvd0FsbFBhcmFtZXRlcnModGhpcy5jb21tYW5kT3V0cHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5lcnJvcnNGb3VuZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyIG9mIHRoaXMucGFyYW1ldGVycy5lcnJvcnNGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmVycm9yKGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2YoLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLndhcm5pbmdzRm91bmQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdhcm4gb2YgdGhpcy5wYXJhbWV0ZXJzLndhcm5pbmdzRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKHdhcm4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVhZE1hc3RlcigpO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYXV0b3RyYW5zbGF0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0b1RyYW5zbGF0ZVNlcnZpY2UgPSBuZXcgWGxpZmZNZXJnZUF1dG9UcmFuc2xhdGVTZXJ2aWNlKHRoaXMucGFyYW1ldGVycy5hcGlrZXkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbkZvckFsbExhbmd1YWdlczogT2JzZXJ2YWJsZTxudW1iZXI+W10gPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMubGFuZ3VhZ2VzKCkuZm9yRWFjaCgobGFuZzogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGlvbkZvckFsbExhbmd1YWdlcy5wdXNoKHRoaXMucHJvY2Vzc0xhbmd1YWdlKGxhbmcpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oZXhlY3V0aW9uRm9yQWxsTGFuZ3VhZ2VzKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKHJldGNvZGVzOiBudW1iZXJbXSkgPT4gdGhpcy50b3RhbFJldGNvZGUocmV0Y29kZXMpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlIGFuIGFycmF5IG9mIHJldGNvZGVzIGZvciB0aGUgZGlmZmVyZW50IGxhbmd1YWdlcywgcmV0dXJuIHRoZSB0b3RhbCByZXRjb2RlLlxyXG4gICAgICogSWYgYWxsIGFyZSAwLCBpdCBpcyAwLCBvdGhlcndpc2UgdGhlIGZpcnN0IG5vbiB6ZXJvLlxyXG4gICAgICogQHBhcmFtIHJldGNvZGVzIHJldGNvZGVzXHJcbiAgICAgKiBAcmV0dXJuIG51bWJlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRvdGFsUmV0Y29kZShyZXRjb2RlczogbnVtYmVyW10pOiBudW1iZXIge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Y29kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHJldGNvZGVzW2ldICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0Y29kZXNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGdlbmVyYXRlZCBmaWxlIGZvciBnaXZlbiBsYW5nLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2VcclxuICAgICAqIEByZXR1cm4gbmFtZSBvZiBnZW5lcmF0ZWQgZmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVkSTE4bkZpbGUobGFuZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzLmdlbmVyYXRlZEkxOG5GaWxlKGxhbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgbmd4LXRyYW5zbGF0aW9uIGZpbGUgZm9yIGdpdmVuIGxhbmcuXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBsYW5ndWFnZVxyXG4gICAgICogQHJldHVybiBuYW1lIG9mIHRyYW5zbGF0ZSBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZW5lcmF0ZWROZ3hUcmFuc2xhdGVGaWxlKGxhbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVycy5nZW5lcmF0ZWROZ3hUcmFuc2xhdGVGaWxlKGxhbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2FybmluZ3MgZm91bmQgZHVyaW5nIHRoZSBydW4uXHJcbiAgICAgKiBAcmV0dXJuIHdhcm5pbmdzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB3YXJuaW5ncygpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVycy53YXJuaW5nc0ZvdW5kO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVhZE1hc3RlcigpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLm1hc3RlciA9IFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyLmZyb21GaWxlKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmkxOG5Gb3JtYXQoKSxcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5pMThuRmlsZSgpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmVuY29kaW5nKCkpO1xyXG4gICAgICAgICAgICB0aGlzLm1hc3Rlci53YXJuaW5ncygpLmZvckVhY2goKHdhcm5pbmc6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4od2FybmluZyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMubWFzdGVyLm51bWJlck9mVHJhbnNVbml0cygpO1xyXG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nSWRDb3VudCA9IHRoaXMubWFzdGVyLm51bWJlck9mVHJhbnNVbml0c1dpdGhNaXNzaW5nSWQoKTtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmluZm8oJ21hc3RlciBjb250YWlucyAlcyB0cmFucy11bml0cycsIGNvdW50KTtcclxuICAgICAgICAgICAgaWYgKG1pc3NpbmdJZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ21hc3RlciBjb250YWlucyAlcyB0cmFucy11bml0cywgYnV0IHRoZXJlIGFyZSAlcyB3aXRob3V0IGlkJywgY291bnQsIG1pc3NpbmdJZENvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VMYW5nOiBzdHJpbmcgPSB0aGlzLm1hc3Rlci5zb3VyY2VMYW5ndWFnZSgpO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlTGFuZyAmJiBzb3VyY2VMYW5nICE9PSB0aGlzLnBhcmFtZXRlcnMuZGVmYXVsdExhbmd1YWdlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKFxyXG4gICAgICAgICAgICAgICAgICAgICdtYXN0ZXIgc2F5cyB0byBoYXZlIHNvdXJjZS1sYW5ndWFnZT1cIiVzXCIsIHNob3VsZCBiZSBcIiVzXCIgKHlvdXIgZGVmYXVsdExhbmd1YWdlKScsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTGFuZyxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZGVmYXVsdExhbmd1YWdlKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXIuc2V0U291cmNlTGFuZ3VhZ2UodGhpcy5wYXJhbWV0ZXJzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICAgICAgICAgIFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyLnNhdmUodGhpcy5tYXN0ZXIsIHRoaXMucGFyYW1ldGVycy5iZWF1dGlmeU91dHB1dCgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdjaGFuZ2VkIG1hc3RlciBzb3VyY2UtbGFuZ3VhZ2U9XCIlc1wiIHRvIFwiJXNcIicsIHNvdXJjZUxhbmcsIHRoaXMucGFyYW1ldGVycy5kZWZhdWx0TGFuZ3VhZ2UoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFhsaWZmTWVyZ2VFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmVycm9yKGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvZigtMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1bmhhbmRsZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGaWxlbmFtZSA9IHRoaXMucGFyYW1ldGVycy5pMThuRmlsZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWVTdHJpbmcgPSAoY3VycmVudEZpbGVuYW1lKSA/IGZvcm1hdCgnZmlsZSBcIiVzXCIsICcsIGN1cnJlbnRGaWxlbmFtZSkgOiAnJztcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5lcnJvcihmaWxlbmFtZVN0cmluZyArICdvb3BzICcgKyBlcnIpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyB0aGUgZ2l2ZW4gbGFuZ3VhZ2UuXHJcbiAgICAgKiBBc3luYyBvcGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBsYW5ndWFnZVxyXG4gICAgICogQHJldHVybiBvbiBjb21wbGV0aW9uIDAgZm9yIG9rLCBvdGhlciBmb3IgZXJyb3JcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwcm9jZXNzTGFuZ3VhZ2UobGFuZzogc3RyaW5nKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuZGVidWcoJ3Byb2Nlc3NpbmcgbGFuZ3VhZ2UgJXMnLCBsYW5nKTtcclxuICAgICAgICBjb25zdCBsYW5ndWFnZVhsaWZmRmlsZSA9IHRoaXMucGFyYW1ldGVycy5nZW5lcmF0ZWRJMThuRmlsZShsYW5nKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50RmlsZW5hbWUgPSBsYW5ndWFnZVhsaWZmRmlsZTtcclxuICAgICAgICBsZXQgcmVzdWx0OiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG4gICAgICAgIGlmICghRmlsZVV0aWwuZXhpc3RzKGxhbmd1YWdlWGxpZmZGaWxlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNyZWF0ZVVudHJhbnNsYXRlZFhsaWZmKGxhbmcsIGxhbmd1YWdlWGxpZmZGaWxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1lcmdlTWFzdGVyVG8obGFuZywgbGFuZ3VhZ2VYbGlmZkZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICAgICAgICAgIC5waXBlKG1hcCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnN1cHBvcnROZ3hUcmFuc2xhdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyLmZyb21GaWxlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvbkZvcm1hdCh0aGlzLnBhcmFtZXRlcnMuaTE4bkZvcm1hdCgpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlWGxpZmZGaWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmVuY29kaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc3Rlci5maWxlbmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBOZ3hUcmFuc2xhdGVFeHRyYWN0b3IuZXh0cmFjdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLm5neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5nZW5lcmF0ZWROZ3hUcmFuc2xhdGVGaWxlKGxhbmcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KSwgY2F0Y2hFcnJvcigoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgWGxpZmZNZXJnZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmVycm9yKGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YoLTEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bmhhbmRsZWRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZVN0cmluZyA9IChjdXJyZW50RmlsZW5hbWUpID8gZm9ybWF0KCdmaWxlIFwiJXNcIiwgJywgY3VycmVudEZpbGVuYW1lKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5lcnJvcihmaWxlbmFtZVN0cmluZyArICdvb3BzICcgKyBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY3JlYXRlIGEgbmV3IGZpbGUgZm9yIHRoZSBsYW5ndWFnZSwgd2hpY2ggY29udGFpbnMgbm8gdHJhbnNsYXRpb25zLCBidXQgYWxsIGtleXMuXHJcbiAgICAgKiBpbiBwcmluY2lwbGUsIHRoaXMgaXMganVzdCBhIGNvcHkgb2YgdGhlIG1hc3RlciB3aXRoIHRhcmdldC1sYW5ndWFnZSBzZXQuXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBsYW5ndWFnZVxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCBuYW1lIG9mIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVVbnRyYW5zbGF0ZWRYbGlmZihsYW5nOiBzdHJpbmcsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aDogc3RyaW5nKTogT2JzZXJ2YWJsZTx2b2lkPiB7XHJcbiAgICAgICAgLy8gY29weSBtYXN0ZXIgLi4uXHJcbiAgICAgICAgLy8gYW5kIHNldCB0YXJnZXQtbGFuZ3VhZ2VcclxuICAgICAgICAvLyBhbmQgY29weSBzb3VyY2UgdG8gdGFyZ2V0IGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGNvbnN0IGlzRGVmYXVsdExhbmc6IGJvb2xlYW4gPSAobGFuZyA9PT0gdGhpcy5wYXJhbWV0ZXJzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICB0aGlzLm1hc3Rlci5zZXROZXdUcmFuc1VuaXRUYXJnZXRQcmFlZml4KHRoaXMucGFyYW1ldGVycy50YXJnZXRQcmFlZml4KCkpO1xyXG4gICAgICAgIHRoaXMubWFzdGVyLnNldE5ld1RyYW5zVW5pdFRhcmdldFN1ZmZpeCh0aGlzLnBhcmFtZXRlcnMudGFyZ2V0U3VmZml4KCkpO1xyXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSA9XHJcbiAgICAgICAgICAgIHRoaXMubWFzdGVyLmNyZWF0ZVRyYW5zbGF0aW9uRmlsZUZvckxhbmcobGFuZywgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoLCBpc0RlZmF1bHRMYW5nLCB0aGlzLnBhcmFtZXRlcnMudXNlU291cmNlQXNUYXJnZXQoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b1RyYW5zbGF0ZSh0aGlzLm1hc3Rlci5zb3VyY2VMYW5ndWFnZSgpLCBsYW5nLCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKHN1bW1hcnkpID0+IHtcclxuICAgICAgICAgICAgLy8gd3JpdGUgaXQgdG8gZmlsZVxyXG4gICAgICAgICAgICBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5zYXZlKGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUsIHRoaXMucGFyYW1ldGVycy5iZWF1dGlmeU91dHB1dCgpKTtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmluZm8oJ2NyZWF0ZWQgbmV3IGZpbGUgXCIlc1wiIGZvciB0YXJnZXQtbGFuZ3VhZ2U9XCIlc1wiJywgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoLCBsYW5nKTtcclxuICAgICAgICAgICAgaWYgKCFpc0RlZmF1bHRMYW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybigncGxlYXNlIHRyYW5zbGF0ZSBmaWxlIFwiJXNcIiB0byB0YXJnZXQtbGFuZ3VhZ2U9XCIlc1wiJywgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoLCBsYW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgdGhlIGlucHV0IGZvcm1hdCB0byB0aGUgZm9ybWF0IG9mIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIE5vcm1hbGx5IHRoZXkgYXJlIHRoZSBzYW1lIGJ1dCBmb3IgeG1iIHRoZSB0cmFuc2xhdGlvbiBmb3JtYXQgaXMgeHRiLlxyXG4gICAgICogQHBhcmFtIGkxOG5Gb3JtYXQgZm9ybWF0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhbnNsYXRpb25Gb3JtYXQoaTE4bkZvcm1hdDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoaTE4bkZvcm1hdCA9PT0gRk9STUFUX1hNQikge1xyXG4gICAgICAgICAgICByZXR1cm4gRk9STUFUX1hUQjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaTE4bkZvcm1hdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXJnZSBhbGxcclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoIGZpbGVuYW1lXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbWVyZ2VNYXN0ZXJUbyhsYW5nOiBzdHJpbmcsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aDogc3RyaW5nKTogT2JzZXJ2YWJsZTx2b2lkPiB7XHJcbiAgICAgICAgLy8gcmVhZCBsYW5nIHNwZWNpZmljIGZpbGVcclxuICAgICAgICBjb25zdCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUgPVxyXG4gICAgICAgICAgICBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5mcm9tRmlsZShcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25Gb3JtYXQodGhpcy5wYXJhbWV0ZXJzLmkxOG5Gb3JtYXQoKSksXHJcbiAgICAgICAgICAgICAgICBsYW5ndWFnZVhsaWZmRmlsZVBhdGgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZW5jb2RpbmcoKSk7XHJcbiAgICAgICAgY29uc3QgaXNEZWZhdWx0TGFuZzogYm9vbGVhbiA9IChsYW5nID09PSB0aGlzLnBhcmFtZXRlcnMuZGVmYXVsdExhbmd1YWdlKCkpO1xyXG4gICAgICAgIGxldCBuZXdDb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IGNvcnJlY3RTb3VyY2VDb250ZW50Q291bnQgPSAwO1xyXG4gICAgICAgIGxldCBjb3JyZWN0U291cmNlUmVmQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBjb3JyZWN0RGVzY3JpcHRpb25Pck1lYW5pbmdDb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IGlkQ2hhbmdlZENvdW50ID0gMDtcclxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLnNldE5ld1RyYW5zVW5pdFRhcmdldFByYWVmaXgodGhpcy5wYXJhbWV0ZXJzLnRhcmdldFByYWVmaXgoKSk7XHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5zZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgodGhpcy5wYXJhbWV0ZXJzLnRhcmdldFN1ZmZpeCgpKTtcclxuICAgICAgICBsZXQgbGFzdFByb2Nlc3NlZFVuaXQ6IElUcmFuc1VuaXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubWFzdGVyLmZvckVhY2hUcmFuc1VuaXQoKG1hc3RlclRyYW5zVW5pdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc1VuaXQ6IElUcmFuc1VuaXQgPSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLnRyYW5zVW5pdFdpdGhJZChtYXN0ZXJUcmFuc1VuaXQuaWQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0cmFuc1VuaXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9vcHMsIG5vIHRyYW5zbGF0aW9uLCBtdXN0IGJlIGEgbmV3IGtleSwgc28gYWRkIGl0XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3VW5pdDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYWxsb3dJZENoYW5nZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgKG5ld1VuaXQgPSB0aGlzLnByb2Nlc3NDaGFuZ2VkSWRVbml0KG1hc3RlclRyYW5zVW5pdCwgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSwgbGFzdFByb2Nlc3NlZFVuaXQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQcm9jZXNzZWRVbml0ID0gbmV3VW5pdDtcclxuICAgICAgICAgICAgICAgICAgICBpZENoYW5nZWRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvY2Vzc2VkVW5pdCA9IGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUuaW1wb3J0TmV3VHJhbnNVbml0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXN0ZXJUcmFuc1VuaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVmYXVsdExhbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy51c2VTb3VyY2VBc1RhcmdldCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5wYXJhbWV0ZXJzLnByZXNlcnZlT3JkZXIoKSkgPyBsYXN0UHJvY2Vzc2VkVW5pdCA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjaGFuZ2VkIHNvdXJjZSBjb250ZW50IGFuZCBjaGFuZ2UgaXQgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICAvLyAoY2FuIG9ubHkgaGFwcGVuIGlmIElEIGlzIGV4cGxpY2l0ZWx5IHNldCwgb3RoZXJ3aXNlIElEIHdvdWxkIGNoYW5nZSBpZiBzb3VyY2UgY29udGVudCBpcyBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zVW5pdC5zdXBwb3J0c1NldFNvdXJjZUNvbnRlbnQoKSAmJiBtYXN0ZXJUcmFuc1VuaXQuc291cmNlQ29udGVudCgpICE9PSB0cmFuc1VuaXQuc291cmNlQ29udGVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LnNldFNvdXJjZUNvbnRlbnQobWFzdGVyVHJhbnNVbml0LnNvdXJjZUNvbnRlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmYXVsdExhbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzgxIGNoYW5nZWQgc291cmNlIG11c3QgYmUgY29waWVkIHRvIHRhcmdldCBmb3IgZGVmYXVsdCBsYW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC50cmFuc2xhdGUobWFzdGVyVHJhbnNVbml0LnNvdXJjZUNvbnRlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5zZXRUYXJnZXRTdGF0ZShTVEFURV9GSU5BTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zVW5pdC50YXJnZXRTdGF0ZSgpID09PSBTVEFURV9GSU5BTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc291cmNlIGlzIGNoYW5nZWQsIHNvIHRyYW5zbGF0aW9uIGhhcyB0byBiZSBjaGVja2VkIGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfVFJBTlNMQVRFRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdFNvdXJjZUNvbnRlbnRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG1pc3Npbmcgb3IgY2hhbmdlZCBzb3VyY2UgcmVmIGFuZCBhZGQgaXQgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNVbml0LnN1cHBvcnRzU2V0U291cmNlUmVmZXJlbmNlcygpXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgIXRoaXMuYXJlU291cmNlUmVmZXJlbmNlc0VxdWFsKG1hc3RlclRyYW5zVW5pdC5zb3VyY2VSZWZlcmVuY2VzKCksIHRyYW5zVW5pdC5zb3VyY2VSZWZlcmVuY2VzKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LnNldFNvdXJjZVJlZmVyZW5jZXMobWFzdGVyVHJhbnNVbml0LnNvdXJjZVJlZmVyZW5jZXMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdFNvdXJjZVJlZkNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgY2hhbmdlZCBkZXNjcmlwdGlvbiBvciBtZWFuaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNVbml0LnN1cHBvcnRzU2V0RGVzY3JpcHRpb25BbmRNZWFuaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc1VuaXQuZGVzY3JpcHRpb24oKSAhPT0gbWFzdGVyVHJhbnNVbml0LmRlc2NyaXB0aW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LnNldERlc2NyaXB0aW9uKG1hc3RlclRyYW5zVW5pdC5kZXNjcmlwdGlvbigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc1VuaXQubWVhbmluZygpICE9PSBtYXN0ZXJUcmFuc1VuaXQubWVhbmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5zZXRNZWFuaW5nKG1hc3RlclRyYW5zVW5pdC5tZWFuaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdERlc2NyaXB0aW9uT3JNZWFuaW5nQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0UHJvY2Vzc2VkVW5pdCA9IHRyYW5zVW5pdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChuZXdDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ21lcmdlZCAlcyB0cmFucy11bml0cyBmcm9tIG1hc3RlciB0byBcIiVzXCInLCBuZXdDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3JyZWN0U291cmNlQ29udGVudENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybigndHJhbnNmZXJyZWQgJXMgY2hhbmdlZCBzb3VyY2UgY29udGVudCBmcm9tIG1hc3RlciB0byBcIiVzXCInLCBjb3JyZWN0U291cmNlQ29udGVudENvdW50LCBsYW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvcnJlY3RTb3VyY2VSZWZDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ3RyYW5zZmVycmVkICVzIHNvdXJjZSByZWZlcmVuY2VzIGZyb20gbWFzdGVyIHRvIFwiJXNcIicsIGNvcnJlY3RTb3VyY2VSZWZDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpZENoYW5nZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ2ZvdW5kICVzIGNoYW5nZWQgaWRcXCdzIGluIFwiJXNcIicsIGlkQ2hhbmdlZENvdW50LCBsYW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvcnJlY3REZXNjcmlwdGlvbk9yTWVhbmluZ0NvdW50ID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybihcclxuICAgICAgICAgICAgICAgICd0cmFuc2ZlcnJlZCAlcyBjaGFuZ2VkIGRlc2NyaXB0aW9ucy9tZWFuaW5ncyBmcm9tIG1hc3RlciB0byBcIiVzXCInLCBjb3JyZWN0RGVzY3JpcHRpb25Pck1lYW5pbmdDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZW1vdmUgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIG5vIGxvbmdlciB1c2VkXHJcbiAgICAgICAgbGV0IHJlbW92ZUNvdW50ID0gMDtcclxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLmZvckVhY2hUcmFuc1VuaXQoKHRyYW5zVW5pdDogSVRyYW5zVW5pdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdHNJbk1hc3RlciA9ICFpc051bGxPclVuZGVmaW5lZCh0aGlzLm1hc3Rlci50cmFuc1VuaXRXaXRoSWQodHJhbnNVbml0LmlkKSk7XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RzSW5NYXN0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMucmVtb3ZlVW51c2VkSWRzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLnJlbW92ZVRyYW5zVW5pdFdpdGhJZCh0cmFuc1VuaXQuaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChyZW1vdmVDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5yZW1vdmVVbnVzZWRJZHMoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ3JlbW92ZWQgJXMgdW51c2VkIHRyYW5zLXVuaXRzIGluIFwiJXNcIicsIHJlbW92ZUNvdW50LCBsYW5nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdrZWVwaW5nICVzIHVudXNlZCB0cmFucy11bml0cyBpbiBcIiVzXCIsIGJlY2F1c2UgcmVtb3ZlVW51c2VkIGlzIGRpc2FibGVkJywgcmVtb3ZlQ291bnQsIGxhbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmV3Q291bnQgPT09IDAgJiYgcmVtb3ZlQ291bnQgPT09IDAgJiYgY29ycmVjdFNvdXJjZUNvbnRlbnRDb3VudCA9PT0gMFxyXG4gICAgICAgICAgICAmJiBjb3JyZWN0U291cmNlUmVmQ291bnQgPT09IDAgJiYgY29ycmVjdERlc2NyaXB0aW9uT3JNZWFuaW5nQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmluZm8oJ2ZpbGUgZm9yIFwiJXNcIiB3YXMgdXAgdG8gZGF0ZScsIGxhbmcpO1xyXG4gICAgICAgICAgICByZXR1cm4gb2YobnVsbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0b1RyYW5zbGF0ZSh0aGlzLm1hc3Rlci5zb3VyY2VMYW5ndWFnZSgpLCBsYW5nLCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlKVxyXG4gICAgICAgICAgICAgICAgLnBpcGUobWFwKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3cml0ZSBpdCB0byBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIuc2F2ZShsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLCB0aGlzLnBhcmFtZXRlcnMuYmVhdXRpZnlPdXRwdXQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmluZm8oJ3VwZGF0ZWQgZmlsZSBcIiVzXCIgZm9yIHRhcmdldC1sYW5ndWFnZT1cIiVzXCInLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGgsIGxhbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDb3VudCA+IDAgJiYgIWlzRGVmYXVsdExhbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ3BsZWFzZSB0cmFuc2xhdGUgZmlsZSBcIiVzXCIgdG8gdGFyZ2V0LWxhbmd1YWdlPVwiJXNcIicsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCwgbGFuZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSB0aGUgY2FzZSBvZiBjaGFuZ2VkIGlkIGR1ZSB0byBzbWFsbCB3aGl0ZSBzcGFjZSBjaGFuZ2VzLlxyXG4gICAgICogQHBhcmFtIG1hc3RlclRyYW5zVW5pdCB1bml0IGluIG1hc3RlciBmaWxlXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSB0cmFuc2xhdGlvbiBmaWxlXHJcbiAgICAgKiBAcGFyYW0gbGFzdFByb2Nlc3NlZFVuaXQgVW5pdCBiZWZvcmUgdGhlIG9uZSBwcm9jZXNzZWQgaGVyZS4gTmV3IHVuaXQgd2lsbCBiZSBpbnNlcnRlZCBhZnRlciB0aGlzIG9uZS5cclxuICAgICAqIEByZXR1cm4gcHJvY2Vzc2VkIHVuaXQsIGlmIGRvbmUsIG51bGwgaWYgbm8gY2hhbmdlZCB1bml0IGZvdW5kXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcHJvY2Vzc0NoYW5nZWRJZFVuaXQoXHJcbiAgICAgICAgbWFzdGVyVHJhbnNVbml0OiBJVHJhbnNVbml0LFxyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSxcclxuICAgICAgICBsYXN0UHJvY2Vzc2VkVW5pdDogSVRyYW5zVW5pdCk6IElUcmFuc1VuaXQge1xyXG5cclxuICAgICAgICBjb25zdCBtYXN0ZXJTb3VyY2VTdHJpbmcgPSBtYXN0ZXJUcmFuc1VuaXQuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKS5hc0Rpc3BsYXlTdHJpbmcoTk9STUFMSVpBVElPTl9GT1JNQVRfREVGQVVMVCkudHJpbSgpO1xyXG4gICAgICAgIGxldCBjaGFuZ2VkVHJhbnNVbml0OiBJVHJhbnNVbml0ID0gbnVsbDtcclxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLmZvckVhY2hUcmFuc1VuaXQoKGxhbmd1YWdlVHJhbnNVbml0KSA9PiB7XHJcbiAgICAgICAgICAgICBpZiAobGFuZ3VhZ2VUcmFuc1VuaXQuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKS5hc0Rpc3BsYXlTdHJpbmcoTk9STUFMSVpBVElPTl9GT1JNQVRfREVGQVVMVCkudHJpbSgpID09PSBtYXN0ZXJTb3VyY2VTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICBjaGFuZ2VkVHJhbnNVbml0ID0gbGFuZ3VhZ2VUcmFuc1VuaXQ7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFjaGFuZ2VkVHJhbnNVbml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZXJnZWRUcmFuc1VuaXQgPSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLmltcG9ydE5ld1RyYW5zVW5pdChcclxuICAgICAgICAgICAgbWFzdGVyVHJhbnNVbml0LFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgICh0aGlzLnBhcmFtZXRlcnMucHJlc2VydmVPcmRlcigpKSA/IGxhc3RQcm9jZXNzZWRVbml0IDogdW5kZWZpbmVkKTtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGVkQ29udGVudCA9IGNoYW5nZWRUcmFuc1VuaXQudGFyZ2V0Q29udGVudCgpO1xyXG4gICAgICAgIGlmICh0cmFuc2xhdGVkQ29udGVudCkgeyAvLyBpc3N1ZSAjNjggc2V0IHRyYW5zbGF0ZWQgb25seSwgaWYgaXQgaXMgcmVhbGx5IHRyYW5zbGF0ZWRcclxuICAgICAgICAgICAgbWVyZ2VkVHJhbnNVbml0LnRyYW5zbGF0ZSh0cmFuc2xhdGVkQ29udGVudCk7XHJcbiAgICAgICAgICAgIG1lcmdlZFRyYW5zVW5pdC5zZXRUYXJnZXRTdGF0ZShTVEFURV9UUkFOU0xBVEVEKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlZFRyYW5zVW5pdDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFyZVNvdXJjZVJlZmVyZW5jZXNFcXVhbChcclxuICAgICAgICByZWYxOiB7c291cmNlZmlsZTogc3RyaW5nOyBsaW5lbnVtYmVyOiBudW1iZXI7IH1bXSxcclxuICAgICAgICByZWYyOiB7c291cmNlZmlsZTogc3RyaW5nOyBsaW5lbnVtYmVyOiBudW1iZXI7IH1bXSk6IGJvb2xlYW4ge1xyXG5cclxuICAgICAgICBpZiAoKGlzTnVsbE9yVW5kZWZpbmVkKHJlZjEpICYmICFpc051bGxPclVuZGVmaW5lZChyZWYyKSkgfHwgKGlzTnVsbE9yVW5kZWZpbmVkKHJlZjIpICYmICFpc051bGxPclVuZGVmaW5lZChyZWYxKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQocmVmMSkgJiYgaXNOdWxsT3JVbmRlZmluZWQocmVmMikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvdCByZWZzIGFyZSBzZXQgbm93LCBjb252ZXJ0IHRvIHNldCB0byBjb21wYXJlIHRoZW1cclxuICAgICAgICBjb25zdCBzZXQxOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gICAgICAgIHJlZjEuZm9yRWFjaCgocmVmKSA9PiB7c2V0MS5hZGQocmVmLnNvdXJjZWZpbGUgKyAnOicgKyByZWYubGluZW51bWJlcik7IH0pO1xyXG4gICAgICAgIGNvbnN0IHNldDI6IFNldDxzdHJpbmc+ID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICAgICAgcmVmMi5mb3JFYWNoKChyZWYpID0+IHtzZXQyLmFkZChyZWYuc291cmNlZmlsZSArICc6JyArIHJlZi5saW5lbnVtYmVyKTsgfSk7XHJcbiAgICAgICAgaWYgKHNldDEuc2l6ZSAhPT0gc2V0Mi5zaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG1hdGNoID0gdHJ1ZTtcclxuICAgICAgICBzZXQyLmZvckVhY2goKHJlZikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNldDEuaGFzKHJlZikpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdXRvIHRyYW5zbGF0ZSBmaWxlIHZpYSBHb29nbGUgVHJhbnNsYXRlLlxyXG4gICAgICogV2lsbCB0cmFuc2xhdGUgYWxsIG5ldyB1bml0cyBpbiBmaWxlLlxyXG4gICAgICogQHBhcmFtIGZyb20gZnJvbVxyXG4gICAgICogQHBhcmFtIHRvIHRvXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlXHJcbiAgICAgKiBAcmV0dXJuIGEgcHJvbWlzZSB3aXRoIHRoZSBleGVjdXRpb24gcmVzdWx0IGFzIGEgc3VtbWFyeSByZXBvcnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXV0b1RyYW5zbGF0ZShcclxuICAgICAgICBmcm9tOiBzdHJpbmcsXHJcbiAgICAgICAgdG86IHN0cmluZyxcclxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpOiBPYnNlcnZhYmxlPEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0PiB7XHJcblxyXG4gICAgICAgIGxldCBzZXJ2aWNlQ2FsbDogT2JzZXJ2YWJsZTxBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydD47XHJcbiAgICAgICAgY29uc3QgYXV0b3RyYW5zbGF0ZUVuYWJsZWQ6IGJvb2xlYW4gPSB0aGlzLnBhcmFtZXRlcnMuYXV0b3RyYW5zbGF0ZUxhbmd1YWdlKHRvKTtcclxuICAgICAgICBpZiAoYXV0b3RyYW5zbGF0ZUVuYWJsZWQpIHtcclxuICAgICAgICAgICAgc2VydmljZUNhbGwgPSB0aGlzLmF1dG9UcmFuc2xhdGVTZXJ2aWNlLmF1dG9UcmFuc2xhdGUoZnJvbSwgdG8sIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlcnZpY2VDYWxsID0gb2YobmV3IEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0KGZyb20sIHRvKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlQ2FsbC5waXBlKG1hcCgoc3VtbWFyeSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXV0b3RyYW5zbGF0ZUVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdW1tYXJ5LmVycm9yKCkgfHwgc3VtbWFyeS5mYWlsZWQoKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuZXJyb3Ioc3VtbWFyeS5jb250ZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybihzdW1tYXJ5LmNvbnRlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1bW1hcnk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iXX0=