(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('stream'), require('chalk'), require('util'), require('fs'), require('@ngx-i18nsupport/ngx-i18nsupport-lib'), require('path'), require('request'), require('rxjs'), require('rxjs/operators'), require('he')) :
    typeof define === 'function' && define.amd ? define('@ngx-i18nsupport/ngx-i18nsupport', ['exports', '@angular/core', 'stream', 'chalk', 'util', 'fs', '@ngx-i18nsupport/ngx-i18nsupport-lib', 'path', 'request', 'rxjs', 'rxjs/operators', 'he'], factory) :
    (factory((global['ngx-i18nsupport'] = global['ngx-i18nsupport'] || {}, global['ngx-i18nsupport']['ngx-i18nsupport'] = {}),global.ng.core,global.stream,global.chalk,global.util,global.fs,global.ngxI18nsupportLib,global.path,global.request,global.rxjs,global.rxjs.operators,global.entityDecoderLib));
}(this, (function (exports,core,stream,chalk,util,fs,ngxI18nsupportLib,path,request,rxjs,operators,entityDecoderLib) { 'use strict';

    chalk = chalk && chalk.hasOwnProperty('default') ? chalk['default'] : chalk;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    // not used, only there to make ng-packagr happy
    var XliffmergeModule = /** @class */ (function () {
        function XliffmergeModule() {
        }
        XliffmergeModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        declarations: [],
                        exports: []
                    },] }
        ];
        return XliffmergeModule;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Collection of utility functions that are deprecated in nodes util.
     */
    /**
     * Replaces node isNullOrUndefined.
     * @param {?} value
     * @return {?}
     */
    function isNullOrUndefined(value) {
        return value === undefined || value === null;
    }
    /**
     * Replaces node isString.
     * @param {?} value
     * @return {?}
     */
    function isString(value) {
        return typeof value === 'string';
    }
    /**
     * Replaces node isArray.
     * @param {?} value
     * @return {?}
     */
    function isArray(value) {
        return Array.isArray(value);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 20.02.2017.
     * A helper class for testing.
     * Can be used as a WritableStream and writes everything (synchronously) into a string,
     * that can easily be read by the tests.
     */
    var /**
     * Created by martin on 20.02.2017.
     * A helper class for testing.
     * Can be used as a WritableStream and writes everything (synchronously) into a string,
     * that can easily be read by the tests.
     */ WriterToString = /** @class */ (function (_super) {
        __extends(WriterToString, _super);
        function WriterToString() {
            var _this = _super.call(this) || this;
            _this.resultString = '';
            return _this;
        }
        /**
         * @param {?} chunk
         * @param {?} encoding
         * @param {?} callback
         * @return {?}
         */
        WriterToString.prototype._write = /**
         * @param {?} chunk
         * @param {?} encoding
         * @param {?} callback
         * @return {?}
         */
            function (chunk, encoding, callback) {
                /** @type {?} */
                var chunkString;
                if (isString(chunk)) {
                    chunkString = chunk;
                }
                else if (chunk instanceof Buffer) {
                    chunkString = chunk.toString();
                }
                else {
                    chunkString = Buffer.alloc(chunk).toString(encoding);
                }
                this.resultString = this.resultString + chunkString;
                callback();
            };
        /**
         * Returns a string of everything, that was written to the stream so far.
         * @return written data
         */
        /**
         * Returns a string of everything, that was written to the stream so far.
         * @return {?} written data
         */
        WriterToString.prototype.writtenData = /**
         * Returns a string of everything, that was written to the stream so far.
         * @return {?} written data
         */
            function () {
                return this.resultString;
            };
        return WriterToString;
    }(stream.Writable));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var LogLevel = {
        'ERROR': 0,
        'WARN': 1,
        'INFO': 2,
        'DEBUG': 3,
    };
    LogLevel[LogLevel['ERROR']] = 'ERROR';
    LogLevel[LogLevel['WARN']] = 'WARN';
    LogLevel[LogLevel['INFO']] = 'INFO';
    LogLevel[LogLevel['DEBUG']] = 'DEBUG';
    var CommandOutput = /** @class */ (function () {
        function CommandOutput(stdout) {
            this._quiet = false;
            this._verbose = false;
            if (stdout) {
                this.outputStream = stdout;
            }
            else {
                this.outputStream = process.stdout;
            }
        }
        /**
         * @return {?}
         */
        CommandOutput.prototype.setVerbose = /**
         * @return {?}
         */
            function () {
                this._verbose = true;
            };
        /**
         * @return {?}
         */
        CommandOutput.prototype.setQuiet = /**
         * @return {?}
         */
            function () {
                this._quiet = true;
            };
        /**
         * Test, wether verbose is enabled.
         * @return wether verbose is enabled.
         */
        /**
         * Test, wether verbose is enabled.
         * @return {?} wether verbose is enabled.
         */
        CommandOutput.prototype.verbose = /**
         * Test, wether verbose is enabled.
         * @return {?} wether verbose is enabled.
         */
            function () {
                return this._verbose;
            };
        /**
         * Test, wether quiet is enabled.
         * @return wether quiet is enabled.
         */
        /**
         * Test, wether quiet is enabled.
         * @return {?} wether quiet is enabled.
         */
        CommandOutput.prototype.quiet = /**
         * Test, wether quiet is enabled.
         * @return {?} wether quiet is enabled.
         */
            function () {
                return this._quiet;
            };
        /**
         * @param {?} msg
         * @param {...?} params
         * @return {?}
         */
        CommandOutput.prototype.error = /**
         * @param {?} msg
         * @param {...?} params
         * @return {?}
         */
            function (msg) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                this.log(LogLevel.ERROR, msg, params);
            };
        /**
         * @param {?} msg
         * @param {...?} params
         * @return {?}
         */
        CommandOutput.prototype.warn = /**
         * @param {?} msg
         * @param {...?} params
         * @return {?}
         */
            function (msg) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                this.log(LogLevel.WARN, msg, params);
            };
        /**
         * @param {?} msg
         * @param {...?} params
         * @return {?}
         */
        CommandOutput.prototype.info = /**
         * @param {?} msg
         * @param {...?} params
         * @return {?}
         */
            function (msg) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                this.log(LogLevel.INFO, msg, params);
            };
        /**
         * @param {?} msg
         * @param {...?} params
         * @return {?}
         */
        CommandOutput.prototype.debug = /**
         * @param {?} msg
         * @param {...?} params
         * @return {?}
         */
            function (msg) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                this.log(LogLevel.DEBUG, msg, params);
            };
        /**
         * @param {?} level
         * @param {?} msg
         * @param {?} params
         * @return {?}
         */
        CommandOutput.prototype.log = /**
         * @param {?} level
         * @param {?} msg
         * @param {?} params
         * @return {?}
         */
            function (level, msg, params) {
                if (!this.isOutputEnabled(level)) {
                    return;
                }
                /** @type {?} */
                var coloredMessage;
                switch (level) {
                    case LogLevel.ERROR:
                        coloredMessage = chalk.red('ERROR: ' + msg);
                        break;
                    case LogLevel.WARN:
                        coloredMessage = chalk.magenta('WARNING: ' + msg);
                        break;
                    default:
                        coloredMessage = chalk.gray('* ' + msg);
                        break;
                }
                /** @type {?} */
                var outMsg = util.format.apply(void 0, __spread([coloredMessage], params));
                this.outputStream.write(outMsg + '\n');
            };
        /**
         * @param {?} level
         * @return {?}
         */
        CommandOutput.prototype.isOutputEnabled = /**
         * @param {?} level
         * @return {?}
         */
            function (level) {
                /** @type {?} */
                var quietEnabled;
                /** @type {?} */
                var verboseEnabled;
                if (this._quiet && this._verbose) {
                    quietEnabled = false;
                    verboseEnabled = false;
                }
                else {
                    quietEnabled = this._quiet;
                    verboseEnabled = this._verbose;
                }
                switch (level) {
                    case LogLevel.ERROR:
                        return true; // always output errors
                    case LogLevel.WARN:
                        return (!quietEnabled);
                    case LogLevel.INFO:
                        return (verboseEnabled && !quietEnabled);
                    case LogLevel.DEBUG:
                        return verboseEnabled;
                    default:
                        return true;
                }
            };
        return CommandOutput;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 17.02.2017.
     */
    var XliffMergeError = /** @class */ (function (_super) {
        __extends(XliffMergeError, _super);
        function XliffMergeError(msg) {
            var _this = _super.call(this, msg) || this;
            // Set the prototype explicitly.
            Object.setPrototypeOf(_this, XliffMergeError.prototype);
            return _this;
        }
        return XliffMergeError;
    }(Error));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 17.02.2017.
     * Some (a few) simple utils for file operations.
     * Just for convenience.
     */
    var /**
     * Created by martin on 17.02.2017.
     * Some (a few) simple utils for file operations.
     * Just for convenience.
     */ FileUtil = /** @class */ (function () {
        function FileUtil() {
        }
        /**
         * Check for existence.
         * @param filename filename
         * @return wether file exists
         */
        /**
         * Check for existence.
         * @param {?} filename filename
         * @return {?} wether file exists
         */
        FileUtil.exists = /**
         * Check for existence.
         * @param {?} filename filename
         * @return {?} wether file exists
         */
            function (filename) {
                return fs.existsSync(filename);
            };
        /**
         * Read a file.
         * @param filename filename
         * @param encoding encoding
         * @return content of file
         */
        /**
         * Read a file.
         * @param {?} filename filename
         * @param {?} encoding encoding
         * @return {?} content of file
         */
        FileUtil.read = /**
         * Read a file.
         * @param {?} filename filename
         * @param {?} encoding encoding
         * @return {?} content of file
         */
            function (filename, encoding) {
                return fs.readFileSync(filename, encoding);
            };
        /**
         * Write a file with given content.
         * @param filename filename
         * @param newContent newContent
         * @param encoding encoding
         */
        /**
         * Write a file with given content.
         * @param {?} filename filename
         * @param {?} newContent newContent
         * @param {?} encoding encoding
         * @return {?}
         */
        FileUtil.replaceContent = /**
         * Write a file with given content.
         * @param {?} filename filename
         * @param {?} newContent newContent
         * @param {?} encoding encoding
         * @return {?}
         */
            function (filename, newContent, encoding) {
                fs.writeFileSync(filename, newContent, { encoding: encoding });
            };
        /**
         * @param {?} srcFile
         * @param {?} destFile
         * @return {?}
         */
        FileUtil.copy = /**
         * @param {?} srcFile
         * @param {?} destFile
         * @return {?}
         */
            function (srcFile, destFile) {
                /** @type {?} */
                var BUF_LENGTH = 64 * 1024;
                /** @type {?} */
                var buff = Buffer.alloc(BUF_LENGTH);
                /** @type {?} */
                var fdr = fs.openSync(srcFile, 'r');
                /** @type {?} */
                var fdw = fs.openSync(destFile, 'w');
                /** @type {?} */
                var bytesRead = 1;
                /** @type {?} */
                var pos = 0;
                while (bytesRead > 0) {
                    bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
                    fs.writeSync(fdw, buff, 0, bytesRead);
                    pos += bytesRead;
                }
                fs.closeSync(fdr);
                fs.closeSync(fdw);
            };
        /**
         * Delete the folder and all of its content (rm -rf).
         * @param path path
         */
        /**
         * Delete the folder and all of its content (rm -rf).
         * @param {?} path path
         * @return {?}
         */
        FileUtil.deleteFolderRecursive = /**
         * Delete the folder and all of its content (rm -rf).
         * @param {?} path path
         * @return {?}
         */
            function (path$$1) {
                /** @type {?} */
                var files = [];
                if (fs.existsSync(path$$1)) {
                    files = fs.readdirSync(path$$1);
                    files.forEach(function (file) {
                        /** @type {?} */
                        var curPath = path$$1 + '/' + file;
                        if (fs.lstatSync(curPath).isDirectory()) { // recurse
                            FileUtil.deleteFolderRecursive(curPath);
                        }
                        else { // delete file
                            fs.unlinkSync(curPath);
                        }
                    });
                    fs.rmdirSync(path$$1);
                }
            };
        /**
         * Delete folders content recursively, but do not delete folder.
         * Folder is left empty at the end.
         * @param path path
         */
        /**
         * Delete folders content recursively, but do not delete folder.
         * Folder is left empty at the end.
         * @param {?} path path
         * @return {?}
         */
        FileUtil.deleteFolderContentRecursive = /**
         * Delete folders content recursively, but do not delete folder.
         * Folder is left empty at the end.
         * @param {?} path path
         * @return {?}
         */
            function (path$$1) {
                /** @type {?} */
                var files = [];
                if (fs.existsSync(path$$1)) {
                    files = fs.readdirSync(path$$1);
                    files.forEach(function (file) {
                        /** @type {?} */
                        var curPath = path$$1 + '/' + file;
                        if (fs.lstatSync(curPath).isDirectory()) { // recurse
                            FileUtil.deleteFolderRecursive(curPath);
                        }
                        else { // delete file
                            fs.unlinkSync(curPath);
                        }
                    });
                }
            };
        /**
         * Delete a file.
         * @param path path
         */
        /**
         * Delete a file.
         * @param {?} path path
         * @return {?}
         */
        FileUtil.deleteFile = /**
         * Delete a file.
         * @param {?} path path
         * @return {?}
         */
            function (path$$1) {
                fs.unlinkSync(path$$1);
            };
        return FileUtil;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Helper class to parse ngx translate extraction pattern
     * and to decide wether a given message matches the pattern.
     */
    var /**
     * Helper class to parse ngx translate extraction pattern
     * and to decide wether a given message matches the pattern.
     */ NgxTranslateExtractionPattern = /** @class */ (function () {
        /**
         * Construct the pattern from given description string
         * @param extractionPatternString extractionPatternString
         * @throws an error, if there is a syntax error
         */
        function NgxTranslateExtractionPattern(extractionPatternString) {
            this.extractionPatternString = extractionPatternString;
            /** @type {?} */
            var parts = extractionPatternString.split('|');
            this._matchExplicitId = false;
            this._descriptionPatterns = [];
            for (var i = 0; i < parts.length; i++) {
                /** @type {?} */
                var part = parts[i];
                if (part === '@@') {
                    if (this._matchExplicitId) {
                        throw new Error('extraction pattern must not contain @@ twice');
                    }
                    this._matchExplicitId = true;
                }
                else {
                    /** @type {?} */
                    var errorString = this.checkValidDescriptionPattern(part);
                    if (errorString) {
                        throw new Error(errorString);
                    }
                    this._descriptionPatterns.push(part);
                }
            }
        }
        /**
         * Check, wether an explicitly set id matches the pattern.
         * @param id id
         * @return wether an explicitly set id matches the pattern.
         */
        /**
         * Check, wether an explicitly set id matches the pattern.
         * @param {?} id id
         * @return {?} wether an explicitly set id matches the pattern.
         */
        NgxTranslateExtractionPattern.prototype.isExplicitIdMatched = /**
         * Check, wether an explicitly set id matches the pattern.
         * @param {?} id id
         * @return {?} wether an explicitly set id matches the pattern.
         */
            function (id) {
                return id && this._matchExplicitId;
            };
        /**
         * Check, wether a given description matches the pattern.
         * @param description description
         * @return wether a given description matches the pattern.
         */
        /**
         * Check, wether a given description matches the pattern.
         * @param {?} description description
         * @return {?} wether a given description matches the pattern.
         */
        NgxTranslateExtractionPattern.prototype.isDescriptionMatched = /**
         * Check, wether a given description matches the pattern.
         * @param {?} description description
         * @return {?} wether a given description matches the pattern.
         */
            function (description) {
                return this._descriptionPatterns.indexOf(description) >= 0;
            };
        /**
         * @param {?} descriptionPattern
         * @return {?}
         */
        NgxTranslateExtractionPattern.prototype.checkValidDescriptionPattern = /**
         * @param {?} descriptionPattern
         * @return {?}
         */
            function (descriptionPattern) {
                if (!descriptionPattern) {
                    return 'empty value not allowed';
                }
                if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {
                    return null; // it is ok
                }
                else {
                    return 'description pattern must be an identifier containing only letters, digits, _ or -';
                }
            };
        return NgxTranslateExtractionPattern;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NgxTranslateExtractor = /** @class */ (function () {
        function NgxTranslateExtractor(messagesFile, extractionPatternString) {
            this.messagesFile = messagesFile;
            this.extractionPattern = new NgxTranslateExtractionPattern(extractionPatternString);
        }
        /**
         * Check, wether extractionPattern has valid syntax.
         * @param extractionPatternString extractionPatternString
         * @return null, if pattern is ok, string describing the error, if it is not ok.
         */
        /**
         * Check, wether extractionPattern has valid syntax.
         * @param {?} extractionPatternString extractionPatternString
         * @return {?} null, if pattern is ok, string describing the error, if it is not ok.
         */
        NgxTranslateExtractor.checkPattern = /**
         * Check, wether extractionPattern has valid syntax.
         * @param {?} extractionPatternString extractionPatternString
         * @return {?} null, if pattern is ok, string describing the error, if it is not ok.
         */
            function (extractionPatternString) {
                try {
                    if (new NgxTranslateExtractionPattern(extractionPatternString)) {
                        return null;
                    }
                }
                catch (error) {
                    return error.message;
                }
                return null;
            };
        /**
         * @param {?} messagesFile
         * @param {?} extractionPattern
         * @param {?} outputFile
         * @return {?}
         */
        NgxTranslateExtractor.extract = /**
         * @param {?} messagesFile
         * @param {?} extractionPattern
         * @param {?} outputFile
         * @return {?}
         */
            function (messagesFile, extractionPattern, outputFile) {
                new NgxTranslateExtractor(messagesFile, extractionPattern).extractTo(outputFile);
            };
        /**
         * Extact messages and write them to a file.
         * @param outputFile outputFile
         */
        /**
         * Extact messages and write them to a file.
         * @param {?} outputFile outputFile
         * @return {?}
         */
        NgxTranslateExtractor.prototype.extractTo = /**
         * Extact messages and write them to a file.
         * @param {?} outputFile outputFile
         * @return {?}
         */
            function (outputFile) {
                /** @type {?} */
                var translations = this.toNgxTranslations(this.extract());
                if (translations && Object.keys(translations).length > 0) {
                    FileUtil.replaceContent(outputFile, JSON.stringify(translations, null, 4), 'UTF-8');
                }
                else {
                    if (FileUtil.exists(outputFile)) {
                        FileUtil.deleteFile(outputFile);
                    }
                }
            };
        /**
         *  Extract messages and convert them to ngx translations.
         *  @return the translation objects.
         */
        /**
         *  Extract messages and convert them to ngx translations.
         * @return {?} the translation objects.
         */
        NgxTranslateExtractor.prototype.extract = /**
         *  Extract messages and convert them to ngx translations.
         * @return {?} the translation objects.
         */
            function () {
                var _this = this;
                /** @type {?} */
                var result = [];
                this.messagesFile.forEachTransUnit(function (tu) {
                    /** @type {?} */
                    var ngxId = _this.ngxTranslateIdFromTU(tu);
                    if (ngxId) {
                        /** @type {?} */
                        var messagetext = tu.targetContentNormalized().asDisplayString(ngxI18nsupportLib.NORMALIZATION_FORMAT_NGXTRANSLATE);
                        result.push({ id: ngxId, message: messagetext });
                    }
                });
                return result;
            };
        /**
         * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.
         * There are 2 possibilities:
         * 1. description is set to "ngx-translate" and meaning contains the id.
         * 2. id is explicitly set to a string.
         * @param tu tu
         * @return an ngx id or null, if this tu should not be extracted.
         */
        /**
         * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.
         * There are 2 possibilities:
         * 1. description is set to "ngx-translate" and meaning contains the id.
         * 2. id is explicitly set to a string.
         * @param {?} tu tu
         * @return {?} an ngx id or null, if this tu should not be extracted.
         */
        NgxTranslateExtractor.prototype.ngxTranslateIdFromTU = /**
         * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.
         * There are 2 possibilities:
         * 1. description is set to "ngx-translate" and meaning contains the id.
         * 2. id is explicitly set to a string.
         * @param {?} tu tu
         * @return {?} an ngx id or null, if this tu should not be extracted.
         */
            function (tu) {
                if (this.isExplicitlySetId(tu.id)) {
                    if (this.extractionPattern.isExplicitIdMatched(tu.id)) {
                        return tu.id;
                    }
                    else {
                        return null;
                    }
                }
                /** @type {?} */
                var description = tu.description();
                if (description && this.extractionPattern.isDescriptionMatched(description)) {
                    return tu.meaning();
                }
            };
        /**
         * Test, wether ID was explicitly set (via i18n="@myid).
         * Just heuristic, an ID is explicitly, if it does not look like a generated one.
         * @param id id
         * @return wether ID was explicitly set (via i18n="@myid).
         */
        /**
         * Test, wether ID was explicitly set (via i18n="\@myid).
         * Just heuristic, an ID is explicitly, if it does not look like a generated one.
         * @param {?} id id
         * @return {?} wether ID was explicitly set (via i18n="\@myid).
         */
        NgxTranslateExtractor.prototype.isExplicitlySetId = /**
         * Test, wether ID was explicitly set (via i18n="\@myid).
         * Just heuristic, an ID is explicitly, if it does not look like a generated one.
         * @param {?} id id
         * @return {?} wether ID was explicitly set (via i18n="\@myid).
         */
            function (id) {
                if (isNullOrUndefined(id)) {
                    return false;
                }
                // generated IDs are either decimal or sha1 hex
                /** @type {?} */
                var reForGeneratedId = /^[0-9a-f]{11,}$/;
                return !reForGeneratedId.test(id);
            };
        /**
         * Convert list of relevant TUs to ngx translations object.
         * @param msgList msgList
         */
        /**
         * Convert list of relevant TUs to ngx translations object.
         * @param {?} msgList msgList
         * @return {?}
         */
        NgxTranslateExtractor.prototype.toNgxTranslations = /**
         * Convert list of relevant TUs to ngx translations object.
         * @param {?} msgList msgList
         * @return {?}
         */
            function (msgList) {
                var _this = this;
                /** @type {?} */
                var translationObject = {};
                msgList.forEach(function (msg) {
                    _this.putInTranslationObject(translationObject, msg);
                });
                return translationObject;
            };
        /**
         * Put a new messages into the translation data object.
         * If you add, e.g. "{id: 'myapp.example', message: 'test'}",
         * the translation object will then contain an object myapp that has property example:
         * {myapp: {
         *   example: 'test'
         *   }}
         * @param translationObject translationObject
         * @param msg msg
         */
        /**
         * Put a new messages into the translation data object.
         * If you add, e.g. "{id: 'myapp.example', message: 'test'}",
         * the translation object will then contain an object myapp that has property example:
         * {myapp: {
         *   example: 'test'
         *   }}
         * @param {?} translationObject translationObject
         * @param {?} msg msg
         * @return {?}
         */
        NgxTranslateExtractor.prototype.putInTranslationObject = /**
         * Put a new messages into the translation data object.
         * If you add, e.g. "{id: 'myapp.example', message: 'test'}",
         * the translation object will then contain an object myapp that has property example:
         * {myapp: {
         *   example: 'test'
         *   }}
         * @param {?} translationObject translationObject
         * @param {?} msg msg
         * @return {?}
         */
            function (translationObject, msg) {
                /** @type {?} */
                var firstPartOfId;
                /** @type {?} */
                var restOfId;
                /** @type {?} */
                var indexOfDot = msg.id.indexOf('.');
                if (indexOfDot === 0 || indexOfDot === (msg.id.length - 1)) {
                    throw new Error('bad nxg-translate id "' + msg.id + '"');
                }
                if (indexOfDot < 0) {
                    firstPartOfId = msg.id;
                    restOfId = '';
                }
                else {
                    firstPartOfId = msg.id.substring(0, indexOfDot);
                    restOfId = msg.id.substring(indexOfDot + 1);
                }
                /** @type {?} */
                var object = translationObject[firstPartOfId];
                if (isNullOrUndefined(object)) {
                    if (restOfId === '') {
                        translationObject[firstPartOfId] = msg.message;
                        return;
                    }
                    object = {};
                    translationObject[firstPartOfId] = object;
                }
                else {
                    if (restOfId === '') {
                        throw new Error('duplicate id praefix "' + msg.id + '"');
                    }
                }
                this.putInTranslationObject(( /** @type {?} */(object)), { id: restOfId, message: msg.message });
            };
        NgxTranslateExtractor.DefaultExtractionPattern = '@@|ngx-translate';
        return NgxTranslateExtractor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var PROFILE_CANDIDATES = ['package.json', '.angular-cli.json'];
    var XliffMergeParameters = /** @class */ (function () {
        function XliffMergeParameters() {
            this.errorsFound = [];
            this.warningsFound = [];
        }
        /**
         * Create Parameters.
         * @param options command options
         * @param profileContent given profile (if not, it is read from the profile path from options).
         */
        /**
         * Create Parameters.
         * @param {?} options command options
         * @param {?=} profileContent given profile (if not, it is read from the profile path from options).
         * @return {?}
         */
        XliffMergeParameters.createFromOptions = /**
         * Create Parameters.
         * @param {?} options command options
         * @param {?=} profileContent given profile (if not, it is read from the profile path from options).
         * @return {?}
         */
            function (options, profileContent) {
                /** @type {?} */
                var parameters = new XliffMergeParameters();
                parameters.configure(options, profileContent);
                return parameters;
            };
        /**
         * Read potential profile.
         * To be a candidate, file must exist and contain property "xliffmergeOptions".
         * @param profilePath path of profile
         * @return parsed content of file or null, if file does not exist or is not a profile candidate.
         */
        /**
         * Read potential profile.
         * To be a candidate, file must exist and contain property "xliffmergeOptions".
         * @param {?} profilePath path of profile
         * @return {?} parsed content of file or null, if file does not exist or is not a profile candidate.
         */
        XliffMergeParameters.readProfileCandidate = /**
         * Read potential profile.
         * To be a candidate, file must exist and contain property "xliffmergeOptions".
         * @param {?} profilePath path of profile
         * @return {?} parsed content of file or null, if file does not exist or is not a profile candidate.
         */
            function (profilePath) {
                /** @type {?} */
                var content;
                try {
                    content = fs.readFileSync(profilePath, 'UTF-8');
                }
                catch (err) {
                    return null;
                }
                /** @type {?} */
                var parsedContent = JSON.parse(content);
                if (parsedContent && parsedContent.xliffmergeOptions) {
                    return parsedContent;
                }
                else {
                    return null;
                }
            };
        /**
         * Initialize me from the profile content.
         * (public only for test usage).
         * @param options options given at runtime via command line
         * @param profileContent if null, read it from profile.
         */
        /**
         * Initialize me from the profile content.
         * (public only for test usage).
         * @param {?} options options given at runtime via command line
         * @param {?=} profileContent if null, read it from profile.
         * @return {?}
         */
        XliffMergeParameters.prototype.configure = /**
         * Initialize me from the profile content.
         * (public only for test usage).
         * @param {?} options options given at runtime via command line
         * @param {?=} profileContent if null, read it from profile.
         * @return {?}
         */
            function (options, profileContent) {
                this.errorsFound = [];
                this.warningsFound = [];
                if (!profileContent) {
                    profileContent = this.readProfile(options);
                }
                /** @type {?} */
                var validProfile = (!!profileContent);
                if (options.quiet) {
                    this._quiet = options.quiet;
                }
                if (options.verbose) {
                    this._verbose = options.verbose;
                }
                if (validProfile) {
                    this.initializeFromConfig(profileContent);
                    // if languages are given as parameters, they ovveride everything said in profile
                    if (!!options.languages && options.languages.length > 0) {
                        this._languages = options.languages;
                        if (!this._defaultLanguage) {
                            this._defaultLanguage = this._languages[0];
                        }
                    }
                    this.checkParameters();
                }
            };
        /**
         * Read profile.
         * @param options program options
         * @return the read profile (empty, if none, null if errors)
         */
        /**
         * Read profile.
         * @param {?} options program options
         * @return {?} the read profile (empty, if none, null if errors)
         */
        XliffMergeParameters.prototype.readProfile = /**
         * Read profile.
         * @param {?} options program options
         * @return {?} the read profile (empty, if none, null if errors)
         */
            function (options) {
                var e_1, _a;
                /** @type {?} */
                var profilePath = options.profilePath;
                if (!profilePath) {
                    try {
                        for (var PROFILE_CANDIDATES_1 = __values(PROFILE_CANDIDATES), PROFILE_CANDIDATES_1_1 = PROFILE_CANDIDATES_1.next(); !PROFILE_CANDIDATES_1_1.done; PROFILE_CANDIDATES_1_1 = PROFILE_CANDIDATES_1.next()) {
                            var configfilename = PROFILE_CANDIDATES_1_1.value;
                            /** @type {?} */
                            var profile = XliffMergeParameters.readProfileCandidate(configfilename);
                            if (profile) {
                                this.usedProfilePath = configfilename;
                                return profile;
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (PROFILE_CANDIDATES_1_1 && !PROFILE_CANDIDATES_1_1.done && (_a = PROFILE_CANDIDATES_1.return))
                                _a.call(PROFILE_CANDIDATES_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    return {};
                }
                /** @type {?} */
                var content;
                try {
                    content = fs.readFileSync(profilePath, 'UTF-8');
                }
                catch (err) {
                    this.errorsFound.push(new XliffMergeError('could not read profile "' + profilePath + '"'));
                    return null;
                }
                this.usedProfilePath = profilePath;
                /** @type {?} */
                var profileContent = JSON.parse(content);
                // replace all pathes in options by absolute paths
                /** @type {?} */
                var xliffmergeOptions = profileContent.xliffmergeOptions;
                xliffmergeOptions.srcDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.srcDir);
                xliffmergeOptions.genDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.genDir);
                xliffmergeOptions.apikeyfile = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.apikeyfile);
                return profileContent;
            };
        /**
         * @param {?} profilePath
         * @param {?} pathToAdjust
         * @return {?}
         */
        XliffMergeParameters.prototype.adjustPathToProfilePath = /**
         * @param {?} profilePath
         * @param {?} pathToAdjust
         * @return {?}
         */
            function (profilePath, pathToAdjust) {
                if (!pathToAdjust || path.isAbsolute(pathToAdjust)) {
                    return pathToAdjust;
                }
                return path.join(path.dirname(profilePath), pathToAdjust).replace(/\\/g, '/');
            };
        /**
         * @param {?} profileContent
         * @return {?}
         */
        XliffMergeParameters.prototype.initializeFromConfig = /**
         * @param {?} profileContent
         * @return {?}
         */
            function (profileContent) {
                if (!profileContent) {
                    return;
                }
                /** @type {?} */
                var profile = profileContent.xliffmergeOptions;
                if (profile) {
                    if (!isNullOrUndefined(profile.quiet)) {
                        this._quiet = profile.quiet;
                    }
                    if (!isNullOrUndefined(profile.verbose)) {
                        this._verbose = profile.verbose;
                    }
                    if (!isNullOrUndefined(profile.allowIdChange)) {
                        this._allowIdChange = profile.allowIdChange;
                    }
                    if (profile.defaultLanguage) {
                        this._defaultLanguage = profile.defaultLanguage;
                    }
                    if (profile.languages) {
                        this._languages = profile.languages;
                    }
                    if (profile.srcDir) {
                        this._srcDir = profile.srcDir;
                    }
                    if (profile.angularCompilerOptions) {
                        if (profile.angularCompilerOptions.genDir) {
                            this._genDir = profile.angularCompilerOptions.genDir;
                        }
                    }
                    if (profile.genDir) {
                        // this must be after angularCompilerOptions to be preferred
                        this._genDir = profile.genDir;
                    }
                    if (profile.i18nBaseFile) {
                        this._i18nBaseFile = profile.i18nBaseFile;
                    }
                    if (profile.i18nFile) {
                        this._i18nFile = profile.i18nFile;
                    }
                    if (profile.i18nFormat) {
                        this._i18nFormat = profile.i18nFormat;
                    }
                    if (profile.encoding) {
                        this._encoding = profile.encoding;
                    }
                    if (!isNullOrUndefined(profile.removeUnusedIds)) {
                        this._removeUnusedIds = profile.removeUnusedIds;
                    }
                    if (!isNullOrUndefined(profile.supportNgxTranslate)) {
                        this._supportNgxTranslate = profile.supportNgxTranslate;
                    }
                    if (!isNullOrUndefined(profile.ngxTranslateExtractionPattern)) {
                        this._ngxTranslateExtractionPattern = profile.ngxTranslateExtractionPattern;
                    }
                    if (!isNullOrUndefined(profile.useSourceAsTarget)) {
                        this._useSourceAsTarget = profile.useSourceAsTarget;
                    }
                    if (!isNullOrUndefined(profile.targetPraefix)) {
                        this._targetPraefix = profile.targetPraefix;
                    }
                    if (!isNullOrUndefined(profile.targetSuffix)) {
                        this._targetSuffix = profile.targetSuffix;
                    }
                    if (!isNullOrUndefined(profile.autotranslate)) {
                        this._autotranslate = profile.autotranslate;
                    }
                    if (!isNullOrUndefined(profile.beautifyOutput)) {
                        this._beautifyOutput = profile.beautifyOutput;
                    }
                    if (!isNullOrUndefined(profile.preserveOrder)) {
                        this._preserveOrder = profile.preserveOrder;
                    }
                    if (!isNullOrUndefined(profile.apikey)) {
                        this._apikey = profile.apikey;
                    }
                    if (!isNullOrUndefined(profile.apikeyfile)) {
                        this._apikeyfile = profile.apikeyfile;
                    }
                }
                else {
                    this.warningsFound.push('did not find "xliffmergeOptions" in profile, using defaults');
                }
            };
        /**
         * Check all Parameters, wether they are complete and consistent.
         * if something is wrong with the parameters, it is collected in errorsFound.
         */
        /**
         * Check all Parameters, wether they are complete and consistent.
         * if something is wrong with the parameters, it is collected in errorsFound.
         * @return {?}
         */
        XliffMergeParameters.prototype.checkParameters = /**
         * Check all Parameters, wether they are complete and consistent.
         * if something is wrong with the parameters, it is collected in errorsFound.
         * @return {?}
         */
            function () {
                var _this = this;
                this.checkLanguageSyntax(this.defaultLanguage());
                if (this.languages().length === 0) {
                    this.errorsFound.push(new XliffMergeError('no languages specified'));
                }
                this.languages().forEach(function (lang) {
                    _this.checkLanguageSyntax(lang);
                });
                /** @type {?} */
                var stats;
                /** @type {?} */
                var err;
                // srcDir should exists
                try {
                    stats = fs.statSync(this.srcDir());
                }
                catch (e) {
                    err = e;
                }
                if (!!err || !stats.isDirectory()) {
                    this.errorsFound.push(new XliffMergeError('srcDir "' + this.srcDir() + '" is not a directory'));
                }
                // genDir should exists
                try {
                    stats = fs.statSync(this.genDir());
                }
                catch (e) {
                    err = e;
                }
                if (!!err || !stats.isDirectory()) {
                    this.errorsFound.push(new XliffMergeError('genDir "' + this.genDir() + '" is not a directory'));
                }
                // master file MUST exist
                try {
                    fs.accessSync(this.i18nFile(), fs.constants.R_OK);
                }
                catch (err) {
                    this.errorsFound.push(new XliffMergeError('i18nFile "' + this.i18nFile() + '" is not readable'));
                }
                // i18nFormat must be xlf xlf2 or xmb
                if (!(this.i18nFormat() === 'xlf' || this.i18nFormat() === 'xlf2' || this.i18nFormat() === 'xmb')) {
                    this.errorsFound.push(new XliffMergeError('i18nFormat "' + this.i18nFormat() + '" invalid, must be "xlf" or "xlf2" or "xmb"'));
                }
                // autotranslate requires api key
                if (this.autotranslate() && !this.apikey()) {
                    this.errorsFound.push(new XliffMergeError('autotranslate requires an API key, please set one'));
                }
                // autotranslated languages must be in list of all languages
                this.autotranslatedLanguages().forEach(function (lang) {
                    if (_this.languages().indexOf(lang) < 0) {
                        _this.errorsFound.push(new XliffMergeError('autotranslate language "' + lang + '" is not in list of languages'));
                    }
                    if (lang === _this.defaultLanguage()) {
                        _this.errorsFound.push(new XliffMergeError('autotranslate language "' + lang + '" cannot be translated, because it is the source language'));
                    }
                });
                // ngx translate pattern check
                if (this.supportNgxTranslate()) {
                    /** @type {?} */
                    var checkResult = NgxTranslateExtractor.checkPattern(this.ngxTranslateExtractionPattern());
                    if (!isNullOrUndefined(checkResult)) {
                        this.errorsFound.push(new XliffMergeError('ngxTranslateExtractionPattern "' + this.ngxTranslateExtractionPattern() + '": ' + checkResult));
                    }
                }
                // targetPraefix and targetSuffix check
                if (!this.useSourceAsTarget()) {
                    if (this.targetPraefix().length > 0) {
                        this.warningsFound.push('configured targetPraefix "' + this.targetPraefix() + '" will not be used because "useSourceAsTarget" is disabled"');
                    }
                    if (this.targetSuffix().length > 0) {
                        this.warningsFound.push('configured targetSuffix "' + this.targetSuffix() + '" will not be used because "useSourceAsTarget" is disabled"');
                    }
                }
            };
        /**
         * Check syntax of language.
         * Must be compatible with XML Schema type xsd:language.
         * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*
         * @param lang language to check
         */
        /**
         * Check syntax of language.
         * Must be compatible with XML Schema type xsd:language.
         * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*
         * @param {?} lang language to check
         * @return {?}
         */
        XliffMergeParameters.prototype.checkLanguageSyntax = /**
         * Check syntax of language.
         * Must be compatible with XML Schema type xsd:language.
         * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*
         * @param {?} lang language to check
         * @return {?}
         */
            function (lang) {
                /** @type {?} */
                var pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;
                if (!pattern.test(lang)) {
                    this.errorsFound.push(new XliffMergeError('language "' + lang + '" is not valid'));
                }
            };
        /**
         * @return {?}
         */
        XliffMergeParameters.prototype.allowIdChange = /**
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._allowIdChange)) ? false : this._allowIdChange;
            };
        /**
         * @return {?}
         */
        XliffMergeParameters.prototype.verbose = /**
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._verbose)) ? false : this._verbose;
            };
        /**
         * @return {?}
         */
        XliffMergeParameters.prototype.quiet = /**
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._quiet)) ? false : this._quiet;
            };
        /**
         * Debug output all parameters to commandOutput.
         */
        /**
         * Debug output all parameters to commandOutput.
         * @param {?} commandOutput
         * @return {?}
         */
        XliffMergeParameters.prototype.showAllParameters = /**
         * Debug output all parameters to commandOutput.
         * @param {?} commandOutput
         * @return {?}
         */
            function (commandOutput) {
                var e_2, _a;
                commandOutput.debug('xliffmerge Used Parameters:');
                commandOutput.debug('usedProfilePath:\t"%s"', this.usedProfilePath);
                commandOutput.debug('defaultLanguage:\t"%s"', this.defaultLanguage());
                commandOutput.debug('srcDir:\t"%s"', this.srcDir());
                commandOutput.debug('genDir:\t"%s"', this.genDir());
                commandOutput.debug('i18nBaseFile:\t"%s"', this.i18nBaseFile());
                commandOutput.debug('i18nFile:\t"%s"', this.i18nFile());
                commandOutput.debug('languages:\t%s', this.languages());
                try {
                    for (var _b = __values(this.languages()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var language = _c.value;
                        commandOutput.debug('outputFile[%s]:\t%s', language, this.generatedI18nFile(language));
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                commandOutput.debug('removeUnusedIds:\t%s', this.removeUnusedIds());
                commandOutput.debug('supportNgxTranslate:\t%s', this.supportNgxTranslate());
                if (this.supportNgxTranslate()) {
                    commandOutput.debug('ngxTranslateExtractionPattern:\t%s', this.ngxTranslateExtractionPattern());
                }
                commandOutput.debug('useSourceAsTarget:\t%s', this.useSourceAsTarget());
                if (this.useSourceAsTarget()) {
                    commandOutput.debug('targetPraefix:\t"%s"', this.targetPraefix());
                    commandOutput.debug('targetSuffix:\t"%s"', this.targetSuffix());
                }
                commandOutput.debug('allowIdChange:\t%s', this.allowIdChange());
                commandOutput.debug('beautifyOutput:\t%s', this.beautifyOutput());
                commandOutput.debug('preserveOrder:\t%s', this.preserveOrder());
                commandOutput.debug('autotranslate:\t%s', this.autotranslate());
                if (this.autotranslate()) {
                    commandOutput.debug('autotranslated languages:\t%s', this.autotranslatedLanguages());
                    commandOutput.debug('apikey:\t%s', this.apikey() ? '****' : 'NOT SET');
                    commandOutput.debug('apikeyfile:\t%s', this.apikeyfile());
                }
            };
        /**
         * Default-Language, default en.
         * @return default language
         */
        /**
         * Default-Language, default en.
         * @return {?} default language
         */
        XliffMergeParameters.prototype.defaultLanguage = /**
         * Default-Language, default en.
         * @return {?} default language
         */
            function () {
                return this._defaultLanguage ? this._defaultLanguage : 'en';
            };
        /**
         * Liste der zu bearbeitenden Sprachen.
         * @return languages
         */
        /**
         * Liste der zu bearbeitenden Sprachen.
         * @return {?} languages
         */
        XliffMergeParameters.prototype.languages = /**
         * Liste der zu bearbeitenden Sprachen.
         * @return {?} languages
         */
            function () {
                return this._languages ? this._languages : [];
            };
        /**
         * src directory, where the master xlif is located.
         * @return srcDir
         */
        /**
         * src directory, where the master xlif is located.
         * @return {?} srcDir
         */
        XliffMergeParameters.prototype.srcDir = /**
         * src directory, where the master xlif is located.
         * @return {?} srcDir
         */
            function () {
                return this._srcDir ? this._srcDir : '.';
            };
        /**
         * The base file name of the xlif file for input and output.
         * Default is messages
         * @return base file
         */
        /**
         * The base file name of the xlif file for input and output.
         * Default is messages
         * @return {?} base file
         */
        XliffMergeParameters.prototype.i18nBaseFile = /**
         * The base file name of the xlif file for input and output.
         * Default is messages
         * @return {?} base file
         */
            function () {
                return this._i18nBaseFile ? this._i18nBaseFile : 'messages';
            };
        /**
         * The master xlif file (the one generated by ng-xi18n).
         * Default is <srcDir>/<i18nBaseFile>.xlf.
         * @return master file
         */
        /**
         * The master xlif file (the one generated by ng-xi18n).
         * Default is <srcDir>/<i18nBaseFile>.xlf.
         * @return {?} master file
         */
        XliffMergeParameters.prototype.i18nFile = /**
         * The master xlif file (the one generated by ng-xi18n).
         * Default is <srcDir>/<i18nBaseFile>.xlf.
         * @return {?} master file
         */
            function () {
                return path.join(this.srcDir(), (this._i18nFile ? this._i18nFile : this.i18nBaseFile() + '.' + this.suffixForGeneratedI18nFile())).replace(/\\/g, '/');
            };
        /**
         * Format of the master xlif file.
         * Default is "xlf", possible are "xlf" or "xlf2" or "xmb".
         * @return format
         */
        /**
         * Format of the master xlif file.
         * Default is "xlf", possible are "xlf" or "xlf2" or "xmb".
         * @return {?} format
         */
        XliffMergeParameters.prototype.i18nFormat = /**
         * Format of the master xlif file.
         * Default is "xlf", possible are "xlf" or "xlf2" or "xmb".
         * @return {?} format
         */
            function () {
                return (this._i18nFormat ? this._i18nFormat : 'xlf');
            };
        /**
         * potentially to be generated I18n-File with the translations for one language.
         * @param lang language shortcut
         * @return Path of file
         */
        /**
         * potentially to be generated I18n-File with the translations for one language.
         * @param {?} lang language shortcut
         * @return {?} Path of file
         */
        XliffMergeParameters.prototype.generatedI18nFile = /**
         * potentially to be generated I18n-File with the translations for one language.
         * @param {?} lang language shortcut
         * @return {?} Path of file
         */
            function (lang) {
                return path.join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + this.suffixForGeneratedI18nFile()).replace(/\\/g, '/');
            };
        /**
         * @return {?}
         */
        XliffMergeParameters.prototype.suffixForGeneratedI18nFile = /**
         * @return {?}
         */
            function () {
                switch (this.i18nFormat()) {
                    case 'xlf':
                        return 'xlf';
                    case 'xlf2':
                        return 'xlf';
                    case 'xmb':
                        return 'xtb';
                }
            };
        /**
         * potentially to be generated translate-File for ngx-translate with the translations for one language.
         * @param lang language shortcut
         * @return Path of file
         */
        /**
         * potentially to be generated translate-File for ngx-translate with the translations for one language.
         * @param {?} lang language shortcut
         * @return {?} Path of file
         */
        XliffMergeParameters.prototype.generatedNgxTranslateFile = /**
         * potentially to be generated translate-File for ngx-translate with the translations for one language.
         * @param {?} lang language shortcut
         * @return {?} Path of file
         */
            function (lang) {
                return path.join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + 'json').replace(/\\/g, '/');
            };
        /**
         * The encoding used to write new XLIFF-files.
         * @return encoding
         */
        /**
         * The encoding used to write new XLIFF-files.
         * @return {?} encoding
         */
        XliffMergeParameters.prototype.encoding = /**
         * The encoding used to write new XLIFF-files.
         * @return {?} encoding
         */
            function () {
                return this._encoding ? this._encoding : 'UTF-8';
            };
        /**
         * Output-Directory, where the output is written to.
         * Default is <srcDir>.
        */
        /**
         * Output-Directory, where the output is written to.
         * Default is <srcDir>.
         * @return {?}
         */
        XliffMergeParameters.prototype.genDir = /**
         * Output-Directory, where the output is written to.
         * Default is <srcDir>.
         * @return {?}
         */
            function () {
                return this._genDir ? this._genDir : this.srcDir();
            };
        /**
         * @return {?}
         */
        XliffMergeParameters.prototype.removeUnusedIds = /**
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._removeUnusedIds)) ? true : this._removeUnusedIds;
            };
        /**
         * @return {?}
         */
        XliffMergeParameters.prototype.supportNgxTranslate = /**
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._supportNgxTranslate)) ? false : this._supportNgxTranslate;
            };
        /**
         * @return {?}
         */
        XliffMergeParameters.prototype.ngxTranslateExtractionPattern = /**
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._ngxTranslateExtractionPattern)) ?
                    NgxTranslateExtractor.DefaultExtractionPattern : this._ngxTranslateExtractionPattern;
            };
        /**
         * Whether source must be used as target for new trans-units
         * Default is true
         */
        /**
         * Whether source must be used as target for new trans-units
         * Default is true
         * @return {?}
         */
        XliffMergeParameters.prototype.useSourceAsTarget = /**
         * Whether source must be used as target for new trans-units
         * Default is true
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._useSourceAsTarget)) ? true : this._useSourceAsTarget;
            };
        /**
         * Praefix used for target when copying new trans-units
         * Default is ""
         */
        /**
         * Praefix used for target when copying new trans-units
         * Default is ""
         * @return {?}
         */
        XliffMergeParameters.prototype.targetPraefix = /**
         * Praefix used for target when copying new trans-units
         * Default is ""
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._targetPraefix)) ? '' : this._targetPraefix;
            };
        /**
         * Suffix used for target when copying new trans-units
         * Default is ""
         */
        /**
         * Suffix used for target when copying new trans-units
         * Default is ""
         * @return {?}
         */
        XliffMergeParameters.prototype.targetSuffix = /**
         * Suffix used for target when copying new trans-units
         * Default is ""
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._targetSuffix)) ? '' : this._targetSuffix;
            };
        /**
         * If set, run xml result through beautifier (pretty-data).
         */
        /**
         * If set, run xml result through beautifier (pretty-data).
         * @return {?}
         */
        XliffMergeParameters.prototype.beautifyOutput = /**
         * If set, run xml result through beautifier (pretty-data).
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._beautifyOutput)) ? false : this._beautifyOutput;
            };
        /**
         * If set, order of new trans units will be as in master.
         * Otherwise they are added at the end.
         */
        /**
         * If set, order of new trans units will be as in master.
         * Otherwise they are added at the end.
         * @return {?}
         */
        XliffMergeParameters.prototype.preserveOrder = /**
         * If set, order of new trans units will be as in master.
         * Otherwise they are added at the end.
         * @return {?}
         */
            function () {
                return (isNullOrUndefined(this._preserveOrder)) ? true : this._preserveOrder;
            };
        /**
         * Whether to use autotranslate for new trans-units
         * Default is false
         */
        /**
         * Whether to use autotranslate for new trans-units
         * Default is false
         * @return {?}
         */
        XliffMergeParameters.prototype.autotranslate = /**
         * Whether to use autotranslate for new trans-units
         * Default is false
         * @return {?}
         */
            function () {
                if (isNullOrUndefined(this._autotranslate)) {
                    return false;
                }
                if (isArray(this._autotranslate)) {
                    return (( /** @type {?} */(this._autotranslate))).length > 0;
                }
                return ( /** @type {?} */(this._autotranslate));
            };
        /**
         * Whether to use autotranslate for a given language.
         * @param lang language code.
         */
        /**
         * Whether to use autotranslate for a given language.
         * @param {?} lang language code.
         * @return {?}
         */
        XliffMergeParameters.prototype.autotranslateLanguage = /**
         * Whether to use autotranslate for a given language.
         * @param {?} lang language code.
         * @return {?}
         */
            function (lang) {
                return this.autotranslatedLanguages().indexOf(lang) >= 0;
            };
        /**
         * Return a list of languages to be autotranslated.
         */
        /**
         * Return a list of languages to be autotranslated.
         * @return {?}
         */
        XliffMergeParameters.prototype.autotranslatedLanguages = /**
         * Return a list of languages to be autotranslated.
         * @return {?}
         */
            function () {
                if (isNullOrUndefined(this._autotranslate) || this._autotranslate === false) {
                    return [];
                }
                if (isArray(this._autotranslate)) {
                    return (( /** @type {?} */(this._autotranslate)));
                }
                return this.languages().slice(1); // first is source language
            };
        /**
         * API key to be used for Google Translate
         * @return api key
         */
        /**
         * API key to be used for Google Translate
         * @return {?} api key
         */
        XliffMergeParameters.prototype.apikey = /**
         * API key to be used for Google Translate
         * @return {?} api key
         */
            function () {
                if (!isNullOrUndefined(this._apikey)) {
                    return this._apikey;
                }
                else {
                    /** @type {?} */
                    var apikeyPath = this.apikeyfile();
                    if (this.apikeyfile()) {
                        if (fs.existsSync(apikeyPath)) {
                            return FileUtil.read(apikeyPath, 'utf-8');
                        }
                        else {
                            throw new Error(util.format('api key file not found: API_KEY_FILE=%s', apikeyPath));
                        }
                    }
                    else {
                        return null;
                    }
                }
            };
        /**
         * file name for API key to be used for Google Translate.
         * Explicitly set or read from env var API_KEY_FILE.
         * @return file of api key
         */
        /**
         * file name for API key to be used for Google Translate.
         * Explicitly set or read from env var API_KEY_FILE.
         * @return {?} file of api key
         */
        XliffMergeParameters.prototype.apikeyfile = /**
         * file name for API key to be used for Google Translate.
         * Explicitly set or read from env var API_KEY_FILE.
         * @return {?} file of api key
         */
            function () {
                if (this._apikeyfile) {
                    return this._apikeyfile;
                }
                else if (process.env.API_KEY_FILE) {
                    return process.env.API_KEY_FILE;
                }
                else {
                    return null;
                }
            };
        return XliffMergeParameters;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var pkg = null;
    try {
        pkg = require(path.resolve(__dirname, '..', 'package.json'));
    }
    catch (e) {
        try {
            pkg = require(path.resolve(__dirname, '..', '..', 'package.json'));
        }
        catch (e) {
            pkg = null;
        }
    }
    /** @type {?} */
    var VERSION = (pkg ? pkg.version : 'unknown');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 10.03.2017.
     * Helper class to read XMl with a correct encoding.
     */
    var XmlReader = /** @class */ (function () {
        function XmlReader() {
        }
        /**
         * Read an xml-File.
         * @param path Path to file
         * @param encoding optional encoding of the xml.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @return file content and encoding found in the file.
         */
        /**
         * Read an xml-File.
         * @param {?} path Path to file
         * @param {?=} encoding optional encoding of the xml.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @return {?} file content and encoding found in the file.
         */
        XmlReader.readXmlFileContent = /**
         * Read an xml-File.
         * @param {?} path Path to file
         * @param {?=} encoding optional encoding of the xml.
         * This is read from the file, but if you know it before, you can avoid reading the file twice.
         * @return {?} file content and encoding found in the file.
         */
            function (path$$1, encoding) {
                if (!encoding) {
                    encoding = XmlReader.DEFAULT_ENCODING;
                }
                /** @type {?} */
                var content = FileUtil.read(path$$1, encoding);
                /** @type {?} */
                var foundEncoding = XmlReader.encodingFromXml(content);
                if (foundEncoding !== encoding) {
                    // read again with the correct encoding
                    content = FileUtil.read(path$$1, foundEncoding);
                }
                return {
                    content: content,
                    encoding: foundEncoding
                };
            };
        /**
         * Read the encoding from the xml.
         * xml File starts with .. encoding=".."
         * @param xmlString xmlString
         * @return encoding
         */
        /**
         * Read the encoding from the xml.
         * xml File starts with .. encoding=".."
         * @param {?} xmlString xmlString
         * @return {?} encoding
         */
        XmlReader.encodingFromXml = /**
         * Read the encoding from the xml.
         * xml File starts with .. encoding=".."
         * @param {?} xmlString xmlString
         * @return {?} encoding
         */
            function (xmlString) {
                /** @type {?} */
                var index = xmlString.indexOf('encoding="');
                if (index < 0) {
                    return this.DEFAULT_ENCODING; // default in xml if not explicitly set
                }
                /** @type {?} */
                var endIndex = xmlString.indexOf('"', index + 10);
                return xmlString.substring(index + 10, endIndex);
            };
        XmlReader.DEFAULT_ENCODING = 'UTF-8';
        return XmlReader;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Helper class to read translation files depending on format.
     */
    var /**
     * Helper class to read translation files depending on format.
     */ TranslationMessagesFileReader = /** @class */ (function () {
        function TranslationMessagesFileReader() {
        }
        /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param i18nFormat format
         * @param path path
         * @param encoding encoding
         * @param optionalMasterFilePath optionalMasterFilePath
         * @return XliffFile
         */
        /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param {?} i18nFormat format
         * @param {?} path path
         * @param {?} encoding encoding
         * @param {?=} optionalMasterFilePath optionalMasterFilePath
         * @return {?} XliffFile
         */
        TranslationMessagesFileReader.fromFile = /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param {?} i18nFormat format
         * @param {?} path path
         * @param {?} encoding encoding
         * @param {?=} optionalMasterFilePath optionalMasterFilePath
         * @return {?} XliffFile
         */
            function (i18nFormat, path$$1, encoding, optionalMasterFilePath) {
                /** @type {?} */
                var xmlContent = XmlReader.readXmlFileContent(path$$1, encoding);
                /** @type {?} */
                var optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);
                return ngxI18nsupportLib.TranslationMessagesFileFactory.fromFileContent(i18nFormat, xmlContent.content, path$$1, xmlContent.encoding, optionalMaster);
            };
        /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param path path
         * @param encoding encoding
         * @param optionalMasterFilePath optionalMasterFilePath
         * @return XliffFile
         */
        /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param {?} path path
         * @param {?} encoding encoding
         * @param {?=} optionalMasterFilePath optionalMasterFilePath
         * @return {?} XliffFile
         */
        TranslationMessagesFileReader.fromUnknownFormatFile = /**
         * Read file function, result depends on format, either XliffFile or XmbFile.
         * @param {?} path path
         * @param {?} encoding encoding
         * @param {?=} optionalMasterFilePath optionalMasterFilePath
         * @return {?} XliffFile
         */
            function (path$$1, encoding, optionalMasterFilePath) {
                /** @type {?} */
                var xmlContent = XmlReader.readXmlFileContent(path$$1, encoding);
                /** @type {?} */
                var optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);
                return ngxI18nsupportLib.TranslationMessagesFileFactory.fromUnknownFormatFileContent(xmlContent.content, path$$1, xmlContent.encoding, optionalMaster);
            };
        /**
         * Read master xmb file
         * @param optionalMasterFilePath optionalMasterFilePath
         * @param encoding encoding
         * @return content and encoding of file
         */
        /**
         * Read master xmb file
         * @param {?} optionalMasterFilePath optionalMasterFilePath
         * @param {?} encoding encoding
         * @return {?} content and encoding of file
         */
        TranslationMessagesFileReader.masterFileContent = /**
         * Read master xmb file
         * @param {?} optionalMasterFilePath optionalMasterFilePath
         * @param {?} encoding encoding
         * @return {?} content and encoding of file
         */
            function (optionalMasterFilePath, encoding) {
                if (optionalMasterFilePath) {
                    /** @type {?} */
                    var masterXmlContent = XmlReader.readXmlFileContent(optionalMasterFilePath, encoding);
                    return {
                        xmlContent: masterXmlContent.content,
                        path: optionalMasterFilePath,
                        encoding: masterXmlContent.encoding
                    };
                }
                else {
                    return null;
                }
            };
        /**
         * Save edited file.
         * @param messagesFile messagesFile
         * @param beautifyOutput Flag whether to use pretty-data to format the output.
         * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
         * See issue #64 for details.
         * Default is false.
         */
        /**
         * Save edited file.
         * @param {?} messagesFile messagesFile
         * @param {?=} beautifyOutput Flag whether to use pretty-data to format the output.
         * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
         * See issue #64 for details.
         * Default is false.
         * @return {?}
         */
        TranslationMessagesFileReader.save = /**
         * Save edited file.
         * @param {?} messagesFile messagesFile
         * @param {?=} beautifyOutput Flag whether to use pretty-data to format the output.
         * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
         * See issue #64 for details.
         * Default is false.
         * @return {?}
         */
            function (messagesFile, beautifyOutput) {
                FileUtil.replaceContent(messagesFile.filename(), messagesFile.editedContent(beautifyOutput), messagesFile.encoding());
            };
        return TranslationMessagesFileReader;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAX_SEGMENTS = 128;
    var AutoTranslateService = /** @class */ (function () {
        function AutoTranslateService(apiKey) {
            this._request = request;
            this._apiKey = apiKey;
            this._rootUrl = 'https://translation.googleapis.com/';
        }
        /**
         * Strip region code and convert to lower
         * @param lang lang
         * @return lang without region code and in lower case.
         */
        /**
         * Strip region code and convert to lower
         * @param {?} lang lang
         * @return {?} lang without region code and in lower case.
         */
        AutoTranslateService.stripRegioncode = /**
         * Strip region code and convert to lower
         * @param {?} lang lang
         * @return {?} lang without region code and in lower case.
         */
            function (lang) {
                /** @type {?} */
                var langLower = lang.toLowerCase();
                for (var i = 0; i < langLower.length; i++) {
                    /** @type {?} */
                    var c = langLower.charAt(i);
                    if (c < 'a' || c > 'z') {
                        return langLower.substring(0, i);
                    }
                }
                return langLower;
            };
        /**
         * Change API key (just for tests).
         * @param apikey apikey
         */
        /**
         * Change API key (just for tests).
         * @param {?} apikey apikey
         * @return {?}
         */
        AutoTranslateService.prototype.setApiKey = /**
         * Change API key (just for tests).
         * @param {?} apikey apikey
         * @return {?}
         */
            function (apikey) {
                this._apiKey = apikey;
            };
        /**
         * Translate an array of messages at once.
         * @param messages the messages to be translated
         * @param from source language code
         * @param to target language code
         * @return Observable with translated messages or error
         */
        /**
         * Translate an array of messages at once.
         * @param {?} messages the messages to be translated
         * @param {?} from source language code
         * @param {?} to target language code
         * @return {?} Observable with translated messages or error
         */
        AutoTranslateService.prototype.translateMultipleStrings = /**
         * Translate an array of messages at once.
         * @param {?} messages the messages to be translated
         * @param {?} from source language code
         * @param {?} to target language code
         * @return {?} Observable with translated messages or error
         */
            function (messages, from, to) {
                var _this = this;
                // empty array needs no translation and always works ... (#78)
                if (messages.length === 0) {
                    return rxjs.of([]);
                }
                if (!this._apiKey) {
                    return rxjs.throwError('cannot autotranslate: no api key');
                }
                if (!from || !to) {
                    return rxjs.throwError('cannot autotranslate: source and target language must be set');
                }
                from = AutoTranslateService.stripRegioncode(from);
                to = AutoTranslateService.stripRegioncode(to);
                /** @type {?} */
                var allRequests = this.splitMessagesToGoogleLimit(messages).map(function (partialMessages) {
                    return _this.limitedTranslateMultipleStrings(partialMessages, from, to);
                });
                return rxjs.forkJoin(allRequests).pipe(operators.map(function (allTranslations) {
                    /** @type {?} */
                    var all = [];
                    for (var i = 0; i < allTranslations.length; i++) {
                        all = all.concat(allTranslations[i]);
                    }
                    return all;
                }));
            };
        /**
         * @param {?} messages
         * @return {?}
         */
        AutoTranslateService.prototype.splitMessagesToGoogleLimit = /**
         * @param {?} messages
         * @return {?}
         */
            function (messages) {
                if (messages.length <= MAX_SEGMENTS) {
                    return [messages];
                }
                /** @type {?} */
                var result = [];
                /** @type {?} */
                var currentPackage = [];
                /** @type {?} */
                var packageSize = 0;
                for (var i = 0; i < messages.length; i++) {
                    currentPackage.push(messages[i]);
                    packageSize++;
                    if (packageSize >= MAX_SEGMENTS) {
                        result.push(currentPackage);
                        currentPackage = [];
                        packageSize = 0;
                    }
                }
                if (currentPackage.length > 0) {
                    result.push(currentPackage);
                }
                return result;
            };
        /**
         * Return translation request, but messages must be limited to google limits.
         * Not more that 128 single messages.
         * @param messages messages
         * @param from from
         * @param to to
         * @return the translated strings
         */
        /**
         * Return translation request, but messages must be limited to google limits.
         * Not more that 128 single messages.
         * @param {?} messages messages
         * @param {?} from from
         * @param {?} to to
         * @return {?} the translated strings
         */
        AutoTranslateService.prototype.limitedTranslateMultipleStrings = /**
         * Return translation request, but messages must be limited to google limits.
         * Not more that 128 single messages.
         * @param {?} messages messages
         * @param {?} from from
         * @param {?} to to
         * @return {?} the translated strings
         */
            function (messages, from, to) {
                /** @type {?} */
                var realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;
                /** @type {?} */
                var translateRequest = {
                    q: messages,
                    target: to,
                    source: from,
                };
                /** @type {?} */
                var options = {
                    url: realUrl,
                    body: translateRequest,
                    json: true,
                };
                return this.post(realUrl, options).pipe(operators.map(function (data) {
                    /** @type {?} */
                    var body = data.body;
                    if (!body) {
                        throw new Error('no result received');
                    }
                    if (body.error) {
                        if (body.error.code === 400) {
                            if (body.error.message === 'Invalid Value') {
                                throw new Error(util.format('Translation from "%s" to "%s" not supported', from, to));
                            }
                            throw new Error(util.format('Invalid request: %s', body.error.message));
                        }
                        else {
                            throw new Error(util.format('Error %s: %s', body.error.code, body.error.message));
                        }
                    }
                    /** @type {?} */
                    var result = body.data;
                    return result.translations.map(function (translation) {
                        return translation.translatedText;
                    });
                }));
            };
        /**
         * Function to do a POST HTTP request
         *
         * @param uri uri
         * @param options options
         *
         * @return response
         */
        /**
         * Function to do a POST HTTP request
         *
         * @param {?} uri uri
         * @param {?=} options options
         *
         * @return {?} response
         */
        AutoTranslateService.prototype.post = /**
         * Function to do a POST HTTP request
         *
         * @param {?} uri uri
         * @param {?=} options options
         *
         * @return {?} response
         */
            function (uri, options) {
                return ( /** @type {?} */(this._call.apply(this, [].concat('post', ( /** @type {?} */(uri)), ( /** @type {?} */(Object.assign({}, options || {})))))));
            };
        /**
         * Function to do a HTTP request for given method
         *
         * @param method method
         * @param uri uri
         * @param options options
         *
         * @return response
         *
         */
        /**
         * Function to do a HTTP request for given method
         *
         * @param {?} method method
         * @param {?} uri uri
         * @param {?=} options options
         *
         * @return {?} response
         *
         */
        AutoTranslateService.prototype._call = /**
         * Function to do a HTTP request for given method
         *
         * @param {?} method method
         * @param {?} uri uri
         * @param {?=} options options
         *
         * @return {?} response
         *
         */
            function (method, uri, options) {
                var _this = this;
                return ( /** @type {?} */(rxjs.Observable.create(function (observer) {
                    // build params array
                    /** @type {?} */
                    var params = [].concat(( /** @type {?} */(uri)), ( /** @type {?} */(Object.assign({}, options || {}))), function (error, response, body) {
                        if (error) {
                            return observer.error(error);
                        }
                        observer.next(( /** @type {?} */(Object.assign({}, {
                            response: ( /** @type {?} */(response)),
                            body: ( /** @type {?} */(body))
                        }))));
                        observer.complete();
                    });
                    // _call request method
                    try {
                        _this._request[( /** @type {?} */(method))].apply(( /** @type {?} */(_this._request)), params);
                    }
                    catch (error) {
                        observer.error(error);
                    }
                })));
            };
        return AutoTranslateService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 29.06.2017.
     */
    var AutoTranslateResult = /** @class */ (function () {
        function AutoTranslateResult(_success, _details) {
            this._success = _success;
            this._details = _details;
        }
        /**
         * @return {?}
         */
        AutoTranslateResult.prototype.success = /**
         * @return {?}
         */
            function () {
                return this._success;
            };
        return AutoTranslateResult;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * A report about a run of Google Translate over all untranslated unit.
     * * Created by martin on 29.06.2017.
     */
    var /**
     * A report about a run of Google Translate over all untranslated unit.
     * * Created by martin on 29.06.2017.
     */ AutoTranslateSummaryReport = /** @class */ (function () {
        function AutoTranslateSummaryReport(from, to) {
            this._from = from;
            this._to = to;
            this._total = 0;
            this._ignored = 0;
            this._success = 0;
            this._failed = 0;
        }
        /**
         * Set error if total call failed (e.g. "invalid api key" or "no connection" ...)
         * @param error error
         * @param total total
         */
        /**
         * Set error if total call failed (e.g. "invalid api key" or "no connection" ...)
         * @param {?} error error
         * @param {?} total total
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.setError = /**
         * Set error if total call failed (e.g. "invalid api key" or "no connection" ...)
         * @param {?} error error
         * @param {?} total total
         * @return {?}
         */
            function (error, total) {
                this._error = error;
                this._total = total;
                this._failed = total;
            };
        /**
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.error = /**
         * @return {?}
         */
            function () {
                return this._error;
            };
        /**
         * @param {?} ignored
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.setIgnored = /**
         * @param {?} ignored
         * @return {?}
         */
            function (ignored) {
                this._total += ignored;
                this._ignored = ignored;
            };
        /**
         * Add a single result to the summary.
         * @param tu tu
         * @param result result
         */
        /**
         * Add a single result to the summary.
         * @param {?} tu tu
         * @param {?} result result
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.addSingleResult = /**
         * Add a single result to the summary.
         * @param {?} tu tu
         * @param {?} result result
         * @return {?}
         */
            function (tu, result) {
                this._total++;
                if (result.success()) {
                    this._success++;
                }
                else {
                    this._failed++;
                }
            };
        /**
         * Merge another summary into this one.
         * @param anotherSummary anotherSummary
         */
        /**
         * Merge another summary into this one.
         * @param {?} anotherSummary anotherSummary
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.merge = /**
         * Merge another summary into this one.
         * @param {?} anotherSummary anotherSummary
         * @return {?}
         */
            function (anotherSummary) {
                if (!this._error) {
                    this._error = anotherSummary._error;
                }
                this._total += anotherSummary.total();
                this._ignored += anotherSummary.ignored();
                this._success += anotherSummary.success();
                this._failed += anotherSummary.failed();
            };
        /**
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.total = /**
         * @return {?}
         */
            function () {
                return this._total;
            };
        /**
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.ignored = /**
         * @return {?}
         */
            function () {
                return this._ignored;
            };
        /**
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.success = /**
         * @return {?}
         */
            function () {
                return this._success;
            };
        /**
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.failed = /**
         * @return {?}
         */
            function () {
                return this._failed;
            };
        /**
         * Human readable version of report
         */
        /**
         * Human readable version of report
         * @return {?}
         */
        AutoTranslateSummaryReport.prototype.content = /**
         * Human readable version of report
         * @return {?}
         */
            function () {
                /** @type {?} */
                var result;
                if (this._error) {
                    result = util.format('Auto translation from "%s" to "%s" failed: "%s", failed units: %s', this._from, this._to, this._error, this._failed);
                }
                else {
                    result = util.format('Auto translation from "%s" to "%s", total auto translated units: %s, ignored: %s, succesful: %s, failed: %s', this._from, this._to, this._total, this._ignored, this._success, this._failed);
                }
                return result;
            };
        return AutoTranslateSummaryReport;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 07.07.2017.
     * Service to autotranslate Transunits via Google Translate.
     */
    var /**
     * Created by martin on 07.07.2017.
     * Service to autotranslate Transunits via Google Translate.
     */ XliffMergeAutoTranslateService = /** @class */ (function () {
        function XliffMergeAutoTranslateService(apikey) {
            this.autoTranslateService = new AutoTranslateService(apikey);
        }
        /**
         * Auto translate file via Google Translate.
         * Will translate all new units in file.
         * @param from from
         * @param to to
         * @param languageSpecificMessagesFile languageSpecificMessagesFile
         * @return a promise with the execution result as a summary report.
         */
        /**
         * Auto translate file via Google Translate.
         * Will translate all new units in file.
         * @param {?} from from
         * @param {?} to to
         * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
         * @return {?} a promise with the execution result as a summary report.
         */
        XliffMergeAutoTranslateService.prototype.autoTranslate = /**
         * Auto translate file via Google Translate.
         * Will translate all new units in file.
         * @param {?} from from
         * @param {?} to to
         * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
         * @return {?} a promise with the execution result as a summary report.
         */
            function (from, to, languageSpecificMessagesFile) {
                return rxjs.forkJoin(__spread([
                    this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile)
                ], this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)))
                    .pipe(operators.map(function (summaries) {
                    /** @type {?} */
                    var summary = summaries[0];
                    for (var i = 1; i < summaries.length; i++) {
                        summary.merge(summaries[i]);
                    }
                    return summary;
                }));
            };
        /**
         * Collect all units that are untranslated.
         * @param languageSpecificMessagesFile languageSpecificMessagesFile
         * @return all untranslated units
         */
        /**
         * Collect all units that are untranslated.
         * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
         * @return {?} all untranslated units
         */
        XliffMergeAutoTranslateService.prototype.allUntranslatedTUs = /**
         * Collect all units that are untranslated.
         * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
         * @return {?} all untranslated units
         */
            function (languageSpecificMessagesFile) {
                // collect all units, that should be auto translated
                /** @type {?} */
                var allUntranslated = [];
                languageSpecificMessagesFile.forEachTransUnit(function (tu) {
                    if (tu.targetState() === ngxI18nsupportLib.STATE_NEW) {
                        allUntranslated.push(tu);
                    }
                });
                return allUntranslated;
            };
        /**
         * @param {?} from
         * @param {?} to
         * @param {?} languageSpecificMessagesFile
         * @return {?}
         */
        XliffMergeAutoTranslateService.prototype.doAutoTranslateNonICUMessages = /**
         * @param {?} from
         * @param {?} to
         * @param {?} languageSpecificMessagesFile
         * @return {?}
         */
            function (from, to, languageSpecificMessagesFile) {
                var _this = this;
                /** @type {?} */
                var allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);
                /** @type {?} */
                var allTranslatable = allUntranslated.filter(function (tu) { return isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()); });
                /** @type {?} */
                var allMessages = allTranslatable.map(function (tu) {
                    return tu.sourceContentNormalized().asDisplayString();
                });
                return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)
                    .pipe(
                // #94 google translate might return &#.. entity refs, that must be decoded
                operators.map(function (translations) { return translations.map(function (encodedTranslation) { return entityDecoderLib.decode(encodedTranslation); }); }), operators.map(function (translations) {
                    /** @type {?} */
                    var summary = new AutoTranslateSummaryReport(from, to);
                    summary.setIgnored(allUntranslated.length - allTranslatable.length);
                    for (var i = 0; i < translations.length; i++) {
                        /** @type {?} */
                        var tu = allTranslatable[i];
                        /** @type {?} */
                        var translationText = translations[i];
                        /** @type {?} */
                        var result = _this.autoTranslateNonICUUnit(tu, translationText);
                        summary.addSingleResult(tu, result);
                    }
                    return summary;
                }), operators.catchError(function (err) {
                    /** @type {?} */
                    var failSummary = new AutoTranslateSummaryReport(from, to);
                    failSummary.setError(err.message, allMessages.length);
                    return rxjs.of(failSummary);
                }));
            };
        /**
         * @param {?} from
         * @param {?} to
         * @param {?} languageSpecificMessagesFile
         * @return {?}
         */
        XliffMergeAutoTranslateService.prototype.doAutoTranslateICUMessages = /**
         * @param {?} from
         * @param {?} to
         * @param {?} languageSpecificMessagesFile
         * @return {?}
         */
            function (from, to, languageSpecificMessagesFile) {
                var _this = this;
                /** @type {?} */
                var allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);
                /** @type {?} */
                var allTranslatableICU = allUntranslated.filter(function (tu) { return !isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()); });
                return allTranslatableICU.map(function (tu) {
                    return _this.doAutoTranslateICUMessage(from, to, tu);
                });
            };
        /**
         * Translate single ICU Messages.
         * @param from from
         * @param to to
         * @param tu transunit to translate (must contain ICU Message)
         * @return summary report
         */
        /**
         * Translate single ICU Messages.
         * @param {?} from from
         * @param {?} to to
         * @param {?} tu transunit to translate (must contain ICU Message)
         * @return {?} summary report
         */
        XliffMergeAutoTranslateService.prototype.doAutoTranslateICUMessage = /**
         * Translate single ICU Messages.
         * @param {?} from from
         * @param {?} to to
         * @param {?} tu transunit to translate (must contain ICU Message)
         * @return {?} summary report
         */
            function (from, to, tu) {
                var _this = this;
                /** @type {?} */
                var icuMessage = tu.sourceContentNormalized().getICUMessage();
                /** @type {?} */
                var categories = icuMessage.getCategories();
                // check for nested ICUs, we do not support that
                if (categories.find(function (category) { return !isNullOrUndefined(category.getMessageNormalized().getICUMessage()); })) {
                    /** @type {?} */
                    var summary = new AutoTranslateSummaryReport(from, to);
                    summary.setIgnored(1);
                    return rxjs.of(summary);
                }
                /** @type {?} */
                var allMessages = categories.map(function (category) { return category.getMessageNormalized().asDisplayString(); });
                return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)
                    .pipe(
                // #94 google translate might return &#.. entity refs, that must be decoded
                operators.map(function (translations) { return translations.map(function (encodedTranslation) { return entityDecoderLib.decode(encodedTranslation); }); }), operators.map(function (translations) {
                    /** @type {?} */
                    var summary = new AutoTranslateSummaryReport(from, to);
                    /** @type {?} */
                    var icuTranslation = {};
                    for (var i = 0; i < translations.length; i++) {
                        icuTranslation[categories[i].getCategory()] = translations[i];
                    }
                    /** @type {?} */
                    var result = _this.autoTranslateICUUnit(tu, icuTranslation);
                    summary.addSingleResult(tu, result);
                    return summary;
                }), operators.catchError(function (err) {
                    /** @type {?} */
                    var failSummary = new AutoTranslateSummaryReport(from, to);
                    failSummary.setError(err.message, allMessages.length);
                    return rxjs.of(failSummary);
                }));
            };
        /**
         * @param {?} tu
         * @param {?} translatedMessage
         * @return {?}
         */
        XliffMergeAutoTranslateService.prototype.autoTranslateNonICUUnit = /**
         * @param {?} tu
         * @param {?} translatedMessage
         * @return {?}
         */
            function (tu, translatedMessage) {
                return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));
            };
        /**
         * @param {?} tu
         * @param {?} translation
         * @return {?}
         */
        XliffMergeAutoTranslateService.prototype.autoTranslateICUUnit = /**
         * @param {?} tu
         * @param {?} translation
         * @return {?}
         */
            function (tu, translation) {
                return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));
            };
        /**
         * @param {?} tu
         * @param {?} translatedMessage
         * @return {?}
         */
        XliffMergeAutoTranslateService.prototype.autoTranslateUnit = /**
         * @param {?} tu
         * @param {?} translatedMessage
         * @return {?}
         */
            function (tu, translatedMessage) {
                /** @type {?} */
                var errors = translatedMessage.validate();
                /** @type {?} */
                var warnings = translatedMessage.validateWarnings();
                if (!isNullOrUndefined(errors)) {
                    return new AutoTranslateResult(false, 'errors detected, not translated');
                }
                else if (!isNullOrUndefined(warnings)) {
                    return new AutoTranslateResult(false, 'warnings detected, not translated');
                }
                else {
                    tu.translate(translatedMessage);
                    return new AutoTranslateResult(true, null); // success
                }
            };
        return XliffMergeAutoTranslateService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Created by martin on 17.02.2017.
     * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.
     *
     */
    var /**
     * Created by martin on 17.02.2017.
     * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.
     *
     */ XliffMerge = /** @class */ (function () {
        function XliffMerge(commandOutput, options) {
            this.commandOutput = commandOutput;
            this.options = options;
            this.parameters = null;
        }
        /**
         * @param {?} argv
         * @return {?}
         */
        XliffMerge.main = /**
         * @param {?} argv
         * @return {?}
         */
            function (argv) {
                /** @type {?} */
                var options = XliffMerge.parseArgs(argv);
                if (options) {
                    new XliffMerge(new CommandOutput(process.stdout), options).run(function (result) {
                        process.exit(result);
                    });
                }
            };
        /**
         * @param {?} argv
         * @return {?}
         */
        XliffMerge.parseArgs = /**
         * @param {?} argv
         * @return {?}
         */
            function (argv) {
                /** @type {?} */
                var options = {
                    languages: []
                };
                for (var i = 1; i < argv.length; i++) {
                    /** @type {?} */
                    var arg = argv[i];
                    if (arg === '--version' || arg === '-version') {
                        console.log('xliffmerge ' + VERSION);
                    }
                    else if (arg === '--verbose' || arg === '-v') {
                        options.verbose = true;
                    }
                    else if (arg === '--profile' || arg === '-p') {
                        i++;
                        if (i >= argv.length) {
                            console.log('missing config file');
                            XliffMerge.showUsage();
                            return null;
                        }
                        else {
                            options.profilePath = argv[i];
                        }
                    }
                    else if (arg === '--quiet' || arg === '-q') {
                        options.quiet = true;
                    }
                    else if (arg === '--help' || arg === '-help' || arg === '-h') {
                        XliffMerge.showUsage();
                    }
                    else if (arg.length > 0 && arg.charAt(0) === '-') {
                        console.log('unknown option');
                        return null;
                    }
                    else {
                        options.languages.push(arg);
                    }
                }
                return options;
            };
        /**
         * @return {?}
         */
        XliffMerge.showUsage = /**
         * @return {?}
         */
            function () {
                console.log('usage: xliffmerge <option>* <language>*');
                console.log('Options');
                console.log('\t-p|--profile a json configuration file containing all relevant parameters.');
                console.log('\t\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');
                console.log('\t-v|--verbose show some output for debugging purposes');
                console.log('\t-q|--quiet only show errors, nothing else');
                console.log('\t-version|--version show version string');
                console.log('');
                console.log('\t<language> has to be a valid language short string, e,g. "en", "de", "de-ch"');
            };
        /**
         * For Tests, create instance with given profile
         * @param commandOutput commandOutput
         * @param options options
         * @param profileContent profileContent
         */
        /**
         * For Tests, create instance with given profile
         * @param {?} commandOutput commandOutput
         * @param {?} options options
         * @param {?=} profileContent profileContent
         * @return {?}
         */
        XliffMerge.createFromOptions = /**
         * For Tests, create instance with given profile
         * @param {?} commandOutput commandOutput
         * @param {?} options options
         * @param {?=} profileContent profileContent
         * @return {?}
         */
            function (commandOutput, options, profileContent) {
                /** @type {?} */
                var instance = new XliffMerge(commandOutput, options);
                instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);
                return instance;
            };
        /**
         * Run the command.
         * This runs async.
         * @param callbackFunction when command is executed, called with the return code (0 for ok), if given.
         * @param errorFunction callbackFunction for error handling
         */
        /**
         * Run the command.
         * This runs async.
         * @param {?=} callbackFunction when command is executed, called with the return code (0 for ok), if given.
         * @param {?=} errorFunction callbackFunction for error handling
         * @return {?}
         */
        XliffMerge.prototype.run = /**
         * Run the command.
         * This runs async.
         * @param {?=} callbackFunction when command is executed, called with the return code (0 for ok), if given.
         * @param {?=} errorFunction callbackFunction for error handling
         * @return {?}
         */
            function (callbackFunction, errorFunction) {
                this.runAsync()
                    .subscribe(function (retcode) {
                    if (!isNullOrUndefined(callbackFunction)) {
                        callbackFunction(retcode);
                    }
                }, function (error) {
                    if (!isNullOrUndefined(errorFunction)) {
                        errorFunction(error);
                    }
                });
            };
        /**
         * Execute merge-Process.
         * @return Async operation, on completion returns retcode 0=ok, other = error.
         */
        /**
         * Execute merge-Process.
         * @return {?} Async operation, on completion returns retcode 0=ok, other = error.
         */
        XliffMerge.prototype.runAsync = /**
         * Execute merge-Process.
         * @return {?} Async operation, on completion returns retcode 0=ok, other = error.
         */
            function () {
                var _this = this;
                var e_1, _a, e_2, _b;
                if (this.options && this.options.quiet) {
                    this.commandOutput.setQuiet();
                }
                if (this.options && this.options.verbose) {
                    this.commandOutput.setVerbose();
                }
                if (!this.parameters) {
                    this.parameters = XliffMergeParameters.createFromOptions(this.options);
                }
                this.commandOutput.info('xliffmerge version %s', VERSION);
                if (this.parameters.verbose()) {
                    this.parameters.showAllParameters(this.commandOutput);
                }
                if (this.parameters.errorsFound.length > 0) {
                    try {
                        for (var _c = __values(this.parameters.errorsFound), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var err = _d.value;
                            this.commandOutput.error(err.message);
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return))
                                _a.call(_c);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    return rxjs.of(-1);
                }
                if (this.parameters.warningsFound.length > 0) {
                    try {
                        for (var _e = __values(this.parameters.warningsFound), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var warn = _f.value;
                            this.commandOutput.warn(warn);
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return))
                                _b.call(_e);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                }
                this.readMaster();
                if (this.parameters.autotranslate()) {
                    this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());
                }
                /** @type {?} */
                var executionForAllLanguages = [];
                this.parameters.languages().forEach(function (lang) {
                    executionForAllLanguages.push(_this.processLanguage(lang));
                });
                return rxjs.forkJoin(executionForAllLanguages).pipe(operators.map(function (retcodes) { return _this.totalRetcode(retcodes); }));
            };
        /**
         * Give an array of retcodes for the different languages, return the total retcode.
         * If all are 0, it is 0, otherwise the first non zero.
         * @param retcodes retcodes
         * @return number
         */
        /**
         * Give an array of retcodes for the different languages, return the total retcode.
         * If all are 0, it is 0, otherwise the first non zero.
         * @param {?} retcodes retcodes
         * @return {?} number
         */
        XliffMerge.prototype.totalRetcode = /**
         * Give an array of retcodes for the different languages, return the total retcode.
         * If all are 0, it is 0, otherwise the first non zero.
         * @param {?} retcodes retcodes
         * @return {?} number
         */
            function (retcodes) {
                for (var i = 0; i < retcodes.length; i++) {
                    if (retcodes[i] !== 0) {
                        return retcodes[i];
                    }
                }
                return 0;
            };
        /**
         * Return the name of the generated file for given lang.
         * @param lang language
         * @return name of generated file
         */
        /**
         * Return the name of the generated file for given lang.
         * @param {?} lang language
         * @return {?} name of generated file
         */
        XliffMerge.prototype.generatedI18nFile = /**
         * Return the name of the generated file for given lang.
         * @param {?} lang language
         * @return {?} name of generated file
         */
            function (lang) {
                return this.parameters.generatedI18nFile(lang);
            };
        /**
         * Return the name of the generated ngx-translation file for given lang.
         * @param lang language
         * @return name of translate file
         */
        /**
         * Return the name of the generated ngx-translation file for given lang.
         * @param {?} lang language
         * @return {?} name of translate file
         */
        XliffMerge.prototype.generatedNgxTranslateFile = /**
         * Return the name of the generated ngx-translation file for given lang.
         * @param {?} lang language
         * @return {?} name of translate file
         */
            function (lang) {
                return this.parameters.generatedNgxTranslateFile(lang);
            };
        /**
         * Warnings found during the run.
         * @return warnings
         */
        /**
         * Warnings found during the run.
         * @return {?} warnings
         */
        XliffMerge.prototype.warnings = /**
         * Warnings found during the run.
         * @return {?} warnings
         */
            function () {
                return this.parameters.warningsFound;
            };
        /**
         * @return {?}
         */
        XliffMerge.prototype.readMaster = /**
         * @return {?}
         */
            function () {
                var _this = this;
                try {
                    this.master = TranslationMessagesFileReader.fromFile(this.parameters.i18nFormat(), this.parameters.i18nFile(), this.parameters.encoding());
                    this.master.warnings().forEach(function (warning) {
                        _this.commandOutput.warn(warning);
                    });
                    /** @type {?} */
                    var count = this.master.numberOfTransUnits();
                    /** @type {?} */
                    var missingIdCount = this.master.numberOfTransUnitsWithMissingId();
                    this.commandOutput.info('master contains %s trans-units', count);
                    if (missingIdCount > 0) {
                        this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);
                    }
                    /** @type {?} */
                    var sourceLang = this.master.sourceLanguage();
                    if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {
                        this.commandOutput.warn('master says to have source-language="%s", should be "%s" (your defaultLanguage)', sourceLang, this.parameters.defaultLanguage());
                        this.master.setSourceLanguage(this.parameters.defaultLanguage());
                        TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());
                        this.commandOutput.warn('changed master source-language="%s" to "%s"', sourceLang, this.parameters.defaultLanguage());
                    }
                }
                catch (err) {
                    if (err instanceof XliffMergeError) {
                        this.commandOutput.error(err.message);
                        return rxjs.of(-1);
                    }
                    else {
                        // unhandled
                        /** @type {?} */
                        var currentFilename = this.parameters.i18nFile();
                        /** @type {?} */
                        var filenameString = (currentFilename) ? util.format('file "%s", ', currentFilename) : '';
                        this.commandOutput.error(filenameString + 'oops ' + err);
                        throw err;
                    }
                }
            };
        /**
         * Process the given language.
         * Async operation.
         * @param lang language
         * @return on completion 0 for ok, other for error
         */
        /**
         * Process the given language.
         * Async operation.
         * @param {?} lang language
         * @return {?} on completion 0 for ok, other for error
         */
        XliffMerge.prototype.processLanguage = /**
         * Process the given language.
         * Async operation.
         * @param {?} lang language
         * @return {?} on completion 0 for ok, other for error
         */
            function (lang) {
                var _this = this;
                this.commandOutput.debug('processing language %s', lang);
                /** @type {?} */
                var languageXliffFile = this.parameters.generatedI18nFile(lang);
                /** @type {?} */
                var currentFilename = languageXliffFile;
                /** @type {?} */
                var result;
                if (!FileUtil.exists(languageXliffFile)) {
                    result = this.createUntranslatedXliff(lang, languageXliffFile);
                }
                else {
                    result = this.mergeMasterTo(lang, languageXliffFile);
                }
                return result
                    .pipe(operators.map(function () {
                    if (_this.parameters.supportNgxTranslate()) {
                        /** @type {?} */
                        var languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(_this.translationFormat(_this.parameters.i18nFormat()), languageXliffFile, _this.parameters.encoding(), _this.master.filename());
                        NgxTranslateExtractor.extract(languageSpecificMessagesFile, _this.parameters.ngxTranslateExtractionPattern(), _this.parameters.generatedNgxTranslateFile(lang));
                    }
                    return 0;
                }), operators.catchError(function (err) {
                    if (err instanceof XliffMergeError) {
                        _this.commandOutput.error(err.message);
                        return rxjs.of(-1);
                    }
                    else {
                        // unhandled
                        /** @type {?} */
                        var filenameString = (currentFilename) ? util.format('file "%s", ', currentFilename) : '';
                        _this.commandOutput.error(filenameString + 'oops ' + err);
                        throw err;
                    }
                }));
            };
        /**
         * create a new file for the language, which contains no translations, but all keys.
         * in principle, this is just a copy of the master with target-language set.
         * @param lang language
         * @param languageXliffFilePath name of file
         */
        /**
         * create a new file for the language, which contains no translations, but all keys.
         * in principle, this is just a copy of the master with target-language set.
         * @param {?} lang language
         * @param {?} languageXliffFilePath name of file
         * @return {?}
         */
        XliffMerge.prototype.createUntranslatedXliff = /**
         * create a new file for the language, which contains no translations, but all keys.
         * in principle, this is just a copy of the master with target-language set.
         * @param {?} lang language
         * @param {?} languageXliffFilePath name of file
         * @return {?}
         */
            function (lang, languageXliffFilePath) {
                var _this = this;
                // copy master ...
                // and set target-language
                // and copy source to target if necessary
                /** @type {?} */
                var isDefaultLang = (lang === this.parameters.defaultLanguage());
                this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
                this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
                /** @type {?} */
                var languageSpecificMessagesFile = this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());
                return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(operators.map(function (summary) {
                    // write it to file
                    TranslationMessagesFileReader.save(languageSpecificMessagesFile, _this.parameters.beautifyOutput());
                    _this.commandOutput.info('created new file "%s" for target-language="%s"', languageXliffFilePath, lang);
                    if (!isDefaultLang) {
                        _this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
                    }
                    return null;
                }));
            };
        /**
         * Map the input format to the format of the translation.
         * Normally they are the same but for xmb the translation format is xtb.
         * @param i18nFormat format
         */
        /**
         * Map the input format to the format of the translation.
         * Normally they are the same but for xmb the translation format is xtb.
         * @param {?} i18nFormat format
         * @return {?}
         */
        XliffMerge.prototype.translationFormat = /**
         * Map the input format to the format of the translation.
         * Normally they are the same but for xmb the translation format is xtb.
         * @param {?} i18nFormat format
         * @return {?}
         */
            function (i18nFormat) {
                if (i18nFormat === ngxI18nsupportLib.FORMAT_XMB) {
                    return ngxI18nsupportLib.FORMAT_XTB;
                }
                else {
                    return i18nFormat;
                }
            };
        /**
         * Merge all
         * @param lang language
         * @param languageXliffFilePath filename
         */
        /**
         * Merge all
         * @param {?} lang language
         * @param {?} languageXliffFilePath filename
         * @return {?}
         */
        XliffMerge.prototype.mergeMasterTo = /**
         * Merge all
         * @param {?} lang language
         * @param {?} languageXliffFilePath filename
         * @return {?}
         */
            function (lang, languageXliffFilePath) {
                var _this = this;
                // read lang specific file
                /** @type {?} */
                var languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFilePath, this.parameters.encoding());
                /** @type {?} */
                var isDefaultLang = (lang === this.parameters.defaultLanguage());
                /** @type {?} */
                var newCount = 0;
                /** @type {?} */
                var correctSourceContentCount = 0;
                /** @type {?} */
                var correctSourceRefCount = 0;
                /** @type {?} */
                var correctDescriptionOrMeaningCount = 0;
                /** @type {?} */
                var idChangedCount = 0;
                languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
                languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
                /** @type {?} */
                var lastProcessedUnit = null;
                this.master.forEachTransUnit(function (masterTransUnit) {
                    /** @type {?} */
                    var transUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);
                    if (!transUnit) {
                        // oops, no translation, must be a new key, so add it
                        /** @type {?} */
                        var newUnit = void 0;
                        if (_this.parameters.allowIdChange()
                            && (newUnit = _this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {
                            lastProcessedUnit = newUnit;
                            idChangedCount++;
                        }
                        else {
                            lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, isDefaultLang, _this.parameters.useSourceAsTarget(), (_this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);
                            newCount++;
                        }
                    }
                    else {
                        // check for changed source content and change it if needed
                        // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.
                        if (transUnit.supportsSetSourceContent() && masterTransUnit.sourceContent() !== transUnit.sourceContent()) {
                            transUnit.setSourceContent(masterTransUnit.sourceContent());
                            if (isDefaultLang) {
                                // #81 changed source must be copied to target for default lang
                                transUnit.translate(masterTransUnit.sourceContent());
                                transUnit.setTargetState(ngxI18nsupportLib.STATE_FINAL);
                            }
                            else {
                                if (transUnit.targetState() === ngxI18nsupportLib.STATE_FINAL) {
                                    // source is changed, so translation has to be checked again
                                    transUnit.setTargetState(ngxI18nsupportLib.STATE_TRANSLATED);
                                }
                            }
                            correctSourceContentCount++;
                        }
                        // check for missing or changed source ref and add it if needed
                        if (transUnit.supportsSetSourceReferences()
                            && !_this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {
                            transUnit.setSourceReferences(masterTransUnit.sourceReferences());
                            correctSourceRefCount++;
                        }
                        // check for changed description or meaning
                        if (transUnit.supportsSetDescriptionAndMeaning()) {
                            /** @type {?} */
                            var changed = false;
                            if (transUnit.description() !== masterTransUnit.description()) {
                                transUnit.setDescription(masterTransUnit.description());
                                changed = true;
                            }
                            if (transUnit.meaning() !== masterTransUnit.meaning()) {
                                transUnit.setMeaning(masterTransUnit.meaning());
                                changed = true;
                            }
                            if (changed) {
                                correctDescriptionOrMeaningCount++;
                            }
                        }
                        lastProcessedUnit = transUnit;
                    }
                });
                if (newCount > 0) {
                    this.commandOutput.warn('merged %s trans-units from master to "%s"', newCount, lang);
                }
                if (correctSourceContentCount > 0) {
                    this.commandOutput.warn('transferred %s changed source content from master to "%s"', correctSourceContentCount, lang);
                }
                if (correctSourceRefCount > 0) {
                    this.commandOutput.warn('transferred %s source references from master to "%s"', correctSourceRefCount, lang);
                }
                if (idChangedCount > 0) {
                    this.commandOutput.warn('found %s changed id\'s in "%s"', idChangedCount, lang);
                }
                if (correctDescriptionOrMeaningCount > 0) {
                    this.commandOutput.warn('transferred %s changed descriptions/meanings from master to "%s"', correctDescriptionOrMeaningCount, lang);
                }
                // remove all elements that are no longer used
                /** @type {?} */
                var removeCount = 0;
                languageSpecificMessagesFile.forEachTransUnit(function (transUnit) {
                    /** @type {?} */
                    var existsInMaster = !isNullOrUndefined(_this.master.transUnitWithId(transUnit.id));
                    if (!existsInMaster) {
                        if (_this.parameters.removeUnusedIds()) {
                            languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);
                        }
                        removeCount++;
                    }
                });
                if (removeCount > 0) {
                    if (this.parameters.removeUnusedIds()) {
                        this.commandOutput.warn('removed %s unused trans-units in "%s"', removeCount, lang);
                    }
                    else {
                        this.commandOutput.warn('keeping %s unused trans-units in "%s", because removeUnused is disabled', removeCount, lang);
                    }
                }
                if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0
                    && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {
                    this.commandOutput.info('file for "%s" was up to date', lang);
                    return rxjs.of(null);
                }
                else {
                    return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)
                        .pipe(operators.map(function () {
                        // write it to file
                        TranslationMessagesFileReader.save(languageSpecificMessagesFile, _this.parameters.beautifyOutput());
                        _this.commandOutput.info('updated file "%s" for target-language="%s"', languageXliffFilePath, lang);
                        if (newCount > 0 && !isDefaultLang) {
                            _this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
                        }
                        return null;
                    }));
                }
            };
        /**
         * Handle the case of changed id due to small white space changes.
         * @param masterTransUnit unit in master file
         * @param languageSpecificMessagesFile translation file
         * @param lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.
         * @return processed unit, if done, null if no changed unit found
         */
        /**
         * Handle the case of changed id due to small white space changes.
         * @param {?} masterTransUnit unit in master file
         * @param {?} languageSpecificMessagesFile translation file
         * @param {?} lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.
         * @return {?} processed unit, if done, null if no changed unit found
         */
        XliffMerge.prototype.processChangedIdUnit = /**
         * Handle the case of changed id due to small white space changes.
         * @param {?} masterTransUnit unit in master file
         * @param {?} languageSpecificMessagesFile translation file
         * @param {?} lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.
         * @return {?} processed unit, if done, null if no changed unit found
         */
            function (masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit) {
                /** @type {?} */
                var masterSourceString = masterTransUnit.sourceContentNormalized().asDisplayString(ngxI18nsupportLib.NORMALIZATION_FORMAT_DEFAULT).trim();
                /** @type {?} */
                var changedTransUnit = null;
                languageSpecificMessagesFile.forEachTransUnit(function (languageTransUnit) {
                    if (languageTransUnit.sourceContentNormalized().asDisplayString(ngxI18nsupportLib.NORMALIZATION_FORMAT_DEFAULT).trim() === masterSourceString) {
                        changedTransUnit = languageTransUnit;
                    }
                });
                if (!changedTransUnit) {
                    return null;
                }
                /** @type {?} */
                var mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, false, false, (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);
                /** @type {?} */
                var translatedContent = changedTransUnit.targetContent();
                if (translatedContent) { // issue #68 set translated only, if it is really translated
                    mergedTransUnit.translate(translatedContent);
                    mergedTransUnit.setTargetState(ngxI18nsupportLib.STATE_TRANSLATED);
                }
                return mergedTransUnit;
            };
        /**
         * @param {?} ref1
         * @param {?} ref2
         * @return {?}
         */
        XliffMerge.prototype.areSourceReferencesEqual = /**
         * @param {?} ref1
         * @param {?} ref2
         * @return {?}
         */
            function (ref1, ref2) {
                if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {
                    return false;
                }
                if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {
                    return true;
                }
                // bot refs are set now, convert to set to compare them
                /** @type {?} */
                var set1 = new Set();
                ref1.forEach(function (ref) { set1.add(ref.sourcefile + ':' + ref.linenumber); });
                /** @type {?} */
                var set2 = new Set();
                ref2.forEach(function (ref) { set2.add(ref.sourcefile + ':' + ref.linenumber); });
                if (set1.size !== set2.size) {
                    return false;
                }
                /** @type {?} */
                var match = true;
                set2.forEach(function (ref) {
                    if (!set1.has(ref)) {
                        match = false;
                    }
                });
                return match;
            };
        /**
         * Auto translate file via Google Translate.
         * Will translate all new units in file.
         * @param from from
         * @param to to
         * @param languageSpecificMessagesFile languageSpecificMessagesFile
         * @return a promise with the execution result as a summary report.
         */
        /**
         * Auto translate file via Google Translate.
         * Will translate all new units in file.
         * @param {?} from from
         * @param {?} to to
         * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
         * @return {?} a promise with the execution result as a summary report.
         */
        XliffMerge.prototype.autoTranslate = /**
         * Auto translate file via Google Translate.
         * Will translate all new units in file.
         * @param {?} from from
         * @param {?} to to
         * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
         * @return {?} a promise with the execution result as a summary report.
         */
            function (from, to, languageSpecificMessagesFile) {
                var _this = this;
                /** @type {?} */
                var serviceCall;
                /** @type {?} */
                var autotranslateEnabled = this.parameters.autotranslateLanguage(to);
                if (autotranslateEnabled) {
                    serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);
                }
                else {
                    serviceCall = rxjs.of(new AutoTranslateSummaryReport(from, to));
                }
                return serviceCall.pipe(operators.map(function (summary) {
                    if (autotranslateEnabled) {
                        if (summary.error() || summary.failed() > 0) {
                            _this.commandOutput.error(summary.content());
                        }
                        else {
                            _this.commandOutput.warn(summary.content());
                        }
                    }
                    return summary;
                }));
            };
        return XliffMerge;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    exports.WriterToString = WriterToString;
    exports.CommandOutput = CommandOutput;
    exports.XliffMerge = XliffMerge;
    exports.XliffmergeModule = XliffmergeModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWkxOG5zdXBwb3J0LW5neC1pMThuc3VwcG9ydC51bWQuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0L2xpYi94bGlmZm1lcmdlLm1vZHVsZS50cyIsIi4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0L2NvbW1vbi91dGlsLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC9jb21tb24vd3JpdGVyLXRvLXN0cmluZy50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvY29tbW9uL2NvbW1hbmQtb3V0cHV0LnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC94bGlmZm1lcmdlL3hsaWZmLW1lcmdlLWVycm9yLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC9jb21tb24vZmlsZS11dGlsLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC94bGlmZm1lcmdlL25neC10cmFuc2xhdGUtZXh0cmFjdGlvbi1wYXR0ZXJuLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC94bGlmZm1lcmdlL25neC10cmFuc2xhdGUtZXh0cmFjdG9yLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC94bGlmZm1lcmdlL3hsaWZmLW1lcmdlLXBhcmFtZXRlcnMudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0L3hsaWZmbWVyZ2UvdmVyc2lvbi50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS94bWwtcmVhZGVyLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC94bGlmZm1lcmdlL3RyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUtcmVhZGVyLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC9hdXRvdHJhbnNsYXRlL2F1dG8tdHJhbnNsYXRlLXNlcnZpY2UudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0L2F1dG90cmFuc2xhdGUvYXV0by10cmFuc2xhdGUtcmVzdWx0LnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC9hdXRvdHJhbnNsYXRlL2F1dG8tdHJhbnNsYXRlLXN1bW1hcnktcmVwb3J0LnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC9hdXRvdHJhbnNsYXRlL3hsaWZmLW1lcmdlLWF1dG8tdHJhbnNsYXRlLXNlcnZpY2UudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0L3hsaWZmbWVyZ2UveGxpZmYtbWVyZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbi8vIG5vdCB1c2VkLCBvbmx5IHRoZXJlIHRvIG1ha2UgbmctcGFja2FnciBoYXBweVxyXG5ATmdNb2R1bGUoe1xyXG4gICAgaW1wb3J0czogW1xyXG4gICAgXSxcclxuICAgIGRlY2xhcmF0aW9uczogW10sXHJcbiAgICBleHBvcnRzOiBbXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgWGxpZmZtZXJnZU1vZHVsZSB7IH1cclxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCIvKipcclxuICogQ29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGFyZSBkZXByZWNhdGVkIGluIG5vZGVzIHV0aWwuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIG5vZGUgaXNOdWxsT3JVbmRlZmluZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWU6IGFueSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXBsYWNlcyBub2RlIGlzU3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlOiBhbnkpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwbGFjZXMgbm9kZSBpc0Jvb2xlYW4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlOiBhbnkpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIG5vZGUgaXNOdW1iZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWU6IGFueSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXBsYWNlcyBub2RlIGlzQXJyYXkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZTogYW55KSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XHJcbn1cclxuIiwiaW1wb3J0IHtXcml0YWJsZX0gZnJvbSAnc3RyZWFtJztcclxuaW1wb3J0IHtpc1N0cmluZ30gZnJvbSAnLi91dGlsJztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDIwLjAyLjIwMTcuXHJcbiAqIEEgaGVscGVyIGNsYXNzIGZvciB0ZXN0aW5nLlxyXG4gKiBDYW4gYmUgdXNlZCBhcyBhIFdyaXRhYmxlU3RyZWFtIGFuZCB3cml0ZXMgZXZlcnl0aGluZyAoc3luY2hyb25vdXNseSkgaW50byBhIHN0cmluZyxcclxuICogdGhhdCBjYW4gZWFzaWx5IGJlIHJlYWQgYnkgdGhlIHRlc3RzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBXcml0ZXJUb1N0cmluZyBleHRlbmRzIFdyaXRhYmxlIHtcclxuXHJcbiAgICBwcml2YXRlIHJlc3VsdFN0cmluZzogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZXN1bHRTdHJpbmcgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX3dyaXRlKGNodW5rOiBhbnksIGVuY29kaW5nOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIGxldCBjaHVua1N0cmluZztcclxuICAgICAgICBpZiAoaXNTdHJpbmcoY2h1bmspKSB7XHJcbiAgICAgICAgICAgIGNodW5rU3RyaW5nID0gY2h1bms7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikge1xyXG4gICAgICAgICAgICBjaHVua1N0cmluZyA9IGNodW5rLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2h1bmtTdHJpbmcgPSBCdWZmZXIuYWxsb2MoY2h1bmspLnRvU3RyaW5nKGVuY29kaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXN1bHRTdHJpbmcgPSB0aGlzLnJlc3VsdFN0cmluZyArIGNodW5rU3RyaW5nO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIGV2ZXJ5dGhpbmcsIHRoYXQgd2FzIHdyaXR0ZW4gdG8gdGhlIHN0cmVhbSBzbyBmYXIuXHJcbiAgICAgKiBAcmV0dXJuIHdyaXR0ZW4gZGF0YVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd3JpdHRlbkRhdGEoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDE3LjAyLjIwMTcuXHJcbiAqIFZlcnkgc2ltcGxlIGNsYXNzIHRvIGNvbnRyb2wgdGhlIG91dHB1dCBvZiBhIGNvbW1hbmQuXHJcbiAqIE91dHB1dCBjYW4gYmUgZXJyb3JzLCB3YXJuaW5ncywgaW5mb3MgYW5kIGRlYnVnLU91dHB1dHMuXHJcbiAqIFRoZSBvdXRwdXQgY2FuIGJlIGNvbnRyb2xsZWQgdmlhIDIgZmxhZ3MsIHF1aWV0IGFuZCB2ZXJib3NlLlxyXG4gKiBJZiBxdWl0IGlzIGVuYWJsZWQgb25seSBlcnJvciBtZXNzYWdlcyBhcmUgc2hvd24uXHJcbiAqIElmIHZlcmJvc2UgaXMgZW5hYmxlZCwgZXZlcnl0aGluZyBpcyBzaG93bi5cclxuICogSWYgYm90aCBhcmUgbm90IGVuYWJsZWQgKHRoZSBkZWZhdWx0KSBlcnJvcnMsIHdhcm5pbmdzIGFuZCBpbmZvcyBhcmUgc2hvd24uXHJcbiAqIElmIG5vdCBhcmUgZW5hYmxlZCAoc3RyYW5nZSksIHdlIGFzc3VtZWQgdGhlIGRlZmF1bHQuXHJcbiAqL1xyXG5cclxuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcclxuaW1wb3J0IFdyaXRhYmxlU3RyZWFtID0gTm9kZUpTLldyaXRhYmxlU3RyZWFtO1xyXG5pbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcblxyXG5lbnVtIExvZ0xldmVsIHtcclxuICAgICdFUlJPUicsXHJcbiAgICAnV0FSTicsXHJcbiAgICAnSU5GTycsXHJcbiAgICAnREVCVUcnXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDb21tYW5kT3V0cHV0IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHZlcmJvc2UgZW5hYmxlcyBvdXRwdXQgb2YgZXZlcnl0aGluZy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIF92ZXJib3NlOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogcXVpZXQgZGlzYWJsZXMgb3V0cHV0IG9mIGV2ZXJ5dGhpbmcgYnV0IGVycm9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIF9xdWlldDogYm9vbGVhbjtcclxuXHJcbiAgICBwcml2YXRlIG91dHB1dFN0cmVhbTogV3JpdGFibGVTdHJlYW07XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc3Rkb3V0PzogV3JpdGFibGVTdHJlYW0pIHtcclxuICAgICAgICB0aGlzLl9xdWlldCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3ZlcmJvc2UgPSBmYWxzZTtcclxuICAgICAgICBpZiAoc3Rkb3V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RyZWFtID0gc3Rkb3V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RyZWFtID0gcHJvY2Vzcy5zdGRvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRWZXJib3NlKCkge1xyXG4gICAgICAgIHRoaXMuX3ZlcmJvc2UgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRRdWlldCgpIHtcclxuICAgICAgICB0aGlzLl9xdWlldCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgdmVyYm9zZSBpcyBlbmFibGVkLlxyXG4gICAgICogQHJldHVybiB3ZXRoZXIgdmVyYm9zZSBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdmVyYm9zZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmVyYm9zZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciBxdWlldCBpcyBlbmFibGVkLlxyXG4gICAgICogQHJldHVybiB3ZXRoZXIgcXVpZXQgaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHF1aWV0KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWlldDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZXJyb3IobXNnLCAuLi5wYXJhbXM6IGFueVtdKSB7XHJcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWwuRVJST1IsIG1zZywgcGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgd2Fybihtc2csIC4uLnBhcmFtczogYW55W10pIHtcclxuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbC5XQVJOLCBtc2csIHBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGluZm8obXNnLCAuLi5wYXJhbXM6IGFueVtdKSB7XHJcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWwuSU5GTywgbXNnLCBwYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZWJ1Zyhtc2csIC4uLnBhcmFtczogYW55W10pIHtcclxuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbC5ERUJVRywgbXNnLCBwYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbG9nKGxldmVsOiBMb2dMZXZlbCwgbXNnLCBwYXJhbXM6IGFueVtdKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzT3V0cHV0RW5hYmxlZChsZXZlbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29sb3JlZE1lc3NhZ2U7XHJcbiAgICAgICAgc3dpdGNoIChsZXZlbCkge1xyXG4gICAgICAgICAgICBjYXNlIExvZ0xldmVsLkVSUk9SOlxyXG4gICAgICAgICAgICAgICAgY29sb3JlZE1lc3NhZ2UgPSBjaGFsay5yZWQoJ0VSUk9SOiAnICsgbXNnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIExvZ0xldmVsLldBUk46XHJcbiAgICAgICAgICAgICAgICBjb2xvcmVkTWVzc2FnZSA9IGNoYWxrLm1hZ2VudGEoJ1dBUk5JTkc6ICcgKyBtc2cpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb2xvcmVkTWVzc2FnZSA9IGNoYWxrLmdyYXkoJyogJyArIG1zZyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3V0TXNnID0gZm9ybWF0KGNvbG9yZWRNZXNzYWdlLCAuLi5wYXJhbXMpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0U3RyZWFtLndyaXRlKG91dE1zZyArICdcXG4nKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGlzT3V0cHV0RW5hYmxlZChsZXZlbDogTG9nTGV2ZWwpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgcXVpZXRFbmFibGVkLCB2ZXJib3NlRW5hYmxlZDogYm9vbGVhbjtcclxuICAgICAgICBpZiAodGhpcy5fcXVpZXQgJiYgdGhpcy5fdmVyYm9zZSkge1xyXG4gICAgICAgICAgICBxdWlldEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmVyYm9zZUVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBxdWlldEVuYWJsZWQgPSB0aGlzLl9xdWlldDtcclxuICAgICAgICAgICAgdmVyYm9zZUVuYWJsZWQgPSB0aGlzLl92ZXJib3NlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XHJcbiAgICAgICAgICAgIGNhc2UgTG9nTGV2ZWwuRVJST1I6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgLy8gYWx3YXlzIG91dHB1dCBlcnJvcnNcclxuICAgICAgICAgICAgY2FzZSBMb2dMZXZlbC5XQVJOOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICghcXVpZXRFbmFibGVkKTtcclxuICAgICAgICAgICAgY2FzZSBMb2dMZXZlbC5JTkZPOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2ZXJib3NlRW5hYmxlZCAmJiAhcXVpZXRFbmFibGVkKTtcclxuICAgICAgICAgICAgY2FzZSBMb2dMZXZlbC5ERUJVRzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJib3NlRW5hYmxlZDtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTcuMDIuMjAxNy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgWGxpZmZNZXJnZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1zZzogc3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIobXNnKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgZXhwbGljaXRseS5cclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgWGxpZmZNZXJnZUVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDE3LjAyLjIwMTcuXHJcbiAqIFNvbWUgKGEgZmV3KSBzaW1wbGUgdXRpbHMgZm9yIGZpbGUgb3BlcmF0aW9ucy5cclxuICogSnVzdCBmb3IgY29udmVuaWVuY2UuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEZpbGVVdGlsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGZvciBleGlzdGVuY2UuXHJcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgZmlsZW5hbWVcclxuICAgICAqIEByZXR1cm4gd2V0aGVyIGZpbGUgZXhpc3RzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZXhpc3RzKGZpbGVuYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gZnMuZXhpc3RzU3luYyhmaWxlbmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGEgZmlsZS5cclxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBmaWxlbmFtZVxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIGVuY29kaW5nXHJcbiAgICAgKiBAcmV0dXJuIGNvbnRlbnQgb2YgZmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWQoZmlsZW5hbWU6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsIGVuY29kaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlIGEgZmlsZSB3aXRoIGdpdmVuIGNvbnRlbnQuXHJcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgZmlsZW5hbWVcclxuICAgICAqIEBwYXJhbSBuZXdDb250ZW50IG5ld0NvbnRlbnRcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyBlbmNvZGluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlcGxhY2VDb250ZW50KGZpbGVuYW1lOiBzdHJpbmcsIG5ld0NvbnRlbnQ6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZykge1xyXG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZW5hbWUsIG5ld0NvbnRlbnQsIHtlbmNvZGluZzogZW5jb2Rpbmd9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNvcHkoc3JjRmlsZTogc3RyaW5nLCBkZXN0RmlsZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgQlVGX0xFTkdUSCA9IDY0ICogMTAyNDtcclxuICAgICAgICBjb25zdCBidWZmID0gQnVmZmVyLmFsbG9jKEJVRl9MRU5HVEgpO1xyXG4gICAgICAgIGNvbnN0IGZkciA9IGZzLm9wZW5TeW5jKHNyY0ZpbGUsICdyJyk7XHJcbiAgICAgICAgY29uc3QgZmR3ID0gZnMub3BlblN5bmMoZGVzdEZpbGUsICd3Jyk7XHJcbiAgICAgICAgbGV0IGJ5dGVzUmVhZCA9IDE7XHJcbiAgICAgICAgbGV0IHBvcyA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGJ5dGVzUmVhZCA+IDApIHtcclxuICAgICAgICAgICAgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmRyLCBidWZmLCAwLCBCVUZfTEVOR1RILCBwb3MpO1xyXG4gICAgICAgICAgICBmcy53cml0ZVN5bmMoZmR3LCBidWZmLCAwLCBieXRlc1JlYWQpO1xyXG4gICAgICAgICAgICBwb3MgKz0gYnl0ZXNSZWFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmcy5jbG9zZVN5bmMoZmRyKTtcclxuICAgICAgICBmcy5jbG9zZVN5bmMoZmR3KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSB0aGUgZm9sZGVyIGFuZCBhbGwgb2YgaXRzIGNvbnRlbnQgKHJtIC1yZikuXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBwYXRoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlRm9sZGVyUmVjdXJzaXZlKHBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBmaWxlcyA9IFtdO1xyXG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHBhdGgpICkge1xyXG4gICAgICAgICAgICBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKHBhdGgpO1xyXG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clBhdGggPSBwYXRoICsgJy8nICsgZmlsZTtcclxuICAgICAgICAgICAgICAgIGlmIChmcy5sc3RhdFN5bmMoY3VyUGF0aCkuaXNEaXJlY3RvcnkoKSkgeyAvLyByZWN1cnNlXHJcbiAgICAgICAgICAgICAgICAgICAgRmlsZVV0aWwuZGVsZXRlRm9sZGVyUmVjdXJzaXZlKGN1clBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZGVsZXRlIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGN1clBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZnMucm1kaXJTeW5jKHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBmb2xkZXJzIGNvbnRlbnQgcmVjdXJzaXZlbHksIGJ1dCBkbyBub3QgZGVsZXRlIGZvbGRlci5cclxuICAgICAqIEZvbGRlciBpcyBsZWZ0IGVtcHR5IGF0IHRoZSBlbmQuXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBwYXRoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlRm9sZGVyQ29udGVudFJlY3Vyc2l2ZShwYXRoOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgZmlsZXMgPSBbXTtcclxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXRoKSApIHtcclxuICAgICAgICAgICAgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhwYXRoKTtcclxuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQYXRoID0gcGF0aCArICcvJyArIGZpbGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnMubHN0YXRTeW5jKGN1clBhdGgpLmlzRGlyZWN0b3J5KCkpIHsgLy8gcmVjdXJzZVxyXG4gICAgICAgICAgICAgICAgICAgIEZpbGVVdGlsLmRlbGV0ZUZvbGRlclJlY3Vyc2l2ZShjdXJQYXRoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGRlbGV0ZSBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhjdXJQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIGEgZmlsZS5cclxuICAgICAqIEBwYXJhbSBwYXRoIHBhdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxldGVGaWxlKHBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGZzLnVubGlua1N5bmMocGF0aCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEhlbHBlciBjbGFzcyB0byBwYXJzZSBuZ3ggdHJhbnNsYXRlIGV4dHJhY3Rpb24gcGF0dGVyblxyXG4gKiBhbmQgdG8gZGVjaWRlIHdldGhlciBhIGdpdmVuIG1lc3NhZ2UgbWF0Y2hlcyB0aGUgcGF0dGVybi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybiB7XHJcblxyXG4gICAgcHJpdmF0ZSBfbWF0Y2hFeHBsaWNpdElkOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBfZGVzY3JpcHRpb25QYXR0ZXJuczogc3RyaW5nW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3QgdGhlIHBhdHRlcm4gZnJvbSBnaXZlbiBkZXNjcmlwdGlvbiBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBleHRyYWN0aW9uUGF0dGVyblN0cmluZyBleHRyYWN0aW9uUGF0dGVyblN0cmluZ1xyXG4gICAgICogQHRocm93cyBhbiBlcnJvciwgaWYgdGhlcmUgaXMgYSBzeW50YXggZXJyb3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBleHRyYWN0aW9uUGF0dGVyblN0cmluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBleHRyYWN0aW9uUGF0dGVyblN0cmluZy5zcGxpdCgnfCcpO1xyXG4gICAgICAgIHRoaXMuX21hdGNoRXhwbGljaXRJZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uUGF0dGVybnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcclxuICAgICAgICAgICAgaWYgKHBhcnQgPT09ICdAQCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaEV4cGxpY2l0SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dHJhY3Rpb24gcGF0dGVybiBtdXN0IG5vdCBjb250YWluIEBAIHR3aWNlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaEV4cGxpY2l0SWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JTdHJpbmcgPSB0aGlzLmNoZWNrVmFsaWREZXNjcmlwdGlvblBhdHRlcm4ocGFydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzY3JpcHRpb25QYXR0ZXJucy5wdXNoKHBhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2ssIHdldGhlciBhbiBleHBsaWNpdGx5IHNldCBpZCBtYXRjaGVzIHRoZSBwYXR0ZXJuLlxyXG4gICAgICogQHBhcmFtIGlkIGlkXHJcbiAgICAgKiBAcmV0dXJuIHdldGhlciBhbiBleHBsaWNpdGx5IHNldCBpZCBtYXRjaGVzIHRoZSBwYXR0ZXJuLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNFeHBsaWNpdElkTWF0Y2hlZChpZDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGlkICYmIHRoaXMuX21hdGNoRXhwbGljaXRJZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrLCB3ZXRoZXIgYSBnaXZlbiBkZXNjcmlwdGlvbiBtYXRjaGVzIHRoZSBwYXR0ZXJuLlxyXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uIGRlc2NyaXB0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHdldGhlciBhIGdpdmVuIGRlc2NyaXB0aW9uIG1hdGNoZXMgdGhlIHBhdHRlcm4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0Rlc2NyaXB0aW9uTWF0Y2hlZChkZXNjcmlwdGlvbjogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0aW9uUGF0dGVybnMuaW5kZXhPZihkZXNjcmlwdGlvbikgPj0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNoZWNrVmFsaWREZXNjcmlwdGlvblBhdHRlcm4oZGVzY3JpcHRpb25QYXR0ZXJuOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICghZGVzY3JpcHRpb25QYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZW1wdHkgdmFsdWUgbm90IGFsbG93ZWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoL15bYS16QS1aX11bYS16QS1aXy1dKiQvLnRlc3QoZGVzY3JpcHRpb25QYXR0ZXJuKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gaXQgaXMgb2tcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2Rlc2NyaXB0aW9uIHBhdHRlcm4gbXVzdCBiZSBhbiBpZGVudGlmaWVyIGNvbnRhaW5pbmcgb25seSBsZXR0ZXJzLCBkaWdpdHMsIF8gb3IgLSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7SVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLCBJVHJhbnNVbml0LCBOT1JNQUxJWkFUSU9OX0ZPUk1BVF9OR1hUUkFOU0xBVEV9IGZyb20gJ0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYic7XHJcbmltcG9ydCB7RmlsZVV0aWx9IGZyb20gJy4uL2NvbW1vbi9maWxlLXV0aWwnO1xyXG5pbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICcuLi9jb21tb24vdXRpbCc7XHJcbmltcG9ydCB7Tmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm59IGZyb20gJy4vbmd4LXRyYW5zbGF0ZS1leHRyYWN0aW9uLXBhdHRlcm4nO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAxNS4wMy4yMDE3LlxyXG4gKiBBIHRvb2wgZm9yIGV4dHJhY3RpbmcgbWVzc2FnZXMgaW4gbmd4LXRyYW5zbGF0ZSBmb3JtYXQuXHJcbiAqIEdlbmVyYXRlcyBhIGpzb24tZmlsZSB0byBiZSB1c2VkIHdpdGggbmd4LXRyYW5zbGF0ZS5cclxuICovXHJcblxyXG4vKipcclxuICogVGhlIGludGVyZmFjZSB1c2VkIGZvciB0cmFuc2xhdGlvbnMgaW4gbmd4LXRyYW5zbGF0ZS5cclxuICogQSBoYXNoIHRoYXQgY29udGFpbnMgZWl0aGVyIHRoZSB0cmFuc2xhdGlvbiBvciBhbm90aGVyIGhhc2guXHJcbiAqL1xyXG5pbnRlcmZhY2UgTmd4VHJhbnNsYXRpb25zIHtcclxuICAgIFtpZDogc3RyaW5nXTogTmd4VHJhbnNsYXRpb25zIHwgc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogaW50ZXJuYWwsXHJcbiAqIGEgbWVzc2FnZSB3aXRoIGlkIChhIGRvdC1zZXBhcmF0ZWQgc3RyaW5nKS5cclxuICovXHJcbmludGVyZmFjZSBOZ3hNZXNzYWdlIHtcclxuICAgIGlkOiBzdHJpbmc7IC8vIGRvdCBzZXBhcmF0ZWQgbmFtZSwgZS5nLiBcIm15YXBwLnNlcnZpY2UxLm1lc3NhZ2UxXCJcclxuICAgIG1lc3NhZ2U6IHN0cmluZzsgLy8gdGhlIG1lc3NhZ2UsIHBsYWNlaG9sZGVyIGFyZSBpbiB7e259fSBzeW50YXgsIGUuZy4gXCJhIHRlc3Qgd2l0aCB2YWx1ZToge3swfX1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE5neFRyYW5zbGF0ZUV4dHJhY3RvciB7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBEZWZhdWx0RXh0cmFjdGlvblBhdHRlcm4gPSAnQEB8bmd4LXRyYW5zbGF0ZSc7XHJcbiAgICBwcml2YXRlIGV4dHJhY3Rpb25QYXR0ZXJuOiBOZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrLCB3ZXRoZXIgZXh0cmFjdGlvblBhdHRlcm4gaGFzIHZhbGlkIHN5bnRheC5cclxuICAgICAqIEBwYXJhbSBleHRyYWN0aW9uUGF0dGVyblN0cmluZyBleHRyYWN0aW9uUGF0dGVyblN0cmluZ1xyXG4gICAgICogQHJldHVybiBudWxsLCBpZiBwYXR0ZXJuIGlzIG9rLCBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZXJyb3IsIGlmIGl0IGlzIG5vdCBvay5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjaGVja1BhdHRlcm4oZXh0cmFjdGlvblBhdHRlcm5TdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmIChuZXcgTmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4oZXh0cmFjdGlvblBhdHRlcm5TdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZXh0cmFjdChtZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSwgZXh0cmFjdGlvblBhdHRlcm46IHN0cmluZywgb3V0cHV0RmlsZTogc3RyaW5nKSB7XHJcbiAgICAgICAgbmV3IE5neFRyYW5zbGF0ZUV4dHJhY3RvcihtZXNzYWdlc0ZpbGUsIGV4dHJhY3Rpb25QYXR0ZXJuKS5leHRyYWN0VG8ob3V0cHV0RmlsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBtZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSwgZXh0cmFjdGlvblBhdHRlcm5TdHJpbmc6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuZXh0cmFjdGlvblBhdHRlcm4gPSBuZXcgTmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4oZXh0cmFjdGlvblBhdHRlcm5TdHJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0YWN0IG1lc3NhZ2VzIGFuZCB3cml0ZSB0aGVtIHRvIGEgZmlsZS5cclxuICAgICAqIEBwYXJhbSBvdXRwdXRGaWxlIG91dHB1dEZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGV4dHJhY3RUbyhvdXRwdXRGaWxlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbnM6IE5neFRyYW5zbGF0aW9ucyA9IHRoaXMudG9OZ3hUcmFuc2xhdGlvbnModGhpcy5leHRyYWN0KCkpO1xyXG4gICAgICAgIGlmICh0cmFuc2xhdGlvbnMgJiYgT2JqZWN0LmtleXModHJhbnNsYXRpb25zKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIEZpbGVVdGlsLnJlcGxhY2VDb250ZW50KG91dHB1dEZpbGUsIEpTT04uc3RyaW5naWZ5KHRyYW5zbGF0aW9ucywgbnVsbCwgNCksICdVVEYtOCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChGaWxlVXRpbC5leGlzdHMob3V0cHV0RmlsZSkpIHtcclxuICAgICAgICAgICAgICAgIEZpbGVVdGlsLmRlbGV0ZUZpbGUob3V0cHV0RmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgRXh0cmFjdCBtZXNzYWdlcyBhbmQgY29udmVydCB0aGVtIHRvIG5neCB0cmFuc2xhdGlvbnMuXHJcbiAgICAgKiAgQHJldHVybiB0aGUgdHJhbnNsYXRpb24gb2JqZWN0cy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBleHRyYWN0KCk6IE5neE1lc3NhZ2VbXSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBOZ3hNZXNzYWdlW10gPSBbXTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VzRmlsZS5mb3JFYWNoVHJhbnNVbml0KCh0dTogSVRyYW5zVW5pdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZ3hJZCA9IHRoaXMubmd4VHJhbnNsYXRlSWRGcm9tVFUodHUpO1xyXG4gICAgICAgICAgICBpZiAobmd4SWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2V0ZXh0ID0gdHUudGFyZ2V0Q29udGVudE5vcm1hbGl6ZWQoKS5hc0Rpc3BsYXlTdHJpbmcoTk9STUFMSVpBVElPTl9GT1JNQVRfTkdYVFJBTlNMQVRFKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtpZDogbmd4SWQsIG1lc3NhZ2U6IG1lc3NhZ2V0ZXh0fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2ssIHdldGhlciB0aGlzIHR1IHNob3VsZCBiZSBleHRyYWN0ZWQgZm9yIG5neC10cmFuc2xhdGUgdXNhZ2UsIGFuZCByZXR1cm4gaXRzIGlkIGZvciBuZ3gtdHJhbnNsYXRlLlxyXG4gICAgICogVGhlcmUgYXJlIDIgcG9zc2liaWxpdGllczpcclxuICAgICAqIDEuIGRlc2NyaXB0aW9uIGlzIHNldCB0byBcIm5neC10cmFuc2xhdGVcIiBhbmQgbWVhbmluZyBjb250YWlucyB0aGUgaWQuXHJcbiAgICAgKiAyLiBpZCBpcyBleHBsaWNpdGx5IHNldCB0byBhIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB0dSB0dVxyXG4gICAgICogQHJldHVybiBhbiBuZ3ggaWQgb3IgbnVsbCwgaWYgdGhpcyB0dSBzaG91bGQgbm90IGJlIGV4dHJhY3RlZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBuZ3hUcmFuc2xhdGVJZEZyb21UVSh0dTogSVRyYW5zVW5pdCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFeHBsaWNpdGx5U2V0SWQodHUuaWQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV4dHJhY3Rpb25QYXR0ZXJuLmlzRXhwbGljaXRJZE1hdGNoZWQodHUuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHUuaWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHR1LmRlc2NyaXB0aW9uKCk7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICYmIHRoaXMuZXh0cmFjdGlvblBhdHRlcm4uaXNEZXNjcmlwdGlvbk1hdGNoZWQoZGVzY3JpcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0dS5tZWFuaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIElEIHdhcyBleHBsaWNpdGx5IHNldCAodmlhIGkxOG49XCJAbXlpZCkuXHJcbiAgICAgKiBKdXN0IGhldXJpc3RpYywgYW4gSUQgaXMgZXhwbGljaXRseSwgaWYgaXQgZG9lcyBub3QgbG9vayBsaWtlIGEgZ2VuZXJhdGVkIG9uZS5cclxuICAgICAqIEBwYXJhbSBpZCBpZFxyXG4gICAgICogQHJldHVybiB3ZXRoZXIgSUQgd2FzIGV4cGxpY2l0bHkgc2V0ICh2aWEgaTE4bj1cIkBteWlkKS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpc0V4cGxpY2l0bHlTZXRJZChpZDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGlkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGdlbmVyYXRlZCBJRHMgYXJlIGVpdGhlciBkZWNpbWFsIG9yIHNoYTEgaGV4XHJcbiAgICAgICAgY29uc3QgcmVGb3JHZW5lcmF0ZWRJZCA9IC9eWzAtOWEtZl17MTEsfSQvO1xyXG4gICAgICAgIHJldHVybiAhcmVGb3JHZW5lcmF0ZWRJZC50ZXN0KGlkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgbGlzdCBvZiByZWxldmFudCBUVXMgdG8gbmd4IHRyYW5zbGF0aW9ucyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gbXNnTGlzdCBtc2dMaXN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdG9OZ3hUcmFuc2xhdGlvbnMobXNnTGlzdDogTmd4TWVzc2FnZVtdKTogTmd4VHJhbnNsYXRpb25zIHtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbk9iamVjdDogTmd4VHJhbnNsYXRpb25zID0ge307XHJcbiAgICAgICAgbXNnTGlzdC5mb3JFYWNoKChtc2c6IE5neE1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wdXRJblRyYW5zbGF0aW9uT2JqZWN0KHRyYW5zbGF0aW9uT2JqZWN0LCBtc2cpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGlvbk9iamVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1dCBhIG5ldyBtZXNzYWdlcyBpbnRvIHRoZSB0cmFuc2xhdGlvbiBkYXRhIG9iamVjdC5cclxuICAgICAqIElmIHlvdSBhZGQsIGUuZy4gXCJ7aWQ6ICdteWFwcC5leGFtcGxlJywgbWVzc2FnZTogJ3Rlc3QnfVwiLFxyXG4gICAgICogdGhlIHRyYW5zbGF0aW9uIG9iamVjdCB3aWxsIHRoZW4gY29udGFpbiBhbiBvYmplY3QgbXlhcHAgdGhhdCBoYXMgcHJvcGVydHkgZXhhbXBsZTpcclxuICAgICAqIHtteWFwcDoge1xyXG4gICAgICogICBleGFtcGxlOiAndGVzdCdcclxuICAgICAqICAgfX1cclxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbk9iamVjdCB0cmFuc2xhdGlvbk9iamVjdFxyXG4gICAgICogQHBhcmFtIG1zZyBtc2dcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwdXRJblRyYW5zbGF0aW9uT2JqZWN0KHRyYW5zbGF0aW9uT2JqZWN0OiBOZ3hUcmFuc2xhdGlvbnMsIG1zZzogTmd4TWVzc2FnZSkge1xyXG4gICAgICAgIGxldCBmaXJzdFBhcnRPZklkOiBzdHJpbmc7XHJcbiAgICAgICAgbGV0IHJlc3RPZklkOiBzdHJpbmc7XHJcbiAgICAgICAgY29uc3QgaW5kZXhPZkRvdCA9IG1zZy5pZC5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgaWYgKGluZGV4T2ZEb3QgPT09IDAgfHwgaW5kZXhPZkRvdCA9PT0gKG1zZy5pZC5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBueGctdHJhbnNsYXRlIGlkIFwiJyArIG1zZy5pZCArICdcIicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5kZXhPZkRvdCA8IDApIHtcclxuICAgICAgICAgICAgZmlyc3RQYXJ0T2ZJZCA9IG1zZy5pZDtcclxuICAgICAgICAgICAgcmVzdE9mSWQgPSAnJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmaXJzdFBhcnRPZklkID0gbXNnLmlkLnN1YnN0cmluZygwLCBpbmRleE9mRG90KTtcclxuICAgICAgICAgICAgcmVzdE9mSWQgPSBtc2cuaWQuc3Vic3RyaW5nKGluZGV4T2ZEb3QgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG9iamVjdCA9IHRyYW5zbGF0aW9uT2JqZWN0W2ZpcnN0UGFydE9mSWRdO1xyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChvYmplY3QpKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN0T2ZJZCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uT2JqZWN0W2ZpcnN0UGFydE9mSWRdID0gbXNnLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uT2JqZWN0W2ZpcnN0UGFydE9mSWRdID0gb2JqZWN0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN0T2ZJZCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHVwbGljYXRlIGlkIHByYWVmaXggXCInICsgbXNnLmlkICsgJ1wiJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wdXRJblRyYW5zbGF0aW9uT2JqZWN0KDxOZ3hUcmFuc2xhdGlvbnM+IG9iamVjdCwge2lkOiByZXN0T2ZJZCwgbWVzc2FnZTogbXNnLm1lc3NhZ2V9KTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTcuMDIuMjAxNy5cclxuICogQ29sbGVjdGlvbiBvZiBhbGwgcGFyYW1ldGVycyB1c2VkIGJ5IHRoZSB0b29sLlxyXG4gKiBUaGUgcGFyYW1ldGVycyBhcmUgcmVhZCBmb3JtIHRoZSBwcm9maWxlIG9yIGRlZmF1bHRzIGFyZSB1c2VkLlxyXG4gKi9cclxuXHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHtYbGlmZk1lcmdlRXJyb3J9IGZyb20gJy4veGxpZmYtbWVyZ2UtZXJyb3InO1xyXG5pbXBvcnQge1N0YXRzfSBmcm9tICdmcyc7XHJcbmltcG9ydCB7Q29tbWFuZE91dHB1dH0gZnJvbSAnLi4vY29tbW9uL2NvbW1hbmQtb3V0cHV0JztcclxuaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge2lzQXJyYXksIGlzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICcuLi9jb21tb24vdXRpbCc7XHJcbmltcG9ydCB7UHJvZ3JhbU9wdGlvbnMsIElDb25maWdGaWxlfSBmcm9tICcuL2kteGxpZmYtbWVyZ2Utb3B0aW9ucyc7XHJcbmltcG9ydCB7RmlsZVV0aWx9IGZyb20gJy4uL2NvbW1vbi9maWxlLXV0aWwnO1xyXG5pbXBvcnQge05neFRyYW5zbGF0ZUV4dHJhY3Rvcn0gZnJvbSAnLi9uZ3gtdHJhbnNsYXRlLWV4dHJhY3Rvcic7XHJcbmltcG9ydCB7ZGlybmFtZSwgaXNBYnNvbHV0ZSwgam9pbiwgbm9ybWFsaXplfSBmcm9tICdwYXRoJztcclxuXHJcbmNvbnN0IFBST0ZJTEVfQ0FORElEQVRFUyA9IFsncGFja2FnZS5qc29uJywgJy5hbmd1bGFyLWNsaS5qc29uJ107XHJcblxyXG5leHBvcnQgY2xhc3MgWGxpZmZNZXJnZVBhcmFtZXRlcnMge1xyXG5cclxuICAgIHByaXZhdGUgdXNlZFByb2ZpbGVQYXRoOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9xdWlldDogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX3ZlcmJvc2U6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9hbGxvd0lkQ2hhbmdlOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBfZGVmYXVsdExhbmd1YWdlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9zcmNEaXI6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2kxOG5CYXNlRmlsZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaTE4bkZpbGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2kxOG5Gb3JtYXQ6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2VuY29kaW5nOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9nZW5EaXI6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2xhbmd1YWdlczogc3RyaW5nW107XHJcbiAgICBwcml2YXRlIF9yZW1vdmVVbnVzZWRJZHM6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9zdXBwb3J0Tmd4VHJhbnNsYXRlOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBfbmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm46IHN0cmluZztcclxuICAgIHByaXZhdGUgX3VzZVNvdXJjZUFzVGFyZ2V0OiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBfdGFyZ2V0UHJhZWZpeDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfdGFyZ2V0U3VmZml4OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9iZWF1dGlmeU91dHB1dDogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX3ByZXNlcnZlT3JkZXI6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9hdXRvdHJhbnNsYXRlOiBib29sZWFufHN0cmluZ1tdO1xyXG4gICAgcHJpdmF0ZSBfYXBpa2V5OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9hcGlrZXlmaWxlOiBzdHJpbmc7XHJcblxyXG4gICAgcHVibGljIGVycm9yc0ZvdW5kOiBYbGlmZk1lcmdlRXJyb3JbXTtcclxuICAgIHB1YmxpYyB3YXJuaW5nc0ZvdW5kOiBzdHJpbmdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBQYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29tbWFuZCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gcHJvZmlsZUNvbnRlbnQgZ2l2ZW4gcHJvZmlsZSAoaWYgbm90LCBpdCBpcyByZWFkIGZyb20gdGhlIHByb2ZpbGUgcGF0aCBmcm9tIG9wdGlvbnMpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZUZyb21PcHRpb25zKG9wdGlvbnM6IFByb2dyYW1PcHRpb25zLCBwcm9maWxlQ29udGVudD86IElDb25maWdGaWxlKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBYbGlmZk1lcmdlUGFyYW1ldGVycygpO1xyXG4gICAgICAgIHBhcmFtZXRlcnMuY29uZmlndXJlKG9wdGlvbnMsIHByb2ZpbGVDb250ZW50KTtcclxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZXJyb3JzRm91bmQgPSBbXTtcclxuICAgICAgICB0aGlzLndhcm5pbmdzRm91bmQgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgcG90ZW50aWFsIHByb2ZpbGUuXHJcbiAgICAgKiBUbyBiZSBhIGNhbmRpZGF0ZSwgZmlsZSBtdXN0IGV4aXN0IGFuZCBjb250YWluIHByb3BlcnR5IFwieGxpZmZtZXJnZU9wdGlvbnNcIi5cclxuICAgICAqIEBwYXJhbSBwcm9maWxlUGF0aCBwYXRoIG9mIHByb2ZpbGVcclxuICAgICAqIEByZXR1cm4gcGFyc2VkIGNvbnRlbnQgb2YgZmlsZSBvciBudWxsLCBpZiBmaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhIHByb2ZpbGUgY2FuZGlkYXRlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkUHJvZmlsZUNhbmRpZGF0ZShwcm9maWxlUGF0aDogc3RyaW5nKTogSUNvbmZpZ0ZpbGUge1xyXG4gICAgICAgIGxldCBjb250ZW50OiBzdHJpbmc7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhwcm9maWxlUGF0aCwgJ1VURi04Jyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJzZWRDb250ZW50OiBJQ29uZmlnRmlsZSA9IEpTT04ucGFyc2UoY29udGVudCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZENvbnRlbnQgJiYgcGFyc2VkQ29udGVudC54bGlmZm1lcmdlT3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkQ29udGVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIG1lIGZyb20gdGhlIHByb2ZpbGUgY29udGVudC5cclxuICAgICAqIChwdWJsaWMgb25seSBmb3IgdGVzdCB1c2FnZSkuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIGdpdmVuIGF0IHJ1bnRpbWUgdmlhIGNvbW1hbmQgbGluZVxyXG4gICAgICogQHBhcmFtIHByb2ZpbGVDb250ZW50IGlmIG51bGwsIHJlYWQgaXQgZnJvbSBwcm9maWxlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNvbmZpZ3VyZShvcHRpb25zOiBQcm9ncmFtT3B0aW9ucywgcHJvZmlsZUNvbnRlbnQ/OiBJQ29uZmlnRmlsZSkge1xyXG4gICAgICAgIHRoaXMuZXJyb3JzRm91bmQgPSBbXTtcclxuICAgICAgICB0aGlzLndhcm5pbmdzRm91bmQgPSBbXTtcclxuICAgICAgICBpZiAoIXByb2ZpbGVDb250ZW50KSB7XHJcbiAgICAgICAgICAgIHByb2ZpbGVDb250ZW50ID0gdGhpcy5yZWFkUHJvZmlsZShvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsaWRQcm9maWxlOiBib29sZWFuID0gKCEhcHJvZmlsZUNvbnRlbnQpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnF1aWV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1aWV0ID0gb3B0aW9ucy5xdWlldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmVyYm9zZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92ZXJib3NlID0gb3B0aW9ucy52ZXJib3NlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsaWRQcm9maWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZyb21Db25maWcocHJvZmlsZUNvbnRlbnQpO1xyXG4gICAgICAgICAgICAvLyBpZiBsYW5ndWFnZXMgYXJlIGdpdmVuIGFzIHBhcmFtZXRlcnMsIHRoZXkgb3Z2ZXJpZGUgZXZlcnl0aGluZyBzYWlkIGluIHByb2ZpbGVcclxuICAgICAgICAgICAgaWYgKCEhb3B0aW9ucy5sYW5ndWFnZXMgJiYgb3B0aW9ucy5sYW5ndWFnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFuZ3VhZ2VzID0gb3B0aW9ucy5sYW5ndWFnZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RlZmF1bHRMYW5ndWFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRMYW5ndWFnZSA9IHRoaXMuX2xhbmd1YWdlc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNoZWNrUGFyYW1ldGVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgcHJvZmlsZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIHByb2dyYW0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB0aGUgcmVhZCBwcm9maWxlIChlbXB0eSwgaWYgbm9uZSwgbnVsbCBpZiBlcnJvcnMpXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVhZFByb2ZpbGUob3B0aW9uczogUHJvZ3JhbU9wdGlvbnMpOiBJQ29uZmlnRmlsZSB7XHJcbiAgICAgICAgY29uc3QgcHJvZmlsZVBhdGg6IHN0cmluZyA9IG9wdGlvbnMucHJvZmlsZVBhdGg7XHJcbiAgICAgICAgaWYgKCFwcm9maWxlUGF0aCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbmZpZ2ZpbGVuYW1lIG9mIFBST0ZJTEVfQ0FORElEQVRFUykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZmlsZSA9IFhsaWZmTWVyZ2VQYXJhbWV0ZXJzLnJlYWRQcm9maWxlQ2FuZGlkYXRlKGNvbmZpZ2ZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VkUHJvZmlsZVBhdGggPSBjb25maWdmaWxlbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvZmlsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb250ZW50OiBzdHJpbmc7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhwcm9maWxlUGF0aCwgJ1VURi04Jyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzRm91bmQucHVzaChuZXcgWGxpZmZNZXJnZUVycm9yKCdjb3VsZCBub3QgcmVhZCBwcm9maWxlIFwiJyArIHByb2ZpbGVQYXRoICsgJ1wiJykpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51c2VkUHJvZmlsZVBhdGggPSBwcm9maWxlUGF0aDtcclxuICAgICAgICBjb25zdCBwcm9maWxlQ29udGVudDogSUNvbmZpZ0ZpbGUgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xyXG4gICAgICAgIC8vIHJlcGxhY2UgYWxsIHBhdGhlcyBpbiBvcHRpb25zIGJ5IGFic29sdXRlIHBhdGhzXHJcbiAgICAgICAgY29uc3QgeGxpZmZtZXJnZU9wdGlvbnMgPSBwcm9maWxlQ29udGVudC54bGlmZm1lcmdlT3B0aW9ucztcclxuICAgICAgICB4bGlmZm1lcmdlT3B0aW9ucy5zcmNEaXIgPSB0aGlzLmFkanVzdFBhdGhUb1Byb2ZpbGVQYXRoKHByb2ZpbGVQYXRoLCB4bGlmZm1lcmdlT3B0aW9ucy5zcmNEaXIpO1xyXG4gICAgICAgIHhsaWZmbWVyZ2VPcHRpb25zLmdlbkRpciA9IHRoaXMuYWRqdXN0UGF0aFRvUHJvZmlsZVBhdGgocHJvZmlsZVBhdGgsIHhsaWZmbWVyZ2VPcHRpb25zLmdlbkRpcik7XHJcbiAgICAgICAgeGxpZmZtZXJnZU9wdGlvbnMuYXBpa2V5ZmlsZSA9IHRoaXMuYWRqdXN0UGF0aFRvUHJvZmlsZVBhdGgocHJvZmlsZVBhdGgsIHhsaWZmbWVyZ2VPcHRpb25zLmFwaWtleWZpbGUpO1xyXG4gICAgICAgIHJldHVybiBwcm9maWxlQ29udGVudDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFkanVzdFBhdGhUb1Byb2ZpbGVQYXRoKHByb2ZpbGVQYXRoOiBzdHJpbmcsIHBhdGhUb0FkanVzdDogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBpZiAoIXBhdGhUb0FkanVzdCB8fCBpc0Fic29sdXRlKHBhdGhUb0FkanVzdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGhUb0FkanVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGpvaW4oZGlybmFtZShwcm9maWxlUGF0aCksIHBhdGhUb0FkanVzdCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZUZyb21Db25maWcocHJvZmlsZUNvbnRlbnQ6IElDb25maWdGaWxlKSB7XHJcbiAgICAgICAgaWYgKCFwcm9maWxlQ29udGVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBwcm9maWxlQ29udGVudC54bGlmZm1lcmdlT3B0aW9ucztcclxuICAgICAgICBpZiAocHJvZmlsZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUucXVpZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlldCA9IHByb2ZpbGUucXVpZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLnZlcmJvc2UpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJib3NlID0gcHJvZmlsZS52ZXJib3NlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5hbGxvd0lkQ2hhbmdlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dJZENoYW5nZSA9IHByb2ZpbGUuYWxsb3dJZENoYW5nZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5kZWZhdWx0TGFuZ3VhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRMYW5ndWFnZSA9IHByb2ZpbGUuZGVmYXVsdExhbmd1YWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmxhbmd1YWdlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFuZ3VhZ2VzID0gcHJvZmlsZS5sYW5ndWFnZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2ZpbGUuc3JjRGlyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcmNEaXIgPSBwcm9maWxlLnNyY0RpcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5hbmd1bGFyQ29tcGlsZXJPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvZmlsZS5hbmd1bGFyQ29tcGlsZXJPcHRpb25zLmdlbkRpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbkRpciA9IHByb2ZpbGUuYW5ndWxhckNvbXBpbGVyT3B0aW9ucy5nZW5EaXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2ZpbGUuZ2VuRGlyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG11c3QgYmUgYWZ0ZXIgYW5ndWxhckNvbXBpbGVyT3B0aW9ucyB0byBiZSBwcmVmZXJyZWRcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dlbkRpciA9IHByb2ZpbGUuZ2VuRGlyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmkxOG5CYXNlRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faTE4bkJhc2VGaWxlID0gcHJvZmlsZS5pMThuQmFzZUZpbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2ZpbGUuaTE4bkZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2kxOG5GaWxlID0gcHJvZmlsZS5pMThuRmlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5pMThuRm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pMThuRm9ybWF0ID0gcHJvZmlsZS5pMThuRm9ybWF0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmVuY29kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGluZyA9IHByb2ZpbGUuZW5jb2Rpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLnJlbW92ZVVudXNlZElkcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVVudXNlZElkcyA9IHByb2ZpbGUucmVtb3ZlVW51c2VkSWRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5zdXBwb3J0Tmd4VHJhbnNsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3VwcG9ydE5neFRyYW5zbGF0ZSA9IHByb2ZpbGUuc3VwcG9ydE5neFRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUubmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybiA9IHByb2ZpbGUubmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLnVzZVNvdXJjZUFzVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlU291cmNlQXNUYXJnZXQgPSBwcm9maWxlLnVzZVNvdXJjZUFzVGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS50YXJnZXRQcmFlZml4KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UHJhZWZpeCA9IHByb2ZpbGUudGFyZ2V0UHJhZWZpeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUudGFyZ2V0U3VmZml4KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0U3VmZml4ID0gcHJvZmlsZS50YXJnZXRTdWZmaXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLmF1dG90cmFuc2xhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvdHJhbnNsYXRlID0gcHJvZmlsZS5hdXRvdHJhbnNsYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5iZWF1dGlmeU91dHB1dCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JlYXV0aWZ5T3V0cHV0ID0gcHJvZmlsZS5iZWF1dGlmeU91dHB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUucHJlc2VydmVPcmRlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXNlcnZlT3JkZXIgPSBwcm9maWxlLnByZXNlcnZlT3JkZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLmFwaWtleSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaWtleSA9IHByb2ZpbGUuYXBpa2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5hcGlrZXlmaWxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpa2V5ZmlsZSA9IHByb2ZpbGUuYXBpa2V5ZmlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3NGb3VuZC5wdXNoKCdkaWQgbm90IGZpbmQgXCJ4bGlmZm1lcmdlT3B0aW9uc1wiIGluIHByb2ZpbGUsIHVzaW5nIGRlZmF1bHRzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgYWxsIFBhcmFtZXRlcnMsIHdldGhlciB0aGV5IGFyZSBjb21wbGV0ZSBhbmQgY29uc2lzdGVudC5cclxuICAgICAqIGlmIHNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIHRoZSBwYXJhbWV0ZXJzLCBpdCBpcyBjb2xsZWN0ZWQgaW4gZXJyb3JzRm91bmQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tQYXJhbWV0ZXJzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY2hlY2tMYW5ndWFnZVN5bnRheCh0aGlzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICBpZiAodGhpcy5sYW5ndWFnZXMoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKG5ldyBYbGlmZk1lcmdlRXJyb3IoJ25vIGxhbmd1YWdlcyBzcGVjaWZpZWQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFuZ3VhZ2VzKCkuZm9yRWFjaCgobGFuZykgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrTGFuZ3VhZ2VTeW50YXgobGFuZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHN0YXRzOiBTdGF0cztcclxuICAgICAgICBsZXQgZXJyOiBhbnk7XHJcbiAgICAgICAgLy8gc3JjRGlyIHNob3VsZCBleGlzdHNcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzdGF0cyA9IGZzLnN0YXRTeW5jKHRoaXMuc3JjRGlyKCkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXJyID0gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhZXJyIHx8ICFzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzRm91bmQucHVzaChuZXcgWGxpZmZNZXJnZUVycm9yKCdzcmNEaXIgXCInICsgdGhpcy5zcmNEaXIoKSArICdcIiBpcyBub3QgYSBkaXJlY3RvcnknKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGdlbkRpciBzaG91bGQgZXhpc3RzXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3RhdHMgPSBmcy5zdGF0U3luYyh0aGlzLmdlbkRpcigpKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGVyciA9IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIWVyciB8fCAhc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2gobmV3IFhsaWZmTWVyZ2VFcnJvcignZ2VuRGlyIFwiJyArIHRoaXMuZ2VuRGlyKCkgKyAnXCIgaXMgbm90IGEgZGlyZWN0b3J5JykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYXN0ZXIgZmlsZSBNVVNUIGV4aXN0XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZnMuYWNjZXNzU3luYyh0aGlzLmkxOG5GaWxlKCksIGZzLmNvbnN0YW50cy5SX09LKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKG5ldyBYbGlmZk1lcmdlRXJyb3IoJ2kxOG5GaWxlIFwiJyArIHRoaXMuaTE4bkZpbGUoKSArICdcIiBpcyBub3QgcmVhZGFibGUnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGkxOG5Gb3JtYXQgbXVzdCBiZSB4bGYgeGxmMiBvciB4bWJcclxuICAgICAgICBpZiAoISh0aGlzLmkxOG5Gb3JtYXQoKSA9PT0gJ3hsZicgfHwgdGhpcy5pMThuRm9ybWF0KCkgPT09ICd4bGYyJyB8fCB0aGlzLmkxOG5Gb3JtYXQoKSA9PT0gJ3htYicpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzRm91bmQucHVzaChuZXcgWGxpZmZNZXJnZUVycm9yKCdpMThuRm9ybWF0IFwiJyArIHRoaXMuaTE4bkZvcm1hdCgpICsgJ1wiIGludmFsaWQsIG11c3QgYmUgXCJ4bGZcIiBvciBcInhsZjJcIiBvciBcInhtYlwiJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhdXRvdHJhbnNsYXRlIHJlcXVpcmVzIGFwaSBrZXlcclxuICAgICAgICBpZiAodGhpcy5hdXRvdHJhbnNsYXRlKCkgJiYgIXRoaXMuYXBpa2V5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKG5ldyBYbGlmZk1lcmdlRXJyb3IoJ2F1dG90cmFuc2xhdGUgcmVxdWlyZXMgYW4gQVBJIGtleSwgcGxlYXNlIHNldCBvbmUnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGF1dG90cmFuc2xhdGVkIGxhbmd1YWdlcyBtdXN0IGJlIGluIGxpc3Qgb2YgYWxsIGxhbmd1YWdlc1xyXG4gICAgICAgIHRoaXMuYXV0b3RyYW5zbGF0ZWRMYW5ndWFnZXMoKS5mb3JFYWNoKChsYW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhbmd1YWdlcygpLmluZGV4T2YobGFuZykgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2gobmV3IFhsaWZmTWVyZ2VFcnJvcignYXV0b3RyYW5zbGF0ZSBsYW5ndWFnZSBcIicgKyBsYW5nICsgJ1wiIGlzIG5vdCBpbiBsaXN0IG9mIGxhbmd1YWdlcycpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZyA9PT0gdGhpcy5kZWZhdWx0TGFuZ3VhZ2UoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBYbGlmZk1lcmdlRXJyb3IoJ2F1dG90cmFuc2xhdGUgbGFuZ3VhZ2UgXCInICsgbGFuZyArICdcIiBjYW5ub3QgYmUgdHJhbnNsYXRlZCwgYmVjYXVzZSBpdCBpcyB0aGUgc291cmNlIGxhbmd1YWdlJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gbmd4IHRyYW5zbGF0ZSBwYXR0ZXJuIGNoZWNrXHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydE5neFRyYW5zbGF0ZSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0ID0gTmd4VHJhbnNsYXRlRXh0cmFjdG9yLmNoZWNrUGF0dGVybih0aGlzLm5neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuKCkpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGNoZWNrUmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBYbGlmZk1lcmdlRXJyb3IoJ25neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuIFwiJyArIHRoaXMubmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4oKSArICdcIjogJyArIGNoZWNrUmVzdWx0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGFyZ2V0UHJhZWZpeCBhbmQgdGFyZ2V0U3VmZml4IGNoZWNrXHJcbiAgICAgICAgaWYgKCF0aGlzLnVzZVNvdXJjZUFzVGFyZ2V0KCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0UHJhZWZpeCgpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3NGb3VuZC5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICdjb25maWd1cmVkIHRhcmdldFByYWVmaXggXCInICsgdGhpcy50YXJnZXRQcmFlZml4KCkgKyAnXCIgd2lsbCBub3QgYmUgdXNlZCBiZWNhdXNlIFwidXNlU291cmNlQXNUYXJnZXRcIiBpcyBkaXNhYmxlZFwiJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0U3VmZml4KCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53YXJuaW5nc0ZvdW5kLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZ3VyZWQgdGFyZ2V0U3VmZml4IFwiJyArIHRoaXMudGFyZ2V0U3VmZml4KCkgKyAnXCIgd2lsbCBub3QgYmUgdXNlZCBiZWNhdXNlIFwidXNlU291cmNlQXNUYXJnZXRcIiBpcyBkaXNhYmxlZFwiJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgc3ludGF4IG9mIGxhbmd1YWdlLlxyXG4gICAgICogTXVzdCBiZSBjb21wYXRpYmxlIHdpdGggWE1MIFNjaGVtYSB0eXBlIHhzZDpsYW5ndWFnZS5cclxuICAgICAqIFBhdHRlcm46IFthLXpBLVpdezEsOH0oKC18XylbYS16QS1aMC05XXsxLDh9KSpcclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlIHRvIGNoZWNrXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tMYW5ndWFnZVN5bnRheChsYW5nOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gL15bYS16QS1aXXsxLDh9KFstX11bYS16QS1aMC05XXsxLDh9KSokLztcclxuICAgICAgICBpZiAoIXBhdHRlcm4udGVzdChsYW5nKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2gobmV3IFhsaWZmTWVyZ2VFcnJvcignbGFuZ3VhZ2UgXCInICsgbGFuZyArICdcIiBpcyBub3QgdmFsaWQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhbGxvd0lkQ2hhbmdlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fYWxsb3dJZENoYW5nZSkpID8gZmFsc2UgOiB0aGlzLl9hbGxvd0lkQ2hhbmdlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2ZXJib3NlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fdmVyYm9zZSkpID8gZmFsc2UgOiB0aGlzLl92ZXJib3NlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBxdWlldCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuX3F1aWV0KSkgPyBmYWxzZSA6IHRoaXMuX3F1aWV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVidWcgb3V0cHV0IGFsbCBwYXJhbWV0ZXJzIHRvIGNvbW1hbmRPdXRwdXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaG93QWxsUGFyYW1ldGVycyhjb21tYW5kT3V0cHV0OiBDb21tYW5kT3V0cHV0KTogdm9pZCB7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygneGxpZmZtZXJnZSBVc2VkIFBhcmFtZXRlcnM6Jyk7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygndXNlZFByb2ZpbGVQYXRoOlxcdFwiJXNcIicsIHRoaXMudXNlZFByb2ZpbGVQYXRoKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdkZWZhdWx0TGFuZ3VhZ2U6XFx0XCIlc1wiJywgdGhpcy5kZWZhdWx0TGFuZ3VhZ2UoKSk7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1Zygnc3JjRGlyOlxcdFwiJXNcIicsIHRoaXMuc3JjRGlyKCkpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ2dlbkRpcjpcXHRcIiVzXCInLCB0aGlzLmdlbkRpcigpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdpMThuQmFzZUZpbGU6XFx0XCIlc1wiJywgdGhpcy5pMThuQmFzZUZpbGUoKSk7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnaTE4bkZpbGU6XFx0XCIlc1wiJywgdGhpcy5pMThuRmlsZSgpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdsYW5ndWFnZXM6XFx0JXMnLCB0aGlzLmxhbmd1YWdlcygpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGxhbmd1YWdlIG9mIHRoaXMubGFuZ3VhZ2VzKCkpIHtcclxuICAgICAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1Zygnb3V0cHV0RmlsZVslc106XFx0JXMnLCBsYW5ndWFnZSwgdGhpcy5nZW5lcmF0ZWRJMThuRmlsZShsYW5ndWFnZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdyZW1vdmVVbnVzZWRJZHM6XFx0JXMnLCB0aGlzLnJlbW92ZVVudXNlZElkcygpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdzdXBwb3J0Tmd4VHJhbnNsYXRlOlxcdCVzJywgdGhpcy5zdXBwb3J0Tmd4VHJhbnNsYXRlKCkpO1xyXG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnROZ3hUcmFuc2xhdGUoKSkge1xyXG4gICAgICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCduZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybjpcXHQlcycsIHRoaXMubmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ3VzZVNvdXJjZUFzVGFyZ2V0OlxcdCVzJywgdGhpcy51c2VTb3VyY2VBc1RhcmdldCgpKTtcclxuICAgICAgICBpZiAodGhpcy51c2VTb3VyY2VBc1RhcmdldCgpKSB7XHJcbiAgICAgICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ3RhcmdldFByYWVmaXg6XFx0XCIlc1wiJywgdGhpcy50YXJnZXRQcmFlZml4KCkpO1xyXG4gICAgICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCd0YXJnZXRTdWZmaXg6XFx0XCIlc1wiJywgdGhpcy50YXJnZXRTdWZmaXgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ2FsbG93SWRDaGFuZ2U6XFx0JXMnLCB0aGlzLmFsbG93SWRDaGFuZ2UoKSk7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnYmVhdXRpZnlPdXRwdXQ6XFx0JXMnLCB0aGlzLmJlYXV0aWZ5T3V0cHV0KCkpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ3ByZXNlcnZlT3JkZXI6XFx0JXMnLCB0aGlzLnByZXNlcnZlT3JkZXIoKSk7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnYXV0b3RyYW5zbGF0ZTpcXHQlcycsIHRoaXMuYXV0b3RyYW5zbGF0ZSgpKTtcclxuICAgICAgICBpZiAodGhpcy5hdXRvdHJhbnNsYXRlKCkpIHtcclxuICAgICAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnYXV0b3RyYW5zbGF0ZWQgbGFuZ3VhZ2VzOlxcdCVzJywgdGhpcy5hdXRvdHJhbnNsYXRlZExhbmd1YWdlcygpKTtcclxuICAgICAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnYXBpa2V5OlxcdCVzJywgdGhpcy5hcGlrZXkoKSA/ICcqKioqJyA6ICdOT1QgU0VUJyk7XHJcbiAgICAgICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ2FwaWtleWZpbGU6XFx0JXMnLCB0aGlzLmFwaWtleWZpbGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdC1MYW5ndWFnZSwgZGVmYXVsdCBlbi5cclxuICAgICAqIEByZXR1cm4gZGVmYXVsdCBsYW5ndWFnZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVmYXVsdExhbmd1YWdlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRMYW5ndWFnZSA/IHRoaXMuX2RlZmF1bHRMYW5ndWFnZSA6ICdlbic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZSBkZXIgenUgYmVhcmJlaXRlbmRlbiBTcHJhY2hlbi5cclxuICAgICAqIEByZXR1cm4gbGFuZ3VhZ2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsYW5ndWFnZXMoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZXMgPyB0aGlzLl9sYW5ndWFnZXMgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHNyYyBkaXJlY3RvcnksIHdoZXJlIHRoZSBtYXN0ZXIgeGxpZiBpcyBsb2NhdGVkLlxyXG4gICAgICogQHJldHVybiBzcmNEaXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNyY0RpcigpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zcmNEaXIgPyB0aGlzLl9zcmNEaXIgOiAnLic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBmaWxlIG5hbWUgb2YgdGhlIHhsaWYgZmlsZSBmb3IgaW5wdXQgYW5kIG91dHB1dC5cclxuICAgICAqIERlZmF1bHQgaXMgbWVzc2FnZXNcclxuICAgICAqIEByZXR1cm4gYmFzZSBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpMThuQmFzZUZpbGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faTE4bkJhc2VGaWxlID8gdGhpcy5faTE4bkJhc2VGaWxlIDogJ21lc3NhZ2VzJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXN0ZXIgeGxpZiBmaWxlICh0aGUgb25lIGdlbmVyYXRlZCBieSBuZy14aTE4bikuXHJcbiAgICAgKiBEZWZhdWx0IGlzIDxzcmNEaXI+LzxpMThuQmFzZUZpbGU+LnhsZi5cclxuICAgICAqIEByZXR1cm4gbWFzdGVyIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGkxOG5GaWxlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGpvaW4odGhpcy5zcmNEaXIoKSxcclxuICAgICAgICAgICAgKHRoaXMuX2kxOG5GaWxlID8gdGhpcy5faTE4bkZpbGUgOiB0aGlzLmkxOG5CYXNlRmlsZSgpICsgJy4nICsgdGhpcy5zdWZmaXhGb3JHZW5lcmF0ZWRJMThuRmlsZSgpKVxyXG4gICAgICAgICkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9ybWF0IG9mIHRoZSBtYXN0ZXIgeGxpZiBmaWxlLlxyXG4gICAgICogRGVmYXVsdCBpcyBcInhsZlwiLCBwb3NzaWJsZSBhcmUgXCJ4bGZcIiBvciBcInhsZjJcIiBvciBcInhtYlwiLlxyXG4gICAgICogQHJldHVybiBmb3JtYXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGkxOG5Gb3JtYXQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2kxOG5Gb3JtYXQgPyB0aGlzLl9pMThuRm9ybWF0IDogJ3hsZicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcG90ZW50aWFsbHkgdG8gYmUgZ2VuZXJhdGVkIEkxOG4tRmlsZSB3aXRoIHRoZSB0cmFuc2xhdGlvbnMgZm9yIG9uZSBsYW5ndWFnZS5cclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlIHNob3J0Y3V0XHJcbiAgICAgKiBAcmV0dXJuIFBhdGggb2YgZmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVkSTE4bkZpbGUobGFuZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gam9pbih0aGlzLmdlbkRpcigpLCB0aGlzLmkxOG5CYXNlRmlsZSgpICsgJy4nICsgbGFuZyArICcuJyArIHRoaXMuc3VmZml4Rm9yR2VuZXJhdGVkSTE4bkZpbGUoKSkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3VmZml4Rm9yR2VuZXJhdGVkSTE4bkZpbGUoKTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuaTE4bkZvcm1hdCgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3hsZic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3hsZic7XHJcbiAgICAgICAgICAgIGNhc2UgJ3hsZjInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd4bGYnO1xyXG4gICAgICAgICAgICBjYXNlICd4bWInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd4dGInO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHBvdGVudGlhbGx5IHRvIGJlIGdlbmVyYXRlZCB0cmFuc2xhdGUtRmlsZSBmb3Igbmd4LXRyYW5zbGF0ZSB3aXRoIHRoZSB0cmFuc2xhdGlvbnMgZm9yIG9uZSBsYW5ndWFnZS5cclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlIHNob3J0Y3V0XHJcbiAgICAgKiBAcmV0dXJuIFBhdGggb2YgZmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVkTmd4VHJhbnNsYXRlRmlsZShsYW5nOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBqb2luKHRoaXMuZ2VuRGlyKCksIHRoaXMuaTE4bkJhc2VGaWxlKCkgKyAnLicgKyBsYW5nICsgJy4nICsgJ2pzb24nKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW5jb2RpbmcgdXNlZCB0byB3cml0ZSBuZXcgWExJRkYtZmlsZXMuXHJcbiAgICAgKiBAcmV0dXJuIGVuY29kaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmNvZGluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZyA/IHRoaXMuX2VuY29kaW5nIDogJ1VURi04JztcclxuICAgIH1cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgICogT3V0cHV0LURpcmVjdG9yeSwgd2hlcmUgdGhlIG91dHB1dCBpcyB3cml0dGVuIHRvLlxyXG4gICAgICAqIERlZmF1bHQgaXMgPHNyY0Rpcj4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZW5EaXIoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuRGlyID8gdGhpcy5fZ2VuRGlyIDogdGhpcy5zcmNEaXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVtb3ZlVW51c2VkSWRzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fcmVtb3ZlVW51c2VkSWRzKSkgPyB0cnVlIDogdGhpcy5fcmVtb3ZlVW51c2VkSWRzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdXBwb3J0Tmd4VHJhbnNsYXRlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fc3VwcG9ydE5neFRyYW5zbGF0ZSkpID8gZmFsc2UgOiB0aGlzLl9zdXBwb3J0Tmd4VHJhbnNsYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBuZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybigpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fbmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4pKSA/XHJcbiAgICAgICAgICAgIE5neFRyYW5zbGF0ZUV4dHJhY3Rvci5EZWZhdWx0RXh0cmFjdGlvblBhdHRlcm4gOiB0aGlzLl9uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgc291cmNlIG11c3QgYmUgdXNlZCBhcyB0YXJnZXQgZm9yIG5ldyB0cmFucy11bml0c1xyXG4gICAgICogRGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VTb3VyY2VBc1RhcmdldCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuX3VzZVNvdXJjZUFzVGFyZ2V0KSkgPyB0cnVlIDogdGhpcy5fdXNlU291cmNlQXNUYXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmFlZml4IHVzZWQgZm9yIHRhcmdldCB3aGVuIGNvcHlpbmcgbmV3IHRyYW5zLXVuaXRzXHJcbiAgICAgKiBEZWZhdWx0IGlzIFwiXCJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldFByYWVmaXgoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuX3RhcmdldFByYWVmaXgpKSA/ICcnIDogdGhpcy5fdGFyZ2V0UHJhZWZpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1ZmZpeCB1c2VkIGZvciB0YXJnZXQgd2hlbiBjb3B5aW5nIG5ldyB0cmFucy11bml0c1xyXG4gICAgICogRGVmYXVsdCBpcyBcIlwiXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRTdWZmaXgoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuX3RhcmdldFN1ZmZpeCkpID8gJycgOiB0aGlzLl90YXJnZXRTdWZmaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBzZXQsIHJ1biB4bWwgcmVzdWx0IHRocm91Z2ggYmVhdXRpZmllciAocHJldHR5LWRhdGEpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYmVhdXRpZnlPdXRwdXQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9iZWF1dGlmeU91dHB1dCkpID8gZmFsc2UgOiB0aGlzLl9iZWF1dGlmeU91dHB1dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCwgb3JkZXIgb2YgbmV3IHRyYW5zIHVuaXRzIHdpbGwgYmUgYXMgaW4gbWFzdGVyLlxyXG4gICAgICogT3RoZXJ3aXNlIHRoZXkgYXJlIGFkZGVkIGF0IHRoZSBlbmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwcmVzZXJ2ZU9yZGVyKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fcHJlc2VydmVPcmRlcikpID8gdHJ1ZSA6IHRoaXMuX3ByZXNlcnZlT3JkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHVzZSBhdXRvdHJhbnNsYXRlIGZvciBuZXcgdHJhbnMtdW5pdHNcclxuICAgICAqIERlZmF1bHQgaXMgZmFsc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGF1dG90cmFuc2xhdGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuX2F1dG90cmFuc2xhdGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkodGhpcy5fYXV0b3RyYW5zbGF0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICg8c3RyaW5nW10+dGhpcy5fYXV0b3RyYW5zbGF0ZSkubGVuZ3RoID4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxib29sZWFuPiB0aGlzLl9hdXRvdHJhbnNsYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byB1c2UgYXV0b3RyYW5zbGF0ZSBmb3IgYSBnaXZlbiBsYW5ndWFnZS5cclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlIGNvZGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhdXRvdHJhbnNsYXRlTGFuZ3VhZ2UobGFuZzogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b3RyYW5zbGF0ZWRMYW5ndWFnZXMoKS5pbmRleE9mKGxhbmcpID49IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBsaXN0IG9mIGxhbmd1YWdlcyB0byBiZSBhdXRvdHJhbnNsYXRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGF1dG90cmFuc2xhdGVkTGFuZ3VhZ2VzKCk6IHN0cmluZ1tdIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fYXV0b3RyYW5zbGF0ZSkgfHwgdGhpcy5fYXV0b3RyYW5zbGF0ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheSh0aGlzLl9hdXRvdHJhbnNsYXRlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKDxzdHJpbmdbXT50aGlzLl9hdXRvdHJhbnNsYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VzKCkuc2xpY2UoMSk7IC8vIGZpcnN0IGlzIHNvdXJjZSBsYW5ndWFnZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQVBJIGtleSB0byBiZSB1c2VkIGZvciBHb29nbGUgVHJhbnNsYXRlXHJcbiAgICAgKiBAcmV0dXJuIGFwaSBrZXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFwaWtleSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fYXBpa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpa2V5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwaWtleVBhdGggPSB0aGlzLmFwaWtleWZpbGUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBpa2V5ZmlsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhhcGlrZXlQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWxlVXRpbC5yZWFkKGFwaWtleVBhdGgsICd1dGYtOCcpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdhcGkga2V5IGZpbGUgbm90IGZvdW5kOiBBUElfS0VZX0ZJTEU9JXMnLCBhcGlrZXlQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGZpbGUgbmFtZSBmb3IgQVBJIGtleSB0byBiZSB1c2VkIGZvciBHb29nbGUgVHJhbnNsYXRlLlxyXG4gICAgICogRXhwbGljaXRseSBzZXQgb3IgcmVhZCBmcm9tIGVudiB2YXIgQVBJX0tFWV9GSUxFLlxyXG4gICAgICogQHJldHVybiBmaWxlIG9mIGFwaSBrZXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFwaWtleWZpbGUoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5fYXBpa2V5ZmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpa2V5ZmlsZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LkFQSV9LRVlfRklMRSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQVBJX0tFWV9GSUxFO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTkuMDIuMjAxNy5cclxuICovXHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG5sZXQgcGtnID0gbnVsbDtcclxudHJ5IHtcclxuICAgIHBrZyA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJ3BhY2thZ2UuanNvbicpKTtcclxufSBjYXRjaCAoZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBwa2cgPSByZXF1aXJlKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLicsICcuLicsICdwYWNrYWdlLmpzb24nKSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcGtnID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAocGtnID8gcGtnLnZlcnNpb24gOiAndW5rbm93bicpO1xyXG4iLCJpbXBvcnQge0ZpbGVVdGlsfSBmcm9tICcuLi9jb21tb24vZmlsZS11dGlsJztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDEwLjAzLjIwMTcuXHJcbiAqIEhlbHBlciBjbGFzcyB0byByZWFkIFhNbCB3aXRoIGEgY29ycmVjdCBlbmNvZGluZy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgWG1sUmVhZGVyIHtcclxuICAgIHN0YXRpYyBERUZBVUxUX0VOQ09ESU5HID0gJ1VURi04JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYW4geG1sLUZpbGUuXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBQYXRoIHRvIGZpbGVcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyBvcHRpb25hbCBlbmNvZGluZyBvZiB0aGUgeG1sLlxyXG4gICAgICogVGhpcyBpcyByZWFkIGZyb20gdGhlIGZpbGUsIGJ1dCBpZiB5b3Uga25vdyBpdCBiZWZvcmUsIHlvdSBjYW4gYXZvaWQgcmVhZGluZyB0aGUgZmlsZSB0d2ljZS5cclxuICAgICAqIEByZXR1cm4gZmlsZSBjb250ZW50IGFuZCBlbmNvZGluZyBmb3VuZCBpbiB0aGUgZmlsZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkWG1sRmlsZUNvbnRlbnQocGF0aDogc3RyaW5nLCBlbmNvZGluZz86IHN0cmluZyk6IHtjb250ZW50OiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmd9IHtcclxuICAgICAgICBpZiAoIWVuY29kaW5nKSB7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gWG1sUmVhZGVyLkRFRkFVTFRfRU5DT0RJTkc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb250ZW50OiBzdHJpbmcgPSBGaWxlVXRpbC5yZWFkKHBhdGgsIGVuY29kaW5nKTtcclxuICAgICAgICBjb25zdCBmb3VuZEVuY29kaW5nID0gWG1sUmVhZGVyLmVuY29kaW5nRnJvbVhtbChjb250ZW50KTtcclxuICAgICAgICBpZiAoZm91bmRFbmNvZGluZyAhPT0gZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgLy8gcmVhZCBhZ2FpbiB3aXRoIHRoZSBjb3JyZWN0IGVuY29kaW5nXHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBGaWxlVXRpbC5yZWFkKHBhdGgsIGZvdW5kRW5jb2RpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxyXG4gICAgICAgICAgICBlbmNvZGluZzogZm91bmRFbmNvZGluZ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIHRoZSBlbmNvZGluZyBmcm9tIHRoZSB4bWwuXHJcbiAgICAgKiB4bWwgRmlsZSBzdGFydHMgd2l0aCAuLiBlbmNvZGluZz1cIi4uXCJcclxuICAgICAqIEBwYXJhbSB4bWxTdHJpbmcgeG1sU3RyaW5nXHJcbiAgICAgKiBAcmV0dXJuIGVuY29kaW5nXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGVuY29kaW5nRnJvbVhtbCh4bWxTdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB4bWxTdHJpbmcuaW5kZXhPZignZW5jb2Rpbmc9XCInKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkRFRkFVTFRfRU5DT0RJTkc7IC8vIGRlZmF1bHQgaW4geG1sIGlmIG5vdCBleHBsaWNpdGx5IHNldFxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHhtbFN0cmluZy5pbmRleE9mKCdcIicsIGluZGV4ICsgMTApOyAvLyAxMCA9IGxlbmd0aCBvZiAnZW5jb2Rpbmc9XCInXHJcbiAgICAgICAgcmV0dXJuIHhtbFN0cmluZy5zdWJzdHJpbmcoaW5kZXggKyAxMCwgZW5kSW5kZXgpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMjEuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCB7VHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5LCBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGV9IGZyb20gJ0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYic7XHJcbmltcG9ydCB7RmlsZVV0aWx9IGZyb20gJy4uL2NvbW1vbi9maWxlLXV0aWwnO1xyXG5pbXBvcnQge1htbFJlYWRlcn0gZnJvbSAnLi94bWwtcmVhZGVyJztcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgdG8gcmVhZCB0cmFuc2xhdGlvbiBmaWxlcyBkZXBlbmRpbmcgb24gZm9ybWF0LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgZmlsZSBmdW5jdGlvbiwgcmVzdWx0IGRlcGVuZHMgb24gZm9ybWF0LCBlaXRoZXIgWGxpZmZGaWxlIG9yIFhtYkZpbGUuXHJcbiAgICAgKiBAcGFyYW0gaTE4bkZvcm1hdCBmb3JtYXRcclxuICAgICAqIEBwYXJhbSBwYXRoIHBhdGhcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyBlbmNvZGluZ1xyXG4gICAgICogQHBhcmFtIG9wdGlvbmFsTWFzdGVyRmlsZVBhdGggb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aFxyXG4gICAgICogQHJldHVybiBYbGlmZkZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmcm9tRmlsZShpMThuRm9ybWF0OiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aD86IHN0cmluZyk6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgY29uc3QgeG1sQ29udGVudCA9IFhtbFJlYWRlci5yZWFkWG1sRmlsZUNvbnRlbnQocGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsTWFzdGVyID0gVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIubWFzdGVyRmlsZUNvbnRlbnQob3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIHJldHVybiBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZUZhY3RvcnkuZnJvbUZpbGVDb250ZW50KGkxOG5Gb3JtYXQsIHhtbENvbnRlbnQuY29udGVudCwgcGF0aCwgeG1sQ29udGVudC5lbmNvZGluZywgb3B0aW9uYWxNYXN0ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBmaWxlIGZ1bmN0aW9uLCByZXN1bHQgZGVwZW5kcyBvbiBmb3JtYXQsIGVpdGhlciBYbGlmZkZpbGUgb3IgWG1iRmlsZS5cclxuICAgICAqIEBwYXJhbSBwYXRoIHBhdGhcclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyBlbmNvZGluZ1xyXG4gICAgICogQHBhcmFtIG9wdGlvbmFsTWFzdGVyRmlsZVBhdGggb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aFxyXG4gICAgICogQHJldHVybiBYbGlmZkZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmcm9tVW5rbm93bkZvcm1hdEZpbGUocGF0aDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsTWFzdGVyRmlsZVBhdGg/OiBzdHJpbmcpOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUge1xyXG4gICAgICAgIGNvbnN0IHhtbENvbnRlbnQgPSBYbWxSZWFkZXIucmVhZFhtbEZpbGVDb250ZW50KHBhdGgsIGVuY29kaW5nKTtcclxuICAgICAgICBjb25zdCBvcHRpb25hbE1hc3RlciA9IFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyLm1hc3RlckZpbGVDb250ZW50KG9wdGlvbmFsTWFzdGVyRmlsZVBhdGgsIGVuY29kaW5nKTtcclxuICAgICAgICByZXR1cm4gVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVGYWN0b3J5LmZyb21Vbmtub3duRm9ybWF0RmlsZUNvbnRlbnQoeG1sQ29udGVudC5jb250ZW50LCBwYXRoLCB4bWxDb250ZW50LmVuY29kaW5nLCBvcHRpb25hbE1hc3Rlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIG1hc3RlciB4bWIgZmlsZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbmFsTWFzdGVyRmlsZVBhdGggb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aFxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIGVuY29kaW5nXHJcbiAgICAgKiBAcmV0dXJuIGNvbnRlbnQgYW5kIGVuY29kaW5nIG9mIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbWFzdGVyRmlsZUNvbnRlbnQob3B0aW9uYWxNYXN0ZXJGaWxlUGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKVxyXG4gICAgICAgIDoge3htbENvbnRlbnQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nfSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbmFsTWFzdGVyRmlsZVBhdGgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWFzdGVyWG1sQ29udGVudCA9IFhtbFJlYWRlci5yZWFkWG1sRmlsZUNvbnRlbnQob3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeG1sQ29udGVudDogbWFzdGVyWG1sQ29udGVudC5jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgcGF0aDogb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCxcclxuICAgICAgICAgICAgICAgIGVuY29kaW5nOiBtYXN0ZXJYbWxDb250ZW50LmVuY29kaW5nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBlZGl0ZWQgZmlsZS5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlc0ZpbGUgbWVzc2FnZXNGaWxlXHJcbiAgICAgKiBAcGFyYW0gYmVhdXRpZnlPdXRwdXQgRmxhZyB3aGV0aGVyIHRvIHVzZSBwcmV0dHktZGF0YSB0byBmb3JtYXQgdGhlIG91dHB1dC5cclxuICAgICAqIFhNTFNlcmlhbGl6ZXIgcHJvZHVjZXMgc29tZSBjb3JyZWN0IGJ1dCBzdHJhbmdlbHkgZm9ybWF0dGVkIG91dHB1dCwgd2hpY2ggcHJldHR5LWRhdGEgY2FuIGNvcnJlY3QuXHJcbiAgICAgKiBTZWUgaXNzdWUgIzY0IGZvciBkZXRhaWxzLlxyXG4gICAgICogRGVmYXVsdCBpcyBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzYXZlKG1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLCBiZWF1dGlmeU91dHB1dD86IGJvb2xlYW4pIHtcclxuICAgICAgICBGaWxlVXRpbC5yZXBsYWNlQ29udGVudChtZXNzYWdlc0ZpbGUuZmlsZW5hbWUoKSwgbWVzc2FnZXNGaWxlLmVkaXRlZENvbnRlbnQoYmVhdXRpZnlPdXRwdXQpLCBtZXNzYWdlc0ZpbGUuZW5jb2RpbmcoKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCB7Zm9ybWF0fSBmcm9tICd1dGlsJztcclxuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICdyZXF1ZXN0JztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHtvZiwgZm9ya0pvaW4sIHRocm93RXJyb3J9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge21hcH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgcm9vYm0gb24gMDMuMDcuMjAxNy5cclxuICogTG93IExldmVsIFNlcnZpY2UgdG8gY2FsbCBHb29nbGUgVHJhbnNsYXRlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUeXBlcyBmb3JtIGdvb2dsZSB0cmFuc2xhdGUgYXBpLlxyXG4gKi9cclxuXHJcbmludGVyZmFjZSBHZXRTdXBwb3J0ZWRMYW5ndWFnZXNSZXF1ZXN0IHtcclxuICAgIHRhcmdldDogc3RyaW5nOyAvLyBUaGUgbGFuZ3VhZ2UgdG8gdXNlIHRvIHJldHVybiBsb2NhbGl6ZWQsIGh1bWFuIHJlYWRhYmxlIG5hbWVzIG9mIHN1cHBvcnRlZFxcbmxhbmd1YWdlcy5cclxufVxyXG5cclxuaW50ZXJmYWNlIExhbmd1YWdlc1Jlc291cmNlIHtcclxuICAgIGxhbmd1YWdlOiBzdHJpbmc7IC8vIGNvZGUgb2YgdGhlIGxhbmd1YWdlXHJcbiAgICBuYW1lOiBzdHJpbmc7IC8vIGh1bWFuIHJlYWRhYmxlIG5hbWUgKGluIHRhcmdldCBsYW5ndWFnZSlcclxufVxyXG5cclxuaW50ZXJmYWNlIExhbmd1YWdlc0xpc3RSZXNwb25zZSB7XHJcbiAgICBsYW5ndWFnZXM6IExhbmd1YWdlc1Jlc291cmNlW107XHJcbn1cclxuXHJcbmludGVyZmFjZSBUcmFuc2xhdGVUZXh0UmVxdWVzdCB7XHJcbiAgICBxOiBzdHJpbmdbXTsgIC8vIFRoZSBpbnB1dCB0ZXh0cyB0byB0cmFuc2xhdGVcclxuICAgIHRhcmdldDogc3RyaW5nOyAvLyBUaGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciB0cmFuc2xhdGlvbiBvZiB0aGUgaW5wdXQgdGV4dFxyXG4gICAgc291cmNlOiBzdHJpbmc7IC8vIFRoZSBsYW5ndWFnZSBvZiB0aGUgc291cmNlIHRleHRcclxuICAgIGZvcm1hdD86IHN0cmluZzsgLy8gXCJodG1sXCIgKGRlZmF1bHQpIG9yIFwidGV4dFwiXHJcbiAgICBtb2RlbD86IHN0cmluZzsgLy8gc2VlIHB1YmxpYyBkb2N1bWVudGF0aW9uXHJcbn1cclxuXHJcbmludGVyZmFjZSBUcmFuc2xhdGlvbnNSZXNvdXJjZSB7XHJcbiAgICBkZXRlY3RlZFNvdXJjZUxhbmd1YWdlPzogc3RyaW5nO1xyXG4gICAgbW9kZWw/OiBzdHJpbmc7XHJcbiAgICB0cmFuc2xhdGVkVGV4dDogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVHJhbnNsYXRpb25zTGlzdFJlc3BvbnNlIHtcclxuICAgIHRyYW5zbGF0aW9uczogVHJhbnNsYXRpb25zUmVzb3VyY2VbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIEludGVybmFsUmVxdWVzdFJlc3BvbnNlIHtcclxuICAgIHJlc3BvbnNlOiByZXF1ZXN0LlJlcXVlc3RSZXNwb25zZTtcclxuICAgIGJvZHk6IGFueTtcclxufVxyXG5cclxuY29uc3QgTUFYX1NFR01FTlRTID0gMTI4O1xyXG5cclxuZXhwb3J0IGNsYXNzIEF1dG9UcmFuc2xhdGVTZXJ2aWNlIHtcclxuXHJcbiAgICBwcml2YXRlIF9yZXF1ZXN0OiByZXF1ZXN0LlJlcXVlc3RBUEk8cmVxdWVzdC5SZXF1ZXN0LCByZXF1ZXN0LkNvcmVPcHRpb25zLCByZXF1ZXN0LlJlcXVpcmVkVXJpVXJsPjtcclxuICAgIF9yb290VXJsOiBzdHJpbmc7XHJcbiAgICBfYXBpS2V5OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpcCByZWdpb24gY29kZSBhbmQgY29udmVydCB0byBsb3dlclxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ1xyXG4gICAgICogQHJldHVybiBsYW5nIHdpdGhvdXQgcmVnaW9uIGNvZGUgYW5kIGluIGxvd2VyIGNhc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RyaXBSZWdpb25jb2RlKGxhbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgbGFuZ0xvd2VyID0gbGFuZy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFuZ0xvd2VyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBsYW5nTG93ZXIuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICBpZiAoYyA8ICdhJyB8fCBjID4gJ3onKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ0xvd2VyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGFuZ0xvd2VyO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwaUtleTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3Q7XHJcbiAgICAgICAgdGhpcy5fYXBpS2V5ID0gYXBpS2V5O1xyXG4gICAgICAgIHRoaXMuX3Jvb3RVcmwgPSAnaHR0cHM6Ly90cmFuc2xhdGlvbi5nb29nbGVhcGlzLmNvbS8nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIEFQSSBrZXkgKGp1c3QgZm9yIHRlc3RzKS5cclxuICAgICAqIEBwYXJhbSBhcGlrZXkgYXBpa2V5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRBcGlLZXkoYXBpa2V5OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9hcGlLZXkgPSBhcGlrZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGUgYW4gYXJyYXkgb2YgbWVzc2FnZXMgYXQgb25jZS5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyB0aGUgbWVzc2FnZXMgdG8gYmUgdHJhbnNsYXRlZFxyXG4gICAgICogQHBhcmFtIGZyb20gc291cmNlIGxhbmd1YWdlIGNvZGVcclxuICAgICAqIEBwYXJhbSB0byB0YXJnZXQgbGFuZ3VhZ2UgY29kZVxyXG4gICAgICogQHJldHVybiBPYnNlcnZhYmxlIHdpdGggdHJhbnNsYXRlZCBtZXNzYWdlcyBvciBlcnJvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlTXVsdGlwbGVTdHJpbmdzKG1lc3NhZ2VzOiBzdHJpbmdbXSwgZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nKTogT2JzZXJ2YWJsZTxzdHJpbmdbXT4ge1xyXG4gICAgICAgIC8vIGVtcHR5IGFycmF5IG5lZWRzIG5vIHRyYW5zbGF0aW9uIGFuZCBhbHdheXMgd29ya3MgLi4uICgjNzgpXHJcbiAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2YoW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2FwaUtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcignY2Fubm90IGF1dG90cmFuc2xhdGU6IG5vIGFwaSBrZXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmcm9tIHx8ICF0bykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcignY2Fubm90IGF1dG90cmFuc2xhdGU6IHNvdXJjZSBhbmQgdGFyZ2V0IGxhbmd1YWdlIG11c3QgYmUgc2V0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZyb20gPSBBdXRvVHJhbnNsYXRlU2VydmljZS5zdHJpcFJlZ2lvbmNvZGUoZnJvbSk7XHJcbiAgICAgICAgdG8gPSBBdXRvVHJhbnNsYXRlU2VydmljZS5zdHJpcFJlZ2lvbmNvZGUodG8pO1xyXG4gICAgICAgIGNvbnN0IGFsbFJlcXVlc3RzOiBPYnNlcnZhYmxlPHN0cmluZ1tdPltdID0gdGhpcy5zcGxpdE1lc3NhZ2VzVG9Hb29nbGVMaW1pdChtZXNzYWdlcykubWFwKChwYXJ0aWFsTWVzc2FnZXM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0ZWRUcmFuc2xhdGVNdWx0aXBsZVN0cmluZ3MocGFydGlhbE1lc3NhZ2VzLCBmcm9tLCB0byk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luKGFsbFJlcXVlc3RzKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKGFsbFRyYW5zbGF0aW9uczogc3RyaW5nW11bXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFsbCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxUcmFuc2xhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGwgPSBhbGwuY29uY2F0KGFsbFRyYW5zbGF0aW9uc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNwbGl0TWVzc2FnZXNUb0dvb2dsZUxpbWl0KG1lc3NhZ2VzOiBzdHJpbmdbXSk6IHN0cmluZ1tdW10ge1xyXG4gICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPD0gTUFYX1NFR01FTlRTKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbbWVzc2FnZXNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudFBhY2thZ2UgPSBbXTtcclxuICAgICAgICBsZXQgcGFja2FnZVNpemUgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3VycmVudFBhY2thZ2UucHVzaChtZXNzYWdlc1tpXSk7XHJcbiAgICAgICAgICAgIHBhY2thZ2VTaXplKys7XHJcbiAgICAgICAgICAgIGlmIChwYWNrYWdlU2l6ZSA+PSBNQVhfU0VHTUVOVFMpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRQYWNrYWdlKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYWNrYWdlID0gW107XHJcbiAgICAgICAgICAgICAgICBwYWNrYWdlU2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYWNrYWdlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudFBhY2thZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRyYW5zbGF0aW9uIHJlcXVlc3QsIGJ1dCBtZXNzYWdlcyBtdXN0IGJlIGxpbWl0ZWQgdG8gZ29vZ2xlIGxpbWl0cy5cclxuICAgICAqIE5vdCBtb3JlIHRoYXQgMTI4IHNpbmdsZSBtZXNzYWdlcy5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyBtZXNzYWdlc1xyXG4gICAgICogQHBhcmFtIGZyb20gZnJvbVxyXG4gICAgICogQHBhcmFtIHRvIHRvXHJcbiAgICAgKiBAcmV0dXJuIHRoZSB0cmFuc2xhdGVkIHN0cmluZ3NcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsaW1pdGVkVHJhbnNsYXRlTXVsdGlwbGVTdHJpbmdzKG1lc3NhZ2VzOiBzdHJpbmdbXSwgZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nKTogT2JzZXJ2YWJsZTxzdHJpbmdbXT4ge1xyXG4gICAgICAgIGNvbnN0IHJlYWxVcmwgPSB0aGlzLl9yb290VXJsICsgJ2xhbmd1YWdlL3RyYW5zbGF0ZS92MicgKyAnP2tleT0nICsgdGhpcy5fYXBpS2V5O1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZVJlcXVlc3Q6IFRyYW5zbGF0ZVRleHRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBxOiBtZXNzYWdlcyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0byxcclxuICAgICAgICAgICAgc291cmNlOiBmcm9tLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgdXJsOiByZWFsVXJsLFxyXG4gICAgICAgICAgICBib2R5OiB0cmFuc2xhdGVSZXF1ZXN0LFxyXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxyXG4vLyAgICAgICAgICAgIHByb3h5OiAnaHR0cDovLzEyNy4wLjAuMTo4ODg4JyBUbyBzZXQgYSBwcm94eSB1c2UgZW52IHZhciBIVFRQU19QUk9YWVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdChyZWFsVXJsLCBvcHRpb25zKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYm9keTogYW55ID0gZGF0YS5ib2R5O1xyXG4gICAgICAgICAgICBpZiAoIWJvZHkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcmVzdWx0IHJlY2VpdmVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvZHkuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib2R5LmVycm9yLmNvZGUgPT09IDQwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5LmVycm9yLm1lc3NhZ2UgPT09ICdJbnZhbGlkIFZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdUcmFuc2xhdGlvbiBmcm9tIFwiJXNcIiB0byBcIiVzXCIgbm90IHN1cHBvcnRlZCcsIGZyb20sIHRvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0ludmFsaWQgcmVxdWVzdDogJXMnLCBib2R5LmVycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRXJyb3IgJXM6ICVzJywgYm9keS5lcnJvci5jb2RlLCBib2R5LmVycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBib2R5LmRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudHJhbnNsYXRpb25zLm1hcCgodHJhbnNsYXRpb246IFRyYW5zbGF0aW9uc1Jlc291cmNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb24udHJhbnNsYXRlZFRleHQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGRvIGEgUE9TVCBIVFRQIHJlcXVlc3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJpIHVyaVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gcmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgcG9zdCh1cmk6IHN0cmluZywgb3B0aW9ucz86IHJlcXVlc3QuQ29yZU9wdGlvbnMpOiBPYnNlcnZhYmxlPEludGVybmFsUmVxdWVzdFJlc3BvbnNlPiB7XHJcbiAgICAgICAgcmV0dXJuIDxPYnNlcnZhYmxlPEludGVybmFsUmVxdWVzdFJlc3BvbnNlPj4gdGhpcy5fY2FsbC5hcHBseSh0aGlzLCBbXS5jb25jYXQoJ3Bvc3QnLCA8c3RyaW5nPiB1cmksXHJcbiAgICAgICAgICAgIDxyZXF1ZXN0LkNvcmVPcHRpb25zPiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zIHx8IHt9KSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gZG8gYSBIVFRQIHJlcXVlc3QgZm9yIGdpdmVuIG1ldGhvZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXRob2QgbWV0aG9kXHJcbiAgICAgKiBAcGFyYW0gdXJpIHVyaVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gcmVzcG9uc2VcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2NhbGwobWV0aG9kOiBzdHJpbmcsIHVyaTogc3RyaW5nLCBvcHRpb25zPzogcmVxdWVzdC5Db3JlT3B0aW9ucyk6IE9ic2VydmFibGU8SW50ZXJuYWxSZXF1ZXN0UmVzcG9uc2U+IHtcclxuICAgICAgICByZXR1cm4gPE9ic2VydmFibGU8SW50ZXJuYWxSZXF1ZXN0UmVzcG9uc2U+PiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgLy8gYnVpbGQgcGFyYW1zIGFycmF5XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdLmNvbmNhdCg8c3RyaW5nPiB1cmksIDxyZXF1ZXN0LkNvcmVPcHRpb25zPiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zIHx8IHt9KSxcclxuICAgICAgICAgICAgICAgIDxSZXF1ZXN0Q2FsbGJhY2s+KGVycm9yOiBhbnksIHJlc3BvbnNlOiByZXF1ZXN0LlJlcXVlc3RSZXNwb25zZSwgYm9keTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KDxJbnRlcm5hbFJlcXVlc3RSZXNwb25zZT4gT2JqZWN0LmFzc2lnbih7fSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogPHJlcXVlc3QuUmVxdWVzdFJlc3BvbnNlPiByZXNwb25zZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogPGFueT4gYm9keVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBfY2FsbCByZXF1ZXN0IG1ldGhvZFxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFs8c3RyaW5nPiBtZXRob2RdLmFwcGx5KFxyXG4gICAgICAgICAgICAgICAgICAgIDxyZXF1ZXN0LlJlcXVlc3RBUEk8cmVxdWVzdC5SZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuQ29yZU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5SZXF1aXJlZFVyaVVybD4+IHRoaXMuX3JlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAyOS4wNi4yMDE3LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBBdXRvVHJhbnNsYXRlUmVzdWx0IHtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc3VjY2VzczogYm9vbGVhbiwgcHJpdmF0ZSBfZGV0YWlsczogc3RyaW5nKSB7XHJcblxyXG4gIH1cclxuXHJcbiAgcHVibGljIHN1Y2Nlc3MoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3VjY2VzcztcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtBdXRvVHJhbnNsYXRlUmVzdWx0fSBmcm9tICcuL2F1dG8tdHJhbnNsYXRlLXJlc3VsdCc7XHJcbmltcG9ydCB7Zm9ybWF0fSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtJVHJhbnNVbml0fSBmcm9tICdAbmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWInO1xyXG5cclxuLyoqXHJcbiAqIEEgcmVwb3J0IGFib3V0IGEgcnVuIG9mIEdvb2dsZSBUcmFuc2xhdGUgb3ZlciBhbGwgdW50cmFuc2xhdGVkIHVuaXQuXHJcbiAqICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMjkuMDYuMjAxNy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQge1xyXG5cclxuICBwcml2YXRlIF9lcnJvcjogc3RyaW5nO1xyXG4gIHByaXZhdGUgX2Zyb206IHN0cmluZztcclxuICBwcml2YXRlIF90bzogc3RyaW5nO1xyXG4gIHByaXZhdGUgX3RvdGFsOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBfaWdub3JlZDogbnVtYmVyO1xyXG4gIHByaXZhdGUgX3N1Y2Nlc3M6IG51bWJlcjtcclxuICBwcml2YXRlIF9mYWlsZWQ6IG51bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nKSB7XHJcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcclxuICAgIHRoaXMuX3RvID0gdG87XHJcbiAgICB0aGlzLl90b3RhbCA9IDA7XHJcbiAgICB0aGlzLl9pZ25vcmVkID0gMDtcclxuICAgIHRoaXMuX3N1Y2Nlc3MgPSAwO1xyXG4gICAgdGhpcy5fZmFpbGVkID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBlcnJvciBpZiB0b3RhbCBjYWxsIGZhaWxlZCAoZS5nLiBcImludmFsaWQgYXBpIGtleVwiIG9yIFwibm8gY29ubmVjdGlvblwiIC4uLilcclxuICAgKiBAcGFyYW0gZXJyb3IgZXJyb3JcclxuICAgKiBAcGFyYW0gdG90YWwgdG90YWxcclxuICAgKi9cclxuICBwdWJsaWMgc2V0RXJyb3IoZXJyb3I6IHN0cmluZywgdG90YWw6IG51bWJlcikge1xyXG4gICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcclxuICAgIHRoaXMuX3RvdGFsID0gdG90YWw7XHJcbiAgICB0aGlzLl9mYWlsZWQgPSB0b3RhbDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBlcnJvcigpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldElnbm9yZWQoaWdub3JlZDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLl90b3RhbCArPSBpZ25vcmVkO1xyXG4gICAgdGhpcy5faWdub3JlZCA9IGlnbm9yZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBzaW5nbGUgcmVzdWx0IHRvIHRoZSBzdW1tYXJ5LlxyXG4gICAqIEBwYXJhbSB0dSB0dVxyXG4gICAqIEBwYXJhbSByZXN1bHQgcmVzdWx0XHJcbiAgICovXHJcbiAgcHVibGljIGFkZFNpbmdsZVJlc3VsdCh0dTogSVRyYW5zVW5pdCwgcmVzdWx0OiBBdXRvVHJhbnNsYXRlUmVzdWx0KSB7XHJcbiAgICB0aGlzLl90b3RhbCsrO1xyXG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKCkpIHtcclxuICAgICAgdGhpcy5fc3VjY2VzcysrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fZmFpbGVkKys7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNZXJnZSBhbm90aGVyIHN1bW1hcnkgaW50byB0aGlzIG9uZS5cclxuICAgKiBAcGFyYW0gYW5vdGhlclN1bW1hcnkgYW5vdGhlclN1bW1hcnlcclxuICAgKi9cclxuICBwdWJsaWMgbWVyZ2UoYW5vdGhlclN1bW1hcnk6IEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0KSB7XHJcbiAgICBpZiAoIXRoaXMuX2Vycm9yKSB7XHJcbiAgICAgIHRoaXMuX2Vycm9yID0gYW5vdGhlclN1bW1hcnkuX2Vycm9yO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdG90YWwgKz0gYW5vdGhlclN1bW1hcnkudG90YWwoKTtcclxuICAgIHRoaXMuX2lnbm9yZWQgKz0gYW5vdGhlclN1bW1hcnkuaWdub3JlZCgpO1xyXG4gICAgdGhpcy5fc3VjY2VzcyArPSBhbm90aGVyU3VtbWFyeS5zdWNjZXNzKCk7XHJcbiAgICB0aGlzLl9mYWlsZWQgKz0gYW5vdGhlclN1bW1hcnkuZmFpbGVkKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdG90YWwoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl90b3RhbDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBpZ25vcmVkKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5faWdub3JlZDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzdWNjZXNzKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3VjY2VzcztcclxuICB9XHJcblxyXG4gIHB1YmxpYyBmYWlsZWQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl9mYWlsZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIdW1hbiByZWFkYWJsZSB2ZXJzaW9uIG9mIHJlcG9ydFxyXG4gICAqL1xyXG4gIHB1YmxpYyBjb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgaWYgKHRoaXMuX2Vycm9yKSB7XHJcbiAgICAgIHJlc3VsdCA9IGZvcm1hdCgnQXV0byB0cmFuc2xhdGlvbiBmcm9tIFwiJXNcIiB0byBcIiVzXCIgZmFpbGVkOiBcIiVzXCIsIGZhaWxlZCB1bml0czogJXMnLCB0aGlzLl9mcm9tLCB0aGlzLl90bywgdGhpcy5fZXJyb3IsIHRoaXMuX2ZhaWxlZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgPSBmb3JtYXQoJ0F1dG8gdHJhbnNsYXRpb24gZnJvbSBcIiVzXCIgdG8gXCIlc1wiLCB0b3RhbCBhdXRvIHRyYW5zbGF0ZWQgdW5pdHM6ICVzLCBpZ25vcmVkOiAlcywgc3VjY2VzZnVsOiAlcywgZmFpbGVkOiAlcycsXHJcbiAgICAgICAgICB0aGlzLl9mcm9tLCB0aGlzLl90bywgdGhpcy5fdG90YWwsIHRoaXMuX2lnbm9yZWQsIHRoaXMuX3N1Y2Nlc3MsIHRoaXMuX2ZhaWxlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICcuLi9jb21tb24vdXRpbCc7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZSwgZm9ya0pvaW4sIG9mfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHttYXAsIGNhdGNoRXJyb3J9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0ICogYXMgZW50aXR5RGVjb2RlckxpYiBmcm9tICdoZSc7XHJcbmltcG9ydCB7XHJcbiAgICBJSUNVTWVzc2FnZSwgSUlDVU1lc3NhZ2VUcmFuc2xhdGlvbiwgSU5vcm1hbGl6ZWRNZXNzYWdlLCBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsIElUcmFuc1VuaXQsXHJcbiAgICBTVEFURV9ORVdcclxufSBmcm9tICdAbmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC1saWInO1xyXG5pbXBvcnQge0F1dG9UcmFuc2xhdGVTZXJ2aWNlfSBmcm9tICcuL2F1dG8tdHJhbnNsYXRlLXNlcnZpY2UnO1xyXG5pbXBvcnQge0F1dG9UcmFuc2xhdGVSZXN1bHR9IGZyb20gJy4vYXV0by10cmFuc2xhdGUtcmVzdWx0JztcclxuaW1wb3J0IHtBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydH0gZnJvbSAnLi9hdXRvLXRyYW5zbGF0ZS1zdW1tYXJ5LXJlcG9ydCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAwNy4wNy4yMDE3LlxyXG4gKiBTZXJ2aWNlIHRvIGF1dG90cmFuc2xhdGUgVHJhbnN1bml0cyB2aWEgR29vZ2xlIFRyYW5zbGF0ZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgWGxpZmZNZXJnZUF1dG9UcmFuc2xhdGVTZXJ2aWNlIHtcclxuXHJcbiAgICBwcml2YXRlIGF1dG9UcmFuc2xhdGVTZXJ2aWNlOiBBdXRvVHJhbnNsYXRlU2VydmljZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcGlrZXk6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuYXV0b1RyYW5zbGF0ZVNlcnZpY2UgPSBuZXcgQXV0b1RyYW5zbGF0ZVNlcnZpY2UoYXBpa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1dG8gdHJhbnNsYXRlIGZpbGUgdmlhIEdvb2dsZSBUcmFuc2xhdGUuXHJcbiAgICAgKiBXaWxsIHRyYW5zbGF0ZSBhbGwgbmV3IHVuaXRzIGluIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gdG8gdG9cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGVcclxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHdpdGggdGhlIGV4ZWN1dGlvbiByZXN1bHQgYXMgYSBzdW1tYXJ5IHJlcG9ydC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGF1dG9UcmFuc2xhdGUoZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nLCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpXHJcbiAgICAgICAgOiBPYnNlcnZhYmxlPEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0PiB7XHJcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luKFtcclxuICAgICAgICAgICAgdGhpcy5kb0F1dG9UcmFuc2xhdGVOb25JQ1VNZXNzYWdlcyhmcm9tLCB0bywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSksXHJcbiAgICAgICAgICAgIC4uLnRoaXMuZG9BdXRvVHJhbnNsYXRlSUNVTWVzc2FnZXMoZnJvbSwgdG8sIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUpXSlcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBtYXAoKHN1bW1hcmllczogQXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnRbXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSBzdW1tYXJpZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdW1tYXJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeS5tZXJnZShzdW1tYXJpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtbWFyeTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0IGFsbCB1bml0cyB0aGF0IGFyZSB1bnRyYW5zbGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlXHJcbiAgICAgKiBAcmV0dXJuIGFsbCB1bnRyYW5zbGF0ZWQgdW5pdHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhbGxVbnRyYW5zbGF0ZWRUVXMobGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTogSVRyYW5zVW5pdFtdIHtcclxuICAgICAgICAvLyBjb2xsZWN0IGFsbCB1bml0cywgdGhhdCBzaG91bGQgYmUgYXV0byB0cmFuc2xhdGVkXHJcbiAgICAgICAgY29uc3QgYWxsVW50cmFuc2xhdGVkOiBJVHJhbnNVbml0W10gPSBbXTtcclxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLmZvckVhY2hUcmFuc1VuaXQoKHR1KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0dS50YXJnZXRTdGF0ZSgpID09PSBTVEFURV9ORVcpIHtcclxuICAgICAgICAgICAgICAgIGFsbFVudHJhbnNsYXRlZC5wdXNoKHR1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhbGxVbnRyYW5zbGF0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkb0F1dG9UcmFuc2xhdGVOb25JQ1VNZXNzYWdlcyhmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSlcclxuICAgICAgICA6IE9ic2VydmFibGU8QXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQ+IHtcclxuICAgICAgICBjb25zdCBhbGxVbnRyYW5zbGF0ZWQ6IElUcmFuc1VuaXRbXSA9IHRoaXMuYWxsVW50cmFuc2xhdGVkVFVzKGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUpO1xyXG4gICAgICAgIGNvbnN0IGFsbFRyYW5zbGF0YWJsZSA9IGFsbFVudHJhbnNsYXRlZC5maWx0ZXIoKHR1KSA9PiBpc051bGxPclVuZGVmaW5lZCh0dS5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLmdldElDVU1lc3NhZ2UoKSkpO1xyXG4gICAgICAgIGNvbnN0IGFsbE1lc3NhZ2VzOiBzdHJpbmdbXSA9IGFsbFRyYW5zbGF0YWJsZS5tYXAoKHR1KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0dS5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLmFzRGlzcGxheVN0cmluZygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9UcmFuc2xhdGVTZXJ2aWNlLnRyYW5zbGF0ZU11bHRpcGxlU3RyaW5ncyhhbGxNZXNzYWdlcywgZnJvbSwgdG8pXHJcbiAgICAgICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgICAgICAgLy8gIzk0IGdvb2dsZSB0cmFuc2xhdGUgbWlnaHQgcmV0dXJuICYjLi4gZW50aXR5IHJlZnMsIHRoYXQgbXVzdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICAgICAgICBtYXAoKHRyYW5zbGF0aW9uczogc3RyaW5nW10pID0+IHRyYW5zbGF0aW9ucy5tYXAoZW5jb2RlZFRyYW5zbGF0aW9uID0+IGVudGl0eURlY29kZXJMaWIuZGVjb2RlKGVuY29kZWRUcmFuc2xhdGlvbikpKSxcclxuICAgICAgICAgICAgICAgIG1hcCgodHJhbnNsYXRpb25zOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3VtbWFyeSA9IG5ldyBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydChmcm9tLCB0byk7XHJcbiAgICAgICAgICAgICAgICBzdW1tYXJ5LnNldElnbm9yZWQoYWxsVW50cmFuc2xhdGVkLmxlbmd0aCAtIGFsbFRyYW5zbGF0YWJsZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2xhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0dSA9IGFsbFRyYW5zbGF0YWJsZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGlvblRleHQgPSB0cmFuc2xhdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hdXRvVHJhbnNsYXRlTm9uSUNVVW5pdCh0dSwgdHJhbnNsYXRpb25UZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5LmFkZFNpbmdsZVJlc3VsdCh0dSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdW1tYXJ5O1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBjYXRjaEVycm9yKChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWlsU3VtbWFyeSA9IG5ldyBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydChmcm9tLCB0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbFN1bW1hcnkuc2V0RXJyb3IoZXJyLm1lc3NhZ2UsIGFsbE1lc3NhZ2VzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKGZhaWxTdW1tYXJ5KTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZG9BdXRvVHJhbnNsYXRlSUNVTWVzc2FnZXMoZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nLCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpXHJcbiAgICAgICAgOiBPYnNlcnZhYmxlPEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0PltdIHtcclxuICAgICAgICBjb25zdCBhbGxVbnRyYW5zbGF0ZWQ6IElUcmFuc1VuaXRbXSA9IHRoaXMuYWxsVW50cmFuc2xhdGVkVFVzKGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUpO1xyXG4gICAgICAgIGNvbnN0IGFsbFRyYW5zbGF0YWJsZUlDVSA9IGFsbFVudHJhbnNsYXRlZC5maWx0ZXIoKHR1KSA9PiAhaXNOdWxsT3JVbmRlZmluZWQodHUuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKS5nZXRJQ1VNZXNzYWdlKCkpKTtcclxuICAgICAgICByZXR1cm4gYWxsVHJhbnNsYXRhYmxlSUNVLm1hcCgodHUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9BdXRvVHJhbnNsYXRlSUNVTWVzc2FnZShmcm9tLCB0bywgdHUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlIHNpbmdsZSBJQ1UgTWVzc2FnZXMuXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gdG8gdG9cclxuICAgICAqIEBwYXJhbSB0dSB0cmFuc3VuaXQgdG8gdHJhbnNsYXRlIChtdXN0IGNvbnRhaW4gSUNVIE1lc3NhZ2UpXHJcbiAgICAgKiBAcmV0dXJuIHN1bW1hcnkgcmVwb3J0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZG9BdXRvVHJhbnNsYXRlSUNVTWVzc2FnZShmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIHR1OiBJVHJhbnNVbml0KTogT2JzZXJ2YWJsZTxBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydD4ge1xyXG4gICAgICAgIGNvbnN0IGljdU1lc3NhZ2U6IElJQ1VNZXNzYWdlID0gdHUuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKS5nZXRJQ1VNZXNzYWdlKCk7XHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IGljdU1lc3NhZ2UuZ2V0Q2F0ZWdvcmllcygpO1xyXG4gICAgICAgIC8vIGNoZWNrIGZvciBuZXN0ZWQgSUNVcywgd2UgZG8gbm90IHN1cHBvcnQgdGhhdFxyXG4gICAgICAgIGlmIChjYXRlZ29yaWVzLmZpbmQoKGNhdGVnb3J5KSA9PiAhaXNOdWxsT3JVbmRlZmluZWQoY2F0ZWdvcnkuZ2V0TWVzc2FnZU5vcm1hbGl6ZWQoKS5nZXRJQ1VNZXNzYWdlKCkpKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gbmV3IEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0KGZyb20sIHRvKTtcclxuICAgICAgICAgICAgc3VtbWFyeS5zZXRJZ25vcmVkKDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gb2Yoc3VtbWFyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFsbE1lc3NhZ2VzOiBzdHJpbmdbXSA9IGNhdGVnb3JpZXMubWFwKChjYXRlZ29yeSkgPT4gY2F0ZWdvcnkuZ2V0TWVzc2FnZU5vcm1hbGl6ZWQoKS5hc0Rpc3BsYXlTdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b1RyYW5zbGF0ZVNlcnZpY2UudHJhbnNsYXRlTXVsdGlwbGVTdHJpbmdzKGFsbE1lc3NhZ2VzLCBmcm9tLCB0bylcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAvLyAjOTQgZ29vZ2xlIHRyYW5zbGF0ZSBtaWdodCByZXR1cm4gJiMuLiBlbnRpdHkgcmVmcywgdGhhdCBtdXN0IGJlIGRlY29kZWRcclxuICAgICAgICAgICAgICAgIG1hcCgodHJhbnNsYXRpb25zOiBzdHJpbmdbXSkgPT4gdHJhbnNsYXRpb25zLm1hcChlbmNvZGVkVHJhbnNsYXRpb24gPT4gZW50aXR5RGVjb2RlckxpYi5kZWNvZGUoZW5jb2RlZFRyYW5zbGF0aW9uKSkpLFxyXG4gICAgICAgICAgICAgICAgbWFwKCh0cmFuc2xhdGlvbnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtbWFyeSA9IG5ldyBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydChmcm9tLCB0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWN1VHJhbnNsYXRpb246IElJQ1VNZXNzYWdlVHJhbnNsYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zbGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY3VUcmFuc2xhdGlvbltjYXRlZ29yaWVzW2ldLmdldENhdGVnb3J5KCldID0gdHJhbnNsYXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmF1dG9UcmFuc2xhdGVJQ1VVbml0KHR1LCBpY3VUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeS5hZGRTaW5nbGVSZXN1bHQodHUsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bW1hcnk7XHJcbiAgICAgICAgICAgICAgICB9KSwgY2F0Y2hFcnJvcigoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmFpbFN1bW1hcnkgPSBuZXcgQXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQoZnJvbSwgdG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhaWxTdW1tYXJ5LnNldEVycm9yKGVyci5tZXNzYWdlLCBhbGxNZXNzYWdlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZihmYWlsU3VtbWFyeSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGF1dG9UcmFuc2xhdGVOb25JQ1VVbml0KHR1OiBJVHJhbnNVbml0LCB0cmFuc2xhdGVkTWVzc2FnZTogc3RyaW5nKTogQXV0b1RyYW5zbGF0ZVJlc3VsdCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b1RyYW5zbGF0ZVVuaXQodHUsIHR1LnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkudHJhbnNsYXRlKHRyYW5zbGF0ZWRNZXNzYWdlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhdXRvVHJhbnNsYXRlSUNVVW5pdCh0dTogSVRyYW5zVW5pdCwgdHJhbnNsYXRpb246IElJQ1VNZXNzYWdlVHJhbnNsYXRpb24pOiBBdXRvVHJhbnNsYXRlUmVzdWx0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRvVHJhbnNsYXRlVW5pdCh0dSwgdHUuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKS50cmFuc2xhdGVJQ1VNZXNzYWdlKHRyYW5zbGF0aW9uKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhdXRvVHJhbnNsYXRlVW5pdCh0dTogSVRyYW5zVW5pdCwgdHJhbnNsYXRlZE1lc3NhZ2U6IElOb3JtYWxpemVkTWVzc2FnZSk6IEF1dG9UcmFuc2xhdGVSZXN1bHQge1xyXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IHRyYW5zbGF0ZWRNZXNzYWdlLnZhbGlkYXRlKCk7XHJcbiAgICAgICAgY29uc3Qgd2FybmluZ3MgPSB0cmFuc2xhdGVkTWVzc2FnZS52YWxpZGF0ZVdhcm5pbmdzKCk7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChlcnJvcnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXV0b1RyYW5zbGF0ZVJlc3VsdChmYWxzZSwgJ2Vycm9ycyBkZXRlY3RlZCwgbm90IHRyYW5zbGF0ZWQnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZCh3YXJuaW5ncykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdXRvVHJhbnNsYXRlUmVzdWx0KGZhbHNlLCAnd2FybmluZ3MgZGV0ZWN0ZWQsIG5vdCB0cmFuc2xhdGVkJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdHUudHJhbnNsYXRlKHRyYW5zbGF0ZWRNZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdXRvVHJhbnNsYXRlUmVzdWx0KHRydWUsIG51bGwpOyAvLyBzdWNjZXNzXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7Q29tbWFuZE91dHB1dH0gZnJvbSAnLi4vY29tbW9uL2NvbW1hbmQtb3V0cHV0JztcclxuaW1wb3J0IHtYbGlmZk1lcmdlUGFyYW1ldGVyc30gZnJvbSAnLi94bGlmZi1tZXJnZS1wYXJhbWV0ZXJzJztcclxuaW1wb3J0IHtYbGlmZk1lcmdlRXJyb3J9IGZyb20gJy4veGxpZmYtbWVyZ2UtZXJyb3InO1xyXG5pbXBvcnQge0ZpbGVVdGlsfSBmcm9tICcuLi9jb21tb24vZmlsZS11dGlsJztcclxuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuL3ZlcnNpb24nO1xyXG5pbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJy4uL2NvbW1vbi91dGlsJztcclxuaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsIElUcmFuc1VuaXQsXHJcbiAgICBGT1JNQVRfWE1CLCBGT1JNQVRfWFRCLFxyXG4gICAgTk9STUFMSVpBVElPTl9GT1JNQVRfREVGQVVMVCwgU1RBVEVfRklOQUwsIFNUQVRFX1RSQU5TTEFURUR9IGZyb20gJ0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYic7XHJcbmltcG9ydCB7UHJvZ3JhbU9wdGlvbnMsIElDb25maWdGaWxlfSBmcm9tICcuL2kteGxpZmYtbWVyZ2Utb3B0aW9ucyc7XHJcbmltcG9ydCB7Tmd4VHJhbnNsYXRlRXh0cmFjdG9yfSBmcm9tICcuL25neC10cmFuc2xhdGUtZXh0cmFjdG9yJztcclxuaW1wb3J0IHtUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlcn0gZnJvbSAnLi90cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlLXJlYWRlcic7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2YsIGZvcmtKb2lufSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHttYXAsIGNhdGNoRXJyb3J9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHtYbGlmZk1lcmdlQXV0b1RyYW5zbGF0ZVNlcnZpY2V9IGZyb20gJy4uL2F1dG90cmFuc2xhdGUveGxpZmYtbWVyZ2UtYXV0by10cmFuc2xhdGUtc2VydmljZSc7XHJcbmltcG9ydCB7QXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnR9IGZyb20gJy4uL2F1dG90cmFuc2xhdGUvYXV0by10cmFuc2xhdGUtc3VtbWFyeS1yZXBvcnQnO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDE3LjAyLjIwMTcuXHJcbiAqIFhsaWZmTWVyZ2UgLSByZWFkIHhsaWZmIG9yIHhtYiBmaWxlIGFuZCBwdXQgdW50cmFuc2xhdGVkIHBhcnRzIGluIGxhbmd1YWdlIHNwZWNpZmljIHhsaWZmIG9yIHhtYiBmaWxlcy5cclxuICpcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgWGxpZmZNZXJnZSB7XHJcblxyXG4gICAgcHJpdmF0ZSBjb21tYW5kT3V0cHV0OiBDb21tYW5kT3V0cHV0O1xyXG5cclxuICAgIHByaXZhdGUgb3B0aW9uczogUHJvZ3JhbU9wdGlvbnM7XHJcblxyXG4gICAgcHJpdmF0ZSBwYXJhbWV0ZXJzOiBYbGlmZk1lcmdlUGFyYW1ldGVycztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZWFkIG1hc3RlciB4bGYgZmlsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtYXN0ZXI6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZTsgLy8gWGxpZmZGaWxlIG9yIFhsaWZmMkZpbGUgb3IgWG1iRmlsZVxyXG5cclxuICAgIHByaXZhdGUgYXV0b1RyYW5zbGF0ZVNlcnZpY2U6IFhsaWZmTWVyZ2VBdXRvVHJhbnNsYXRlU2VydmljZTtcclxuXHJcbiAgICBzdGF0aWMgbWFpbihhcmd2OiBzdHJpbmdbXSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBYbGlmZk1lcmdlLnBhcnNlQXJncyhhcmd2KTtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBuZXcgWGxpZmZNZXJnZShuZXcgQ29tbWFuZE91dHB1dChwcm9jZXNzLnN0ZG91dCksIG9wdGlvbnMpLnJ1bigocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmV4aXQocmVzdWx0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwYXJzZUFyZ3MoYXJndjogc3RyaW5nW10pOiBQcm9ncmFtT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uczogUHJvZ3JhbU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGxhbmd1YWdlczogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmd2W2ldO1xyXG4gICAgICAgICAgICBpZiAoYXJnID09PSAnLS12ZXJzaW9uJyB8fCBhcmcgPT09ICctdmVyc2lvbicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd4bGlmZm1lcmdlICcgKyBWRVJTSU9OKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09ICctLXZlcmJvc2UnIHx8IGFyZyA9PT0gJy12Jykge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52ZXJib3NlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09ICctLXByb2ZpbGUnIHx8IGFyZyA9PT0gJy1wJykge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJndi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbWlzc2luZyBjb25maWcgZmlsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIFhsaWZmTWVyZ2Uuc2hvd1VzYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvZmlsZVBhdGggPSBhcmd2W2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyA9PT0gJy0tcXVpZXQnIHx8IGFyZyA9PT0gJy1xJykge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5xdWlldCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnID09PSAnLS1oZWxwJyB8fCBhcmcgPT09ICctaGVscCcgfHwgYXJnID09PSAnLWgnKSB7XHJcbiAgICAgICAgICAgICAgICBYbGlmZk1lcmdlLnNob3dVc2FnZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5sZW5ndGggPiAwICYmIGFyZy5jaGFyQXQoMCkgPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Vua25vd24gb3B0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubGFuZ3VhZ2VzLnB1c2goYXJnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgc2hvd1VzYWdlKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCd1c2FnZTogeGxpZmZtZXJnZSA8b3B0aW9uPiogPGxhbmd1YWdlPionKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnT3B0aW9ucycpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXHQtcHwtLXByb2ZpbGUgYSBqc29uIGNvbmZpZ3VyYXRpb24gZmlsZSBjb250YWluaW5nIGFsbCByZWxldmFudCBwYXJhbWV0ZXJzLicpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXHRcXHRmb3IgZGV0YWlscyBwbGVhc2UgY29uc3VsdCB0aGUgaG9tZSBwYWdlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJ0aW5yb29iL25neC1pMThuc3VwcG9ydCcpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXHQtdnwtLXZlcmJvc2Ugc2hvdyBzb21lIG91dHB1dCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdC1xfC0tcXVpZXQgb25seSBzaG93IGVycm9ycywgbm90aGluZyBlbHNlJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdC12ZXJzaW9ufC0tdmVyc2lvbiBzaG93IHZlcnNpb24gc3RyaW5nJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJycpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXHQ8bGFuZ3VhZ2U+IGhhcyB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIHNob3J0IHN0cmluZywgZSxnLiBcImVuXCIsIFwiZGVcIiwgXCJkZS1jaFwiJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgVGVzdHMsIGNyZWF0ZSBpbnN0YW5jZSB3aXRoIGdpdmVuIHByb2ZpbGVcclxuICAgICAqIEBwYXJhbSBjb21tYW5kT3V0cHV0IGNvbW1hbmRPdXRwdXRcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSBwcm9maWxlQ29udGVudCBwcm9maWxlQ29udGVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZUZyb21PcHRpb25zKGNvbW1hbmRPdXRwdXQ6IENvbW1hbmRPdXRwdXQsIG9wdGlvbnM6IFByb2dyYW1PcHRpb25zLCBwcm9maWxlQ29udGVudD86IElDb25maWdGaWxlKSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgWGxpZmZNZXJnZShjb21tYW5kT3V0cHV0LCBvcHRpb25zKTtcclxuICAgICAgICBpbnN0YW5jZS5wYXJhbWV0ZXJzID0gWGxpZmZNZXJnZVBhcmFtZXRlcnMuY3JlYXRlRnJvbU9wdGlvbnMob3B0aW9ucywgcHJvZmlsZUNvbnRlbnQpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kT3V0cHV0OiBDb21tYW5kT3V0cHV0LCBvcHRpb25zOiBQcm9ncmFtT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZE91dHB1dCA9IGNvbW1hbmRPdXRwdXQ7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVuIHRoZSBjb21tYW5kLlxyXG4gICAgICogVGhpcyBydW5zIGFzeW5jLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrRnVuY3Rpb24gd2hlbiBjb21tYW5kIGlzIGV4ZWN1dGVkLCBjYWxsZWQgd2l0aCB0aGUgcmV0dXJuIGNvZGUgKDAgZm9yIG9rKSwgaWYgZ2l2ZW4uXHJcbiAgICAgKiBAcGFyYW0gZXJyb3JGdW5jdGlvbiBjYWxsYmFja0Z1bmN0aW9uIGZvciBlcnJvciBoYW5kbGluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcnVuKGNhbGxiYWNrRnVuY3Rpb24/OiAoKHJldGNvZGU6IG51bWJlcikgPT4gYW55KSwgZXJyb3JGdW5jdGlvbj86ICgoZXJyb3I6IGFueSkgPT4gYW55KSkge1xyXG4gICAgICAgIHRoaXMucnVuQXN5bmMoKVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChyZXRjb2RlOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoY2FsbGJhY2tGdW5jdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0Z1bmN0aW9uKHJldGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoZXJyb3JGdW5jdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvckZ1bmN0aW9uKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlIG1lcmdlLVByb2Nlc3MuXHJcbiAgICAgKiBAcmV0dXJuIEFzeW5jIG9wZXJhdGlvbiwgb24gY29tcGxldGlvbiByZXR1cm5zIHJldGNvZGUgMD1vaywgb3RoZXIgPSBlcnJvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJ1bkFzeW5jKCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucXVpZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LnNldFF1aWV0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnZlcmJvc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LnNldFZlcmJvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLnBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gWGxpZmZNZXJnZVBhcmFtZXRlcnMuY3JlYXRlRnJvbU9wdGlvbnModGhpcy5vcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmluZm8oJ3hsaWZmbWVyZ2UgdmVyc2lvbiAlcycsIFZFUlNJT04pO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudmVyYm9zZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5zaG93QWxsUGFyYW1ldGVycyh0aGlzLmNvbW1hbmRPdXRwdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmVycm9yc0ZvdW5kLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlcnIgb2YgdGhpcy5wYXJhbWV0ZXJzLmVycm9yc0ZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuZXJyb3IoZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvZigtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMud2FybmluZ3NGb3VuZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd2FybiBvZiB0aGlzLnBhcmFtZXRlcnMud2FybmluZ3NGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4od2Fybik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWFkTWFzdGVyKCk7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5hdXRvdHJhbnNsYXRlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRvVHJhbnNsYXRlU2VydmljZSA9IG5ldyBYbGlmZk1lcmdlQXV0b1RyYW5zbGF0ZVNlcnZpY2UodGhpcy5wYXJhbWV0ZXJzLmFwaWtleSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uRm9yQWxsTGFuZ3VhZ2VzOiBPYnNlcnZhYmxlPG51bWJlcj5bXSA9IFtdO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5sYW5ndWFnZXMoKS5mb3JFYWNoKChsYW5nOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgZXhlY3V0aW9uRm9yQWxsTGFuZ3VhZ2VzLnB1c2godGhpcy5wcm9jZXNzTGFuZ3VhZ2UobGFuZykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmb3JrSm9pbihleGVjdXRpb25Gb3JBbGxMYW5ndWFnZXMpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgocmV0Y29kZXM6IG51bWJlcltdKSA9PiB0aGlzLnRvdGFsUmV0Y29kZShyZXRjb2RlcykpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmUgYW4gYXJyYXkgb2YgcmV0Y29kZXMgZm9yIHRoZSBkaWZmZXJlbnQgbGFuZ3VhZ2VzLCByZXR1cm4gdGhlIHRvdGFsIHJldGNvZGUuXHJcbiAgICAgKiBJZiBhbGwgYXJlIDAsIGl0IGlzIDAsIG90aGVyd2lzZSB0aGUgZmlyc3Qgbm9uIHplcm8uXHJcbiAgICAgKiBAcGFyYW0gcmV0Y29kZXMgcmV0Y29kZXNcclxuICAgICAqIEByZXR1cm4gbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdG90YWxSZXRjb2RlKHJldGNvZGVzOiBudW1iZXJbXSk6IG51bWJlciB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRjb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocmV0Y29kZXNbaV0gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXRjb2Rlc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIGZpbGUgZm9yIGdpdmVuIGxhbmcuXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBsYW5ndWFnZVxyXG4gICAgICogQHJldHVybiBuYW1lIG9mIGdlbmVyYXRlZCBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZW5lcmF0ZWRJMThuRmlsZShsYW5nOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnMuZ2VuZXJhdGVkSTE4bkZpbGUobGFuZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGdlbmVyYXRlZCBuZ3gtdHJhbnNsYXRpb24gZmlsZSBmb3IgZ2l2ZW4gbGFuZy5cclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlXHJcbiAgICAgKiBAcmV0dXJuIG5hbWUgb2YgdHJhbnNsYXRlIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdlbmVyYXRlZE5neFRyYW5zbGF0ZUZpbGUobGFuZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzLmdlbmVyYXRlZE5neFRyYW5zbGF0ZUZpbGUobGFuZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXYXJuaW5ncyBmb3VuZCBkdXJpbmcgdGhlIHJ1bi5cclxuICAgICAqIEByZXR1cm4gd2FybmluZ3NcclxuICAgICAqL1xyXG4gICAgcHVibGljIHdhcm5pbmdzKCk6IHN0cmluZ1tdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzLndhcm5pbmdzRm91bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkTWFzdGVyKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFzdGVyID0gVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIuZnJvbUZpbGUoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaTE4bkZvcm1hdCgpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmkxOG5GaWxlKCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZW5jb2RpbmcoKSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFzdGVyLndhcm5pbmdzKCkuZm9yRWFjaCgod2FybmluZzogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2Fybih3YXJuaW5nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5tYXN0ZXIubnVtYmVyT2ZUcmFuc1VuaXRzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdJZENvdW50ID0gdGhpcy5tYXN0ZXIubnVtYmVyT2ZUcmFuc1VuaXRzV2l0aE1pc3NpbmdJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuaW5mbygnbWFzdGVyIGNvbnRhaW5zICVzIHRyYW5zLXVuaXRzJywgY291bnQpO1xyXG4gICAgICAgICAgICBpZiAobWlzc2luZ0lkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybignbWFzdGVyIGNvbnRhaW5zICVzIHRyYW5zLXVuaXRzLCBidXQgdGhlcmUgYXJlICVzIHdpdGhvdXQgaWQnLCBjb3VudCwgbWlzc2luZ0lkQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUxhbmc6IHN0cmluZyA9IHRoaXMubWFzdGVyLnNvdXJjZUxhbmd1YWdlKCk7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VMYW5nICYmIHNvdXJjZUxhbmcgIT09IHRoaXMucGFyYW1ldGVycy5kZWZhdWx0TGFuZ3VhZ2UoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgJ21hc3RlciBzYXlzIHRvIGhhdmUgc291cmNlLWxhbmd1YWdlPVwiJXNcIiwgc2hvdWxkIGJlIFwiJXNcIiAoeW91ciBkZWZhdWx0TGFuZ3VhZ2UpJyxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VMYW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5kZWZhdWx0TGFuZ3VhZ2UoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hc3Rlci5zZXRTb3VyY2VMYW5ndWFnZSh0aGlzLnBhcmFtZXRlcnMuZGVmYXVsdExhbmd1YWdlKCkpO1xyXG4gICAgICAgICAgICAgICAgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIuc2F2ZSh0aGlzLm1hc3RlciwgdGhpcy5wYXJhbWV0ZXJzLmJlYXV0aWZ5T3V0cHV0KCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ2NoYW5nZWQgbWFzdGVyIHNvdXJjZS1sYW5ndWFnZT1cIiVzXCIgdG8gXCIlc1wiJywgc291cmNlTGFuZywgdGhpcy5wYXJhbWV0ZXJzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgWGxpZmZNZXJnZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuZXJyb3IoZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKC0xKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHVuaGFuZGxlZFxyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEZpbGVuYW1lID0gdGhpcy5wYXJhbWV0ZXJzLmkxOG5GaWxlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZVN0cmluZyA9IChjdXJyZW50RmlsZW5hbWUpID8gZm9ybWF0KCdmaWxlIFwiJXNcIiwgJywgY3VycmVudEZpbGVuYW1lKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmVycm9yKGZpbGVuYW1lU3RyaW5nICsgJ29vcHMgJyArIGVycik7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzIHRoZSBnaXZlbiBsYW5ndWFnZS5cclxuICAgICAqIEFzeW5jIG9wZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlXHJcbiAgICAgKiBAcmV0dXJuIG9uIGNvbXBsZXRpb24gMCBmb3Igb2ssIG90aGVyIGZvciBlcnJvclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHByb2Nlc3NMYW5ndWFnZShsYW5nOiBzdHJpbmcpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5kZWJ1ZygncHJvY2Vzc2luZyBsYW5ndWFnZSAlcycsIGxhbmcpO1xyXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlWGxpZmZGaWxlID0gdGhpcy5wYXJhbWV0ZXJzLmdlbmVyYXRlZEkxOG5GaWxlKGxhbmcpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGaWxlbmFtZSA9IGxhbmd1YWdlWGxpZmZGaWxlO1xyXG4gICAgICAgIGxldCByZXN1bHQ6IE9ic2VydmFibGU8dm9pZD47XHJcbiAgICAgICAgaWYgKCFGaWxlVXRpbC5leGlzdHMobGFuZ3VhZ2VYbGlmZkZpbGUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY3JlYXRlVW50cmFuc2xhdGVkWGxpZmYobGFuZywgbGFuZ3VhZ2VYbGlmZkZpbGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWVyZ2VNYXN0ZXJUbyhsYW5nLCBsYW5ndWFnZVhsaWZmRmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgICAgICAgLnBpcGUobWFwKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuc3VwcG9ydE5neFRyYW5zbGF0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIuZnJvbUZpbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9uRm9ybWF0KHRoaXMucGFyYW1ldGVycy5pMThuRm9ybWF0KCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VYbGlmZkZpbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZW5jb2RpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFzdGVyLmZpbGVuYW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIE5neFRyYW5zbGF0ZUV4dHJhY3Rvci5leHRyYWN0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMubmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmdlbmVyYXRlZE5neFRyYW5zbGF0ZUZpbGUobGFuZykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH0pLCBjYXRjaEVycm9yKChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBYbGlmZk1lcmdlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuZXJyb3IoZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZigtMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuaGFuZGxlZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lU3RyaW5nID0gKGN1cnJlbnRGaWxlbmFtZSkgPyBmb3JtYXQoJ2ZpbGUgXCIlc1wiLCAnLCBjdXJyZW50RmlsZW5hbWUpIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmVycm9yKGZpbGVuYW1lU3RyaW5nICsgJ29vcHMgJyArIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBjcmVhdGUgYSBuZXcgZmlsZSBmb3IgdGhlIGxhbmd1YWdlLCB3aGljaCBjb250YWlucyBubyB0cmFuc2xhdGlvbnMsIGJ1dCBhbGwga2V5cy5cclxuICAgICAqIGluIHByaW5jaXBsZSwgdGhpcyBpcyBqdXN0IGEgY29weSBvZiB0aGUgbWFzdGVyIHdpdGggdGFyZ2V0LWxhbmd1YWdlIHNldC5cclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoIG5hbWUgb2YgZmlsZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZVVudHJhbnNsYXRlZFhsaWZmKGxhbmc6IHN0cmluZywgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcclxuICAgICAgICAvLyBjb3B5IG1hc3RlciAuLi5cclxuICAgICAgICAvLyBhbmQgc2V0IHRhcmdldC1sYW5ndWFnZVxyXG4gICAgICAgIC8vIGFuZCBjb3B5IHNvdXJjZSB0byB0YXJnZXQgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgY29uc3QgaXNEZWZhdWx0TGFuZzogYm9vbGVhbiA9IChsYW5nID09PSB0aGlzLnBhcmFtZXRlcnMuZGVmYXVsdExhbmd1YWdlKCkpO1xyXG4gICAgICAgIHRoaXMubWFzdGVyLnNldE5ld1RyYW5zVW5pdFRhcmdldFByYWVmaXgodGhpcy5wYXJhbWV0ZXJzLnRhcmdldFByYWVmaXgoKSk7XHJcbiAgICAgICAgdGhpcy5tYXN0ZXIuc2V0TmV3VHJhbnNVbml0VGFyZ2V0U3VmZml4KHRoaXMucGFyYW1ldGVycy50YXJnZXRTdWZmaXgoKSk7XHJcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlID1cclxuICAgICAgICAgICAgdGhpcy5tYXN0ZXIuY3JlYXRlVHJhbnNsYXRpb25GaWxlRm9yTGFuZyhsYW5nLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGgsIGlzRGVmYXVsdExhbmcsIHRoaXMucGFyYW1ldGVycy51c2VTb3VyY2VBc1RhcmdldCgpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRvVHJhbnNsYXRlKHRoaXMubWFzdGVyLnNvdXJjZUxhbmd1YWdlKCksIGxhbmcsIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoc3VtbWFyeSkgPT4ge1xyXG4gICAgICAgICAgICAvLyB3cml0ZSBpdCB0byBmaWxlXHJcbiAgICAgICAgICAgIFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyLnNhdmUobGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSwgdGhpcy5wYXJhbWV0ZXJzLmJlYXV0aWZ5T3V0cHV0KCkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuaW5mbygnY3JlYXRlZCBuZXcgZmlsZSBcIiVzXCIgZm9yIHRhcmdldC1sYW5ndWFnZT1cIiVzXCInLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGgsIGxhbmcpO1xyXG4gICAgICAgICAgICBpZiAoIWlzRGVmYXVsdExhbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdwbGVhc2UgdHJhbnNsYXRlIGZpbGUgXCIlc1wiIHRvIHRhcmdldC1sYW5ndWFnZT1cIiVzXCInLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGgsIGxhbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCB0aGUgaW5wdXQgZm9ybWF0IHRvIHRoZSBmb3JtYXQgb2YgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogTm9ybWFsbHkgdGhleSBhcmUgdGhlIHNhbWUgYnV0IGZvciB4bWIgdGhlIHRyYW5zbGF0aW9uIGZvcm1hdCBpcyB4dGIuXHJcbiAgICAgKiBAcGFyYW0gaTE4bkZvcm1hdCBmb3JtYXRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmFuc2xhdGlvbkZvcm1hdChpMThuRm9ybWF0OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmIChpMThuRm9ybWF0ID09PSBGT1JNQVRfWE1CKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBGT1JNQVRfWFRCO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpMThuRm9ybWF0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlIGFsbFxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2VcclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZVhsaWZmRmlsZVBhdGggZmlsZW5hbWVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtZXJnZU1hc3RlclRvKGxhbmc6IHN0cmluZywgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcclxuICAgICAgICAvLyByZWFkIGxhbmcgc3BlY2lmaWMgZmlsZVxyXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSA9XHJcbiAgICAgICAgICAgIFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyLmZyb21GaWxlKFxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvbkZvcm1hdCh0aGlzLnBhcmFtZXRlcnMuaTE4bkZvcm1hdCgpKSxcclxuICAgICAgICAgICAgICAgIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCxcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5lbmNvZGluZygpKTtcclxuICAgICAgICBjb25zdCBpc0RlZmF1bHRMYW5nOiBib29sZWFuID0gKGxhbmcgPT09IHRoaXMucGFyYW1ldGVycy5kZWZhdWx0TGFuZ3VhZ2UoKSk7XHJcbiAgICAgICAgbGV0IG5ld0NvdW50ID0gMDtcclxuICAgICAgICBsZXQgY29ycmVjdFNvdXJjZUNvbnRlbnRDb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IGNvcnJlY3RTb3VyY2VSZWZDb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IGNvcnJlY3REZXNjcmlwdGlvbk9yTWVhbmluZ0NvdW50ID0gMDtcclxuICAgICAgICBsZXQgaWRDaGFuZ2VkQ291bnQgPSAwO1xyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUuc2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCh0aGlzLnBhcmFtZXRlcnMudGFyZ2V0UHJhZWZpeCgpKTtcclxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLnNldE5ld1RyYW5zVW5pdFRhcmdldFN1ZmZpeCh0aGlzLnBhcmFtZXRlcnMudGFyZ2V0U3VmZml4KCkpO1xyXG4gICAgICAgIGxldCBsYXN0UHJvY2Vzc2VkVW5pdDogSVRyYW5zVW5pdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tYXN0ZXIuZm9yRWFjaFRyYW5zVW5pdCgobWFzdGVyVHJhbnNVbml0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zVW5pdDogSVRyYW5zVW5pdCA9IGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUudHJhbnNVbml0V2l0aElkKG1hc3RlclRyYW5zVW5pdC5pZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRyYW5zVW5pdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gb29wcywgbm8gdHJhbnNsYXRpb24sIG11c3QgYmUgYSBuZXcga2V5LCBzbyBhZGQgaXRcclxuICAgICAgICAgICAgICAgIGxldCBuZXdVbml0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5hbGxvd0lkQ2hhbmdlKClcclxuICAgICAgICAgICAgICAgICAgICAmJiAobmV3VW5pdCA9IHRoaXMucHJvY2Vzc0NoYW5nZWRJZFVuaXQobWFzdGVyVHJhbnNVbml0LCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLCBsYXN0UHJvY2Vzc2VkVW5pdCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb2Nlc3NlZFVuaXQgPSBuZXdVbml0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlkQ2hhbmdlZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQcm9jZXNzZWRVbml0ID0gbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5pbXBvcnROZXdUcmFuc1VuaXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc3RlclRyYW5zVW5pdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEZWZhdWx0TGFuZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnVzZVNvdXJjZUFzVGFyZ2V0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnBhcmFtZXRlcnMucHJlc2VydmVPcmRlcigpKSA/IGxhc3RQcm9jZXNzZWRVbml0IDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGNoYW5nZWQgc291cmNlIGNvbnRlbnQgYW5kIGNoYW5nZSBpdCBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIC8vIChjYW4gb25seSBoYXBwZW4gaWYgSUQgaXMgZXhwbGljaXRlbHkgc2V0LCBvdGhlcndpc2UgSUQgd291bGQgY2hhbmdlIGlmIHNvdXJjZSBjb250ZW50IGlzIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNVbml0LnN1cHBvcnRzU2V0U291cmNlQ29udGVudCgpICYmIG1hc3RlclRyYW5zVW5pdC5zb3VyY2VDb250ZW50KCkgIT09IHRyYW5zVW5pdC5zb3VyY2VDb250ZW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuc2V0U291cmNlQ29udGVudChtYXN0ZXJUcmFuc1VuaXQuc291cmNlQ29udGVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZhdWx0TGFuZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAjODEgY2hhbmdlZCBzb3VyY2UgbXVzdCBiZSBjb3BpZWQgdG8gdGFyZ2V0IGZvciBkZWZhdWx0IGxhbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LnRyYW5zbGF0ZShtYXN0ZXJUcmFuc1VuaXQuc291cmNlQ29udGVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LnNldFRhcmdldFN0YXRlKFNUQVRFX0ZJTkFMKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNVbml0LnRhcmdldFN0YXRlKCkgPT09IFNUQVRFX0ZJTkFMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzb3VyY2UgaXMgY2hhbmdlZCwgc28gdHJhbnNsYXRpb24gaGFzIHRvIGJlIGNoZWNrZWQgYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5zZXRUYXJnZXRTdGF0ZShTVEFURV9UUkFOU0xBVEVEKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0U291cmNlQ29udGVudENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBvciBjaGFuZ2VkIHNvdXJjZSByZWYgYW5kIGFkZCBpdCBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc1VuaXQuc3VwcG9ydHNTZXRTb3VyY2VSZWZlcmVuY2VzKClcclxuICAgICAgICAgICAgICAgICAgICAmJiAhdGhpcy5hcmVTb3VyY2VSZWZlcmVuY2VzRXF1YWwobWFzdGVyVHJhbnNVbml0LnNvdXJjZVJlZmVyZW5jZXMoKSwgdHJhbnNVbml0LnNvdXJjZVJlZmVyZW5jZXMoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuc2V0U291cmNlUmVmZXJlbmNlcyhtYXN0ZXJUcmFuc1VuaXQuc291cmNlUmVmZXJlbmNlcygpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0U291cmNlUmVmQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjaGFuZ2VkIGRlc2NyaXB0aW9uIG9yIG1lYW5pbmdcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc1VuaXQuc3VwcG9ydHNTZXREZXNjcmlwdGlvbkFuZE1lYW5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zVW5pdC5kZXNjcmlwdGlvbigpICE9PSBtYXN0ZXJUcmFuc1VuaXQuZGVzY3JpcHRpb24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuc2V0RGVzY3JpcHRpb24obWFzdGVyVHJhbnNVbml0LmRlc2NyaXB0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zVW5pdC5tZWFuaW5nKCkgIT09IG1hc3RlclRyYW5zVW5pdC5tZWFuaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LnNldE1lYW5pbmcobWFzdGVyVHJhbnNVbml0Lm1lYW5pbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWN0RGVzY3JpcHRpb25Pck1lYW5pbmdDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RQcm9jZXNzZWRVbml0ID0gdHJhbnNVbml0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG5ld0NvdW50ID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybignbWVyZ2VkICVzIHRyYW5zLXVuaXRzIGZyb20gbWFzdGVyIHRvIFwiJXNcIicsIG5ld0NvdW50LCBsYW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvcnJlY3RTb3VyY2VDb250ZW50Q291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCd0cmFuc2ZlcnJlZCAlcyBjaGFuZ2VkIHNvdXJjZSBjb250ZW50IGZyb20gbWFzdGVyIHRvIFwiJXNcIicsIGNvcnJlY3RTb3VyY2VDb250ZW50Q291bnQsIGxhbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29ycmVjdFNvdXJjZVJlZkNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybigndHJhbnNmZXJyZWQgJXMgc291cmNlIHJlZmVyZW5jZXMgZnJvbSBtYXN0ZXIgdG8gXCIlc1wiJywgY29ycmVjdFNvdXJjZVJlZkNvdW50LCBsYW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlkQ2hhbmdlZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybignZm91bmQgJXMgY2hhbmdlZCBpZFxcJ3MgaW4gXCIlc1wiJywgaWRDaGFuZ2VkQ291bnQsIGxhbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29ycmVjdERlc2NyaXB0aW9uT3JNZWFuaW5nQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKFxyXG4gICAgICAgICAgICAgICAgJ3RyYW5zZmVycmVkICVzIGNoYW5nZWQgZGVzY3JpcHRpb25zL21lYW5pbmdzIGZyb20gbWFzdGVyIHRvIFwiJXNcIicsIGNvcnJlY3REZXNjcmlwdGlvbk9yTWVhbmluZ0NvdW50LCBsYW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgZWxlbWVudHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcclxuICAgICAgICBsZXQgcmVtb3ZlQ291bnQgPSAwO1xyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUuZm9yRWFjaFRyYW5zVW5pdCgodHJhbnNVbml0OiBJVHJhbnNVbml0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0c0luTWFzdGVyID0gIWlzTnVsbE9yVW5kZWZpbmVkKHRoaXMubWFzdGVyLnRyYW5zVW5pdFdpdGhJZCh0cmFuc1VuaXQuaWQpKTtcclxuICAgICAgICAgICAgaWYgKCFleGlzdHNJbk1hc3Rlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5yZW1vdmVVbnVzZWRJZHMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUucmVtb3ZlVHJhbnNVbml0V2l0aElkKHRyYW5zVW5pdC5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlbW92ZUNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnJlbW92ZVVudXNlZElkcygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybigncmVtb3ZlZCAlcyB1bnVzZWQgdHJhbnMtdW5pdHMgaW4gXCIlc1wiJywgcmVtb3ZlQ291bnQsIGxhbmcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ2tlZXBpbmcgJXMgdW51c2VkIHRyYW5zLXVuaXRzIGluIFwiJXNcIiwgYmVjYXVzZSByZW1vdmVVbnVzZWQgaXMgZGlzYWJsZWQnLCByZW1vdmVDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZXdDb3VudCA9PT0gMCAmJiByZW1vdmVDb3VudCA9PT0gMCAmJiBjb3JyZWN0U291cmNlQ29udGVudENvdW50ID09PSAwXHJcbiAgICAgICAgICAgICYmIGNvcnJlY3RTb3VyY2VSZWZDb3VudCA9PT0gMCAmJiBjb3JyZWN0RGVzY3JpcHRpb25Pck1lYW5pbmdDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuaW5mbygnZmlsZSBmb3IgXCIlc1wiIHdhcyB1cCB0byBkYXRlJywgbGFuZyk7XHJcbiAgICAgICAgICAgIHJldHVybiBvZihudWxsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvVHJhbnNsYXRlKHRoaXMubWFzdGVyLnNvdXJjZUxhbmd1YWdlKCksIGxhbmcsIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUpXHJcbiAgICAgICAgICAgICAgICAucGlwZShtYXAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyaXRlIGl0IHRvIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5zYXZlKGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUsIHRoaXMucGFyYW1ldGVycy5iZWF1dGlmeU91dHB1dCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuaW5mbygndXBkYXRlZCBmaWxlIFwiJXNcIiBmb3IgdGFyZ2V0LWxhbmd1YWdlPVwiJXNcIicsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCwgbGFuZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvdW50ID4gMCAmJiAhaXNEZWZhdWx0TGFuZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybigncGxlYXNlIHRyYW5zbGF0ZSBmaWxlIFwiJXNcIiB0byB0YXJnZXQtbGFuZ3VhZ2U9XCIlc1wiJywgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoLCBsYW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHRoZSBjYXNlIG9mIGNoYW5nZWQgaWQgZHVlIHRvIHNtYWxsIHdoaXRlIHNwYWNlIGNoYW5nZXMuXHJcbiAgICAgKiBAcGFyYW0gbWFzdGVyVHJhbnNVbml0IHVuaXQgaW4gbWFzdGVyIGZpbGVcclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlIHRyYW5zbGF0aW9uIGZpbGVcclxuICAgICAqIEBwYXJhbSBsYXN0UHJvY2Vzc2VkVW5pdCBVbml0IGJlZm9yZSB0aGUgb25lIHByb2Nlc3NlZCBoZXJlLiBOZXcgdW5pdCB3aWxsIGJlIGluc2VydGVkIGFmdGVyIHRoaXMgb25lLlxyXG4gICAgICogQHJldHVybiBwcm9jZXNzZWQgdW5pdCwgaWYgZG9uZSwgbnVsbCBpZiBubyBjaGFuZ2VkIHVuaXQgZm91bmRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwcm9jZXNzQ2hhbmdlZElkVW5pdChcclxuICAgICAgICBtYXN0ZXJUcmFuc1VuaXQ6IElUcmFuc1VuaXQsXHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLFxyXG4gICAgICAgIGxhc3RQcm9jZXNzZWRVbml0OiBJVHJhbnNVbml0KTogSVRyYW5zVW5pdCB7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hc3RlclNvdXJjZVN0cmluZyA9IG1hc3RlclRyYW5zVW5pdC5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLmFzRGlzcGxheVN0cmluZyhOT1JNQUxJWkFUSU9OX0ZPUk1BVF9ERUZBVUxUKS50cmltKCk7XHJcbiAgICAgICAgbGV0IGNoYW5nZWRUcmFuc1VuaXQ6IElUcmFuc1VuaXQgPSBudWxsO1xyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUuZm9yRWFjaFRyYW5zVW5pdCgobGFuZ3VhZ2VUcmFuc1VuaXQpID0+IHtcclxuICAgICAgICAgICAgIGlmIChsYW5ndWFnZVRyYW5zVW5pdC5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLmFzRGlzcGxheVN0cmluZyhOT1JNQUxJWkFUSU9OX0ZPUk1BVF9ERUZBVUxUKS50cmltKCkgPT09IG1hc3RlclNvdXJjZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgIGNoYW5nZWRUcmFuc1VuaXQgPSBsYW5ndWFnZVRyYW5zVW5pdDtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWNoYW5nZWRUcmFuc1VuaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1lcmdlZFRyYW5zVW5pdCA9IGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUuaW1wb3J0TmV3VHJhbnNVbml0KFxyXG4gICAgICAgICAgICBtYXN0ZXJUcmFuc1VuaXQsXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgKHRoaXMucGFyYW1ldGVycy5wcmVzZXJ2ZU9yZGVyKCkpID8gbGFzdFByb2Nlc3NlZFVuaXQgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRDb250ZW50ID0gY2hhbmdlZFRyYW5zVW5pdC50YXJnZXRDb250ZW50KCk7XHJcbiAgICAgICAgaWYgKHRyYW5zbGF0ZWRDb250ZW50KSB7IC8vIGlzc3VlICM2OCBzZXQgdHJhbnNsYXRlZCBvbmx5LCBpZiBpdCBpcyByZWFsbHkgdHJhbnNsYXRlZFxyXG4gICAgICAgICAgICBtZXJnZWRUcmFuc1VuaXQudHJhbnNsYXRlKHRyYW5zbGF0ZWRDb250ZW50KTtcclxuICAgICAgICAgICAgbWVyZ2VkVHJhbnNVbml0LnNldFRhcmdldFN0YXRlKFNUQVRFX1RSQU5TTEFURUQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWVyZ2VkVHJhbnNVbml0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXJlU291cmNlUmVmZXJlbmNlc0VxdWFsKFxyXG4gICAgICAgIHJlZjE6IHtzb3VyY2VmaWxlOiBzdHJpbmc7IGxpbmVudW1iZXI6IG51bWJlcjsgfVtdLFxyXG4gICAgICAgIHJlZjI6IHtzb3VyY2VmaWxlOiBzdHJpbmc7IGxpbmVudW1iZXI6IG51bWJlcjsgfVtdKTogYm9vbGVhbiB7XHJcblxyXG4gICAgICAgIGlmICgoaXNOdWxsT3JVbmRlZmluZWQocmVmMSkgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKHJlZjIpKSB8fCAoaXNOdWxsT3JVbmRlZmluZWQocmVmMikgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKHJlZjEpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChyZWYxKSAmJiBpc051bGxPclVuZGVmaW5lZChyZWYyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYm90IHJlZnMgYXJlIHNldCBub3csIGNvbnZlcnQgdG8gc2V0IHRvIGNvbXBhcmUgdGhlbVxyXG4gICAgICAgIGNvbnN0IHNldDE6IFNldDxzdHJpbmc+ID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICAgICAgcmVmMS5mb3JFYWNoKChyZWYpID0+IHtzZXQxLmFkZChyZWYuc291cmNlZmlsZSArICc6JyArIHJlZi5saW5lbnVtYmVyKTsgfSk7XHJcbiAgICAgICAgY29uc3Qgc2V0MjogU2V0PHN0cmluZz4gPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICByZWYyLmZvckVhY2goKHJlZikgPT4ge3NldDIuYWRkKHJlZi5zb3VyY2VmaWxlICsgJzonICsgcmVmLmxpbmVudW1iZXIpOyB9KTtcclxuICAgICAgICBpZiAoc2V0MS5zaXplICE9PSBzZXQyLnNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgIHNldDIuZm9yRWFjaCgocmVmKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghc2V0MS5oYXMocmVmKSkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1dG8gdHJhbnNsYXRlIGZpbGUgdmlhIEdvb2dsZSBUcmFuc2xhdGUuXHJcbiAgICAgKiBXaWxsIHRyYW5zbGF0ZSBhbGwgbmV3IHVuaXRzIGluIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gdG8gdG9cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGVcclxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHdpdGggdGhlIGV4ZWN1dGlvbiByZXN1bHQgYXMgYSBzdW1tYXJ5IHJlcG9ydC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhdXRvVHJhbnNsYXRlKFxyXG4gICAgICAgIGZyb206IHN0cmluZyxcclxuICAgICAgICB0bzogc3RyaW5nLFxyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSk6IE9ic2VydmFibGU8QXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQ+IHtcclxuXHJcbiAgICAgICAgbGV0IHNlcnZpY2VDYWxsOiBPYnNlcnZhYmxlPEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0PjtcclxuICAgICAgICBjb25zdCBhdXRvdHJhbnNsYXRlRW5hYmxlZDogYm9vbGVhbiA9IHRoaXMucGFyYW1ldGVycy5hdXRvdHJhbnNsYXRlTGFuZ3VhZ2UodG8pO1xyXG4gICAgICAgIGlmIChhdXRvdHJhbnNsYXRlRW5hYmxlZCkge1xyXG4gICAgICAgICAgICBzZXJ2aWNlQ2FsbCA9IHRoaXMuYXV0b1RyYW5zbGF0ZVNlcnZpY2UuYXV0b1RyYW5zbGF0ZShmcm9tLCB0bywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VydmljZUNhbGwgPSBvZihuZXcgQXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQoZnJvbSwgdG8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VDYWxsLnBpcGUobWFwKChzdW1tYXJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhdXRvdHJhbnNsYXRlRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnkuZXJyb3IoKSB8fCBzdW1tYXJ5LmZhaWxlZCgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5lcnJvcihzdW1tYXJ5LmNvbnRlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKHN1bW1hcnkuY29udGVudCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3VtbWFyeTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG59XHJcbiJdLCJuYW1lcyI6WyJOZ01vZHVsZSIsInRzbGliXzEuX19leHRlbmRzIiwiV3JpdGFibGUiLCJmb3JtYXQiLCJmcy5leGlzdHNTeW5jIiwiZnMucmVhZEZpbGVTeW5jIiwiZnMud3JpdGVGaWxlU3luYyIsImZzLm9wZW5TeW5jIiwiZnMucmVhZFN5bmMiLCJmcy53cml0ZVN5bmMiLCJmcy5jbG9zZVN5bmMiLCJwYXRoIiwiZnMucmVhZGRpclN5bmMiLCJmcy5sc3RhdFN5bmMiLCJmcy51bmxpbmtTeW5jIiwiZnMucm1kaXJTeW5jIiwiTk9STUFMSVpBVElPTl9GT1JNQVRfTkdYVFJBTlNMQVRFIiwidHNsaWJfMS5fX3ZhbHVlcyIsImlzQWJzb2x1dGUiLCJqb2luIiwiZGlybmFtZSIsImZzLnN0YXRTeW5jIiwiZnMuYWNjZXNzU3luYyIsImZzLmNvbnN0YW50cyIsInBhdGgucmVzb2x2ZSIsIlRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeSIsIm9mIiwidGhyb3dFcnJvciIsImZvcmtKb2luIiwibWFwIiwiT2JzZXJ2YWJsZSIsIlNUQVRFX05FVyIsImVudGl0eURlY29kZXJMaWIuZGVjb2RlIiwiY2F0Y2hFcnJvciIsIkZPUk1BVF9YTUIiLCJGT1JNQVRfWFRCIiwiU1RBVEVfRklOQUwiLCJTVEFURV9UUkFOU0xBVEVE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