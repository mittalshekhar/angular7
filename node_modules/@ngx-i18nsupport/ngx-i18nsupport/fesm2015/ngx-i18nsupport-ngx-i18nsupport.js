import { NgModule } from '@angular/core';
import { Writable } from 'stream';
import chalk from 'chalk';
import { format } from 'util';
import { readFileSync, statSync, accessSync, constants, existsSync, writeFileSync, openSync, readSync, writeSync, closeSync, readdirSync, lstatSync, unlinkSync, rmdirSync } from 'fs';
import { NORMALIZATION_FORMAT_NGXTRANSLATE, TranslationMessagesFileFactory, STATE_NEW, FORMAT_XMB, FORMAT_XTB, NORMALIZATION_FORMAT_DEFAULT, STATE_FINAL, STATE_TRANSLATED } from '@ngx-i18nsupport/ngx-i18nsupport-lib';
import { dirname, isAbsolute, join, resolve } from 'path';
import * as request from 'request';
import { Observable, of, forkJoin, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { decode } from 'he';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
// not used, only there to make ng-packagr happy
class XliffmergeModule {
}
XliffmergeModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [],
                exports: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Collection of utility functions that are deprecated in nodes util.
 */
/**
 * Replaces node isNullOrUndefined.
 * @param {?} value
 * @return {?}
 */
function isNullOrUndefined(value) {
    return value === undefined || value === null;
}
/**
 * Replaces node isString.
 * @param {?} value
 * @return {?}
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * Replaces node isArray.
 * @param {?} value
 * @return {?}
 */
function isArray(value) {
    return Array.isArray(value);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 20.02.2017.
 * A helper class for testing.
 * Can be used as a WritableStream and writes everything (synchronously) into a string,
 * that can easily be read by the tests.
 */
class WriterToString extends Writable {
    constructor() {
        super();
        this.resultString = '';
    }
    /**
     * @param {?} chunk
     * @param {?} encoding
     * @param {?} callback
     * @return {?}
     */
    _write(chunk, encoding, callback) {
        /** @type {?} */
        let chunkString;
        if (isString(chunk)) {
            chunkString = chunk;
        }
        else if (chunk instanceof Buffer) {
            chunkString = chunk.toString();
        }
        else {
            chunkString = Buffer.alloc(chunk).toString(encoding);
        }
        this.resultString = this.resultString + chunkString;
        callback();
    }
    /**
     * Returns a string of everything, that was written to the stream so far.
     * @return {?} written data
     */
    writtenData() {
        return this.resultString;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @enum {number} */
const LogLevel = {
    'ERROR': 0,
    'WARN': 1,
    'INFO': 2,
    'DEBUG': 3,
};
LogLevel[LogLevel['ERROR']] = 'ERROR';
LogLevel[LogLevel['WARN']] = 'WARN';
LogLevel[LogLevel['INFO']] = 'INFO';
LogLevel[LogLevel['DEBUG']] = 'DEBUG';
class CommandOutput {
    /**
     * @param {?=} stdout
     */
    constructor(stdout) {
        this._quiet = false;
        this._verbose = false;
        if (stdout) {
            this.outputStream = stdout;
        }
        else {
            this.outputStream = process.stdout;
        }
    }
    /**
     * @return {?}
     */
    setVerbose() {
        this._verbose = true;
    }
    /**
     * @return {?}
     */
    setQuiet() {
        this._quiet = true;
    }
    /**
     * Test, wether verbose is enabled.
     * @return {?} wether verbose is enabled.
     */
    verbose() {
        return this._verbose;
    }
    /**
     * Test, wether quiet is enabled.
     * @return {?} wether quiet is enabled.
     */
    quiet() {
        return this._quiet;
    }
    /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    error(msg, ...params) {
        this.log(LogLevel.ERROR, msg, params);
    }
    /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    warn(msg, ...params) {
        this.log(LogLevel.WARN, msg, params);
    }
    /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    info(msg, ...params) {
        this.log(LogLevel.INFO, msg, params);
    }
    /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    debug(msg, ...params) {
        this.log(LogLevel.DEBUG, msg, params);
    }
    /**
     * @param {?} level
     * @param {?} msg
     * @param {?} params
     * @return {?}
     */
    log(level, msg, params) {
        if (!this.isOutputEnabled(level)) {
            return;
        }
        /** @type {?} */
        let coloredMessage;
        switch (level) {
            case LogLevel.ERROR:
                coloredMessage = chalk.red('ERROR: ' + msg);
                break;
            case LogLevel.WARN:
                coloredMessage = chalk.magenta('WARNING: ' + msg);
                break;
            default:
                coloredMessage = chalk.gray('* ' + msg);
                break;
        }
        /** @type {?} */
        const outMsg = format(coloredMessage, ...params);
        this.outputStream.write(outMsg + '\n');
    }
    /**
     * @param {?} level
     * @return {?}
     */
    isOutputEnabled(level) {
        /** @type {?} */
        let quietEnabled;
        /** @type {?} */
        let verboseEnabled;
        if (this._quiet && this._verbose) {
            quietEnabled = false;
            verboseEnabled = false;
        }
        else {
            quietEnabled = this._quiet;
            verboseEnabled = this._verbose;
        }
        switch (level) {
            case LogLevel.ERROR:
                return true; // always output errors
            case LogLevel.WARN:
                return (!quietEnabled);
            case LogLevel.INFO:
                return (verboseEnabled && !quietEnabled);
            case LogLevel.DEBUG:
                return verboseEnabled;
            default:
                return true;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 17.02.2017.
 */
class XliffMergeError extends Error {
    /**
     * @param {?} msg
     */
    constructor(msg) {
        super(msg);
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, XliffMergeError.prototype);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 17.02.2017.
 * Some (a few) simple utils for file operations.
 * Just for convenience.
 */
class FileUtil {
    /**
     * Check for existence.
     * @param {?} filename filename
     * @return {?} wether file exists
     */
    static exists(filename) {
        return existsSync(filename);
    }
    /**
     * Read a file.
     * @param {?} filename filename
     * @param {?} encoding encoding
     * @return {?} content of file
     */
    static read(filename, encoding) {
        return readFileSync(filename, encoding);
    }
    /**
     * Write a file with given content.
     * @param {?} filename filename
     * @param {?} newContent newContent
     * @param {?} encoding encoding
     * @return {?}
     */
    static replaceContent(filename, newContent, encoding) {
        writeFileSync(filename, newContent, { encoding: encoding });
    }
    /**
     * @param {?} srcFile
     * @param {?} destFile
     * @return {?}
     */
    static copy(srcFile, destFile) {
        /** @type {?} */
        const BUF_LENGTH = 64 * 1024;
        /** @type {?} */
        const buff = Buffer.alloc(BUF_LENGTH);
        /** @type {?} */
        const fdr = openSync(srcFile, 'r');
        /** @type {?} */
        const fdw = openSync(destFile, 'w');
        /** @type {?} */
        let bytesRead = 1;
        /** @type {?} */
        let pos = 0;
        while (bytesRead > 0) {
            bytesRead = readSync(fdr, buff, 0, BUF_LENGTH, pos);
            writeSync(fdw, buff, 0, bytesRead);
            pos += bytesRead;
        }
        closeSync(fdr);
        closeSync(fdw);
    }
    /**
     * Delete the folder and all of its content (rm -rf).
     * @param {?} path path
     * @return {?}
     */
    static deleteFolderRecursive(path) {
        /** @type {?} */
        let files = [];
        if (existsSync(path)) {
            files = readdirSync(path);
            files.forEach(function (file) {
                /** @type {?} */
                const curPath = path + '/' + file;
                if (lstatSync(curPath).isDirectory()) { // recurse
                    FileUtil.deleteFolderRecursive(curPath);
                }
                else { // delete file
                    unlinkSync(curPath);
                }
            });
            rmdirSync(path);
        }
    }
    /**
     * Delete folders content recursively, but do not delete folder.
     * Folder is left empty at the end.
     * @param {?} path path
     * @return {?}
     */
    static deleteFolderContentRecursive(path) {
        /** @type {?} */
        let files = [];
        if (existsSync(path)) {
            files = readdirSync(path);
            files.forEach(function (file) {
                /** @type {?} */
                const curPath = path + '/' + file;
                if (lstatSync(curPath).isDirectory()) { // recurse
                    FileUtil.deleteFolderRecursive(curPath);
                }
                else { // delete file
                    unlinkSync(curPath);
                }
            });
        }
    }
    /**
     * Delete a file.
     * @param {?} path path
     * @return {?}
     */
    static deleteFile(path) {
        unlinkSync(path);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Helper class to parse ngx translate extraction pattern
 * and to decide wether a given message matches the pattern.
 */
class NgxTranslateExtractionPattern {
    /**
     * Construct the pattern from given description string
     * @throws an error, if there is a syntax error
     * @param {?} extractionPatternString extractionPatternString
     */
    constructor(extractionPatternString) {
        this.extractionPatternString = extractionPatternString;
        /** @type {?} */
        const parts = extractionPatternString.split('|');
        this._matchExplicitId = false;
        this._descriptionPatterns = [];
        for (let i = 0; i < parts.length; i++) {
            /** @type {?} */
            const part = parts[i];
            if (part === '@@') {
                if (this._matchExplicitId) {
                    throw new Error('extraction pattern must not contain @@ twice');
                }
                this._matchExplicitId = true;
            }
            else {
                /** @type {?} */
                const errorString = this.checkValidDescriptionPattern(part);
                if (errorString) {
                    throw new Error(errorString);
                }
                this._descriptionPatterns.push(part);
            }
        }
    }
    /**
     * Check, wether an explicitly set id matches the pattern.
     * @param {?} id id
     * @return {?} wether an explicitly set id matches the pattern.
     */
    isExplicitIdMatched(id) {
        return id && this._matchExplicitId;
    }
    /**
     * Check, wether a given description matches the pattern.
     * @param {?} description description
     * @return {?} wether a given description matches the pattern.
     */
    isDescriptionMatched(description) {
        return this._descriptionPatterns.indexOf(description) >= 0;
    }
    /**
     * @param {?} descriptionPattern
     * @return {?}
     */
    checkValidDescriptionPattern(descriptionPattern) {
        if (!descriptionPattern) {
            return 'empty value not allowed';
        }
        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {
            return null; // it is ok
        }
        else {
            return 'description pattern must be an identifier containing only letters, digits, _ or -';
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class NgxTranslateExtractor {
    /**
     * @param {?} messagesFile
     * @param {?} extractionPatternString
     */
    constructor(messagesFile, extractionPatternString) {
        this.messagesFile = messagesFile;
        this.extractionPattern = new NgxTranslateExtractionPattern(extractionPatternString);
    }
    /**
     * Check, wether extractionPattern has valid syntax.
     * @param {?} extractionPatternString extractionPatternString
     * @return {?} null, if pattern is ok, string describing the error, if it is not ok.
     */
    static checkPattern(extractionPatternString) {
        try {
            if (new NgxTranslateExtractionPattern(extractionPatternString)) {
                return null;
            }
        }
        catch (error) {
            return error.message;
        }
        return null;
    }
    /**
     * @param {?} messagesFile
     * @param {?} extractionPattern
     * @param {?} outputFile
     * @return {?}
     */
    static extract(messagesFile, extractionPattern, outputFile) {
        new NgxTranslateExtractor(messagesFile, extractionPattern).extractTo(outputFile);
    }
    /**
     * Extact messages and write them to a file.
     * @param {?} outputFile outputFile
     * @return {?}
     */
    extractTo(outputFile) {
        /** @type {?} */
        const translations = this.toNgxTranslations(this.extract());
        if (translations && Object.keys(translations).length > 0) {
            FileUtil.replaceContent(outputFile, JSON.stringify(translations, null, 4), 'UTF-8');
        }
        else {
            if (FileUtil.exists(outputFile)) {
                FileUtil.deleteFile(outputFile);
            }
        }
    }
    /**
     *  Extract messages and convert them to ngx translations.
     * @return {?} the translation objects.
     */
    extract() {
        /** @type {?} */
        const result = [];
        this.messagesFile.forEachTransUnit((tu) => {
            /** @type {?} */
            const ngxId = this.ngxTranslateIdFromTU(tu);
            if (ngxId) {
                /** @type {?} */
                const messagetext = tu.targetContentNormalized().asDisplayString(NORMALIZATION_FORMAT_NGXTRANSLATE);
                result.push({ id: ngxId, message: messagetext });
            }
        });
        return result;
    }
    /**
     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.
     * There are 2 possibilities:
     * 1. description is set to "ngx-translate" and meaning contains the id.
     * 2. id is explicitly set to a string.
     * @param {?} tu tu
     * @return {?} an ngx id or null, if this tu should not be extracted.
     */
    ngxTranslateIdFromTU(tu) {
        if (this.isExplicitlySetId(tu.id)) {
            if (this.extractionPattern.isExplicitIdMatched(tu.id)) {
                return tu.id;
            }
            else {
                return null;
            }
        }
        /** @type {?} */
        const description = tu.description();
        if (description && this.extractionPattern.isDescriptionMatched(description)) {
            return tu.meaning();
        }
    }
    /**
     * Test, wether ID was explicitly set (via i18n="\@myid).
     * Just heuristic, an ID is explicitly, if it does not look like a generated one.
     * @param {?} id id
     * @return {?} wether ID was explicitly set (via i18n="\@myid).
     */
    isExplicitlySetId(id) {
        if (isNullOrUndefined(id)) {
            return false;
        }
        // generated IDs are either decimal or sha1 hex
        /** @type {?} */
        const reForGeneratedId = /^[0-9a-f]{11,}$/;
        return !reForGeneratedId.test(id);
    }
    /**
     * Convert list of relevant TUs to ngx translations object.
     * @param {?} msgList msgList
     * @return {?}
     */
    toNgxTranslations(msgList) {
        /** @type {?} */
        const translationObject = {};
        msgList.forEach((msg) => {
            this.putInTranslationObject(translationObject, msg);
        });
        return translationObject;
    }
    /**
     * Put a new messages into the translation data object.
     * If you add, e.g. "{id: 'myapp.example', message: 'test'}",
     * the translation object will then contain an object myapp that has property example:
     * {myapp: {
     *   example: 'test'
     *   }}
     * @param {?} translationObject translationObject
     * @param {?} msg msg
     * @return {?}
     */
    putInTranslationObject(translationObject, msg) {
        /** @type {?} */
        let firstPartOfId;
        /** @type {?} */
        let restOfId;
        /** @type {?} */
        const indexOfDot = msg.id.indexOf('.');
        if (indexOfDot === 0 || indexOfDot === (msg.id.length - 1)) {
            throw new Error('bad nxg-translate id "' + msg.id + '"');
        }
        if (indexOfDot < 0) {
            firstPartOfId = msg.id;
            restOfId = '';
        }
        else {
            firstPartOfId = msg.id.substring(0, indexOfDot);
            restOfId = msg.id.substring(indexOfDot + 1);
        }
        /** @type {?} */
        let object = translationObject[firstPartOfId];
        if (isNullOrUndefined(object)) {
            if (restOfId === '') {
                translationObject[firstPartOfId] = msg.message;
                return;
            }
            object = {};
            translationObject[firstPartOfId] = object;
        }
        else {
            if (restOfId === '') {
                throw new Error('duplicate id praefix "' + msg.id + '"');
            }
        }
        this.putInTranslationObject((/** @type {?} */ (object)), { id: restOfId, message: msg.message });
    }
}
NgxTranslateExtractor.DefaultExtractionPattern = '@@|ngx-translate';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const PROFILE_CANDIDATES = ['package.json', '.angular-cli.json'];
class XliffMergeParameters {
    /**
     * Create Parameters.
     * @param {?} options command options
     * @param {?=} profileContent given profile (if not, it is read from the profile path from options).
     * @return {?}
     */
    static createFromOptions(options, profileContent) {
        /** @type {?} */
        const parameters = new XliffMergeParameters();
        parameters.configure(options, profileContent);
        return parameters;
    }
    constructor() {
        this.errorsFound = [];
        this.warningsFound = [];
    }
    /**
     * Read potential profile.
     * To be a candidate, file must exist and contain property "xliffmergeOptions".
     * @param {?} profilePath path of profile
     * @return {?} parsed content of file or null, if file does not exist or is not a profile candidate.
     */
    static readProfileCandidate(profilePath) {
        /** @type {?} */
        let content;
        try {
            content = readFileSync(profilePath, 'UTF-8');
        }
        catch (err) {
            return null;
        }
        /** @type {?} */
        const parsedContent = JSON.parse(content);
        if (parsedContent && parsedContent.xliffmergeOptions) {
            return parsedContent;
        }
        else {
            return null;
        }
    }
    /**
     * Initialize me from the profile content.
     * (public only for test usage).
     * @param {?} options options given at runtime via command line
     * @param {?=} profileContent if null, read it from profile.
     * @return {?}
     */
    configure(options, profileContent) {
        this.errorsFound = [];
        this.warningsFound = [];
        if (!profileContent) {
            profileContent = this.readProfile(options);
        }
        /** @type {?} */
        const validProfile = (!!profileContent);
        if (options.quiet) {
            this._quiet = options.quiet;
        }
        if (options.verbose) {
            this._verbose = options.verbose;
        }
        if (validProfile) {
            this.initializeFromConfig(profileContent);
            // if languages are given as parameters, they ovveride everything said in profile
            if (!!options.languages && options.languages.length > 0) {
                this._languages = options.languages;
                if (!this._defaultLanguage) {
                    this._defaultLanguage = this._languages[0];
                }
            }
            this.checkParameters();
        }
    }
    /**
     * Read profile.
     * @param {?} options program options
     * @return {?} the read profile (empty, if none, null if errors)
     */
    readProfile(options) {
        /** @type {?} */
        const profilePath = options.profilePath;
        if (!profilePath) {
            for (const configfilename of PROFILE_CANDIDATES) {
                /** @type {?} */
                const profile = XliffMergeParameters.readProfileCandidate(configfilename);
                if (profile) {
                    this.usedProfilePath = configfilename;
                    return profile;
                }
            }
            return {};
        }
        /** @type {?} */
        let content;
        try {
            content = readFileSync(profilePath, 'UTF-8');
        }
        catch (err) {
            this.errorsFound.push(new XliffMergeError('could not read profile "' + profilePath + '"'));
            return null;
        }
        this.usedProfilePath = profilePath;
        /** @type {?} */
        const profileContent = JSON.parse(content);
        // replace all pathes in options by absolute paths
        /** @type {?} */
        const xliffmergeOptions = profileContent.xliffmergeOptions;
        xliffmergeOptions.srcDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.srcDir);
        xliffmergeOptions.genDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.genDir);
        xliffmergeOptions.apikeyfile = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.apikeyfile);
        return profileContent;
    }
    /**
     * @param {?} profilePath
     * @param {?} pathToAdjust
     * @return {?}
     */
    adjustPathToProfilePath(profilePath, pathToAdjust) {
        if (!pathToAdjust || isAbsolute(pathToAdjust)) {
            return pathToAdjust;
        }
        return join(dirname(profilePath), pathToAdjust).replace(/\\/g, '/');
    }
    /**
     * @param {?} profileContent
     * @return {?}
     */
    initializeFromConfig(profileContent) {
        if (!profileContent) {
            return;
        }
        /** @type {?} */
        const profile = profileContent.xliffmergeOptions;
        if (profile) {
            if (!isNullOrUndefined(profile.quiet)) {
                this._quiet = profile.quiet;
            }
            if (!isNullOrUndefined(profile.verbose)) {
                this._verbose = profile.verbose;
            }
            if (!isNullOrUndefined(profile.allowIdChange)) {
                this._allowIdChange = profile.allowIdChange;
            }
            if (profile.defaultLanguage) {
                this._defaultLanguage = profile.defaultLanguage;
            }
            if (profile.languages) {
                this._languages = profile.languages;
            }
            if (profile.srcDir) {
                this._srcDir = profile.srcDir;
            }
            if (profile.angularCompilerOptions) {
                if (profile.angularCompilerOptions.genDir) {
                    this._genDir = profile.angularCompilerOptions.genDir;
                }
            }
            if (profile.genDir) {
                // this must be after angularCompilerOptions to be preferred
                this._genDir = profile.genDir;
            }
            if (profile.i18nBaseFile) {
                this._i18nBaseFile = profile.i18nBaseFile;
            }
            if (profile.i18nFile) {
                this._i18nFile = profile.i18nFile;
            }
            if (profile.i18nFormat) {
                this._i18nFormat = profile.i18nFormat;
            }
            if (profile.encoding) {
                this._encoding = profile.encoding;
            }
            if (!isNullOrUndefined(profile.removeUnusedIds)) {
                this._removeUnusedIds = profile.removeUnusedIds;
            }
            if (!isNullOrUndefined(profile.supportNgxTranslate)) {
                this._supportNgxTranslate = profile.supportNgxTranslate;
            }
            if (!isNullOrUndefined(profile.ngxTranslateExtractionPattern)) {
                this._ngxTranslateExtractionPattern = profile.ngxTranslateExtractionPattern;
            }
            if (!isNullOrUndefined(profile.useSourceAsTarget)) {
                this._useSourceAsTarget = profile.useSourceAsTarget;
            }
            if (!isNullOrUndefined(profile.targetPraefix)) {
                this._targetPraefix = profile.targetPraefix;
            }
            if (!isNullOrUndefined(profile.targetSuffix)) {
                this._targetSuffix = profile.targetSuffix;
            }
            if (!isNullOrUndefined(profile.autotranslate)) {
                this._autotranslate = profile.autotranslate;
            }
            if (!isNullOrUndefined(profile.beautifyOutput)) {
                this._beautifyOutput = profile.beautifyOutput;
            }
            if (!isNullOrUndefined(profile.preserveOrder)) {
                this._preserveOrder = profile.preserveOrder;
            }
            if (!isNullOrUndefined(profile.apikey)) {
                this._apikey = profile.apikey;
            }
            if (!isNullOrUndefined(profile.apikeyfile)) {
                this._apikeyfile = profile.apikeyfile;
            }
        }
        else {
            this.warningsFound.push('did not find "xliffmergeOptions" in profile, using defaults');
        }
    }
    /**
     * Check all Parameters, wether they are complete and consistent.
     * if something is wrong with the parameters, it is collected in errorsFound.
     * @return {?}
     */
    checkParameters() {
        this.checkLanguageSyntax(this.defaultLanguage());
        if (this.languages().length === 0) {
            this.errorsFound.push(new XliffMergeError('no languages specified'));
        }
        this.languages().forEach((lang) => {
            this.checkLanguageSyntax(lang);
        });
        /** @type {?} */
        let stats;
        /** @type {?} */
        let err;
        // srcDir should exists
        try {
            stats = statSync(this.srcDir());
        }
        catch (e) {
            err = e;
        }
        if (!!err || !stats.isDirectory()) {
            this.errorsFound.push(new XliffMergeError('srcDir "' + this.srcDir() + '" is not a directory'));
        }
        // genDir should exists
        try {
            stats = statSync(this.genDir());
        }
        catch (e) {
            err = e;
        }
        if (!!err || !stats.isDirectory()) {
            this.errorsFound.push(new XliffMergeError('genDir "' + this.genDir() + '" is not a directory'));
        }
        // master file MUST exist
        try {
            accessSync(this.i18nFile(), constants.R_OK);
        }
        catch (err) {
            this.errorsFound.push(new XliffMergeError('i18nFile "' + this.i18nFile() + '" is not readable'));
        }
        // i18nFormat must be xlf xlf2 or xmb
        if (!(this.i18nFormat() === 'xlf' || this.i18nFormat() === 'xlf2' || this.i18nFormat() === 'xmb')) {
            this.errorsFound.push(new XliffMergeError('i18nFormat "' + this.i18nFormat() + '" invalid, must be "xlf" or "xlf2" or "xmb"'));
        }
        // autotranslate requires api key
        if (this.autotranslate() && !this.apikey()) {
            this.errorsFound.push(new XliffMergeError('autotranslate requires an API key, please set one'));
        }
        // autotranslated languages must be in list of all languages
        this.autotranslatedLanguages().forEach((lang) => {
            if (this.languages().indexOf(lang) < 0) {
                this.errorsFound.push(new XliffMergeError('autotranslate language "' + lang + '" is not in list of languages'));
            }
            if (lang === this.defaultLanguage()) {
                this.errorsFound.push(new XliffMergeError('autotranslate language "' + lang + '" cannot be translated, because it is the source language'));
            }
        });
        // ngx translate pattern check
        if (this.supportNgxTranslate()) {
            /** @type {?} */
            const checkResult = NgxTranslateExtractor.checkPattern(this.ngxTranslateExtractionPattern());
            if (!isNullOrUndefined(checkResult)) {
                this.errorsFound.push(new XliffMergeError('ngxTranslateExtractionPattern "' + this.ngxTranslateExtractionPattern() + '": ' + checkResult));
            }
        }
        // targetPraefix and targetSuffix check
        if (!this.useSourceAsTarget()) {
            if (this.targetPraefix().length > 0) {
                this.warningsFound.push('configured targetPraefix "' + this.targetPraefix() + '" will not be used because "useSourceAsTarget" is disabled"');
            }
            if (this.targetSuffix().length > 0) {
                this.warningsFound.push('configured targetSuffix "' + this.targetSuffix() + '" will not be used because "useSourceAsTarget" is disabled"');
            }
        }
    }
    /**
     * Check syntax of language.
     * Must be compatible with XML Schema type xsd:language.
     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*
     * @param {?} lang language to check
     * @return {?}
     */
    checkLanguageSyntax(lang) {
        /** @type {?} */
        const pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;
        if (!pattern.test(lang)) {
            this.errorsFound.push(new XliffMergeError('language "' + lang + '" is not valid'));
        }
    }
    /**
     * @return {?}
     */
    allowIdChange() {
        return (isNullOrUndefined(this._allowIdChange)) ? false : this._allowIdChange;
    }
    /**
     * @return {?}
     */
    verbose() {
        return (isNullOrUndefined(this._verbose)) ? false : this._verbose;
    }
    /**
     * @return {?}
     */
    quiet() {
        return (isNullOrUndefined(this._quiet)) ? false : this._quiet;
    }
    /**
     * Debug output all parameters to commandOutput.
     * @param {?} commandOutput
     * @return {?}
     */
    showAllParameters(commandOutput) {
        commandOutput.debug('xliffmerge Used Parameters:');
        commandOutput.debug('usedProfilePath:\t"%s"', this.usedProfilePath);
        commandOutput.debug('defaultLanguage:\t"%s"', this.defaultLanguage());
        commandOutput.debug('srcDir:\t"%s"', this.srcDir());
        commandOutput.debug('genDir:\t"%s"', this.genDir());
        commandOutput.debug('i18nBaseFile:\t"%s"', this.i18nBaseFile());
        commandOutput.debug('i18nFile:\t"%s"', this.i18nFile());
        commandOutput.debug('languages:\t%s', this.languages());
        for (const language of this.languages()) {
            commandOutput.debug('outputFile[%s]:\t%s', language, this.generatedI18nFile(language));
        }
        commandOutput.debug('removeUnusedIds:\t%s', this.removeUnusedIds());
        commandOutput.debug('supportNgxTranslate:\t%s', this.supportNgxTranslate());
        if (this.supportNgxTranslate()) {
            commandOutput.debug('ngxTranslateExtractionPattern:\t%s', this.ngxTranslateExtractionPattern());
        }
        commandOutput.debug('useSourceAsTarget:\t%s', this.useSourceAsTarget());
        if (this.useSourceAsTarget()) {
            commandOutput.debug('targetPraefix:\t"%s"', this.targetPraefix());
            commandOutput.debug('targetSuffix:\t"%s"', this.targetSuffix());
        }
        commandOutput.debug('allowIdChange:\t%s', this.allowIdChange());
        commandOutput.debug('beautifyOutput:\t%s', this.beautifyOutput());
        commandOutput.debug('preserveOrder:\t%s', this.preserveOrder());
        commandOutput.debug('autotranslate:\t%s', this.autotranslate());
        if (this.autotranslate()) {
            commandOutput.debug('autotranslated languages:\t%s', this.autotranslatedLanguages());
            commandOutput.debug('apikey:\t%s', this.apikey() ? '****' : 'NOT SET');
            commandOutput.debug('apikeyfile:\t%s', this.apikeyfile());
        }
    }
    /**
     * Default-Language, default en.
     * @return {?} default language
     */
    defaultLanguage() {
        return this._defaultLanguage ? this._defaultLanguage : 'en';
    }
    /**
     * Liste der zu bearbeitenden Sprachen.
     * @return {?} languages
     */
    languages() {
        return this._languages ? this._languages : [];
    }
    /**
     * src directory, where the master xlif is located.
     * @return {?} srcDir
     */
    srcDir() {
        return this._srcDir ? this._srcDir : '.';
    }
    /**
     * The base file name of the xlif file for input and output.
     * Default is messages
     * @return {?} base file
     */
    i18nBaseFile() {
        return this._i18nBaseFile ? this._i18nBaseFile : 'messages';
    }
    /**
     * The master xlif file (the one generated by ng-xi18n).
     * Default is <srcDir>/<i18nBaseFile>.xlf.
     * @return {?} master file
     */
    i18nFile() {
        return join(this.srcDir(), (this._i18nFile ? this._i18nFile : this.i18nBaseFile() + '.' + this.suffixForGeneratedI18nFile())).replace(/\\/g, '/');
    }
    /**
     * Format of the master xlif file.
     * Default is "xlf", possible are "xlf" or "xlf2" or "xmb".
     * @return {?} format
     */
    i18nFormat() {
        return (this._i18nFormat ? this._i18nFormat : 'xlf');
    }
    /**
     * potentially to be generated I18n-File with the translations for one language.
     * @param {?} lang language shortcut
     * @return {?} Path of file
     */
    generatedI18nFile(lang) {
        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + this.suffixForGeneratedI18nFile()).replace(/\\/g, '/');
    }
    /**
     * @return {?}
     */
    suffixForGeneratedI18nFile() {
        switch (this.i18nFormat()) {
            case 'xlf':
                return 'xlf';
            case 'xlf2':
                return 'xlf';
            case 'xmb':
                return 'xtb';
        }
    }
    /**
     * potentially to be generated translate-File for ngx-translate with the translations for one language.
     * @param {?} lang language shortcut
     * @return {?} Path of file
     */
    generatedNgxTranslateFile(lang) {
        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + 'json').replace(/\\/g, '/');
    }
    /**
     * The encoding used to write new XLIFF-files.
     * @return {?} encoding
     */
    encoding() {
        return this._encoding ? this._encoding : 'UTF-8';
    }
    /**
     * Output-Directory, where the output is written to.
     * Default is <srcDir>.
     * @return {?}
     */
    genDir() {
        return this._genDir ? this._genDir : this.srcDir();
    }
    /**
     * @return {?}
     */
    removeUnusedIds() {
        return (isNullOrUndefined(this._removeUnusedIds)) ? true : this._removeUnusedIds;
    }
    /**
     * @return {?}
     */
    supportNgxTranslate() {
        return (isNullOrUndefined(this._supportNgxTranslate)) ? false : this._supportNgxTranslate;
    }
    /**
     * @return {?}
     */
    ngxTranslateExtractionPattern() {
        return (isNullOrUndefined(this._ngxTranslateExtractionPattern)) ?
            NgxTranslateExtractor.DefaultExtractionPattern : this._ngxTranslateExtractionPattern;
    }
    /**
     * Whether source must be used as target for new trans-units
     * Default is true
     * @return {?}
     */
    useSourceAsTarget() {
        return (isNullOrUndefined(this._useSourceAsTarget)) ? true : this._useSourceAsTarget;
    }
    /**
     * Praefix used for target when copying new trans-units
     * Default is ""
     * @return {?}
     */
    targetPraefix() {
        return (isNullOrUndefined(this._targetPraefix)) ? '' : this._targetPraefix;
    }
    /**
     * Suffix used for target when copying new trans-units
     * Default is ""
     * @return {?}
     */
    targetSuffix() {
        return (isNullOrUndefined(this._targetSuffix)) ? '' : this._targetSuffix;
    }
    /**
     * If set, run xml result through beautifier (pretty-data).
     * @return {?}
     */
    beautifyOutput() {
        return (isNullOrUndefined(this._beautifyOutput)) ? false : this._beautifyOutput;
    }
    /**
     * If set, order of new trans units will be as in master.
     * Otherwise they are added at the end.
     * @return {?}
     */
    preserveOrder() {
        return (isNullOrUndefined(this._preserveOrder)) ? true : this._preserveOrder;
    }
    /**
     * Whether to use autotranslate for new trans-units
     * Default is false
     * @return {?}
     */
    autotranslate() {
        if (isNullOrUndefined(this._autotranslate)) {
            return false;
        }
        if (isArray(this._autotranslate)) {
            return ((/** @type {?} */ (this._autotranslate))).length > 0;
        }
        return (/** @type {?} */ (this._autotranslate));
    }
    /**
     * Whether to use autotranslate for a given language.
     * @param {?} lang language code.
     * @return {?}
     */
    autotranslateLanguage(lang) {
        return this.autotranslatedLanguages().indexOf(lang) >= 0;
    }
    /**
     * Return a list of languages to be autotranslated.
     * @return {?}
     */
    autotranslatedLanguages() {
        if (isNullOrUndefined(this._autotranslate) || this._autotranslate === false) {
            return [];
        }
        if (isArray(this._autotranslate)) {
            return ((/** @type {?} */ (this._autotranslate)));
        }
        return this.languages().slice(1); // first is source language
    }
    /**
     * API key to be used for Google Translate
     * @return {?} api key
     */
    apikey() {
        if (!isNullOrUndefined(this._apikey)) {
            return this._apikey;
        }
        else {
            /** @type {?} */
            const apikeyPath = this.apikeyfile();
            if (this.apikeyfile()) {
                if (existsSync(apikeyPath)) {
                    return FileUtil.read(apikeyPath, 'utf-8');
                }
                else {
                    throw new Error(format('api key file not found: API_KEY_FILE=%s', apikeyPath));
                }
            }
            else {
                return null;
            }
        }
    }
    /**
     * file name for API key to be used for Google Translate.
     * Explicitly set or read from env var API_KEY_FILE.
     * @return {?} file of api key
     */
    apikeyfile() {
        if (this._apikeyfile) {
            return this._apikeyfile;
        }
        else if (process.env.API_KEY_FILE) {
            return process.env.API_KEY_FILE;
        }
        else {
            return null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
let pkg = null;
try {
    pkg = require(resolve(__dirname, '..', 'package.json'));
}
catch (e) {
    try {
        pkg = require(resolve(__dirname, '..', '..', 'package.json'));
    }
    catch (e) {
        pkg = null;
    }
}
/** @type {?} */
const VERSION = (pkg ? pkg.version : 'unknown');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 10.03.2017.
 * Helper class to read XMl with a correct encoding.
 */
class XmlReader {
    /**
     * Read an xml-File.
     * @param {?} path Path to file
     * @param {?=} encoding optional encoding of the xml.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @return {?} file content and encoding found in the file.
     */
    static readXmlFileContent(path, encoding) {
        if (!encoding) {
            encoding = XmlReader.DEFAULT_ENCODING;
        }
        /** @type {?} */
        let content = FileUtil.read(path, encoding);
        /** @type {?} */
        const foundEncoding = XmlReader.encodingFromXml(content);
        if (foundEncoding !== encoding) {
            // read again with the correct encoding
            content = FileUtil.read(path, foundEncoding);
        }
        return {
            content: content,
            encoding: foundEncoding
        };
    }
    /**
     * Read the encoding from the xml.
     * xml File starts with .. encoding=".."
     * @param {?} xmlString xmlString
     * @return {?} encoding
     */
    static encodingFromXml(xmlString) {
        /** @type {?} */
        const index = xmlString.indexOf('encoding="');
        if (index < 0) {
            return this.DEFAULT_ENCODING; // default in xml if not explicitly set
        }
        /** @type {?} */
        const endIndex = xmlString.indexOf('"', index + 10);
        return xmlString.substring(index + 10, endIndex);
    }
}
XmlReader.DEFAULT_ENCODING = 'UTF-8';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Helper class to read translation files depending on format.
 */
class TranslationMessagesFileReader {
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} i18nFormat format
     * @param {?} path path
     * @param {?} encoding encoding
     * @param {?=} optionalMasterFilePath optionalMasterFilePath
     * @return {?} XliffFile
     */
    static fromFile(i18nFormat, path, encoding, optionalMasterFilePath) {
        /** @type {?} */
        const xmlContent = XmlReader.readXmlFileContent(path, encoding);
        /** @type {?} */
        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);
        return TranslationMessagesFileFactory.fromFileContent(i18nFormat, xmlContent.content, path, xmlContent.encoding, optionalMaster);
    }
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} path path
     * @param {?} encoding encoding
     * @param {?=} optionalMasterFilePath optionalMasterFilePath
     * @return {?} XliffFile
     */
    static fromUnknownFormatFile(path, encoding, optionalMasterFilePath) {
        /** @type {?} */
        const xmlContent = XmlReader.readXmlFileContent(path, encoding);
        /** @type {?} */
        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);
        return TranslationMessagesFileFactory.fromUnknownFormatFileContent(xmlContent.content, path, xmlContent.encoding, optionalMaster);
    }
    /**
     * Read master xmb file
     * @param {?} optionalMasterFilePath optionalMasterFilePath
     * @param {?} encoding encoding
     * @return {?} content and encoding of file
     */
    static masterFileContent(optionalMasterFilePath, encoding) {
        if (optionalMasterFilePath) {
            /** @type {?} */
            const masterXmlContent = XmlReader.readXmlFileContent(optionalMasterFilePath, encoding);
            return {
                xmlContent: masterXmlContent.content,
                path: optionalMasterFilePath,
                encoding: masterXmlContent.encoding
            };
        }
        else {
            return null;
        }
    }
    /**
     * Save edited file.
     * @param {?} messagesFile messagesFile
     * @param {?=} beautifyOutput Flag whether to use pretty-data to format the output.
     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
     * See issue #64 for details.
     * Default is false.
     * @return {?}
     */
    static save(messagesFile, beautifyOutput) {
        FileUtil.replaceContent(messagesFile.filename(), messagesFile.editedContent(beautifyOutput), messagesFile.encoding());
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const MAX_SEGMENTS = 128;
class AutoTranslateService {
    /**
     * Strip region code and convert to lower
     * @param {?} lang lang
     * @return {?} lang without region code and in lower case.
     */
    static stripRegioncode(lang) {
        /** @type {?} */
        const langLower = lang.toLowerCase();
        for (let i = 0; i < langLower.length; i++) {
            /** @type {?} */
            const c = langLower.charAt(i);
            if (c < 'a' || c > 'z') {
                return langLower.substring(0, i);
            }
        }
        return langLower;
    }
    /**
     * @param {?} apiKey
     */
    constructor(apiKey) {
        this._request = request;
        this._apiKey = apiKey;
        this._rootUrl = 'https://translation.googleapis.com/';
    }
    /**
     * Change API key (just for tests).
     * @param {?} apikey apikey
     * @return {?}
     */
    setApiKey(apikey) {
        this._apiKey = apikey;
    }
    /**
     * Translate an array of messages at once.
     * @param {?} messages the messages to be translated
     * @param {?} from source language code
     * @param {?} to target language code
     * @return {?} Observable with translated messages or error
     */
    translateMultipleStrings(messages, from, to) {
        // empty array needs no translation and always works ... (#78)
        if (messages.length === 0) {
            return of([]);
        }
        if (!this._apiKey) {
            return throwError('cannot autotranslate: no api key');
        }
        if (!from || !to) {
            return throwError('cannot autotranslate: source and target language must be set');
        }
        from = AutoTranslateService.stripRegioncode(from);
        to = AutoTranslateService.stripRegioncode(to);
        /** @type {?} */
        const allRequests = this.splitMessagesToGoogleLimit(messages).map((partialMessages) => {
            return this.limitedTranslateMultipleStrings(partialMessages, from, to);
        });
        return forkJoin(allRequests).pipe(map((allTranslations) => {
            /** @type {?} */
            let all = [];
            for (let i = 0; i < allTranslations.length; i++) {
                all = all.concat(allTranslations[i]);
            }
            return all;
        }));
    }
    /**
     * @param {?} messages
     * @return {?}
     */
    splitMessagesToGoogleLimit(messages) {
        if (messages.length <= MAX_SEGMENTS) {
            return [messages];
        }
        /** @type {?} */
        const result = [];
        /** @type {?} */
        let currentPackage = [];
        /** @type {?} */
        let packageSize = 0;
        for (let i = 0; i < messages.length; i++) {
            currentPackage.push(messages[i]);
            packageSize++;
            if (packageSize >= MAX_SEGMENTS) {
                result.push(currentPackage);
                currentPackage = [];
                packageSize = 0;
            }
        }
        if (currentPackage.length > 0) {
            result.push(currentPackage);
        }
        return result;
    }
    /**
     * Return translation request, but messages must be limited to google limits.
     * Not more that 128 single messages.
     * @param {?} messages messages
     * @param {?} from from
     * @param {?} to to
     * @return {?} the translated strings
     */
    limitedTranslateMultipleStrings(messages, from, to) {
        /** @type {?} */
        const realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;
        /** @type {?} */
        const translateRequest = {
            q: messages,
            target: to,
            source: from,
        };
        /** @type {?} */
        const options = {
            url: realUrl,
            body: translateRequest,
            json: true,
        };
        return this.post(realUrl, options).pipe(map((data) => {
            /** @type {?} */
            const body = data.body;
            if (!body) {
                throw new Error('no result received');
            }
            if (body.error) {
                if (body.error.code === 400) {
                    if (body.error.message === 'Invalid Value') {
                        throw new Error(format('Translation from "%s" to "%s" not supported', from, to));
                    }
                    throw new Error(format('Invalid request: %s', body.error.message));
                }
                else {
                    throw new Error(format('Error %s: %s', body.error.code, body.error.message));
                }
            }
            /** @type {?} */
            const result = body.data;
            return result.translations.map((translation) => {
                return translation.translatedText;
            });
        }));
    }
    /**
     * Function to do a POST HTTP request
     *
     * @param {?} uri uri
     * @param {?=} options options
     *
     * @return {?} response
     */
    post(uri, options) {
        return (/** @type {?} */ (this._call.apply(this, [].concat('post', (/** @type {?} */ (uri)), (/** @type {?} */ (Object.assign({}, options || {})))))));
    }
    /**
     * Function to do a HTTP request for given method
     *
     * @param {?} method method
     * @param {?} uri uri
     * @param {?=} options options
     *
     * @return {?} response
     *
     */
    _call(method, uri, options) {
        return (/** @type {?} */ (Observable.create((observer) => {
            // build params array
            /** @type {?} */
            const params = [].concat((/** @type {?} */ (uri)), (/** @type {?} */ (Object.assign({}, options || {}))), (error, response, body) => {
                if (error) {
                    return observer.error(error);
                }
                observer.next((/** @type {?} */ (Object.assign({}, {
                    response: (/** @type {?} */ (response)),
                    body: (/** @type {?} */ (body))
                }))));
                observer.complete();
            });
            // _call request method
            try {
                this._request[(/** @type {?} */ (method))].apply((/** @type {?} */ (this._request)), params);
            }
            catch (error) {
                observer.error(error);
            }
        })));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 29.06.2017.
 */
class AutoTranslateResult {
    /**
     * @param {?} _success
     * @param {?} _details
     */
    constructor(_success, _details) {
        this._success = _success;
        this._details = _details;
    }
    /**
     * @return {?}
     */
    success() {
        return this._success;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * A report about a run of Google Translate over all untranslated unit.
 * * Created by martin on 29.06.2017.
 */
class AutoTranslateSummaryReport {
    /**
     * @param {?} from
     * @param {?} to
     */
    constructor(from, to) {
        this._from = from;
        this._to = to;
        this._total = 0;
        this._ignored = 0;
        this._success = 0;
        this._failed = 0;
    }
    /**
     * Set error if total call failed (e.g. "invalid api key" or "no connection" ...)
     * @param {?} error error
     * @param {?} total total
     * @return {?}
     */
    setError(error, total) {
        this._error = error;
        this._total = total;
        this._failed = total;
    }
    /**
     * @return {?}
     */
    error() {
        return this._error;
    }
    /**
     * @param {?} ignored
     * @return {?}
     */
    setIgnored(ignored) {
        this._total += ignored;
        this._ignored = ignored;
    }
    /**
     * Add a single result to the summary.
     * @param {?} tu tu
     * @param {?} result result
     * @return {?}
     */
    addSingleResult(tu, result) {
        this._total++;
        if (result.success()) {
            this._success++;
        }
        else {
            this._failed++;
        }
    }
    /**
     * Merge another summary into this one.
     * @param {?} anotherSummary anotherSummary
     * @return {?}
     */
    merge(anotherSummary) {
        if (!this._error) {
            this._error = anotherSummary._error;
        }
        this._total += anotherSummary.total();
        this._ignored += anotherSummary.ignored();
        this._success += anotherSummary.success();
        this._failed += anotherSummary.failed();
    }
    /**
     * @return {?}
     */
    total() {
        return this._total;
    }
    /**
     * @return {?}
     */
    ignored() {
        return this._ignored;
    }
    /**
     * @return {?}
     */
    success() {
        return this._success;
    }
    /**
     * @return {?}
     */
    failed() {
        return this._failed;
    }
    /**
     * Human readable version of report
     * @return {?}
     */
    content() {
        /** @type {?} */
        let result;
        if (this._error) {
            result = format('Auto translation from "%s" to "%s" failed: "%s", failed units: %s', this._from, this._to, this._error, this._failed);
        }
        else {
            result = format('Auto translation from "%s" to "%s", total auto translated units: %s, ignored: %s, succesful: %s, failed: %s', this._from, this._to, this._total, this._ignored, this._success, this._failed);
        }
        return result;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 07.07.2017.
 * Service to autotranslate Transunits via Google Translate.
 */
class XliffMergeAutoTranslateService {
    /**
     * @param {?} apikey
     */
    constructor(apikey) {
        this.autoTranslateService = new AutoTranslateService(apikey);
    }
    /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param {?} from from
     * @param {?} to to
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} a promise with the execution result as a summary report.
     */
    autoTranslate(from, to, languageSpecificMessagesFile) {
        return forkJoin([
            this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile),
            ...this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)
        ])
            .pipe(map((summaries) => {
            /** @type {?} */
            const summary = summaries[0];
            for (let i = 1; i < summaries.length; i++) {
                summary.merge(summaries[i]);
            }
            return summary;
        }));
    }
    /**
     * Collect all units that are untranslated.
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} all untranslated units
     */
    allUntranslatedTUs(languageSpecificMessagesFile) {
        // collect all units, that should be auto translated
        /** @type {?} */
        const allUntranslated = [];
        languageSpecificMessagesFile.forEachTransUnit((tu) => {
            if (tu.targetState() === STATE_NEW) {
                allUntranslated.push(tu);
            }
        });
        return allUntranslated;
    }
    /**
     * @param {?} from
     * @param {?} to
     * @param {?} languageSpecificMessagesFile
     * @return {?}
     */
    doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile) {
        /** @type {?} */
        const allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);
        /** @type {?} */
        const allTranslatable = allUntranslated.filter((tu) => isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));
        /** @type {?} */
        const allMessages = allTranslatable.map((tu) => {
            return tu.sourceContentNormalized().asDisplayString();
        });
        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)
            .pipe(
        // #94 google translate might return &#.. entity refs, that must be decoded
        map((translations) => translations.map(encodedTranslation => decode(encodedTranslation))), map((translations) => {
            /** @type {?} */
            const summary = new AutoTranslateSummaryReport(from, to);
            summary.setIgnored(allUntranslated.length - allTranslatable.length);
            for (let i = 0; i < translations.length; i++) {
                /** @type {?} */
                const tu = allTranslatable[i];
                /** @type {?} */
                const translationText = translations[i];
                /** @type {?} */
                const result = this.autoTranslateNonICUUnit(tu, translationText);
                summary.addSingleResult(tu, result);
            }
            return summary;
        }), catchError((err) => {
            /** @type {?} */
            const failSummary = new AutoTranslateSummaryReport(from, to);
            failSummary.setError(err.message, allMessages.length);
            return of(failSummary);
        }));
    }
    /**
     * @param {?} from
     * @param {?} to
     * @param {?} languageSpecificMessagesFile
     * @return {?}
     */
    doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile) {
        /** @type {?} */
        const allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);
        /** @type {?} */
        const allTranslatableICU = allUntranslated.filter((tu) => !isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));
        return allTranslatableICU.map((tu) => {
            return this.doAutoTranslateICUMessage(from, to, tu);
        });
    }
    /**
     * Translate single ICU Messages.
     * @param {?} from from
     * @param {?} to to
     * @param {?} tu transunit to translate (must contain ICU Message)
     * @return {?} summary report
     */
    doAutoTranslateICUMessage(from, to, tu) {
        /** @type {?} */
        const icuMessage = tu.sourceContentNormalized().getICUMessage();
        /** @type {?} */
        const categories = icuMessage.getCategories();
        // check for nested ICUs, we do not support that
        if (categories.find((category) => !isNullOrUndefined(category.getMessageNormalized().getICUMessage()))) {
            /** @type {?} */
            const summary = new AutoTranslateSummaryReport(from, to);
            summary.setIgnored(1);
            return of(summary);
        }
        /** @type {?} */
        const allMessages = categories.map((category) => category.getMessageNormalized().asDisplayString());
        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)
            .pipe(
        // #94 google translate might return &#.. entity refs, that must be decoded
        map((translations) => translations.map(encodedTranslation => decode(encodedTranslation))), map((translations) => {
            /** @type {?} */
            const summary = new AutoTranslateSummaryReport(from, to);
            /** @type {?} */
            const icuTranslation = {};
            for (let i = 0; i < translations.length; i++) {
                icuTranslation[categories[i].getCategory()] = translations[i];
            }
            /** @type {?} */
            const result = this.autoTranslateICUUnit(tu, icuTranslation);
            summary.addSingleResult(tu, result);
            return summary;
        }), catchError((err) => {
            /** @type {?} */
            const failSummary = new AutoTranslateSummaryReport(from, to);
            failSummary.setError(err.message, allMessages.length);
            return of(failSummary);
        }));
    }
    /**
     * @param {?} tu
     * @param {?} translatedMessage
     * @return {?}
     */
    autoTranslateNonICUUnit(tu, translatedMessage) {
        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));
    }
    /**
     * @param {?} tu
     * @param {?} translation
     * @return {?}
     */
    autoTranslateICUUnit(tu, translation) {
        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));
    }
    /**
     * @param {?} tu
     * @param {?} translatedMessage
     * @return {?}
     */
    autoTranslateUnit(tu, translatedMessage) {
        /** @type {?} */
        const errors = translatedMessage.validate();
        /** @type {?} */
        const warnings = translatedMessage.validateWarnings();
        if (!isNullOrUndefined(errors)) {
            return new AutoTranslateResult(false, 'errors detected, not translated');
        }
        else if (!isNullOrUndefined(warnings)) {
            return new AutoTranslateResult(false, 'warnings detected, not translated');
        }
        else {
            tu.translate(translatedMessage);
            return new AutoTranslateResult(true, null); // success
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 17.02.2017.
 * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.
 *
 */
class XliffMerge {
    /**
     * @param {?} argv
     * @return {?}
     */
    static main(argv) {
        /** @type {?} */
        const options = XliffMerge.parseArgs(argv);
        if (options) {
            new XliffMerge(new CommandOutput(process.stdout), options).run((result) => {
                process.exit(result);
            });
        }
    }
    /**
     * @param {?} argv
     * @return {?}
     */
    static parseArgs(argv) {
        /** @type {?} */
        const options = {
            languages: []
        };
        for (let i = 1; i < argv.length; i++) {
            /** @type {?} */
            const arg = argv[i];
            if (arg === '--version' || arg === '-version') {
                console.log('xliffmerge ' + VERSION);
            }
            else if (arg === '--verbose' || arg === '-v') {
                options.verbose = true;
            }
            else if (arg === '--profile' || arg === '-p') {
                i++;
                if (i >= argv.length) {
                    console.log('missing config file');
                    XliffMerge.showUsage();
                    return null;
                }
                else {
                    options.profilePath = argv[i];
                }
            }
            else if (arg === '--quiet' || arg === '-q') {
                options.quiet = true;
            }
            else if (arg === '--help' || arg === '-help' || arg === '-h') {
                XliffMerge.showUsage();
            }
            else if (arg.length > 0 && arg.charAt(0) === '-') {
                console.log('unknown option');
                return null;
            }
            else {
                options.languages.push(arg);
            }
        }
        return options;
    }
    /**
     * @return {?}
     */
    static showUsage() {
        console.log('usage: xliffmerge <option>* <language>*');
        console.log('Options');
        console.log('\t-p|--profile a json configuration file containing all relevant parameters.');
        console.log('\t\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');
        console.log('\t-v|--verbose show some output for debugging purposes');
        console.log('\t-q|--quiet only show errors, nothing else');
        console.log('\t-version|--version show version string');
        console.log('');
        console.log('\t<language> has to be a valid language short string, e,g. "en", "de", "de-ch"');
    }
    /**
     * For Tests, create instance with given profile
     * @param {?} commandOutput commandOutput
     * @param {?} options options
     * @param {?=} profileContent profileContent
     * @return {?}
     */
    static createFromOptions(commandOutput, options, profileContent) {
        /** @type {?} */
        const instance = new XliffMerge(commandOutput, options);
        instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);
        return instance;
    }
    /**
     * @param {?} commandOutput
     * @param {?} options
     */
    constructor(commandOutput, options) {
        this.commandOutput = commandOutput;
        this.options = options;
        this.parameters = null;
    }
    /**
     * Run the command.
     * This runs async.
     * @param {?=} callbackFunction when command is executed, called with the return code (0 for ok), if given.
     * @param {?=} errorFunction callbackFunction for error handling
     * @return {?}
     */
    run(callbackFunction, errorFunction) {
        this.runAsync()
            .subscribe((retcode) => {
            if (!isNullOrUndefined(callbackFunction)) {
                callbackFunction(retcode);
            }
        }, (error) => {
            if (!isNullOrUndefined(errorFunction)) {
                errorFunction(error);
            }
        });
    }
    /**
     * Execute merge-Process.
     * @return {?} Async operation, on completion returns retcode 0=ok, other = error.
     */
    runAsync() {
        if (this.options && this.options.quiet) {
            this.commandOutput.setQuiet();
        }
        if (this.options && this.options.verbose) {
            this.commandOutput.setVerbose();
        }
        if (!this.parameters) {
            this.parameters = XliffMergeParameters.createFromOptions(this.options);
        }
        this.commandOutput.info('xliffmerge version %s', VERSION);
        if (this.parameters.verbose()) {
            this.parameters.showAllParameters(this.commandOutput);
        }
        if (this.parameters.errorsFound.length > 0) {
            for (const err of this.parameters.errorsFound) {
                this.commandOutput.error(err.message);
            }
            return of(-1);
        }
        if (this.parameters.warningsFound.length > 0) {
            for (const warn of this.parameters.warningsFound) {
                this.commandOutput.warn(warn);
            }
        }
        this.readMaster();
        if (this.parameters.autotranslate()) {
            this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());
        }
        /** @type {?} */
        const executionForAllLanguages = [];
        this.parameters.languages().forEach((lang) => {
            executionForAllLanguages.push(this.processLanguage(lang));
        });
        return forkJoin(executionForAllLanguages).pipe(map((retcodes) => this.totalRetcode(retcodes)));
    }
    /**
     * Give an array of retcodes for the different languages, return the total retcode.
     * If all are 0, it is 0, otherwise the first non zero.
     * @param {?} retcodes retcodes
     * @return {?} number
     */
    totalRetcode(retcodes) {
        for (let i = 0; i < retcodes.length; i++) {
            if (retcodes[i] !== 0) {
                return retcodes[i];
            }
        }
        return 0;
    }
    /**
     * Return the name of the generated file for given lang.
     * @param {?} lang language
     * @return {?} name of generated file
     */
    generatedI18nFile(lang) {
        return this.parameters.generatedI18nFile(lang);
    }
    /**
     * Return the name of the generated ngx-translation file for given lang.
     * @param {?} lang language
     * @return {?} name of translate file
     */
    generatedNgxTranslateFile(lang) {
        return this.parameters.generatedNgxTranslateFile(lang);
    }
    /**
     * Warnings found during the run.
     * @return {?} warnings
     */
    warnings() {
        return this.parameters.warningsFound;
    }
    /**
     * @return {?}
     */
    readMaster() {
        try {
            this.master = TranslationMessagesFileReader.fromFile(this.parameters.i18nFormat(), this.parameters.i18nFile(), this.parameters.encoding());
            this.master.warnings().forEach((warning) => {
                this.commandOutput.warn(warning);
            });
            /** @type {?} */
            const count = this.master.numberOfTransUnits();
            /** @type {?} */
            const missingIdCount = this.master.numberOfTransUnitsWithMissingId();
            this.commandOutput.info('master contains %s trans-units', count);
            if (missingIdCount > 0) {
                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);
            }
            /** @type {?} */
            const sourceLang = this.master.sourceLanguage();
            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {
                this.commandOutput.warn('master says to have source-language="%s", should be "%s" (your defaultLanguage)', sourceLang, this.parameters.defaultLanguage());
                this.master.setSourceLanguage(this.parameters.defaultLanguage());
                TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());
                this.commandOutput.warn('changed master source-language="%s" to "%s"', sourceLang, this.parameters.defaultLanguage());
            }
        }
        catch (err) {
            if (err instanceof XliffMergeError) {
                this.commandOutput.error(err.message);
                return of(-1);
            }
            else {
                // unhandled
                /** @type {?} */
                const currentFilename = this.parameters.i18nFile();
                /** @type {?} */
                const filenameString = (currentFilename) ? format('file "%s", ', currentFilename) : '';
                this.commandOutput.error(filenameString + 'oops ' + err);
                throw err;
            }
        }
    }
    /**
     * Process the given language.
     * Async operation.
     * @param {?} lang language
     * @return {?} on completion 0 for ok, other for error
     */
    processLanguage(lang) {
        this.commandOutput.debug('processing language %s', lang);
        /** @type {?} */
        const languageXliffFile = this.parameters.generatedI18nFile(lang);
        /** @type {?} */
        const currentFilename = languageXliffFile;
        /** @type {?} */
        let result;
        if (!FileUtil.exists(languageXliffFile)) {
            result = this.createUntranslatedXliff(lang, languageXliffFile);
        }
        else {
            result = this.mergeMasterTo(lang, languageXliffFile);
        }
        return result
            .pipe(map(() => {
            if (this.parameters.supportNgxTranslate()) {
                /** @type {?} */
                const languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFile, this.parameters.encoding(), this.master.filename());
                NgxTranslateExtractor.extract(languageSpecificMessagesFile, this.parameters.ngxTranslateExtractionPattern(), this.parameters.generatedNgxTranslateFile(lang));
            }
            return 0;
        }), catchError((err) => {
            if (err instanceof XliffMergeError) {
                this.commandOutput.error(err.message);
                return of(-1);
            }
            else {
                // unhandled
                /** @type {?} */
                const filenameString = (currentFilename) ? format('file "%s", ', currentFilename) : '';
                this.commandOutput.error(filenameString + 'oops ' + err);
                throw err;
            }
        }));
    }
    /**
     * create a new file for the language, which contains no translations, but all keys.
     * in principle, this is just a copy of the master with target-language set.
     * @param {?} lang language
     * @param {?} languageXliffFilePath name of file
     * @return {?}
     */
    createUntranslatedXliff(lang, languageXliffFilePath) {
        // copy master ...
        // and set target-language
        // and copy source to target if necessary
        /** @type {?} */
        const isDefaultLang = (lang === this.parameters.defaultLanguage());
        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
        /** @type {?} */
        const languageSpecificMessagesFile = this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());
        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(map((summary) => {
            // write it to file
            TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());
            this.commandOutput.info('created new file "%s" for target-language="%s"', languageXliffFilePath, lang);
            if (!isDefaultLang) {
                this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
            }
            return null;
        }));
    }
    /**
     * Map the input format to the format of the translation.
     * Normally they are the same but for xmb the translation format is xtb.
     * @param {?} i18nFormat format
     * @return {?}
     */
    translationFormat(i18nFormat) {
        if (i18nFormat === FORMAT_XMB) {
            return FORMAT_XTB;
        }
        else {
            return i18nFormat;
        }
    }
    /**
     * Merge all
     * @param {?} lang language
     * @param {?} languageXliffFilePath filename
     * @return {?}
     */
    mergeMasterTo(lang, languageXliffFilePath) {
        // read lang specific file
        /** @type {?} */
        const languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFilePath, this.parameters.encoding());
        /** @type {?} */
        const isDefaultLang = (lang === this.parameters.defaultLanguage());
        /** @type {?} */
        let newCount = 0;
        /** @type {?} */
        let correctSourceContentCount = 0;
        /** @type {?} */
        let correctSourceRefCount = 0;
        /** @type {?} */
        let correctDescriptionOrMeaningCount = 0;
        /** @type {?} */
        let idChangedCount = 0;
        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
        /** @type {?} */
        let lastProcessedUnit = null;
        this.master.forEachTransUnit((masterTransUnit) => {
            /** @type {?} */
            const transUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);
            if (!transUnit) {
                // oops, no translation, must be a new key, so add it
                /** @type {?} */
                let newUnit;
                if (this.parameters.allowIdChange()
                    && (newUnit = this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {
                    lastProcessedUnit = newUnit;
                    idChangedCount++;
                }
                else {
                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, isDefaultLang, this.parameters.useSourceAsTarget(), (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);
                    newCount++;
                }
            }
            else {
                // check for changed source content and change it if needed
                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.
                if (transUnit.supportsSetSourceContent() && masterTransUnit.sourceContent() !== transUnit.sourceContent()) {
                    transUnit.setSourceContent(masterTransUnit.sourceContent());
                    if (isDefaultLang) {
                        // #81 changed source must be copied to target for default lang
                        transUnit.translate(masterTransUnit.sourceContent());
                        transUnit.setTargetState(STATE_FINAL);
                    }
                    else {
                        if (transUnit.targetState() === STATE_FINAL) {
                            // source is changed, so translation has to be checked again
                            transUnit.setTargetState(STATE_TRANSLATED);
                        }
                    }
                    correctSourceContentCount++;
                }
                // check for missing or changed source ref and add it if needed
                if (transUnit.supportsSetSourceReferences()
                    && !this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {
                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());
                    correctSourceRefCount++;
                }
                // check for changed description or meaning
                if (transUnit.supportsSetDescriptionAndMeaning()) {
                    /** @type {?} */
                    let changed = false;
                    if (transUnit.description() !== masterTransUnit.description()) {
                        transUnit.setDescription(masterTransUnit.description());
                        changed = true;
                    }
                    if (transUnit.meaning() !== masterTransUnit.meaning()) {
                        transUnit.setMeaning(masterTransUnit.meaning());
                        changed = true;
                    }
                    if (changed) {
                        correctDescriptionOrMeaningCount++;
                    }
                }
                lastProcessedUnit = transUnit;
            }
        });
        if (newCount > 0) {
            this.commandOutput.warn('merged %s trans-units from master to "%s"', newCount, lang);
        }
        if (correctSourceContentCount > 0) {
            this.commandOutput.warn('transferred %s changed source content from master to "%s"', correctSourceContentCount, lang);
        }
        if (correctSourceRefCount > 0) {
            this.commandOutput.warn('transferred %s source references from master to "%s"', correctSourceRefCount, lang);
        }
        if (idChangedCount > 0) {
            this.commandOutput.warn('found %s changed id\'s in "%s"', idChangedCount, lang);
        }
        if (correctDescriptionOrMeaningCount > 0) {
            this.commandOutput.warn('transferred %s changed descriptions/meanings from master to "%s"', correctDescriptionOrMeaningCount, lang);
        }
        // remove all elements that are no longer used
        /** @type {?} */
        let removeCount = 0;
        languageSpecificMessagesFile.forEachTransUnit((transUnit) => {
            /** @type {?} */
            const existsInMaster = !isNullOrUndefined(this.master.transUnitWithId(transUnit.id));
            if (!existsInMaster) {
                if (this.parameters.removeUnusedIds()) {
                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);
                }
                removeCount++;
            }
        });
        if (removeCount > 0) {
            if (this.parameters.removeUnusedIds()) {
                this.commandOutput.warn('removed %s unused trans-units in "%s"', removeCount, lang);
            }
            else {
                this.commandOutput.warn('keeping %s unused trans-units in "%s", because removeUnused is disabled', removeCount, lang);
            }
        }
        if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0
            && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {
            this.commandOutput.info('file for "%s" was up to date', lang);
            return of(null);
        }
        else {
            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)
                .pipe(map(() => {
                // write it to file
                TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());
                this.commandOutput.info('updated file "%s" for target-language="%s"', languageXliffFilePath, lang);
                if (newCount > 0 && !isDefaultLang) {
                    this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
                }
                return null;
            }));
        }
    }
    /**
     * Handle the case of changed id due to small white space changes.
     * @param {?} masterTransUnit unit in master file
     * @param {?} languageSpecificMessagesFile translation file
     * @param {?} lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.
     * @return {?} processed unit, if done, null if no changed unit found
     */
    processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit) {
        /** @type {?} */
        const masterSourceString = masterTransUnit.sourceContentNormalized().asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();
        /** @type {?} */
        let changedTransUnit = null;
        languageSpecificMessagesFile.forEachTransUnit((languageTransUnit) => {
            if (languageTransUnit.sourceContentNormalized().asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim() === masterSourceString) {
                changedTransUnit = languageTransUnit;
            }
        });
        if (!changedTransUnit) {
            return null;
        }
        /** @type {?} */
        const mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, false, false, (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);
        /** @type {?} */
        const translatedContent = changedTransUnit.targetContent();
        if (translatedContent) { // issue #68 set translated only, if it is really translated
            mergedTransUnit.translate(translatedContent);
            mergedTransUnit.setTargetState(STATE_TRANSLATED);
        }
        return mergedTransUnit;
    }
    /**
     * @param {?} ref1
     * @param {?} ref2
     * @return {?}
     */
    areSourceReferencesEqual(ref1, ref2) {
        if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {
            return false;
        }
        if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {
            return true;
        }
        // bot refs are set now, convert to set to compare them
        /** @type {?} */
        const set1 = new Set();
        ref1.forEach((ref) => { set1.add(ref.sourcefile + ':' + ref.linenumber); });
        /** @type {?} */
        const set2 = new Set();
        ref2.forEach((ref) => { set2.add(ref.sourcefile + ':' + ref.linenumber); });
        if (set1.size !== set2.size) {
            return false;
        }
        /** @type {?} */
        let match = true;
        set2.forEach((ref) => {
            if (!set1.has(ref)) {
                match = false;
            }
        });
        return match;
    }
    /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param {?} from from
     * @param {?} to to
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} a promise with the execution result as a summary report.
     */
    autoTranslate(from, to, languageSpecificMessagesFile) {
        /** @type {?} */
        let serviceCall;
        /** @type {?} */
        const autotranslateEnabled = this.parameters.autotranslateLanguage(to);
        if (autotranslateEnabled) {
            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);
        }
        else {
            serviceCall = of(new AutoTranslateSummaryReport(from, to));
        }
        return serviceCall.pipe(map((summary) => {
            if (autotranslateEnabled) {
                if (summary.error() || summary.failed() > 0) {
                    this.commandOutput.error(summary.content());
                }
                else {
                    this.commandOutput.warn(summary.content());
                }
            }
            return summary;
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { WriterToString, CommandOutput, XliffMerge, XliffmergeModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWkxOG5zdXBwb3J0LW5neC1pMThuc3VwcG9ydC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvbGliL3hsaWZmbWVyZ2UubW9kdWxlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC9jb21tb24vdXRpbC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvY29tbW9uL3dyaXRlci10by1zdHJpbmcudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0L2NvbW1vbi9jb21tYW5kLW91dHB1dC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS94bGlmZi1tZXJnZS1lcnJvci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvY29tbW9uL2ZpbGUtdXRpbC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS9uZ3gtdHJhbnNsYXRlLWV4dHJhY3Rpb24tcGF0dGVybi50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS9uZ3gtdHJhbnNsYXRlLWV4dHJhY3Rvci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS94bGlmZi1tZXJnZS1wYXJhbWV0ZXJzLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC94bGlmZm1lcmdlL3ZlcnNpb24udHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0L3hsaWZmbWVyZ2UveG1sLXJlYWRlci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS90cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlLXJlYWRlci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvYXV0b3RyYW5zbGF0ZS9hdXRvLXRyYW5zbGF0ZS1zZXJ2aWNlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC9hdXRvdHJhbnNsYXRlL2F1dG8tdHJhbnNsYXRlLXJlc3VsdC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvYXV0b3RyYW5zbGF0ZS9hdXRvLXRyYW5zbGF0ZS1zdW1tYXJ5LXJlcG9ydC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvYXV0b3RyYW5zbGF0ZS94bGlmZi1tZXJnZS1hdXRvLXRyYW5zbGF0ZS1zZXJ2aWNlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC94bGlmZm1lcmdlL3hsaWZmLW1lcmdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vLyBub3QgdXNlZCwgb25seSB0aGVyZSB0byBtYWtlIG5nLXBhY2thZ3IgaGFwcHlcclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgIF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtdLFxyXG4gICAgZXhwb3J0czogW11cclxufSlcclxuZXhwb3J0IGNsYXNzIFhsaWZmbWVyZ2VNb2R1bGUgeyB9XHJcbiIsIi8qKlxyXG4gKiBDb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgYXJlIGRlcHJlY2F0ZWQgaW4gbm9kZXMgdXRpbC5cclxuICovXHJcblxyXG4vKipcclxuICogUmVwbGFjZXMgbm9kZSBpc051bGxPclVuZGVmaW5lZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZTogYW55KSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIG5vZGUgaXNTdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IGFueSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXBsYWNlcyBub2RlIGlzQm9vbGVhbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWU6IGFueSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwbGFjZXMgbm9kZSBpc051bWJlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZTogYW55KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIG5vZGUgaXNBcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KHZhbHVlOiBhbnkpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcclxufVxyXG4iLCJpbXBvcnQge1dyaXRhYmxlfSBmcm9tICdzdHJlYW0nO1xyXG5pbXBvcnQge2lzU3RyaW5nfSBmcm9tICcuL3V0aWwnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMjAuMDIuMjAxNy5cclxuICogQSBoZWxwZXIgY2xhc3MgZm9yIHRlc3RpbmcuXHJcbiAqIENhbiBiZSB1c2VkIGFzIGEgV3JpdGFibGVTdHJlYW0gYW5kIHdyaXRlcyBldmVyeXRoaW5nIChzeW5jaHJvbm91c2x5KSBpbnRvIGEgc3RyaW5nLFxyXG4gKiB0aGF0IGNhbiBlYXNpbHkgYmUgcmVhZCBieSB0aGUgdGVzdHMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFdyaXRlclRvU3RyaW5nIGV4dGVuZHMgV3JpdGFibGUge1xyXG5cclxuICAgIHByaXZhdGUgcmVzdWx0U3RyaW5nOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnJlc3VsdFN0cmluZyA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfd3JpdGUoY2h1bms6IGFueSwgZW5jb2Rpbmc6IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGNodW5rU3RyaW5nO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaHVuaykpIHtcclxuICAgICAgICAgICAgY2h1bmtTdHJpbmcgPSBjaHVuaztcclxuICAgICAgICB9IGVsc2UgaWYgKGNodW5rIGluc3RhbmNlb2YgQnVmZmVyKSB7XHJcbiAgICAgICAgICAgIGNodW5rU3RyaW5nID0gY2h1bmsudG9TdHJpbmcoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaHVua1N0cmluZyA9IEJ1ZmZlci5hbGxvYyhjaHVuaykudG9TdHJpbmcoZW5jb2RpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3VsdFN0cmluZyA9IHRoaXMucmVzdWx0U3RyaW5nICsgY2h1bmtTdHJpbmc7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgb2YgZXZlcnl0aGluZywgdGhhdCB3YXMgd3JpdHRlbiB0byB0aGUgc3RyZWFtIHNvIGZhci5cclxuICAgICAqIEByZXR1cm4gd3JpdHRlbiBkYXRhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB3cml0dGVuRGF0YSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdFN0cmluZztcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTcuMDIuMjAxNy5cclxuICogVmVyeSBzaW1wbGUgY2xhc3MgdG8gY29udHJvbCB0aGUgb3V0cHV0IG9mIGEgY29tbWFuZC5cclxuICogT3V0cHV0IGNhbiBiZSBlcnJvcnMsIHdhcm5pbmdzLCBpbmZvcyBhbmQgZGVidWctT3V0cHV0cy5cclxuICogVGhlIG91dHB1dCBjYW4gYmUgY29udHJvbGxlZCB2aWEgMiBmbGFncywgcXVpZXQgYW5kIHZlcmJvc2UuXHJcbiAqIElmIHF1aXQgaXMgZW5hYmxlZCBvbmx5IGVycm9yIG1lc3NhZ2VzIGFyZSBzaG93bi5cclxuICogSWYgdmVyYm9zZSBpcyBlbmFibGVkLCBldmVyeXRoaW5nIGlzIHNob3duLlxyXG4gKiBJZiBib3RoIGFyZSBub3QgZW5hYmxlZCAodGhlIGRlZmF1bHQpIGVycm9ycywgd2FybmluZ3MgYW5kIGluZm9zIGFyZSBzaG93bi5cclxuICogSWYgbm90IGFyZSBlbmFibGVkIChzdHJhbmdlKSwgd2UgYXNzdW1lZCB0aGUgZGVmYXVsdC5cclxuICovXHJcblxyXG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xyXG5pbXBvcnQgV3JpdGFibGVTdHJlYW0gPSBOb2RlSlMuV3JpdGFibGVTdHJlYW07XHJcbmltcG9ydCB7Zm9ybWF0fSBmcm9tICd1dGlsJztcclxuXHJcbmVudW0gTG9nTGV2ZWwge1xyXG4gICAgJ0VSUk9SJyxcclxuICAgICdXQVJOJyxcclxuICAgICdJTkZPJyxcclxuICAgICdERUJVRydcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENvbW1hbmRPdXRwdXQge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdmVyYm9zZSBlbmFibGVzIG91dHB1dCBvZiBldmVyeXRoaW5nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgX3ZlcmJvc2U6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBxdWlldCBkaXNhYmxlcyBvdXRwdXQgb2YgZXZlcnl0aGluZyBidXQgZXJyb3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgX3F1aWV0OiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgb3V0cHV0U3RyZWFtOiBXcml0YWJsZVN0cmVhbTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzdGRvdXQ/OiBXcml0YWJsZVN0cmVhbSkge1xyXG4gICAgICAgIHRoaXMuX3F1aWV0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdmVyYm9zZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChzdGRvdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRTdHJlYW0gPSBzdGRvdXQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRTdHJlYW0gPSBwcm9jZXNzLnN0ZG91dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFZlcmJvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5fdmVyYm9zZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFF1aWV0KCkge1xyXG4gICAgICAgIHRoaXMuX3F1aWV0ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciB2ZXJib3NlIGlzIGVuYWJsZWQuXHJcbiAgICAgKiBAcmV0dXJuIHdldGhlciB2ZXJib3NlIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB2ZXJib3NlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJib3NlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHF1aWV0IGlzIGVuYWJsZWQuXHJcbiAgICAgKiBAcmV0dXJuIHdldGhlciBxdWlldCBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcXVpZXQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1aWV0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBlcnJvcihtc2csIC4uLnBhcmFtczogYW55W10pIHtcclxuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbC5FUlJPUiwgbXNnLCBwYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB3YXJuKG1zZywgLi4ucGFyYW1zOiBhbnlbXSkge1xyXG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsLldBUk4sIG1zZywgcGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaW5mbyhtc2csIC4uLnBhcmFtczogYW55W10pIHtcclxuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbC5JTkZPLCBtc2csIHBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlYnVnKG1zZywgLi4ucGFyYW1zOiBhbnlbXSkge1xyXG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsLkRFQlVHLCBtc2csIHBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBsb2cobGV2ZWw6IExvZ0xldmVsLCBtc2csIHBhcmFtczogYW55W10pIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNPdXRwdXRFbmFibGVkKGxldmVsKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb2xvcmVkTWVzc2FnZTtcclxuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XHJcbiAgICAgICAgICAgIGNhc2UgTG9nTGV2ZWwuRVJST1I6XHJcbiAgICAgICAgICAgICAgICBjb2xvcmVkTWVzc2FnZSA9IGNoYWxrLnJlZCgnRVJST1I6ICcgKyBtc2cpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTG9nTGV2ZWwuV0FSTjpcclxuICAgICAgICAgICAgICAgIGNvbG9yZWRNZXNzYWdlID0gY2hhbGsubWFnZW50YSgnV0FSTklORzogJyArIG1zZyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbG9yZWRNZXNzYWdlID0gY2hhbGsuZ3JheSgnKiAnICsgbXNnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvdXRNc2cgPSBmb3JtYXQoY29sb3JlZE1lc3NhZ2UsIC4uLnBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdHJlYW0ud3JpdGUob3V0TXNnICsgJ1xcbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaXNPdXRwdXRFbmFibGVkKGxldmVsOiBMb2dMZXZlbCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBxdWlldEVuYWJsZWQsIHZlcmJvc2VFbmFibGVkOiBib29sZWFuO1xyXG4gICAgICAgIGlmICh0aGlzLl9xdWlldCAmJiB0aGlzLl92ZXJib3NlKSB7XHJcbiAgICAgICAgICAgIHF1aWV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2ZXJib3NlRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHF1aWV0RW5hYmxlZCA9IHRoaXMuX3F1aWV0O1xyXG4gICAgICAgICAgICB2ZXJib3NlRW5hYmxlZCA9IHRoaXMuX3ZlcmJvc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcclxuICAgICAgICAgICAgY2FzZSBMb2dMZXZlbC5FUlJPUjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAvLyBhbHdheXMgb3V0cHV0IGVycm9yc1xyXG4gICAgICAgICAgICBjYXNlIExvZ0xldmVsLldBUk46XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCFxdWlldEVuYWJsZWQpO1xyXG4gICAgICAgICAgICBjYXNlIExvZ0xldmVsLklORk86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZlcmJvc2VFbmFibGVkICYmICFxdWlldEVuYWJsZWQpO1xyXG4gICAgICAgICAgICBjYXNlIExvZ0xldmVsLkRFQlVHOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcmJvc2VFbmFibGVkO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxNy4wMi4yMDE3LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZk1lcmdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IobXNnOiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihtc2cpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBleHBsaWNpdGx5LlxyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBYbGlmZk1lcmdlRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTcuMDIuMjAxNy5cclxuICogU29tZSAoYSBmZXcpIHNpbXBsZSB1dGlscyBmb3IgZmlsZSBvcGVyYXRpb25zLlxyXG4gKiBKdXN0IGZvciBjb252ZW5pZW5jZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgRmlsZVV0aWwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgZm9yIGV4aXN0ZW5jZS5cclxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBmaWxlbmFtZVxyXG4gICAgICogQHJldHVybiB3ZXRoZXIgZmlsZSBleGlzdHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBleGlzdHMoZmlsZW5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBmcy5leGlzdHNTeW5jKGZpbGVuYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYSBmaWxlLlxyXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIGZpbGVuYW1lXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgZW5jb2RpbmdcclxuICAgICAqIEByZXR1cm4gY29udGVudCBvZiBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZChmaWxlbmFtZTogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgZW5jb2RpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGUgYSBmaWxlIHdpdGggZ2l2ZW4gY29udGVudC5cclxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBmaWxlbmFtZVxyXG4gICAgICogQHBhcmFtIG5ld0NvbnRlbnQgbmV3Q29udGVudFxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIGVuY29kaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVwbGFjZUNvbnRlbnQoZmlsZW5hbWU6IHN0cmluZywgbmV3Q29udGVudDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlbmFtZSwgbmV3Q29udGVudCwge2VuY29kaW5nOiBlbmNvZGluZ30pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY29weShzcmNGaWxlOiBzdHJpbmcsIGRlc3RGaWxlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBCVUZfTEVOR1RIID0gNjQgKiAxMDI0O1xyXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBCdWZmZXIuYWxsb2MoQlVGX0xFTkdUSCk7XHJcbiAgICAgICAgY29uc3QgZmRyID0gZnMub3BlblN5bmMoc3JjRmlsZSwgJ3InKTtcclxuICAgICAgICBjb25zdCBmZHcgPSBmcy5vcGVuU3luYyhkZXN0RmlsZSwgJ3cnKTtcclxuICAgICAgICBsZXQgYnl0ZXNSZWFkID0gMTtcclxuICAgICAgICBsZXQgcG9zID0gMDtcclxuICAgICAgICB3aGlsZSAoYnl0ZXNSZWFkID4gMCkge1xyXG4gICAgICAgICAgICBieXRlc1JlYWQgPSBmcy5yZWFkU3luYyhmZHIsIGJ1ZmYsIDAsIEJVRl9MRU5HVEgsIHBvcyk7XHJcbiAgICAgICAgICAgIGZzLndyaXRlU3luYyhmZHcsIGJ1ZmYsIDAsIGJ5dGVzUmVhZCk7XHJcbiAgICAgICAgICAgIHBvcyArPSBieXRlc1JlYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZzLmNsb3NlU3luYyhmZHIpO1xyXG4gICAgICAgIGZzLmNsb3NlU3luYyhmZHcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIHRoZSBmb2xkZXIgYW5kIGFsbCBvZiBpdHMgY29udGVudCAocm0gLXJmKS5cclxuICAgICAqIEBwYXJhbSBwYXRoIHBhdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxldGVGb2xkZXJSZWN1cnNpdmUocGF0aDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGZpbGVzID0gW107XHJcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGF0aCkgKSB7XHJcbiAgICAgICAgICAgIGZpbGVzID0gZnMucmVhZGRpclN5bmMocGF0aCk7XHJcbiAgICAgICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUGF0aCA9IHBhdGggKyAnLycgKyBmaWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZzLmxzdGF0U3luYyhjdXJQYXRoKS5pc0RpcmVjdG9yeSgpKSB7IC8vIHJlY3Vyc2VcclxuICAgICAgICAgICAgICAgICAgICBGaWxlVXRpbC5kZWxldGVGb2xkZXJSZWN1cnNpdmUoY3VyUGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBkZWxldGUgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGZzLnVubGlua1N5bmMoY3VyUGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmcy5ybWRpclN5bmMocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIGZvbGRlcnMgY29udGVudCByZWN1cnNpdmVseSwgYnV0IGRvIG5vdCBkZWxldGUgZm9sZGVyLlxyXG4gICAgICogRm9sZGVyIGlzIGxlZnQgZW1wdHkgYXQgdGhlIGVuZC5cclxuICAgICAqIEBwYXJhbSBwYXRoIHBhdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxldGVGb2xkZXJDb250ZW50UmVjdXJzaXZlKHBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBmaWxlcyA9IFtdO1xyXG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHBhdGgpICkge1xyXG4gICAgICAgICAgICBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKHBhdGgpO1xyXG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clBhdGggPSBwYXRoICsgJy8nICsgZmlsZTtcclxuICAgICAgICAgICAgICAgIGlmIChmcy5sc3RhdFN5bmMoY3VyUGF0aCkuaXNEaXJlY3RvcnkoKSkgeyAvLyByZWN1cnNlXHJcbiAgICAgICAgICAgICAgICAgICAgRmlsZVV0aWwuZGVsZXRlRm9sZGVyUmVjdXJzaXZlKGN1clBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZGVsZXRlIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGN1clBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgYSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHBhdGggcGF0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGV0ZUZpbGUocGF0aDogc3RyaW5nKSB7XHJcbiAgICAgICAgZnMudW5saW5rU3luYyhwYXRoKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogSGVscGVyIGNsYXNzIHRvIHBhcnNlIG5neCB0cmFuc2xhdGUgZXh0cmFjdGlvbiBwYXR0ZXJuXHJcbiAqIGFuZCB0byBkZWNpZGUgd2V0aGVyIGEgZ2l2ZW4gbWVzc2FnZSBtYXRjaGVzIHRoZSBwYXR0ZXJuLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE5neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuIHtcclxuXHJcbiAgICBwcml2YXRlIF9tYXRjaEV4cGxpY2l0SWQ6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9kZXNjcmlwdGlvblBhdHRlcm5zOiBzdHJpbmdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdCB0aGUgcGF0dGVybiBmcm9tIGdpdmVuIGRlc2NyaXB0aW9uIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nXHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yLCBpZiB0aGVyZSBpcyBhIHN5bnRheCBlcnJvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nLnNwbGl0KCd8Jyk7XHJcbiAgICAgICAgdGhpcy5fbWF0Y2hFeHBsaWNpdElkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGVzY3JpcHRpb25QYXR0ZXJucyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJ0BAJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoRXhwbGljaXRJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0cmFjdGlvbiBwYXR0ZXJuIG11c3Qgbm90IGNvbnRhaW4gQEAgdHdpY2UnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoRXhwbGljaXRJZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclN0cmluZyA9IHRoaXMuY2hlY2tWYWxpZERlc2NyaXB0aW9uUGF0dGVybihwYXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvclN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvblBhdHRlcm5zLnB1c2gocGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjaywgd2V0aGVyIGFuIGV4cGxpY2l0bHkgc2V0IGlkIG1hdGNoZXMgdGhlIHBhdHRlcm4uXHJcbiAgICAgKiBAcGFyYW0gaWQgaWRcclxuICAgICAqIEByZXR1cm4gd2V0aGVyIGFuIGV4cGxpY2l0bHkgc2V0IGlkIG1hdGNoZXMgdGhlIHBhdHRlcm4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0V4cGxpY2l0SWRNYXRjaGVkKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gaWQgJiYgdGhpcy5fbWF0Y2hFeHBsaWNpdElkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2ssIHdldGhlciBhIGdpdmVuIGRlc2NyaXB0aW9uIG1hdGNoZXMgdGhlIHBhdHRlcm4uXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gZGVzY3JpcHRpb25cclxuICAgICAqIEByZXR1cm4gd2V0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gbWF0Y2hlcyB0aGUgcGF0dGVybi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzRGVzY3JpcHRpb25NYXRjaGVkKGRlc2NyaXB0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzY3JpcHRpb25QYXR0ZXJucy5pbmRleE9mKGRlc2NyaXB0aW9uKSA+PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2hlY2tWYWxpZERlc2NyaXB0aW9uUGF0dGVybihkZXNjcmlwdGlvblBhdHRlcm46IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKCFkZXNjcmlwdGlvblBhdHRlcm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuICdlbXB0eSB2YWx1ZSBub3QgYWxsb3dlZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgvXlthLXpBLVpfXVthLXpBLVpfLV0qJC8udGVzdChkZXNjcmlwdGlvblBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBpdCBpcyBva1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGVzY3JpcHRpb24gcGF0dGVybiBtdXN0IGJlIGFuIGlkZW50aWZpZXIgY29udGFpbmluZyBvbmx5IGxldHRlcnMsIGRpZ2l0cywgXyBvciAtJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsIElUcmFuc1VuaXQsIE5PUk1BTElaQVRJT05fRk9STUFUX05HWFRSQU5TTEFURX0gZnJvbSAnQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliJztcclxuaW1wb3J0IHtGaWxlVXRpbH0gZnJvbSAnLi4vY29tbW9uL2ZpbGUtdXRpbCc7XHJcbmltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJy4uL2NvbW1vbi91dGlsJztcclxuaW1wb3J0IHtOZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybn0gZnJvbSAnLi9uZ3gtdHJhbnNsYXRlLWV4dHJhY3Rpb24tcGF0dGVybic7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IHJvb2JtIG9uIDE1LjAzLjIwMTcuXHJcbiAqIEEgdG9vbCBmb3IgZXh0cmFjdGluZyBtZXNzYWdlcyBpbiBuZ3gtdHJhbnNsYXRlIGZvcm1hdC5cclxuICogR2VuZXJhdGVzIGEganNvbi1maWxlIHRvIGJlIHVzZWQgd2l0aCBuZ3gtdHJhbnNsYXRlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgaW50ZXJmYWNlIHVzZWQgZm9yIHRyYW5zbGF0aW9ucyBpbiBuZ3gtdHJhbnNsYXRlLlxyXG4gKiBBIGhhc2ggdGhhdCBjb250YWlucyBlaXRoZXIgdGhlIHRyYW5zbGF0aW9uIG9yIGFub3RoZXIgaGFzaC5cclxuICovXHJcbmludGVyZmFjZSBOZ3hUcmFuc2xhdGlvbnMge1xyXG4gICAgW2lkOiBzdHJpbmddOiBOZ3hUcmFuc2xhdGlvbnMgfCBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBpbnRlcm5hbCxcclxuICogYSBtZXNzYWdlIHdpdGggaWQgKGEgZG90LXNlcGFyYXRlZCBzdHJpbmcpLlxyXG4gKi9cclxuaW50ZXJmYWNlIE5neE1lc3NhZ2Uge1xyXG4gICAgaWQ6IHN0cmluZzsgLy8gZG90IHNlcGFyYXRlZCBuYW1lLCBlLmcuIFwibXlhcHAuc2VydmljZTEubWVzc2FnZTFcIlxyXG4gICAgbWVzc2FnZTogc3RyaW5nOyAvLyB0aGUgbWVzc2FnZSwgcGxhY2Vob2xkZXIgYXJlIGluIHt7bn19IHN5bnRheCwgZS5nLiBcImEgdGVzdCB3aXRoIHZhbHVlOiB7ezB9fVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTmd4VHJhbnNsYXRlRXh0cmFjdG9yIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIERlZmF1bHRFeHRyYWN0aW9uUGF0dGVybiA9ICdAQHxuZ3gtdHJhbnNsYXRlJztcclxuICAgIHByaXZhdGUgZXh0cmFjdGlvblBhdHRlcm46IE5neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2ssIHdldGhlciBleHRyYWN0aW9uUGF0dGVybiBoYXMgdmFsaWQgc3ludGF4LlxyXG4gICAgICogQHBhcmFtIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nXHJcbiAgICAgKiBAcmV0dXJuIG51bGwsIGlmIHBhdHRlcm4gaXMgb2ssIHN0cmluZyBkZXNjcmliaW5nIHRoZSBlcnJvciwgaWYgaXQgaXMgbm90IG9rLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNoZWNrUGF0dGVybihleHRyYWN0aW9uUGF0dGVyblN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKG5ldyBOZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybihleHRyYWN0aW9uUGF0dGVyblN0cmluZykpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBleHRyYWN0KG1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLCBleHRyYWN0aW9uUGF0dGVybjogc3RyaW5nLCBvdXRwdXRGaWxlOiBzdHJpbmcpIHtcclxuICAgICAgICBuZXcgTmd4VHJhbnNsYXRlRXh0cmFjdG9yKG1lc3NhZ2VzRmlsZSwgZXh0cmFjdGlvblBhdHRlcm4pLmV4dHJhY3RUbyhvdXRwdXRGaWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLCBleHRyYWN0aW9uUGF0dGVyblN0cmluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5leHRyYWN0aW9uUGF0dGVybiA9IG5ldyBOZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybihleHRyYWN0aW9uUGF0dGVyblN0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRhY3QgbWVzc2FnZXMgYW5kIHdyaXRlIHRoZW0gdG8gYSBmaWxlLlxyXG4gICAgICogQHBhcmFtIG91dHB1dEZpbGUgb3V0cHV0RmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZXh0cmFjdFRvKG91dHB1dEZpbGU6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uczogTmd4VHJhbnNsYXRpb25zID0gdGhpcy50b05neFRyYW5zbGF0aW9ucyh0aGlzLmV4dHJhY3QoKSk7XHJcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9ucyAmJiBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbnMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgRmlsZVV0aWwucmVwbGFjZUNvbnRlbnQob3V0cHV0RmlsZSwgSlNPTi5zdHJpbmdpZnkodHJhbnNsYXRpb25zLCBudWxsLCA0KSwgJ1VURi04Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKEZpbGVVdGlsLmV4aXN0cyhvdXRwdXRGaWxlKSkge1xyXG4gICAgICAgICAgICAgICAgRmlsZVV0aWwuZGVsZXRlRmlsZShvdXRwdXRGaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICBFeHRyYWN0IG1lc3NhZ2VzIGFuZCBjb252ZXJ0IHRoZW0gdG8gbmd4IHRyYW5zbGF0aW9ucy5cclxuICAgICAqICBAcmV0dXJuIHRoZSB0cmFuc2xhdGlvbiBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGV4dHJhY3QoKTogTmd4TWVzc2FnZVtdIHtcclxuICAgICAgICBjb25zdCByZXN1bHQ6IE5neE1lc3NhZ2VbXSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZXNGaWxlLmZvckVhY2hUcmFuc1VuaXQoKHR1OiBJVHJhbnNVbml0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5neElkID0gdGhpcy5uZ3hUcmFuc2xhdGVJZEZyb21UVSh0dSk7XHJcbiAgICAgICAgICAgIGlmIChuZ3hJZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZXRleHQgPSB0dS50YXJnZXRDb250ZW50Tm9ybWFsaXplZCgpLmFzRGlzcGxheVN0cmluZyhOT1JNQUxJWkFUSU9OX0ZPUk1BVF9OR1hUUkFOU0xBVEUpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe2lkOiBuZ3hJZCwgbWVzc2FnZTogbWVzc2FnZXRleHR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjaywgd2V0aGVyIHRoaXMgdHUgc2hvdWxkIGJlIGV4dHJhY3RlZCBmb3Igbmd4LXRyYW5zbGF0ZSB1c2FnZSwgYW5kIHJldHVybiBpdHMgaWQgZm9yIG5neC10cmFuc2xhdGUuXHJcbiAgICAgKiBUaGVyZSBhcmUgMiBwb3NzaWJpbGl0aWVzOlxyXG4gICAgICogMS4gZGVzY3JpcHRpb24gaXMgc2V0IHRvIFwibmd4LXRyYW5zbGF0ZVwiIGFuZCBtZWFuaW5nIGNvbnRhaW5zIHRoZSBpZC5cclxuICAgICAqIDIuIGlkIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHR1IHR1XHJcbiAgICAgKiBAcmV0dXJuIGFuIG5neCBpZCBvciBudWxsLCBpZiB0aGlzIHR1IHNob3VsZCBub3QgYmUgZXh0cmFjdGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG5neFRyYW5zbGF0ZUlkRnJvbVRVKHR1OiBJVHJhbnNVbml0KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5pc0V4cGxpY2l0bHlTZXRJZCh0dS5pZCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXh0cmFjdGlvblBhdHRlcm4uaXNFeHBsaWNpdElkTWF0Y2hlZCh0dS5pZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0dS5pZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdHUuZGVzY3JpcHRpb24oKTtcclxuICAgICAgICBpZiAoZGVzY3JpcHRpb24gJiYgdGhpcy5leHRyYWN0aW9uUGF0dGVybi5pc0Rlc2NyaXB0aW9uTWF0Y2hlZChkZXNjcmlwdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR1Lm1lYW5pbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgSUQgd2FzIGV4cGxpY2l0bHkgc2V0ICh2aWEgaTE4bj1cIkBteWlkKS5cclxuICAgICAqIEp1c3QgaGV1cmlzdGljLCBhbiBJRCBpcyBleHBsaWNpdGx5LCBpZiBpdCBkb2VzIG5vdCBsb29rIGxpa2UgYSBnZW5lcmF0ZWQgb25lLlxyXG4gICAgICogQHBhcmFtIGlkIGlkXHJcbiAgICAgKiBAcmV0dXJuIHdldGhlciBJRCB3YXMgZXhwbGljaXRseSBzZXQgKHZpYSBpMThuPVwiQG15aWQpLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzRXhwbGljaXRseVNldElkKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoaWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2VuZXJhdGVkIElEcyBhcmUgZWl0aGVyIGRlY2ltYWwgb3Igc2hhMSBoZXhcclxuICAgICAgICBjb25zdCByZUZvckdlbmVyYXRlZElkID0gL15bMC05YS1mXXsxMSx9JC87XHJcbiAgICAgICAgcmV0dXJuICFyZUZvckdlbmVyYXRlZElkLnRlc3QoaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBsaXN0IG9mIHJlbGV2YW50IFRVcyB0byBuZ3ggdHJhbnNsYXRpb25zIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBtc2dMaXN0IG1zZ0xpc3RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0b05neFRyYW5zbGF0aW9ucyhtc2dMaXN0OiBOZ3hNZXNzYWdlW10pOiBOZ3hUcmFuc2xhdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uT2JqZWN0OiBOZ3hUcmFuc2xhdGlvbnMgPSB7fTtcclxuICAgICAgICBtc2dMaXN0LmZvckVhY2goKG1zZzogTmd4TWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnB1dEluVHJhbnNsYXRpb25PYmplY3QodHJhbnNsYXRpb25PYmplY3QsIG1zZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uT2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHV0IGEgbmV3IG1lc3NhZ2VzIGludG8gdGhlIHRyYW5zbGF0aW9uIGRhdGEgb2JqZWN0LlxyXG4gICAgICogSWYgeW91IGFkZCwgZS5nLiBcIntpZDogJ215YXBwLmV4YW1wbGUnLCBtZXNzYWdlOiAndGVzdCd9XCIsXHJcbiAgICAgKiB0aGUgdHJhbnNsYXRpb24gb2JqZWN0IHdpbGwgdGhlbiBjb250YWluIGFuIG9iamVjdCBteWFwcCB0aGF0IGhhcyBwcm9wZXJ0eSBleGFtcGxlOlxyXG4gICAgICoge215YXBwOiB7XHJcbiAgICAgKiAgIGV4YW1wbGU6ICd0ZXN0J1xyXG4gICAgICogICB9fVxyXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uT2JqZWN0IHRyYW5zbGF0aW9uT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gbXNnIG1zZ1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHB1dEluVHJhbnNsYXRpb25PYmplY3QodHJhbnNsYXRpb25PYmplY3Q6IE5neFRyYW5zbGF0aW9ucywgbXNnOiBOZ3hNZXNzYWdlKSB7XHJcbiAgICAgICAgbGV0IGZpcnN0UGFydE9mSWQ6IHN0cmluZztcclxuICAgICAgICBsZXQgcmVzdE9mSWQ6IHN0cmluZztcclxuICAgICAgICBjb25zdCBpbmRleE9mRG90ID0gbXNnLmlkLmluZGV4T2YoJy4nKTtcclxuICAgICAgICBpZiAoaW5kZXhPZkRvdCA9PT0gMCB8fCBpbmRleE9mRG90ID09PSAobXNnLmlkLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIG54Zy10cmFuc2xhdGUgaWQgXCInICsgbXNnLmlkICsgJ1wiJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmRleE9mRG90IDwgMCkge1xyXG4gICAgICAgICAgICBmaXJzdFBhcnRPZklkID0gbXNnLmlkO1xyXG4gICAgICAgICAgICByZXN0T2ZJZCA9ICcnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZpcnN0UGFydE9mSWQgPSBtc2cuaWQuc3Vic3RyaW5nKDAsIGluZGV4T2ZEb3QpO1xyXG4gICAgICAgICAgICByZXN0T2ZJZCA9IG1zZy5pZC5zdWJzdHJpbmcoaW5kZXhPZkRvdCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgb2JqZWN0ID0gdHJhbnNsYXRpb25PYmplY3RbZmlyc3RQYXJ0T2ZJZF07XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG9iamVjdCkpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3RPZklkID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25PYmplY3RbZmlyc3RQYXJ0T2ZJZF0gPSBtc2cubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgdHJhbnNsYXRpb25PYmplY3RbZmlyc3RQYXJ0T2ZJZF0gPSBvYmplY3Q7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHJlc3RPZklkID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXBsaWNhdGUgaWQgcHJhZWZpeCBcIicgKyBtc2cuaWQgKyAnXCInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnB1dEluVHJhbnNsYXRpb25PYmplY3QoPE5neFRyYW5zbGF0aW9ucz4gb2JqZWN0LCB7aWQ6IHJlc3RPZklkLCBtZXNzYWdlOiBtc2cubWVzc2FnZX0pO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxNy4wMi4yMDE3LlxyXG4gKiBDb2xsZWN0aW9uIG9mIGFsbCBwYXJhbWV0ZXJzIHVzZWQgYnkgdGhlIHRvb2wuXHJcbiAqIFRoZSBwYXJhbWV0ZXJzIGFyZSByZWFkIGZvcm0gdGhlIHByb2ZpbGUgb3IgZGVmYXVsdHMgYXJlIHVzZWQuXHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQge1hsaWZmTWVyZ2VFcnJvcn0gZnJvbSAnLi94bGlmZi1tZXJnZS1lcnJvcic7XHJcbmltcG9ydCB7U3RhdHN9IGZyb20gJ2ZzJztcclxuaW1wb3J0IHtDb21tYW5kT3V0cHV0fSBmcm9tICcuLi9jb21tb24vY29tbWFuZC1vdXRwdXQnO1xyXG5pbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7aXNBcnJheSwgaXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJy4uL2NvbW1vbi91dGlsJztcclxuaW1wb3J0IHtQcm9ncmFtT3B0aW9ucywgSUNvbmZpZ0ZpbGV9IGZyb20gJy4vaS14bGlmZi1tZXJnZS1vcHRpb25zJztcclxuaW1wb3J0IHtGaWxlVXRpbH0gZnJvbSAnLi4vY29tbW9uL2ZpbGUtdXRpbCc7XHJcbmltcG9ydCB7Tmd4VHJhbnNsYXRlRXh0cmFjdG9yfSBmcm9tICcuL25neC10cmFuc2xhdGUtZXh0cmFjdG9yJztcclxuaW1wb3J0IHtkaXJuYW1lLCBpc0Fic29sdXRlLCBqb2luLCBub3JtYWxpemV9IGZyb20gJ3BhdGgnO1xyXG5cclxuY29uc3QgUFJPRklMRV9DQU5ESURBVEVTID0gWydwYWNrYWdlLmpzb24nLCAnLmFuZ3VsYXItY2xpLmpzb24nXTtcclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZk1lcmdlUGFyYW1ldGVycyB7XHJcblxyXG4gICAgcHJpdmF0ZSB1c2VkUHJvZmlsZVBhdGg6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3F1aWV0OiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBfdmVyYm9zZTogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX2FsbG93SWRDaGFuZ2U6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9kZWZhdWx0TGFuZ3VhZ2U6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3NyY0Rpcjogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaTE4bkJhc2VGaWxlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9pMThuRmlsZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaTE4bkZvcm1hdDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfZW5jb2Rpbmc6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2dlbkRpcjogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfbGFuZ3VhZ2VzOiBzdHJpbmdbXTtcclxuICAgIHByaXZhdGUgX3JlbW92ZVVudXNlZElkczogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX3N1cHBvcnROZ3hUcmFuc2xhdGU6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybjogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfdXNlU291cmNlQXNUYXJnZXQ6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF90YXJnZXRQcmFlZml4OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF90YXJnZXRTdWZmaXg6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2JlYXV0aWZ5T3V0cHV0OiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBfcHJlc2VydmVPcmRlcjogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX2F1dG90cmFuc2xhdGU6IGJvb2xlYW58c3RyaW5nW107XHJcbiAgICBwcml2YXRlIF9hcGlrZXk6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2FwaWtleWZpbGU6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgZXJyb3JzRm91bmQ6IFhsaWZmTWVyZ2VFcnJvcltdO1xyXG4gICAgcHVibGljIHdhcm5pbmdzRm91bmQ6IHN0cmluZ1tdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIFBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb21tYW5kIG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSBwcm9maWxlQ29udGVudCBnaXZlbiBwcm9maWxlIChpZiBub3QsIGl0IGlzIHJlYWQgZnJvbSB0aGUgcHJvZmlsZSBwYXRoIGZyb20gb3B0aW9ucykuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRnJvbU9wdGlvbnMob3B0aW9uczogUHJvZ3JhbU9wdGlvbnMsIHByb2ZpbGVDb250ZW50PzogSUNvbmZpZ0ZpbGUpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFhsaWZmTWVyZ2VQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgcGFyYW1ldGVycy5jb25maWd1cmUob3B0aW9ucywgcHJvZmlsZUNvbnRlbnQpO1xyXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvcnNGb3VuZCA9IFtdO1xyXG4gICAgICAgIHRoaXMud2FybmluZ3NGb3VuZCA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBwb3RlbnRpYWwgcHJvZmlsZS5cclxuICAgICAqIFRvIGJlIGEgY2FuZGlkYXRlLCBmaWxlIG11c3QgZXhpc3QgYW5kIGNvbnRhaW4gcHJvcGVydHkgXCJ4bGlmZm1lcmdlT3B0aW9uc1wiLlxyXG4gICAgICogQHBhcmFtIHByb2ZpbGVQYXRoIHBhdGggb2YgcHJvZmlsZVxyXG4gICAgICogQHJldHVybiBwYXJzZWQgY29udGVudCBvZiBmaWxlIG9yIG51bGwsIGlmIGZpbGUgZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IGEgcHJvZmlsZSBjYW5kaWRhdGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRQcm9maWxlQ2FuZGlkYXRlKHByb2ZpbGVQYXRoOiBzdHJpbmcpOiBJQ29uZmlnRmlsZSB7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHByb2ZpbGVQYXRoLCAnVVRGLTgnKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZENvbnRlbnQ6IElDb25maWdGaWxlID0gSlNPTi5wYXJzZShjb250ZW50KTtcclxuICAgICAgICBpZiAocGFyc2VkQ29udGVudCAmJiBwYXJzZWRDb250ZW50LnhsaWZmbWVyZ2VPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRDb250ZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgbWUgZnJvbSB0aGUgcHJvZmlsZSBjb250ZW50LlxyXG4gICAgICogKHB1YmxpYyBvbmx5IGZvciB0ZXN0IHVzYWdlKS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgZ2l2ZW4gYXQgcnVudGltZSB2aWEgY29tbWFuZCBsaW5lXHJcbiAgICAgKiBAcGFyYW0gcHJvZmlsZUNvbnRlbnQgaWYgbnVsbCwgcmVhZCBpdCBmcm9tIHByb2ZpbGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY29uZmlndXJlKG9wdGlvbnM6IFByb2dyYW1PcHRpb25zLCBwcm9maWxlQ29udGVudD86IElDb25maWdGaWxlKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvcnNGb3VuZCA9IFtdO1xyXG4gICAgICAgIHRoaXMud2FybmluZ3NGb3VuZCA9IFtdO1xyXG4gICAgICAgIGlmICghcHJvZmlsZUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgcHJvZmlsZUNvbnRlbnQgPSB0aGlzLnJlYWRQcm9maWxlKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2YWxpZFByb2ZpbGU6IGJvb2xlYW4gPSAoISFwcm9maWxlQ29udGVudCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucXVpZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcXVpZXQgPSBvcHRpb25zLnF1aWV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy52ZXJib3NlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZlcmJvc2UgPSBvcHRpb25zLnZlcmJvc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWxpZFByb2ZpbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRnJvbUNvbmZpZyhwcm9maWxlQ29udGVudCk7XHJcbiAgICAgICAgICAgIC8vIGlmIGxhbmd1YWdlcyBhcmUgZ2l2ZW4gYXMgcGFyYW1ldGVycywgdGhleSBvdnZlcmlkZSBldmVyeXRoaW5nIHNhaWQgaW4gcHJvZmlsZVxyXG4gICAgICAgICAgICBpZiAoISFvcHRpb25zLmxhbmd1YWdlcyAmJiBvcHRpb25zLmxhbmd1YWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYW5ndWFnZXMgPSBvcHRpb25zLmxhbmd1YWdlcztcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGVmYXVsdExhbmd1YWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdExhbmd1YWdlID0gdGhpcy5fbGFuZ3VhZ2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBwcm9maWxlLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgcHJvZ3JhbSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHRoZSByZWFkIHByb2ZpbGUgKGVtcHR5LCBpZiBub25lLCBudWxsIGlmIGVycm9ycylcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWFkUHJvZmlsZShvcHRpb25zOiBQcm9ncmFtT3B0aW9ucyk6IElDb25maWdGaWxlIHtcclxuICAgICAgICBjb25zdCBwcm9maWxlUGF0aDogc3RyaW5nID0gb3B0aW9ucy5wcm9maWxlUGF0aDtcclxuICAgICAgICBpZiAoIXByb2ZpbGVQYXRoKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29uZmlnZmlsZW5hbWUgb2YgUFJPRklMRV9DQU5ESURBVEVTKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gWGxpZmZNZXJnZVBhcmFtZXRlcnMucmVhZFByb2ZpbGVDYW5kaWRhdGUoY29uZmlnZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2ZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZWRQcm9maWxlUGF0aCA9IGNvbmZpZ2ZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9maWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHByb2ZpbGVQYXRoLCAnVVRGLTgnKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKG5ldyBYbGlmZk1lcmdlRXJyb3IoJ2NvdWxkIG5vdCByZWFkIHByb2ZpbGUgXCInICsgcHJvZmlsZVBhdGggKyAnXCInKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVzZWRQcm9maWxlUGF0aCA9IHByb2ZpbGVQYXRoO1xyXG4gICAgICAgIGNvbnN0IHByb2ZpbGVDb250ZW50OiBJQ29uZmlnRmlsZSA9IEpTT04ucGFyc2UoY29udGVudCk7XHJcbiAgICAgICAgLy8gcmVwbGFjZSBhbGwgcGF0aGVzIGluIG9wdGlvbnMgYnkgYWJzb2x1dGUgcGF0aHNcclxuICAgICAgICBjb25zdCB4bGlmZm1lcmdlT3B0aW9ucyA9IHByb2ZpbGVDb250ZW50LnhsaWZmbWVyZ2VPcHRpb25zO1xyXG4gICAgICAgIHhsaWZmbWVyZ2VPcHRpb25zLnNyY0RpciA9IHRoaXMuYWRqdXN0UGF0aFRvUHJvZmlsZVBhdGgocHJvZmlsZVBhdGgsIHhsaWZmbWVyZ2VPcHRpb25zLnNyY0Rpcik7XHJcbiAgICAgICAgeGxpZmZtZXJnZU9wdGlvbnMuZ2VuRGlyID0gdGhpcy5hZGp1c3RQYXRoVG9Qcm9maWxlUGF0aChwcm9maWxlUGF0aCwgeGxpZmZtZXJnZU9wdGlvbnMuZ2VuRGlyKTtcclxuICAgICAgICB4bGlmZm1lcmdlT3B0aW9ucy5hcGlrZXlmaWxlID0gdGhpcy5hZGp1c3RQYXRoVG9Qcm9maWxlUGF0aChwcm9maWxlUGF0aCwgeGxpZmZtZXJnZU9wdGlvbnMuYXBpa2V5ZmlsZSk7XHJcbiAgICAgICAgcmV0dXJuIHByb2ZpbGVDb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYWRqdXN0UGF0aFRvUHJvZmlsZVBhdGgocHJvZmlsZVBhdGg6IHN0cmluZywgcGF0aFRvQWRqdXN0OiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGlmICghcGF0aFRvQWRqdXN0IHx8IGlzQWJzb2x1dGUocGF0aFRvQWRqdXN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aFRvQWRqdXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gam9pbihkaXJuYW1lKHByb2ZpbGVQYXRoKSwgcGF0aFRvQWRqdXN0KS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplRnJvbUNvbmZpZyhwcm9maWxlQ29udGVudDogSUNvbmZpZ0ZpbGUpIHtcclxuICAgICAgICBpZiAoIXByb2ZpbGVDb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IHByb2ZpbGVDb250ZW50LnhsaWZmbWVyZ2VPcHRpb25zO1xyXG4gICAgICAgIGlmIChwcm9maWxlKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5xdWlldCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1aWV0ID0gcHJvZmlsZS5xdWlldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUudmVyYm9zZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZlcmJvc2UgPSBwcm9maWxlLnZlcmJvc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLmFsbG93SWRDaGFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxvd0lkQ2hhbmdlID0gcHJvZmlsZS5hbGxvd0lkQ2hhbmdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmRlZmF1bHRMYW5ndWFnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdExhbmd1YWdlID0gcHJvZmlsZS5kZWZhdWx0TGFuZ3VhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2ZpbGUubGFuZ3VhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYW5ndWFnZXMgPSBwcm9maWxlLmxhbmd1YWdlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5zcmNEaXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NyY0RpciA9IHByb2ZpbGUuc3JjRGlyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmFuZ3VsYXJDb21waWxlck9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9maWxlLmFuZ3VsYXJDb21waWxlck9wdGlvbnMuZ2VuRGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VuRGlyID0gcHJvZmlsZS5hbmd1bGFyQ29tcGlsZXJPcHRpb25zLmdlbkRpcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5nZW5EaXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgbXVzdCBiZSBhZnRlciBhbmd1bGFyQ29tcGlsZXJPcHRpb25zIHRvIGJlIHByZWZlcnJlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VuRGlyID0gcHJvZmlsZS5nZW5EaXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2ZpbGUuaTE4bkJhc2VGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pMThuQmFzZUZpbGUgPSBwcm9maWxlLmkxOG5CYXNlRmlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5pMThuRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faTE4bkZpbGUgPSBwcm9maWxlLmkxOG5GaWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmkxOG5Gb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2kxOG5Gb3JtYXQgPSBwcm9maWxlLmkxOG5Gb3JtYXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2ZpbGUuZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kaW5nID0gcHJvZmlsZS5lbmNvZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUucmVtb3ZlVW51c2VkSWRzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVW51c2VkSWRzID0gcHJvZmlsZS5yZW1vdmVVbnVzZWRJZHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLnN1cHBvcnROZ3hUcmFuc2xhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0Tmd4VHJhbnNsYXRlID0gcHJvZmlsZS5zdXBwb3J0Tmd4VHJhbnNsYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuID0gcHJvZmlsZS5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUudXNlU291cmNlQXNUYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VTb3VyY2VBc1RhcmdldCA9IHByb2ZpbGUudXNlU291cmNlQXNUYXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLnRhcmdldFByYWVmaXgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRQcmFlZml4ID0gcHJvZmlsZS50YXJnZXRQcmFlZml4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS50YXJnZXRTdWZmaXgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRTdWZmaXggPSBwcm9maWxlLnRhcmdldFN1ZmZpeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUuYXV0b3RyYW5zbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG90cmFuc2xhdGUgPSBwcm9maWxlLmF1dG90cmFuc2xhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLmJlYXV0aWZ5T3V0cHV0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmVhdXRpZnlPdXRwdXQgPSBwcm9maWxlLmJlYXV0aWZ5T3V0cHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5wcmVzZXJ2ZU9yZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlc2VydmVPcmRlciA9IHByb2ZpbGUucHJlc2VydmVPcmRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUuYXBpa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpa2V5ID0gcHJvZmlsZS5hcGlrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLmFwaWtleWZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGlrZXlmaWxlID0gcHJvZmlsZS5hcGlrZXlmaWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5nc0ZvdW5kLnB1c2goJ2RpZCBub3QgZmluZCBcInhsaWZmbWVyZ2VPcHRpb25zXCIgaW4gcHJvZmlsZSwgdXNpbmcgZGVmYXVsdHMnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBhbGwgUGFyYW1ldGVycywgd2V0aGVyIHRoZXkgYXJlIGNvbXBsZXRlIGFuZCBjb25zaXN0ZW50LlxyXG4gICAgICogaWYgc29tZXRoaW5nIGlzIHdyb25nIHdpdGggdGhlIHBhcmFtZXRlcnMsIGl0IGlzIGNvbGxlY3RlZCBpbiBlcnJvcnNGb3VuZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja1BhcmFtZXRlcnMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jaGVja0xhbmd1YWdlU3ludGF4KHRoaXMuZGVmYXVsdExhbmd1YWdlKCkpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhbmd1YWdlcygpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2gobmV3IFhsaWZmTWVyZ2VFcnJvcignbm8gbGFuZ3VhZ2VzIHNwZWNpZmllZCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZXMoKS5mb3JFYWNoKChsYW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tMYW5ndWFnZVN5bnRheChsYW5nKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgc3RhdHM6IFN0YXRzO1xyXG4gICAgICAgIGxldCBlcnI6IGFueTtcclxuICAgICAgICAvLyBzcmNEaXIgc2hvdWxkIGV4aXN0c1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN0YXRzID0gZnMuc3RhdFN5bmModGhpcy5zcmNEaXIoKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlcnIgPSBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISFlcnIgfHwgIXN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKG5ldyBYbGlmZk1lcmdlRXJyb3IoJ3NyY0RpciBcIicgKyB0aGlzLnNyY0RpcigpICsgJ1wiIGlzIG5vdCBhIGRpcmVjdG9yeScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2VuRGlyIHNob3VsZCBleGlzdHNcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzdGF0cyA9IGZzLnN0YXRTeW5jKHRoaXMuZ2VuRGlyKCkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXJyID0gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhZXJyIHx8ICFzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzRm91bmQucHVzaChuZXcgWGxpZmZNZXJnZUVycm9yKCdnZW5EaXIgXCInICsgdGhpcy5nZW5EaXIoKSArICdcIiBpcyBub3QgYSBkaXJlY3RvcnknKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1hc3RlciBmaWxlIE1VU1QgZXhpc3RcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmcy5hY2Nlc3NTeW5jKHRoaXMuaTE4bkZpbGUoKSwgZnMuY29uc3RhbnRzLlJfT0spO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2gobmV3IFhsaWZmTWVyZ2VFcnJvcignaTE4bkZpbGUgXCInICsgdGhpcy5pMThuRmlsZSgpICsgJ1wiIGlzIG5vdCByZWFkYWJsZScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaTE4bkZvcm1hdCBtdXN0IGJlIHhsZiB4bGYyIG9yIHhtYlxyXG4gICAgICAgIGlmICghKHRoaXMuaTE4bkZvcm1hdCgpID09PSAneGxmJyB8fCB0aGlzLmkxOG5Gb3JtYXQoKSA9PT0gJ3hsZjInIHx8IHRoaXMuaTE4bkZvcm1hdCgpID09PSAneG1iJykpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKG5ldyBYbGlmZk1lcmdlRXJyb3IoJ2kxOG5Gb3JtYXQgXCInICsgdGhpcy5pMThuRm9ybWF0KCkgKyAnXCIgaW52YWxpZCwgbXVzdCBiZSBcInhsZlwiIG9yIFwieGxmMlwiIG9yIFwieG1iXCInKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGF1dG90cmFuc2xhdGUgcmVxdWlyZXMgYXBpIGtleVxyXG4gICAgICAgIGlmICh0aGlzLmF1dG90cmFuc2xhdGUoKSAmJiAhdGhpcy5hcGlrZXkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2gobmV3IFhsaWZmTWVyZ2VFcnJvcignYXV0b3RyYW5zbGF0ZSByZXF1aXJlcyBhbiBBUEkga2V5LCBwbGVhc2Ugc2V0IG9uZScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXV0b3RyYW5zbGF0ZWQgbGFuZ3VhZ2VzIG11c3QgYmUgaW4gbGlzdCBvZiBhbGwgbGFuZ3VhZ2VzXHJcbiAgICAgICAgdGhpcy5hdXRvdHJhbnNsYXRlZExhbmd1YWdlcygpLmZvckVhY2goKGxhbmcpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGFuZ3VhZ2VzKCkuaW5kZXhPZihsYW5nKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzRm91bmQucHVzaChuZXcgWGxpZmZNZXJnZUVycm9yKCdhdXRvdHJhbnNsYXRlIGxhbmd1YWdlIFwiJyArIGxhbmcgKyAnXCIgaXMgbm90IGluIGxpc3Qgb2YgbGFuZ3VhZ2VzJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYW5nID09PSB0aGlzLmRlZmF1bHRMYW5ndWFnZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFhsaWZmTWVyZ2VFcnJvcignYXV0b3RyYW5zbGF0ZSBsYW5ndWFnZSBcIicgKyBsYW5nICsgJ1wiIGNhbm5vdCBiZSB0cmFuc2xhdGVkLCBiZWNhdXNlIGl0IGlzIHRoZSBzb3VyY2UgbGFuZ3VhZ2UnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBuZ3ggdHJhbnNsYXRlIHBhdHRlcm4gY2hlY2tcclxuICAgICAgICBpZiAodGhpcy5zdXBwb3J0Tmd4VHJhbnNsYXRlKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBOZ3hUcmFuc2xhdGVFeHRyYWN0b3IuY2hlY2tQYXR0ZXJuKHRoaXMubmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4oKSk7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoY2hlY2tSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFhsaWZmTWVyZ2VFcnJvcignbmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4gXCInICsgdGhpcy5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybigpICsgJ1wiOiAnICsgY2hlY2tSZXN1bHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0YXJnZXRQcmFlZml4IGFuZCB0YXJnZXRTdWZmaXggY2hlY2tcclxuICAgICAgICBpZiAoIXRoaXMudXNlU291cmNlQXNUYXJnZXQoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXRQcmFlZml4KCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53YXJuaW5nc0ZvdW5kLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZ3VyZWQgdGFyZ2V0UHJhZWZpeCBcIicgKyB0aGlzLnRhcmdldFByYWVmaXgoKSArICdcIiB3aWxsIG5vdCBiZSB1c2VkIGJlY2F1c2UgXCJ1c2VTb3VyY2VBc1RhcmdldFwiIGlzIGRpc2FibGVkXCInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXRTdWZmaXgoKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdzRm91bmQucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAnY29uZmlndXJlZCB0YXJnZXRTdWZmaXggXCInICsgdGhpcy50YXJnZXRTdWZmaXgoKSArICdcIiB3aWxsIG5vdCBiZSB1c2VkIGJlY2F1c2UgXCJ1c2VTb3VyY2VBc1RhcmdldFwiIGlzIGRpc2FibGVkXCInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBzeW50YXggb2YgbGFuZ3VhZ2UuXHJcbiAgICAgKiBNdXN0IGJlIGNvbXBhdGlibGUgd2l0aCBYTUwgU2NoZW1hIHR5cGUgeHNkOmxhbmd1YWdlLlxyXG4gICAgICogUGF0dGVybjogW2EtekEtWl17MSw4fSgoLXxfKVthLXpBLVowLTldezEsOH0pKlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2UgdG8gY2hlY2tcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja0xhbmd1YWdlU3ludGF4KGxhbmc6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAvXlthLXpBLVpdezEsOH0oWy1fXVthLXpBLVowLTldezEsOH0pKiQvO1xyXG4gICAgICAgIGlmICghcGF0dGVybi50ZXN0KGxhbmcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzRm91bmQucHVzaChuZXcgWGxpZmZNZXJnZUVycm9yKCdsYW5ndWFnZSBcIicgKyBsYW5nICsgJ1wiIGlzIG5vdCB2YWxpZCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFsbG93SWRDaGFuZ2UoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9hbGxvd0lkQ2hhbmdlKSkgPyBmYWxzZSA6IHRoaXMuX2FsbG93SWRDaGFuZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZlcmJvc2UoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl92ZXJib3NlKSkgPyBmYWxzZSA6IHRoaXMuX3ZlcmJvc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHF1aWV0KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fcXVpZXQpKSA/IGZhbHNlIDogdGhpcy5fcXVpZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWJ1ZyBvdXRwdXQgYWxsIHBhcmFtZXRlcnMgdG8gY29tbWFuZE91dHB1dC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNob3dBbGxQYXJhbWV0ZXJzKGNvbW1hbmRPdXRwdXQ6IENvbW1hbmRPdXRwdXQpOiB2b2lkIHtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCd4bGlmZm1lcmdlIFVzZWQgUGFyYW1ldGVyczonKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCd1c2VkUHJvZmlsZVBhdGg6XFx0XCIlc1wiJywgdGhpcy51c2VkUHJvZmlsZVBhdGgpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ2RlZmF1bHRMYW5ndWFnZTpcXHRcIiVzXCInLCB0aGlzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdzcmNEaXI6XFx0XCIlc1wiJywgdGhpcy5zcmNEaXIoKSk7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnZ2VuRGlyOlxcdFwiJXNcIicsIHRoaXMuZ2VuRGlyKCkpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ2kxOG5CYXNlRmlsZTpcXHRcIiVzXCInLCB0aGlzLmkxOG5CYXNlRmlsZSgpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdpMThuRmlsZTpcXHRcIiVzXCInLCB0aGlzLmkxOG5GaWxlKCkpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ2xhbmd1YWdlczpcXHQlcycsIHRoaXMubGFuZ3VhZ2VzKCkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgbGFuZ3VhZ2Ugb2YgdGhpcy5sYW5ndWFnZXMoKSkge1xyXG4gICAgICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdvdXRwdXRGaWxlWyVzXTpcXHQlcycsIGxhbmd1YWdlLCB0aGlzLmdlbmVyYXRlZEkxOG5GaWxlKGxhbmd1YWdlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ3JlbW92ZVVudXNlZElkczpcXHQlcycsIHRoaXMucmVtb3ZlVW51c2VkSWRzKCkpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ3N1cHBvcnROZ3hUcmFuc2xhdGU6XFx0JXMnLCB0aGlzLnN1cHBvcnROZ3hUcmFuc2xhdGUoKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydE5neFRyYW5zbGF0ZSgpKSB7XHJcbiAgICAgICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ25neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuOlxcdCVzJywgdGhpcy5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygndXNlU291cmNlQXNUYXJnZXQ6XFx0JXMnLCB0aGlzLnVzZVNvdXJjZUFzVGFyZ2V0KCkpO1xyXG4gICAgICAgIGlmICh0aGlzLnVzZVNvdXJjZUFzVGFyZ2V0KCkpIHtcclxuICAgICAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygndGFyZ2V0UHJhZWZpeDpcXHRcIiVzXCInLCB0aGlzLnRhcmdldFByYWVmaXgoKSk7XHJcbiAgICAgICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ3RhcmdldFN1ZmZpeDpcXHRcIiVzXCInLCB0aGlzLnRhcmdldFN1ZmZpeCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnYWxsb3dJZENoYW5nZTpcXHQlcycsIHRoaXMuYWxsb3dJZENoYW5nZSgpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdiZWF1dGlmeU91dHB1dDpcXHQlcycsIHRoaXMuYmVhdXRpZnlPdXRwdXQoKSk7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygncHJlc2VydmVPcmRlcjpcXHQlcycsIHRoaXMucHJlc2VydmVPcmRlcigpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdhdXRvdHJhbnNsYXRlOlxcdCVzJywgdGhpcy5hdXRvdHJhbnNsYXRlKCkpO1xyXG4gICAgICAgIGlmICh0aGlzLmF1dG90cmFuc2xhdGUoKSkge1xyXG4gICAgICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdhdXRvdHJhbnNsYXRlZCBsYW5ndWFnZXM6XFx0JXMnLCB0aGlzLmF1dG90cmFuc2xhdGVkTGFuZ3VhZ2VzKCkpO1xyXG4gICAgICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdhcGlrZXk6XFx0JXMnLCB0aGlzLmFwaWtleSgpID8gJyoqKionIDogJ05PVCBTRVQnKTtcclxuICAgICAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnYXBpa2V5ZmlsZTpcXHQlcycsIHRoaXMuYXBpa2V5ZmlsZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0LUxhbmd1YWdlLCBkZWZhdWx0IGVuLlxyXG4gICAgICogQHJldHVybiBkZWZhdWx0IGxhbmd1YWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWZhdWx0TGFuZ3VhZ2UoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdExhbmd1YWdlID8gdGhpcy5fZGVmYXVsdExhbmd1YWdlIDogJ2VuJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3RlIGRlciB6dSBiZWFyYmVpdGVuZGVuIFNwcmFjaGVuLlxyXG4gICAgICogQHJldHVybiBsYW5ndWFnZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxhbmd1YWdlcygpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlcyA/IHRoaXMuX2xhbmd1YWdlcyA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc3JjIGRpcmVjdG9yeSwgd2hlcmUgdGhlIG1hc3RlciB4bGlmIGlzIGxvY2F0ZWQuXHJcbiAgICAgKiBAcmV0dXJuIHNyY0RpclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3JjRGlyKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NyY0RpciA/IHRoaXMuX3NyY0RpciA6ICcuJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGZpbGUgbmFtZSBvZiB0aGUgeGxpZiBmaWxlIGZvciBpbnB1dCBhbmQgb3V0cHV0LlxyXG4gICAgICogRGVmYXVsdCBpcyBtZXNzYWdlc1xyXG4gICAgICogQHJldHVybiBiYXNlIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGkxOG5CYXNlRmlsZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pMThuQmFzZUZpbGUgPyB0aGlzLl9pMThuQmFzZUZpbGUgOiAnbWVzc2FnZXMnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1hc3RlciB4bGlmIGZpbGUgKHRoZSBvbmUgZ2VuZXJhdGVkIGJ5IG5nLXhpMThuKS5cclxuICAgICAqIERlZmF1bHQgaXMgPHNyY0Rpcj4vPGkxOG5CYXNlRmlsZT4ueGxmLlxyXG4gICAgICogQHJldHVybiBtYXN0ZXIgZmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaTE4bkZpbGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gam9pbih0aGlzLnNyY0RpcigpLFxyXG4gICAgICAgICAgICAodGhpcy5faTE4bkZpbGUgPyB0aGlzLl9pMThuRmlsZSA6IHRoaXMuaTE4bkJhc2VGaWxlKCkgKyAnLicgKyB0aGlzLnN1ZmZpeEZvckdlbmVyYXRlZEkxOG5GaWxlKCkpXHJcbiAgICAgICAgKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXQgb2YgdGhlIG1hc3RlciB4bGlmIGZpbGUuXHJcbiAgICAgKiBEZWZhdWx0IGlzIFwieGxmXCIsIHBvc3NpYmxlIGFyZSBcInhsZlwiIG9yIFwieGxmMlwiIG9yIFwieG1iXCIuXHJcbiAgICAgKiBAcmV0dXJuIGZvcm1hdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaTE4bkZvcm1hdCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5faTE4bkZvcm1hdCA/IHRoaXMuX2kxOG5Gb3JtYXQgOiAneGxmJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBwb3RlbnRpYWxseSB0byBiZSBnZW5lcmF0ZWQgSTE4bi1GaWxlIHdpdGggdGhlIHRyYW5zbGF0aW9ucyBmb3Igb25lIGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2Ugc2hvcnRjdXRcclxuICAgICAqIEByZXR1cm4gUGF0aCBvZiBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZW5lcmF0ZWRJMThuRmlsZShsYW5nOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBqb2luKHRoaXMuZ2VuRGlyKCksIHRoaXMuaTE4bkJhc2VGaWxlKCkgKyAnLicgKyBsYW5nICsgJy4nICsgdGhpcy5zdWZmaXhGb3JHZW5lcmF0ZWRJMThuRmlsZSgpKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdWZmaXhGb3JHZW5lcmF0ZWRJMThuRmlsZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5pMThuRm9ybWF0KCkpIHtcclxuICAgICAgICAgICAgY2FzZSAneGxmJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAneGxmJztcclxuICAgICAgICAgICAgY2FzZSAneGxmMic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3hsZic7XHJcbiAgICAgICAgICAgIGNhc2UgJ3htYic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3h0Yic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcG90ZW50aWFsbHkgdG8gYmUgZ2VuZXJhdGVkIHRyYW5zbGF0ZS1GaWxlIGZvciBuZ3gtdHJhbnNsYXRlIHdpdGggdGhlIHRyYW5zbGF0aW9ucyBmb3Igb25lIGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2Ugc2hvcnRjdXRcclxuICAgICAqIEByZXR1cm4gUGF0aCBvZiBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZW5lcmF0ZWROZ3hUcmFuc2xhdGVGaWxlKGxhbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGpvaW4odGhpcy5nZW5EaXIoKSwgdGhpcy5pMThuQmFzZUZpbGUoKSArICcuJyArIGxhbmcgKyAnLicgKyAnanNvbicpLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlbmNvZGluZyB1c2VkIHRvIHdyaXRlIG5ldyBYTElGRi1maWxlcy5cclxuICAgICAqIEByZXR1cm4gZW5jb2RpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuY29kaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kaW5nID8gdGhpcy5fZW5jb2RpbmcgOiAnVVRGLTgnO1xyXG4gICAgfVxyXG5cclxuICAgICAvKipcclxuICAgICAgKiBPdXRwdXQtRGlyZWN0b3J5LCB3aGVyZSB0aGUgb3V0cHV0IGlzIHdyaXR0ZW4gdG8uXHJcbiAgICAgICogRGVmYXVsdCBpcyA8c3JjRGlyPi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdlbkRpcigpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5EaXIgPyB0aGlzLl9nZW5EaXIgOiB0aGlzLnNyY0RpcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZW1vdmVVbnVzZWRJZHMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9yZW1vdmVVbnVzZWRJZHMpKSA/IHRydWUgOiB0aGlzLl9yZW1vdmVVbnVzZWRJZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN1cHBvcnROZ3hUcmFuc2xhdGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9zdXBwb3J0Tmd4VHJhbnNsYXRlKSkgPyBmYWxzZSA6IHRoaXMuX3N1cHBvcnROZ3hUcmFuc2xhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG5neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybikpID9cclxuICAgICAgICAgICAgTmd4VHJhbnNsYXRlRXh0cmFjdG9yLkRlZmF1bHRFeHRyYWN0aW9uUGF0dGVybiA6IHRoaXMuX25neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBzb3VyY2UgbXVzdCBiZSB1c2VkIGFzIHRhcmdldCBmb3IgbmV3IHRyYW5zLXVuaXRzXHJcbiAgICAgKiBEZWZhdWx0IGlzIHRydWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVzZVNvdXJjZUFzVGFyZ2V0KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fdXNlU291cmNlQXNUYXJnZXQpKSA/IHRydWUgOiB0aGlzLl91c2VTb3VyY2VBc1RhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByYWVmaXggdXNlZCBmb3IgdGFyZ2V0IHdoZW4gY29weWluZyBuZXcgdHJhbnMtdW5pdHNcclxuICAgICAqIERlZmF1bHQgaXMgXCJcIlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdGFyZ2V0UHJhZWZpeCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fdGFyZ2V0UHJhZWZpeCkpID8gJycgOiB0aGlzLl90YXJnZXRQcmFlZml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VmZml4IHVzZWQgZm9yIHRhcmdldCB3aGVuIGNvcHlpbmcgbmV3IHRyYW5zLXVuaXRzXHJcbiAgICAgKiBEZWZhdWx0IGlzIFwiXCJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldFN1ZmZpeCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fdGFyZ2V0U3VmZml4KSkgPyAnJyA6IHRoaXMuX3RhcmdldFN1ZmZpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCwgcnVuIHhtbCByZXN1bHQgdGhyb3VnaCBiZWF1dGlmaWVyIChwcmV0dHktZGF0YSkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBiZWF1dGlmeU91dHB1dCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuX2JlYXV0aWZ5T3V0cHV0KSkgPyBmYWxzZSA6IHRoaXMuX2JlYXV0aWZ5T3V0cHV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0LCBvcmRlciBvZiBuZXcgdHJhbnMgdW5pdHMgd2lsbCBiZSBhcyBpbiBtYXN0ZXIuXHJcbiAgICAgKiBPdGhlcndpc2UgdGhleSBhcmUgYWRkZWQgYXQgdGhlIGVuZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHByZXNlcnZlT3JkZXIoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9wcmVzZXJ2ZU9yZGVyKSkgPyB0cnVlIDogdGhpcy5fcHJlc2VydmVPcmRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gdXNlIGF1dG90cmFuc2xhdGUgZm9yIG5ldyB0cmFucy11bml0c1xyXG4gICAgICogRGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXV0b3RyYW5zbGF0ZSgpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fYXV0b3RyYW5zbGF0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheSh0aGlzLl9hdXRvdHJhbnNsYXRlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKDxzdHJpbmdbXT50aGlzLl9hdXRvdHJhbnNsYXRlKS5sZW5ndGggPiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGJvb2xlYW4+IHRoaXMuX2F1dG90cmFuc2xhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHVzZSBhdXRvdHJhbnNsYXRlIGZvciBhIGdpdmVuIGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2UgY29kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGF1dG90cmFuc2xhdGVMYW5ndWFnZShsYW5nOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRvdHJhbnNsYXRlZExhbmd1YWdlcygpLmluZGV4T2YobGFuZykgPj0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGxpc3Qgb2YgbGFuZ3VhZ2VzIHRvIGJlIGF1dG90cmFuc2xhdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXV0b3RyYW5zbGF0ZWRMYW5ndWFnZXMoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9hdXRvdHJhbnNsYXRlKSB8fCB0aGlzLl9hdXRvdHJhbnNsYXRlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KHRoaXMuX2F1dG90cmFuc2xhdGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoPHN0cmluZ1tdPnRoaXMuX2F1dG90cmFuc2xhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZXMoKS5zbGljZSgxKTsgLy8gZmlyc3QgaXMgc291cmNlIGxhbmd1YWdlXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBUEkga2V5IHRvIGJlIHVzZWQgZm9yIEdvb2dsZSBUcmFuc2xhdGVcclxuICAgICAqIEByZXR1cm4gYXBpIGtleVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXBpa2V5KCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0aGlzLl9hcGlrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcGlrZXk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgYXBpa2V5UGF0aCA9IHRoaXMuYXBpa2V5ZmlsZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hcGlrZXlmaWxlKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGFwaWtleVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpbGVVdGlsLnJlYWQoYXBpa2V5UGF0aCwgJ3V0Zi04Jyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ2FwaSBrZXkgZmlsZSBub3QgZm91bmQ6IEFQSV9LRVlfRklMRT0lcycsIGFwaWtleVBhdGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmlsZSBuYW1lIGZvciBBUEkga2V5IHRvIGJlIHVzZWQgZm9yIEdvb2dsZSBUcmFuc2xhdGUuXHJcbiAgICAgKiBFeHBsaWNpdGx5IHNldCBvciByZWFkIGZyb20gZW52IHZhciBBUElfS0VZX0ZJTEUuXHJcbiAgICAgKiBAcmV0dXJuIGZpbGUgb2YgYXBpIGtleVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXBpa2V5ZmlsZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLl9hcGlrZXlmaWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcGlrZXlmaWxlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuQVBJX0tFWV9GSUxFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5BUElfS0VZX0ZJTEU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxOS4wMi4yMDE3LlxyXG4gKi9cclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuXHJcbmxldCBwa2cgPSBudWxsO1xyXG50cnkge1xyXG4gICAgcGtnID0gcmVxdWlyZShwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAncGFja2FnZS5qc29uJykpO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHBrZyA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJ3BhY2thZ2UuanNvbicpKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBwa2cgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IChwa2cgPyBwa2cudmVyc2lvbiA6ICd1bmtub3duJyk7XHJcbiIsImltcG9ydCB7RmlsZVV0aWx9IGZyb20gJy4uL2NvbW1vbi9maWxlLXV0aWwnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTAuMDMuMjAxNy5cclxuICogSGVscGVyIGNsYXNzIHRvIHJlYWQgWE1sIHdpdGggYSBjb3JyZWN0IGVuY29kaW5nLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbWxSZWFkZXIge1xyXG4gICAgc3RhdGljIERFRkFVTFRfRU5DT0RJTkcgPSAnVVRGLTgnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBhbiB4bWwtRmlsZS5cclxuICAgICAqIEBwYXJhbSBwYXRoIFBhdGggdG8gZmlsZVxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIG9wdGlvbmFsIGVuY29kaW5nIG9mIHRoZSB4bWwuXHJcbiAgICAgKiBUaGlzIGlzIHJlYWQgZnJvbSB0aGUgZmlsZSwgYnV0IGlmIHlvdSBrbm93IGl0IGJlZm9yZSwgeW91IGNhbiBhdm9pZCByZWFkaW5nIHRoZSBmaWxlIHR3aWNlLlxyXG4gICAgICogQHJldHVybiBmaWxlIGNvbnRlbnQgYW5kIGVuY29kaW5nIGZvdW5kIGluIHRoZSBmaWxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRYbWxGaWxlQ29udGVudChwYXRoOiBzdHJpbmcsIGVuY29kaW5nPzogc3RyaW5nKToge2NvbnRlbnQ6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZ30ge1xyXG4gICAgICAgIGlmICghZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSBYbWxSZWFkZXIuREVGQVVMVF9FTkNPRElORztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZyA9IEZpbGVVdGlsLnJlYWQocGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIGNvbnN0IGZvdW5kRW5jb2RpbmcgPSBYbWxSZWFkZXIuZW5jb2RpbmdGcm9tWG1sKGNvbnRlbnQpO1xyXG4gICAgICAgIGlmIChmb3VuZEVuY29kaW5nICE9PSBlbmNvZGluZykge1xyXG4gICAgICAgICAgICAvLyByZWFkIGFnYWluIHdpdGggdGhlIGNvcnJlY3QgZW5jb2RpbmdcclxuICAgICAgICAgICAgY29udGVudCA9IEZpbGVVdGlsLnJlYWQocGF0aCwgZm91bmRFbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgIGVuY29kaW5nOiBmb3VuZEVuY29kaW5nXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgdGhlIGVuY29kaW5nIGZyb20gdGhlIHhtbC5cclxuICAgICAqIHhtbCBGaWxlIHN0YXJ0cyB3aXRoIC4uIGVuY29kaW5nPVwiLi5cIlxyXG4gICAgICogQHBhcmFtIHhtbFN0cmluZyB4bWxTdHJpbmdcclxuICAgICAqIEByZXR1cm4gZW5jb2RpbmdcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZW5jb2RpbmdGcm9tWG1sKHhtbFN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHhtbFN0cmluZy5pbmRleE9mKCdlbmNvZGluZz1cIicpO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuREVGQVVMVF9FTkNPRElORzsgLy8gZGVmYXVsdCBpbiB4bWwgaWYgbm90IGV4cGxpY2l0bHkgc2V0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0geG1sU3RyaW5nLmluZGV4T2YoJ1wiJywgaW5kZXggKyAxMCk7IC8vIDEwID0gbGVuZ3RoIG9mICdlbmNvZGluZz1cIidcclxuICAgICAgICByZXR1cm4geG1sU3RyaW5nLnN1YnN0cmluZyhpbmRleCArIDEwLCBlbmRJbmRleCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAyMS4wMy4yMDE3LlxyXG4gKi9cclxuaW1wb3J0IHtUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZUZhY3RvcnksIElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliJztcclxuaW1wb3J0IHtGaWxlVXRpbH0gZnJvbSAnLi4vY29tbW9uL2ZpbGUtdXRpbCc7XHJcbmltcG9ydCB7WG1sUmVhZGVyfSBmcm9tICcuL3htbC1yZWFkZXInO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyB0byByZWFkIHRyYW5zbGF0aW9uIGZpbGVzIGRlcGVuZGluZyBvbiBmb3JtYXQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBmaWxlIGZ1bmN0aW9uLCByZXN1bHQgZGVwZW5kcyBvbiBmb3JtYXQsIGVpdGhlciBYbGlmZkZpbGUgb3IgWG1iRmlsZS5cclxuICAgICAqIEBwYXJhbSBpMThuRm9ybWF0IGZvcm1hdFxyXG4gICAgICogQHBhcmFtIHBhdGggcGF0aFxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIGVuY29kaW5nXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCBvcHRpb25hbE1hc3RlckZpbGVQYXRoXHJcbiAgICAgKiBAcmV0dXJuIFhsaWZmRmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZyb21GaWxlKGkxOG5Gb3JtYXQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3RlckZpbGVQYXRoPzogc3RyaW5nKTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuICAgICAgICBjb25zdCB4bWxDb250ZW50ID0gWG1sUmVhZGVyLnJlYWRYbWxGaWxlQ29udGVudChwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxNYXN0ZXIgPSBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5tYXN0ZXJGaWxlQ29udGVudChvcHRpb25hbE1hc3RlckZpbGVQYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgcmV0dXJuIFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeS5mcm9tRmlsZUNvbnRlbnQoaTE4bkZvcm1hdCwgeG1sQ29udGVudC5jb250ZW50LCBwYXRoLCB4bWxDb250ZW50LmVuY29kaW5nLCBvcHRpb25hbE1hc3Rlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGZpbGUgZnVuY3Rpb24sIHJlc3VsdCBkZXBlbmRzIG9uIGZvcm1hdCwgZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlLlxyXG4gICAgICogQHBhcmFtIHBhdGggcGF0aFxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIGVuY29kaW5nXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCBvcHRpb25hbE1hc3RlckZpbGVQYXRoXHJcbiAgICAgKiBAcmV0dXJuIFhsaWZmRmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZyb21Vbmtub3duRm9ybWF0RmlsZShwYXRoOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aD86IHN0cmluZyk6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgY29uc3QgeG1sQ29udGVudCA9IFhtbFJlYWRlci5yZWFkWG1sRmlsZUNvbnRlbnQocGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsTWFzdGVyID0gVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIubWFzdGVyRmlsZUNvbnRlbnQob3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIHJldHVybiBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZUZhY3RvcnkuZnJvbVVua25vd25Gb3JtYXRGaWxlQ29udGVudCh4bWxDb250ZW50LmNvbnRlbnQsIHBhdGgsIHhtbENvbnRlbnQuZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgbWFzdGVyIHhtYiBmaWxlXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCBvcHRpb25hbE1hc3RlckZpbGVQYXRoXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgZW5jb2RpbmdcclxuICAgICAqIEByZXR1cm4gY29udGVudCBhbmQgZW5jb2Rpbmcgb2YgZmlsZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBtYXN0ZXJGaWxlQ29udGVudChvcHRpb25hbE1hc3RlckZpbGVQYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpXHJcbiAgICAgICAgOiB7eG1sQ29udGVudDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmd9IHtcclxuICAgICAgICBpZiAob3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXN0ZXJYbWxDb250ZW50ID0gWG1sUmVhZGVyLnJlYWRYbWxGaWxlQ29udGVudChvcHRpb25hbE1hc3RlckZpbGVQYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4bWxDb250ZW50OiBtYXN0ZXJYbWxDb250ZW50LmNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICBwYXRoOiBvcHRpb25hbE1hc3RlckZpbGVQYXRoLFxyXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IG1hc3RlclhtbENvbnRlbnQuZW5jb2RpbmdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIGVkaXRlZCBmaWxlLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzRmlsZSBtZXNzYWdlc0ZpbGVcclxuICAgICAqIEBwYXJhbSBiZWF1dGlmeU91dHB1dCBGbGFnIHdoZXRoZXIgdG8gdXNlIHByZXR0eS1kYXRhIHRvIGZvcm1hdCB0aGUgb3V0cHV0LlxyXG4gICAgICogWE1MU2VyaWFsaXplciBwcm9kdWNlcyBzb21lIGNvcnJlY3QgYnV0IHN0cmFuZ2VseSBmb3JtYXR0ZWQgb3V0cHV0LCB3aGljaCBwcmV0dHktZGF0YSBjYW4gY29ycmVjdC5cclxuICAgICAqIFNlZSBpc3N1ZSAjNjQgZm9yIGRldGFpbHMuXHJcbiAgICAgKiBEZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNhdmUobWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsIGJlYXV0aWZ5T3V0cHV0PzogYm9vbGVhbikge1xyXG4gICAgICAgIEZpbGVVdGlsLnJlcGxhY2VDb250ZW50KG1lc3NhZ2VzRmlsZS5maWxlbmFtZSgpLCBtZXNzYWdlc0ZpbGUuZWRpdGVkQ29udGVudChiZWF1dGlmeU91dHB1dCksIG1lc3NhZ2VzRmlsZS5lbmNvZGluZygpKTtcclxuICAgIH1cclxufVxyXG5cclxuIiwiaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3JlcXVlc3QnO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge29mLCBmb3JrSm9pbiwgdGhyb3dFcnJvcn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7bWFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAwMy4wNy4yMDE3LlxyXG4gKiBMb3cgTGV2ZWwgU2VydmljZSB0byBjYWxsIEdvb2dsZSBUcmFuc2xhdGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFR5cGVzIGZvcm0gZ29vZ2xlIHRyYW5zbGF0ZSBhcGkuXHJcbiAqL1xyXG5cclxuaW50ZXJmYWNlIEdldFN1cHBvcnRlZExhbmd1YWdlc1JlcXVlc3Qge1xyXG4gICAgdGFyZ2V0OiBzdHJpbmc7IC8vIFRoZSBsYW5ndWFnZSB0byB1c2UgdG8gcmV0dXJuIGxvY2FsaXplZCwgaHVtYW4gcmVhZGFibGUgbmFtZXMgb2Ygc3VwcG9ydGVkXFxubGFuZ3VhZ2VzLlxyXG59XHJcblxyXG5pbnRlcmZhY2UgTGFuZ3VhZ2VzUmVzb3VyY2Uge1xyXG4gICAgbGFuZ3VhZ2U6IHN0cmluZzsgLy8gY29kZSBvZiB0aGUgbGFuZ3VhZ2VcclxuICAgIG5hbWU6IHN0cmluZzsgLy8gaHVtYW4gcmVhZGFibGUgbmFtZSAoaW4gdGFyZ2V0IGxhbmd1YWdlKVxyXG59XHJcblxyXG5pbnRlcmZhY2UgTGFuZ3VhZ2VzTGlzdFJlc3BvbnNlIHtcclxuICAgIGxhbmd1YWdlczogTGFuZ3VhZ2VzUmVzb3VyY2VbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFRyYW5zbGF0ZVRleHRSZXF1ZXN0IHtcclxuICAgIHE6IHN0cmluZ1tdOyAgLy8gVGhlIGlucHV0IHRleHRzIHRvIHRyYW5zbGF0ZVxyXG4gICAgdGFyZ2V0OiBzdHJpbmc7IC8vIFRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIHRyYW5zbGF0aW9uIG9mIHRoZSBpbnB1dCB0ZXh0XHJcbiAgICBzb3VyY2U6IHN0cmluZzsgLy8gVGhlIGxhbmd1YWdlIG9mIHRoZSBzb3VyY2UgdGV4dFxyXG4gICAgZm9ybWF0Pzogc3RyaW5nOyAvLyBcImh0bWxcIiAoZGVmYXVsdCkgb3IgXCJ0ZXh0XCJcclxuICAgIG1vZGVsPzogc3RyaW5nOyAvLyBzZWUgcHVibGljIGRvY3VtZW50YXRpb25cclxufVxyXG5cclxuaW50ZXJmYWNlIFRyYW5zbGF0aW9uc1Jlc291cmNlIHtcclxuICAgIGRldGVjdGVkU291cmNlTGFuZ3VhZ2U/OiBzdHJpbmc7XHJcbiAgICBtb2RlbD86IHN0cmluZztcclxuICAgIHRyYW5zbGF0ZWRUZXh0OiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUcmFuc2xhdGlvbnNMaXN0UmVzcG9uc2Uge1xyXG4gICAgdHJhbnNsYXRpb25zOiBUcmFuc2xhdGlvbnNSZXNvdXJjZVtdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgSW50ZXJuYWxSZXF1ZXN0UmVzcG9uc2Uge1xyXG4gICAgcmVzcG9uc2U6IHJlcXVlc3QuUmVxdWVzdFJlc3BvbnNlO1xyXG4gICAgYm9keTogYW55O1xyXG59XHJcblxyXG5jb25zdCBNQVhfU0VHTUVOVFMgPSAxMjg7XHJcblxyXG5leHBvcnQgY2xhc3MgQXV0b1RyYW5zbGF0ZVNlcnZpY2Uge1xyXG5cclxuICAgIHByaXZhdGUgX3JlcXVlc3Q6IHJlcXVlc3QuUmVxdWVzdEFQSTxyZXF1ZXN0LlJlcXVlc3QsIHJlcXVlc3QuQ29yZU9wdGlvbnMsIHJlcXVlc3QuUmVxdWlyZWRVcmlVcmw+O1xyXG4gICAgX3Jvb3RVcmw6IHN0cmluZztcclxuICAgIF9hcGlLZXk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmlwIHJlZ2lvbiBjb2RlIGFuZCBjb252ZXJ0IHRvIGxvd2VyXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBsYW5nXHJcbiAgICAgKiBAcmV0dXJuIGxhbmcgd2l0aG91dCByZWdpb24gY29kZSBhbmQgaW4gbG93ZXIgY2FzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdHJpcFJlZ2lvbmNvZGUobGFuZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBsYW5nTG93ZXIgPSBsYW5nLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYW5nTG93ZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYyA9IGxhbmdMb3dlci5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgIGlmIChjIDwgJ2EnIHx8IGMgPiAneicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nTG93ZXIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsYW5nTG93ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBpS2V5OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgICAgICB0aGlzLl9hcGlLZXkgPSBhcGlLZXk7XHJcbiAgICAgICAgdGhpcy5fcm9vdFVybCA9ICdodHRwczovL3RyYW5zbGF0aW9uLmdvb2dsZWFwaXMuY29tLyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgQVBJIGtleSAoanVzdCBmb3IgdGVzdHMpLlxyXG4gICAgICogQHBhcmFtIGFwaWtleSBhcGlrZXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEFwaUtleShhcGlrZXk6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2FwaUtleSA9IGFwaWtleTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZSBhbiBhcnJheSBvZiBtZXNzYWdlcyBhdCBvbmNlLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIHRoZSBtZXNzYWdlcyB0byBiZSB0cmFuc2xhdGVkXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBzb3VyY2UgbGFuZ3VhZ2UgY29kZVxyXG4gICAgICogQHBhcmFtIHRvIHRhcmdldCBsYW5ndWFnZSBjb2RlXHJcbiAgICAgKiBAcmV0dXJuIE9ic2VydmFibGUgd2l0aCB0cmFuc2xhdGVkIG1lc3NhZ2VzIG9yIGVycm9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVNdWx0aXBsZVN0cmluZ3MobWVzc2FnZXM6IHN0cmluZ1tdLCBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZ1tdPiB7XHJcbiAgICAgICAgLy8gZW1wdHkgYXJyYXkgbmVlZHMgbm8gdHJhbnNsYXRpb24gYW5kIGFsd2F5cyB3b3JrcyAuLi4gKCM3OClcclxuICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvZihbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fYXBpS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdjYW5ub3QgYXV0b3RyYW5zbGF0ZTogbm8gYXBpIGtleScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZyb20gfHwgIXRvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdjYW5ub3QgYXV0b3RyYW5zbGF0ZTogc291cmNlIGFuZCB0YXJnZXQgbGFuZ3VhZ2UgbXVzdCBiZSBzZXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJvbSA9IEF1dG9UcmFuc2xhdGVTZXJ2aWNlLnN0cmlwUmVnaW9uY29kZShmcm9tKTtcclxuICAgICAgICB0byA9IEF1dG9UcmFuc2xhdGVTZXJ2aWNlLnN0cmlwUmVnaW9uY29kZSh0byk7XHJcbiAgICAgICAgY29uc3QgYWxsUmVxdWVzdHM6IE9ic2VydmFibGU8c3RyaW5nW10+W10gPSB0aGlzLnNwbGl0TWVzc2FnZXNUb0dvb2dsZUxpbWl0KG1lc3NhZ2VzKS5tYXAoKHBhcnRpYWxNZXNzYWdlczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGltaXRlZFRyYW5zbGF0ZU11bHRpcGxlU3RyaW5ncyhwYXJ0aWFsTWVzc2FnZXMsIGZyb20sIHRvKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oYWxsUmVxdWVzdHMpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoYWxsVHJhbnNsYXRpb25zOiBzdHJpbmdbXVtdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWxsID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbFRyYW5zbGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbCA9IGFsbC5jb25jYXQoYWxsVHJhbnNsYXRpb25zW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhbGw7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3BsaXRNZXNzYWdlc1RvR29vZ2xlTGltaXQobWVzc2FnZXM6IHN0cmluZ1tdKTogc3RyaW5nW11bXSB7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA8PSBNQVhfU0VHTUVOVFMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFttZXNzYWdlc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50UGFja2FnZSA9IFtdO1xyXG4gICAgICAgIGxldCBwYWNrYWdlU2l6ZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjdXJyZW50UGFja2FnZS5wdXNoKG1lc3NhZ2VzW2ldKTtcclxuICAgICAgICAgICAgcGFja2FnZVNpemUrKztcclxuICAgICAgICAgICAgaWYgKHBhY2thZ2VTaXplID49IE1BWF9TRUdNRU5UUykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudFBhY2thZ2UpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhY2thZ2UgPSBbXTtcclxuICAgICAgICAgICAgICAgIHBhY2thZ2VTaXplID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VycmVudFBhY2thZ2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50UGFja2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdHJhbnNsYXRpb24gcmVxdWVzdCwgYnV0IG1lc3NhZ2VzIG11c3QgYmUgbGltaXRlZCB0byBnb29nbGUgbGltaXRzLlxyXG4gICAgICogTm90IG1vcmUgdGhhdCAxMjggc2luZ2xlIG1lc3NhZ2VzLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIG1lc3NhZ2VzXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gdG8gdG9cclxuICAgICAqIEByZXR1cm4gdGhlIHRyYW5zbGF0ZWQgc3RyaW5nc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxpbWl0ZWRUcmFuc2xhdGVNdWx0aXBsZVN0cmluZ3MobWVzc2FnZXM6IHN0cmluZ1tdLCBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZ1tdPiB7XHJcbiAgICAgICAgY29uc3QgcmVhbFVybCA9IHRoaXMuX3Jvb3RVcmwgKyAnbGFuZ3VhZ2UvdHJhbnNsYXRlL3YyJyArICc/a2V5PScgKyB0aGlzLl9hcGlLZXk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlUmVxdWVzdDogVHJhbnNsYXRlVGV4dFJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIHE6IG1lc3NhZ2VzLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRvLFxyXG4gICAgICAgICAgICBzb3VyY2U6IGZyb20sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICB1cmw6IHJlYWxVcmwsXHJcbiAgICAgICAgICAgIGJvZHk6IHRyYW5zbGF0ZVJlcXVlc3QsXHJcbiAgICAgICAgICAgIGpzb246IHRydWUsXHJcbi8vICAgICAgICAgICAgcHJveHk6ICdodHRwOi8vMTI3LjAuMC4xOjg4ODgnIFRvIHNldCBhIHByb3h5IHVzZSBlbnYgdmFyIEhUVFBTX1BST1hZXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHJlYWxVcmwsIG9wdGlvbnMpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBib2R5OiBhbnkgPSBkYXRhLmJvZHk7XHJcbiAgICAgICAgICAgIGlmICghYm9keSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyByZXN1bHQgcmVjZWl2ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm9keS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHkuZXJyb3IuY29kZSA9PT0gNDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkuZXJyb3IubWVzc2FnZSA9PT0gJ0ludmFsaWQgVmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ1RyYW5zbGF0aW9uIGZyb20gXCIlc1wiIHRvIFwiJXNcIiBub3Qgc3VwcG9ydGVkJywgZnJvbSwgdG8pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnSW52YWxpZCByZXF1ZXN0OiAlcycsIGJvZHkuZXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdFcnJvciAlczogJXMnLCBib2R5LmVycm9yLmNvZGUsIGJvZHkuZXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGJvZHkuZGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50cmFuc2xhdGlvbnMubWFwKCh0cmFuc2xhdGlvbjogVHJhbnNsYXRpb25zUmVzb3VyY2UpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbi50cmFuc2xhdGVkVGV4dDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gZG8gYSBQT1NUIEhUVFAgcmVxdWVzdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmkgdXJpXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiByZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBwb3N0KHVyaTogc3RyaW5nLCBvcHRpb25zPzogcmVxdWVzdC5Db3JlT3B0aW9ucyk6IE9ic2VydmFibGU8SW50ZXJuYWxSZXF1ZXN0UmVzcG9uc2U+IHtcclxuICAgICAgICByZXR1cm4gPE9ic2VydmFibGU8SW50ZXJuYWxSZXF1ZXN0UmVzcG9uc2U+PiB0aGlzLl9jYWxsLmFwcGx5KHRoaXMsIFtdLmNvbmNhdCgncG9zdCcsIDxzdHJpbmc+IHVyaSxcclxuICAgICAgICAgICAgPHJlcXVlc3QuQ29yZU9wdGlvbnM+IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgfHwge30pKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBkbyBhIEhUVFAgcmVxdWVzdCBmb3IgZ2l2ZW4gbWV0aG9kXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1ldGhvZCBtZXRob2RcclxuICAgICAqIEBwYXJhbSB1cmkgdXJpXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiByZXNwb25zZVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfY2FsbChtZXRob2Q6IHN0cmluZywgdXJpOiBzdHJpbmcsIG9wdGlvbnM/OiByZXF1ZXN0LkNvcmVPcHRpb25zKTogT2JzZXJ2YWJsZTxJbnRlcm5hbFJlcXVlc3RSZXNwb25zZT4ge1xyXG4gICAgICAgIHJldHVybiA8T2JzZXJ2YWJsZTxJbnRlcm5hbFJlcXVlc3RSZXNwb25zZT4+IE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICAvLyBidWlsZCBwYXJhbXMgYXJyYXlcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW10uY29uY2F0KDxzdHJpbmc+IHVyaSwgPHJlcXVlc3QuQ29yZU9wdGlvbnM+IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgfHwge30pLFxyXG4gICAgICAgICAgICAgICAgPFJlcXVlc3RDYWxsYmFjaz4oZXJyb3I6IGFueSwgcmVzcG9uc2U6IHJlcXVlc3QuUmVxdWVzdFJlc3BvbnNlLCBib2R5OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoPEludGVybmFsUmVxdWVzdFJlc3BvbnNlPiBPYmplY3QuYXNzaWduKHt9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiA8cmVxdWVzdC5SZXF1ZXN0UmVzcG9uc2U+IHJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiA8YW55PiBib2R5XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIF9jYWxsIHJlcXVlc3QgbWV0aG9kXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0WzxzdHJpbmc+IG1ldGhvZF0uYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgPHJlcXVlc3QuUmVxdWVzdEFQSTxyZXF1ZXN0LlJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5Db3JlT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LlJlcXVpcmVkVXJpVXJsPj4gdGhpcy5fcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDI5LjA2LjIwMTcuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEF1dG9UcmFuc2xhdGVSZXN1bHQge1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zdWNjZXNzOiBib29sZWFuLCBwcml2YXRlIF9kZXRhaWxzOiBzdHJpbmcpIHtcclxuXHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3VjY2VzcygpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9zdWNjZXNzO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge0F1dG9UcmFuc2xhdGVSZXN1bHR9IGZyb20gJy4vYXV0by10cmFuc2xhdGUtcmVzdWx0JztcclxuaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0lUcmFuc1VuaXR9IGZyb20gJ0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYic7XHJcblxyXG4vKipcclxuICogQSByZXBvcnQgYWJvdXQgYSBydW4gb2YgR29vZ2xlIFRyYW5zbGF0ZSBvdmVyIGFsbCB1bnRyYW5zbGF0ZWQgdW5pdC5cclxuICogKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAyOS4wNi4yMDE3LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydCB7XHJcblxyXG4gIHByaXZhdGUgX2Vycm9yOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfZnJvbTogc3RyaW5nO1xyXG4gIHByaXZhdGUgX3RvOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfdG90YWw6IG51bWJlcjtcclxuICBwcml2YXRlIF9pZ25vcmVkOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBfc3VjY2VzczogbnVtYmVyO1xyXG4gIHByaXZhdGUgX2ZhaWxlZDogbnVtYmVyO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xyXG4gICAgdGhpcy5fdG8gPSB0bztcclxuICAgIHRoaXMuX3RvdGFsID0gMDtcclxuICAgIHRoaXMuX2lnbm9yZWQgPSAwO1xyXG4gICAgdGhpcy5fc3VjY2VzcyA9IDA7XHJcbiAgICB0aGlzLl9mYWlsZWQgPSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGVycm9yIGlmIHRvdGFsIGNhbGwgZmFpbGVkIChlLmcuIFwiaW52YWxpZCBhcGkga2V5XCIgb3IgXCJubyBjb25uZWN0aW9uXCIgLi4uKVxyXG4gICAqIEBwYXJhbSBlcnJvciBlcnJvclxyXG4gICAqIEBwYXJhbSB0b3RhbCB0b3RhbFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRFcnJvcihlcnJvcjogc3RyaW5nLCB0b3RhbDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xyXG4gICAgdGhpcy5fdG90YWwgPSB0b3RhbDtcclxuICAgIHRoaXMuX2ZhaWxlZCA9IHRvdGFsO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGVycm9yKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fZXJyb3I7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0SWdub3JlZChpZ25vcmVkOiBudW1iZXIpIHtcclxuICAgIHRoaXMuX3RvdGFsICs9IGlnbm9yZWQ7XHJcbiAgICB0aGlzLl9pZ25vcmVkID0gaWdub3JlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHNpbmdsZSByZXN1bHQgdG8gdGhlIHN1bW1hcnkuXHJcbiAgICogQHBhcmFtIHR1IHR1XHJcbiAgICogQHBhcmFtIHJlc3VsdCByZXN1bHRcclxuICAgKi9cclxuICBwdWJsaWMgYWRkU2luZ2xlUmVzdWx0KHR1OiBJVHJhbnNVbml0LCByZXN1bHQ6IEF1dG9UcmFuc2xhdGVSZXN1bHQpIHtcclxuICAgIHRoaXMuX3RvdGFsKys7XHJcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MoKSkge1xyXG4gICAgICB0aGlzLl9zdWNjZXNzKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9mYWlsZWQrKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIGFub3RoZXIgc3VtbWFyeSBpbnRvIHRoaXMgb25lLlxyXG4gICAqIEBwYXJhbSBhbm90aGVyU3VtbWFyeSBhbm90aGVyU3VtbWFyeVxyXG4gICAqL1xyXG4gIHB1YmxpYyBtZXJnZShhbm90aGVyU3VtbWFyeTogQXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQpIHtcclxuICAgIGlmICghdGhpcy5fZXJyb3IpIHtcclxuICAgICAgdGhpcy5fZXJyb3IgPSBhbm90aGVyU3VtbWFyeS5fZXJyb3I7XHJcbiAgICB9XHJcbiAgICB0aGlzLl90b3RhbCArPSBhbm90aGVyU3VtbWFyeS50b3RhbCgpO1xyXG4gICAgdGhpcy5faWdub3JlZCArPSBhbm90aGVyU3VtbWFyeS5pZ25vcmVkKCk7XHJcbiAgICB0aGlzLl9zdWNjZXNzICs9IGFub3RoZXJTdW1tYXJ5LnN1Y2Nlc3MoKTtcclxuICAgIHRoaXMuX2ZhaWxlZCArPSBhbm90aGVyU3VtbWFyeS5mYWlsZWQoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyB0b3RhbCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGlnbm9yZWQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl9pZ25vcmVkO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN1Y2Nlc3MoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl9zdWNjZXNzO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGZhaWxlZCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZhaWxlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEh1bWFuIHJlYWRhYmxlIHZlcnNpb24gb2YgcmVwb3J0XHJcbiAgICovXHJcbiAgcHVibGljIGNvbnRlbnQoKTogc3RyaW5nIHtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBpZiAodGhpcy5fZXJyb3IpIHtcclxuICAgICAgcmVzdWx0ID0gZm9ybWF0KCdBdXRvIHRyYW5zbGF0aW9uIGZyb20gXCIlc1wiIHRvIFwiJXNcIiBmYWlsZWQ6IFwiJXNcIiwgZmFpbGVkIHVuaXRzOiAlcycsIHRoaXMuX2Zyb20sIHRoaXMuX3RvLCB0aGlzLl9lcnJvciwgdGhpcy5fZmFpbGVkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdCA9IGZvcm1hdCgnQXV0byB0cmFuc2xhdGlvbiBmcm9tIFwiJXNcIiB0byBcIiVzXCIsIHRvdGFsIGF1dG8gdHJhbnNsYXRlZCB1bml0czogJXMsIGlnbm9yZWQ6ICVzLCBzdWNjZXNmdWw6ICVzLCBmYWlsZWQ6ICVzJyxcclxuICAgICAgICAgIHRoaXMuX2Zyb20sIHRoaXMuX3RvLCB0aGlzLl90b3RhbCwgdGhpcy5faWdub3JlZCwgdGhpcy5fc3VjY2VzcywgdGhpcy5fZmFpbGVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJy4uL2NvbW1vbi91dGlsJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBmb3JrSm9pbiwgb2Z9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge21hcCwgY2F0Y2hFcnJvcn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgKiBhcyBlbnRpdHlEZWNvZGVyTGliIGZyb20gJ2hlJztcclxuaW1wb3J0IHtcclxuICAgIElJQ1VNZXNzYWdlLCBJSUNVTWVzc2FnZVRyYW5zbGF0aW9uLCBJTm9ybWFsaXplZE1lc3NhZ2UsIElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSwgSVRyYW5zVW5pdCxcclxuICAgIFNUQVRFX05FV1xyXG59IGZyb20gJ0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYic7XHJcbmltcG9ydCB7QXV0b1RyYW5zbGF0ZVNlcnZpY2V9IGZyb20gJy4vYXV0by10cmFuc2xhdGUtc2VydmljZSc7XHJcbmltcG9ydCB7QXV0b1RyYW5zbGF0ZVJlc3VsdH0gZnJvbSAnLi9hdXRvLXRyYW5zbGF0ZS1yZXN1bHQnO1xyXG5pbXBvcnQge0F1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0fSBmcm9tICcuL2F1dG8tdHJhbnNsYXRlLXN1bW1hcnktcmVwb3J0JztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDA3LjA3LjIwMTcuXHJcbiAqIFNlcnZpY2UgdG8gYXV0b3RyYW5zbGF0ZSBUcmFuc3VuaXRzIHZpYSBHb29nbGUgVHJhbnNsYXRlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZk1lcmdlQXV0b1RyYW5zbGF0ZVNlcnZpY2Uge1xyXG5cclxuICAgIHByaXZhdGUgYXV0b1RyYW5zbGF0ZVNlcnZpY2U6IEF1dG9UcmFuc2xhdGVTZXJ2aWNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwaWtleTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5hdXRvVHJhbnNsYXRlU2VydmljZSA9IG5ldyBBdXRvVHJhbnNsYXRlU2VydmljZShhcGlrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXV0byB0cmFuc2xhdGUgZmlsZSB2aWEgR29vZ2xlIFRyYW5zbGF0ZS5cclxuICAgICAqIFdpbGwgdHJhbnNsYXRlIGFsbCBuZXcgdW5pdHMgaW4gZmlsZS5cclxuICAgICAqIEBwYXJhbSBmcm9tIGZyb21cclxuICAgICAqIEBwYXJhbSB0byB0b1xyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZVxyXG4gICAgICogQHJldHVybiBhIHByb21pc2Ugd2l0aCB0aGUgZXhlY3V0aW9uIHJlc3VsdCBhcyBhIHN1bW1hcnkgcmVwb3J0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXV0b1RyYW5zbGF0ZShmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSlcclxuICAgICAgICA6IE9ic2VydmFibGU8QXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQ+IHtcclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oW1xyXG4gICAgICAgICAgICB0aGlzLmRvQXV0b1RyYW5zbGF0ZU5vbklDVU1lc3NhZ2VzKGZyb20sIHRvLCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlKSxcclxuICAgICAgICAgICAgLi4udGhpcy5kb0F1dG9UcmFuc2xhdGVJQ1VNZXNzYWdlcyhmcm9tLCB0bywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSldKVxyXG4gICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgIG1hcCgoc3VtbWFyaWVzOiBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydFtdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtbWFyeSA9IHN1bW1hcmllc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN1bW1hcmllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5Lm1lcmdlKHN1bW1hcmllc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW1tYXJ5O1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgYWxsIHVuaXRzIHRoYXQgYXJlIHVudHJhbnNsYXRlZC5cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGVcclxuICAgICAqIEByZXR1cm4gYWxsIHVudHJhbnNsYXRlZCB1bml0c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFsbFVudHJhbnNsYXRlZFRVcyhsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpOiBJVHJhbnNVbml0W10ge1xyXG4gICAgICAgIC8vIGNvbGxlY3QgYWxsIHVuaXRzLCB0aGF0IHNob3VsZCBiZSBhdXRvIHRyYW5zbGF0ZWRcclxuICAgICAgICBjb25zdCBhbGxVbnRyYW5zbGF0ZWQ6IElUcmFuc1VuaXRbXSA9IFtdO1xyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUuZm9yRWFjaFRyYW5zVW5pdCgodHUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHR1LnRhcmdldFN0YXRlKCkgPT09IFNUQVRFX05FVykge1xyXG4gICAgICAgICAgICAgICAgYWxsVW50cmFuc2xhdGVkLnB1c2godHUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFsbFVudHJhbnNsYXRlZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGRvQXV0b1RyYW5zbGF0ZU5vbklDVU1lc3NhZ2VzKGZyb206IHN0cmluZywgdG86IHN0cmluZywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKVxyXG4gICAgICAgIDogT2JzZXJ2YWJsZTxBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydD4ge1xyXG4gICAgICAgIGNvbnN0IGFsbFVudHJhbnNsYXRlZDogSVRyYW5zVW5pdFtdID0gdGhpcy5hbGxVbnRyYW5zbGF0ZWRUVXMobGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSk7XHJcbiAgICAgICAgY29uc3QgYWxsVHJhbnNsYXRhYmxlID0gYWxsVW50cmFuc2xhdGVkLmZpbHRlcigodHUpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHR1LnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkuZ2V0SUNVTWVzc2FnZSgpKSk7XHJcbiAgICAgICAgY29uc3QgYWxsTWVzc2FnZXM6IHN0cmluZ1tdID0gYWxsVHJhbnNsYXRhYmxlLm1hcCgodHUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHR1LnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkuYXNEaXNwbGF5U3RyaW5nKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b1RyYW5zbGF0ZVNlcnZpY2UudHJhbnNsYXRlTXVsdGlwbGVTdHJpbmdzKGFsbE1lc3NhZ2VzLCBmcm9tLCB0bylcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAvLyAjOTQgZ29vZ2xlIHRyYW5zbGF0ZSBtaWdodCByZXR1cm4gJiMuLiBlbnRpdHkgcmVmcywgdGhhdCBtdXN0IGJlIGRlY29kZWRcclxuICAgICAgICAgICAgICAgIG1hcCgodHJhbnNsYXRpb25zOiBzdHJpbmdbXSkgPT4gdHJhbnNsYXRpb25zLm1hcChlbmNvZGVkVHJhbnNsYXRpb24gPT4gZW50aXR5RGVjb2RlckxpYi5kZWNvZGUoZW5jb2RlZFRyYW5zbGF0aW9uKSkpLFxyXG4gICAgICAgICAgICAgICAgbWFwKCh0cmFuc2xhdGlvbnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gbmV3IEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0KGZyb20sIHRvKTtcclxuICAgICAgICAgICAgICAgIHN1bW1hcnkuc2V0SWdub3JlZChhbGxVbnRyYW5zbGF0ZWQubGVuZ3RoIC0gYWxsVHJhbnNsYXRhYmxlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zbGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR1ID0gYWxsVHJhbnNsYXRhYmxlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uVGV4dCA9IHRyYW5zbGF0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmF1dG9UcmFuc2xhdGVOb25JQ1VVbml0KHR1LCB0cmFuc2xhdGlvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnkuYWRkU2luZ2xlUmVzdWx0KHR1LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bW1hcnk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhaWxTdW1tYXJ5ID0gbmV3IEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0KGZyb20sIHRvKTtcclxuICAgICAgICAgICAgICAgICAgICBmYWlsU3VtbWFyeS5zZXRFcnJvcihlcnIubWVzc2FnZSwgYWxsTWVzc2FnZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YoZmFpbFN1bW1hcnkpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkb0F1dG9UcmFuc2xhdGVJQ1VNZXNzYWdlcyhmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSlcclxuICAgICAgICA6IE9ic2VydmFibGU8QXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQ+W10ge1xyXG4gICAgICAgIGNvbnN0IGFsbFVudHJhbnNsYXRlZDogSVRyYW5zVW5pdFtdID0gdGhpcy5hbGxVbnRyYW5zbGF0ZWRUVXMobGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSk7XHJcbiAgICAgICAgY29uc3QgYWxsVHJhbnNsYXRhYmxlSUNVID0gYWxsVW50cmFuc2xhdGVkLmZpbHRlcigodHUpID0+ICFpc051bGxPclVuZGVmaW5lZCh0dS5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLmdldElDVU1lc3NhZ2UoKSkpO1xyXG4gICAgICAgIHJldHVybiBhbGxUcmFuc2xhdGFibGVJQ1UubWFwKCh0dSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F1dG9UcmFuc2xhdGVJQ1VNZXNzYWdlKGZyb20sIHRvLCB0dSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGUgc2luZ2xlIElDVSBNZXNzYWdlcy5cclxuICAgICAqIEBwYXJhbSBmcm9tIGZyb21cclxuICAgICAqIEBwYXJhbSB0byB0b1xyXG4gICAgICogQHBhcmFtIHR1IHRyYW5zdW5pdCB0byB0cmFuc2xhdGUgKG11c3QgY29udGFpbiBJQ1UgTWVzc2FnZSlcclxuICAgICAqIEByZXR1cm4gc3VtbWFyeSByZXBvcnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkb0F1dG9UcmFuc2xhdGVJQ1VNZXNzYWdlKGZyb206IHN0cmluZywgdG86IHN0cmluZywgdHU6IElUcmFuc1VuaXQpOiBPYnNlcnZhYmxlPEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0PiB7XHJcbiAgICAgICAgY29uc3QgaWN1TWVzc2FnZTogSUlDVU1lc3NhZ2UgPSB0dS5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLmdldElDVU1lc3NhZ2UoKTtcclxuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gaWN1TWVzc2FnZS5nZXRDYXRlZ29yaWVzKCk7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIG5lc3RlZCBJQ1VzLCB3ZSBkbyBub3Qgc3VwcG9ydCB0aGF0XHJcbiAgICAgICAgaWYgKGNhdGVnb3JpZXMuZmluZCgoY2F0ZWdvcnkpID0+ICFpc051bGxPclVuZGVmaW5lZChjYXRlZ29yeS5nZXRNZXNzYWdlTm9ybWFsaXplZCgpLmdldElDVU1lc3NhZ2UoKSkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSBuZXcgQXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQoZnJvbSwgdG8pO1xyXG4gICAgICAgICAgICBzdW1tYXJ5LnNldElnbm9yZWQoMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvZihzdW1tYXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWxsTWVzc2FnZXM6IHN0cmluZ1tdID0gY2F0ZWdvcmllcy5tYXAoKGNhdGVnb3J5KSA9PiBjYXRlZ29yeS5nZXRNZXNzYWdlTm9ybWFsaXplZCgpLmFzRGlzcGxheVN0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRvVHJhbnNsYXRlU2VydmljZS50cmFuc2xhdGVNdWx0aXBsZVN0cmluZ3MoYWxsTWVzc2FnZXMsIGZyb20sIHRvKVxyXG4gICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgIC8vICM5NCBnb29nbGUgdHJhbnNsYXRlIG1pZ2h0IHJldHVybiAmIy4uIGVudGl0eSByZWZzLCB0aGF0IG11c3QgYmUgZGVjb2RlZFxyXG4gICAgICAgICAgICAgICAgbWFwKCh0cmFuc2xhdGlvbnM6IHN0cmluZ1tdKSA9PiB0cmFuc2xhdGlvbnMubWFwKGVuY29kZWRUcmFuc2xhdGlvbiA9PiBlbnRpdHlEZWNvZGVyTGliLmRlY29kZShlbmNvZGVkVHJhbnNsYXRpb24pKSksXHJcbiAgICAgICAgICAgICAgICBtYXAoKHRyYW5zbGF0aW9uczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gbmV3IEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0KGZyb20sIHRvKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY3VUcmFuc2xhdGlvbjogSUlDVU1lc3NhZ2VUcmFuc2xhdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNsYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljdVRyYW5zbGF0aW9uW2NhdGVnb3JpZXNbaV0uZ2V0Q2F0ZWdvcnkoKV0gPSB0cmFuc2xhdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXV0b1RyYW5zbGF0ZUlDVVVuaXQodHUsIGljdVRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5LmFkZFNpbmdsZVJlc3VsdCh0dSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtbWFyeTtcclxuICAgICAgICAgICAgICAgIH0pLCBjYXRjaEVycm9yKChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWlsU3VtbWFyeSA9IG5ldyBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydChmcm9tLCB0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbFN1bW1hcnkuc2V0RXJyb3IoZXJyLm1lc3NhZ2UsIGFsbE1lc3NhZ2VzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKGZhaWxTdW1tYXJ5KTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXV0b1RyYW5zbGF0ZU5vbklDVVVuaXQodHU6IElUcmFuc1VuaXQsIHRyYW5zbGF0ZWRNZXNzYWdlOiBzdHJpbmcpOiBBdXRvVHJhbnNsYXRlUmVzdWx0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRvVHJhbnNsYXRlVW5pdCh0dSwgdHUuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKS50cmFuc2xhdGUodHJhbnNsYXRlZE1lc3NhZ2UpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGF1dG9UcmFuc2xhdGVJQ1VVbml0KHR1OiBJVHJhbnNVbml0LCB0cmFuc2xhdGlvbjogSUlDVU1lc3NhZ2VUcmFuc2xhdGlvbik6IEF1dG9UcmFuc2xhdGVSZXN1bHQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9UcmFuc2xhdGVVbml0KHR1LCB0dS5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLnRyYW5zbGF0ZUlDVU1lc3NhZ2UodHJhbnNsYXRpb24pKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGF1dG9UcmFuc2xhdGVVbml0KHR1OiBJVHJhbnNVbml0LCB0cmFuc2xhdGVkTWVzc2FnZTogSU5vcm1hbGl6ZWRNZXNzYWdlKTogQXV0b1RyYW5zbGF0ZVJlc3VsdCB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JzID0gdHJhbnNsYXRlZE1lc3NhZ2UudmFsaWRhdGUoKTtcclxuICAgICAgICBjb25zdCB3YXJuaW5ncyA9IHRyYW5zbGF0ZWRNZXNzYWdlLnZhbGlkYXRlV2FybmluZ3MoKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGVycm9ycykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdXRvVHJhbnNsYXRlUmVzdWx0KGZhbHNlLCAnZXJyb3JzIGRldGVjdGVkLCBub3QgdHJhbnNsYXRlZCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHdhcm5pbmdzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1dG9UcmFuc2xhdGVSZXN1bHQoZmFsc2UsICd3YXJuaW5ncyBkZXRlY3RlZCwgbm90IHRyYW5zbGF0ZWQnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0dS50cmFuc2xhdGUodHJhbnNsYXRlZE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1dG9UcmFuc2xhdGVSZXN1bHQodHJ1ZSwgbnVsbCk7IC8vIHN1Y2Nlc3NcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtDb21tYW5kT3V0cHV0fSBmcm9tICcuLi9jb21tb24vY29tbWFuZC1vdXRwdXQnO1xyXG5pbXBvcnQge1hsaWZmTWVyZ2VQYXJhbWV0ZXJzfSBmcm9tICcuL3hsaWZmLW1lcmdlLXBhcmFtZXRlcnMnO1xyXG5pbXBvcnQge1hsaWZmTWVyZ2VFcnJvcn0gZnJvbSAnLi94bGlmZi1tZXJnZS1lcnJvcic7XHJcbmltcG9ydCB7RmlsZVV0aWx9IGZyb20gJy4uL2NvbW1vbi9maWxlLXV0aWwnO1xyXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4vdmVyc2lvbic7XHJcbmltcG9ydCB7Zm9ybWF0fSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZH0gZnJvbSAnLi4vY29tbW9uL3V0aWwnO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSwgSVRyYW5zVW5pdCxcclxuICAgIEZPUk1BVF9YTUIsIEZPUk1BVF9YVEIsXHJcbiAgICBOT1JNQUxJWkFUSU9OX0ZPUk1BVF9ERUZBVUxULCBTVEFURV9GSU5BTCwgU1RBVEVfVFJBTlNMQVRFRH0gZnJvbSAnQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliJztcclxuaW1wb3J0IHtQcm9ncmFtT3B0aW9ucywgSUNvbmZpZ0ZpbGV9IGZyb20gJy4vaS14bGlmZi1tZXJnZS1vcHRpb25zJztcclxuaW1wb3J0IHtOZ3hUcmFuc2xhdGVFeHRyYWN0b3J9IGZyb20gJy4vbmd4LXRyYW5zbGF0ZS1leHRyYWN0b3InO1xyXG5pbXBvcnQge1RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyfSBmcm9tICcuL3RyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUtcmVhZGVyJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBvZiwgZm9ya0pvaW59IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge21hcCwgY2F0Y2hFcnJvcn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQge1hsaWZmTWVyZ2VBdXRvVHJhbnNsYXRlU2VydmljZX0gZnJvbSAnLi4vYXV0b3RyYW5zbGF0ZS94bGlmZi1tZXJnZS1hdXRvLXRyYW5zbGF0ZS1zZXJ2aWNlJztcclxuaW1wb3J0IHtBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydH0gZnJvbSAnLi4vYXV0b3RyYW5zbGF0ZS9hdXRvLXRyYW5zbGF0ZS1zdW1tYXJ5LXJlcG9ydCc7XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTcuMDIuMjAxNy5cclxuICogWGxpZmZNZXJnZSAtIHJlYWQgeGxpZmYgb3IgeG1iIGZpbGUgYW5kIHB1dCB1bnRyYW5zbGF0ZWQgcGFydHMgaW4gbGFuZ3VhZ2Ugc3BlY2lmaWMgeGxpZmYgb3IgeG1iIGZpbGVzLlxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZk1lcmdlIHtcclxuXHJcbiAgICBwcml2YXRlIGNvbW1hbmRPdXRwdXQ6IENvbW1hbmRPdXRwdXQ7XHJcblxyXG4gICAgcHJpdmF0ZSBvcHRpb25zOiBQcm9ncmFtT3B0aW9ucztcclxuXHJcbiAgICBwcml2YXRlIHBhcmFtZXRlcnM6IFhsaWZmTWVyZ2VQYXJhbWV0ZXJzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlYWQgbWFzdGVyIHhsZiBmaWxlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG1hc3RlcjogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlOyAvLyBYbGlmZkZpbGUgb3IgWGxpZmYyRmlsZSBvciBYbWJGaWxlXHJcblxyXG4gICAgcHJpdmF0ZSBhdXRvVHJhbnNsYXRlU2VydmljZTogWGxpZmZNZXJnZUF1dG9UcmFuc2xhdGVTZXJ2aWNlO1xyXG5cclxuICAgIHN0YXRpYyBtYWluKGFyZ3Y6IHN0cmluZ1tdKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IFhsaWZmTWVyZ2UucGFyc2VBcmdzKGFyZ3YpO1xyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG5ldyBYbGlmZk1lcmdlKG5ldyBDb21tYW5kT3V0cHV0KHByb2Nlc3Muc3Rkb3V0KSwgb3B0aW9ucykucnVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZXhpdChyZXN1bHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHBhcnNlQXJncyhhcmd2OiBzdHJpbmdbXSk6IFByb2dyYW1PcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBQcm9ncmFtT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbGFuZ3VhZ2VzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3ZbaV07XHJcbiAgICAgICAgICAgIGlmIChhcmcgPT09ICctLXZlcnNpb24nIHx8IGFyZyA9PT0gJy12ZXJzaW9uJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3hsaWZmbWVyZ2UgJyArIFZFUlNJT04pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyA9PT0gJy0tdmVyYm9zZScgfHwgYXJnID09PSAnLXYnKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZlcmJvc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyA9PT0gJy0tcHJvZmlsZScgfHwgYXJnID09PSAnLXAnKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcmd2Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtaXNzaW5nIGNvbmZpZyBmaWxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgWGxpZmZNZXJnZS5zaG93VXNhZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9maWxlUGF0aCA9IGFyZ3ZbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnID09PSAnLS1xdWlldCcgfHwgYXJnID09PSAnLXEnKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnF1aWV0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09ICctLWhlbHAnIHx8IGFyZyA9PT0gJy1oZWxwJyB8fCBhcmcgPT09ICctaCcpIHtcclxuICAgICAgICAgICAgICAgIFhsaWZmTWVyZ2Uuc2hvd1VzYWdlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmxlbmd0aCA+IDAgJiYgYXJnLmNoYXJBdCgwKSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndW5rbm93biBvcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZXMucHVzaChhcmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBzaG93VXNhZ2UoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3VzYWdlOiB4bGlmZm1lcmdlIDxvcHRpb24+KiA8bGFuZ3VhZ2U+KicpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdPcHRpb25zJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdC1wfC0tcHJvZmlsZSBhIGpzb24gY29uZmlndXJhdGlvbiBmaWxlIGNvbnRhaW5pbmcgYWxsIHJlbGV2YW50IHBhcmFtZXRlcnMuJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdFxcdGZvciBkZXRhaWxzIHBsZWFzZSBjb25zdWx0IHRoZSBob21lIHBhZ2UgaHR0cHM6Ly9naXRodWIuY29tL21hcnRpbnJvb2Ivbmd4LWkxOG5zdXBwb3J0Jyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdC12fC0tdmVyYm9zZSBzaG93IHNvbWUgb3V0cHV0IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMnKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnXFx0LXF8LS1xdWlldCBvbmx5IHNob3cgZXJyb3JzLCBub3RoaW5nIGVsc2UnKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnXFx0LXZlcnNpb258LS12ZXJzaW9uIHNob3cgdmVyc2lvbiBzdHJpbmcnKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdDxsYW5ndWFnZT4gaGFzIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2Ugc2hvcnQgc3RyaW5nLCBlLGcuIFwiZW5cIiwgXCJkZVwiLCBcImRlLWNoXCInKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBUZXN0cywgY3JlYXRlIGluc3RhbmNlIHdpdGggZ2l2ZW4gcHJvZmlsZVxyXG4gICAgICogQHBhcmFtIGNvbW1hbmRPdXRwdXQgY29tbWFuZE91dHB1dFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHByb2ZpbGVDb250ZW50IHByb2ZpbGVDb250ZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRnJvbU9wdGlvbnMoY29tbWFuZE91dHB1dDogQ29tbWFuZE91dHB1dCwgb3B0aW9uczogUHJvZ3JhbU9wdGlvbnMsIHByb2ZpbGVDb250ZW50PzogSUNvbmZpZ0ZpbGUpIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBYbGlmZk1lcmdlKGNvbW1hbmRPdXRwdXQsIG9wdGlvbnMpO1xyXG4gICAgICAgIGluc3RhbmNlLnBhcmFtZXRlcnMgPSBYbGlmZk1lcmdlUGFyYW1ldGVycy5jcmVhdGVGcm9tT3B0aW9ucyhvcHRpb25zLCBwcm9maWxlQ29udGVudCk7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRPdXRwdXQ6IENvbW1hbmRPdXRwdXQsIG9wdGlvbnM6IFByb2dyYW1PcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0ID0gY29tbWFuZE91dHB1dDtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW4gdGhlIGNvbW1hbmQuXHJcbiAgICAgKiBUaGlzIHJ1bnMgYXN5bmMuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tGdW5jdGlvbiB3aGVuIGNvbW1hbmQgaXMgZXhlY3V0ZWQsIGNhbGxlZCB3aXRoIHRoZSByZXR1cm4gY29kZSAoMCBmb3Igb2spLCBpZiBnaXZlbi5cclxuICAgICAqIEBwYXJhbSBlcnJvckZ1bmN0aW9uIGNhbGxiYWNrRnVuY3Rpb24gZm9yIGVycm9yIGhhbmRsaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBydW4oY2FsbGJhY2tGdW5jdGlvbj86ICgocmV0Y29kZTogbnVtYmVyKSA9PiBhbnkpLCBlcnJvckZ1bmN0aW9uPzogKChlcnJvcjogYW55KSA9PiBhbnkpKSB7XHJcbiAgICAgICAgdGhpcy5ydW5Bc3luYygpXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJldGNvZGU6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChjYWxsYmFja0Z1bmN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrRnVuY3Rpb24ocmV0Y29kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChlcnJvckZ1bmN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRnVuY3Rpb24oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGUgbWVyZ2UtUHJvY2Vzcy5cclxuICAgICAqIEByZXR1cm4gQXN5bmMgb3BlcmF0aW9uLCBvbiBjb21wbGV0aW9uIHJldHVybnMgcmV0Y29kZSAwPW9rLCBvdGhlciA9IGVycm9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcnVuQXN5bmMoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5xdWlldCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuc2V0UXVpZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMudmVyYm9zZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuc2V0VmVyYm9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMucGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBYbGlmZk1lcmdlUGFyYW1ldGVycy5jcmVhdGVGcm9tT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuaW5mbygneGxpZmZtZXJnZSB2ZXJzaW9uICVzJywgVkVSU0lPTik7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy52ZXJib3NlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnNob3dBbGxQYXJhbWV0ZXJzKHRoaXMuY29tbWFuZE91dHB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuZXJyb3JzRm91bmQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVyciBvZiB0aGlzLnBhcmFtZXRlcnMuZXJyb3JzRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5lcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9mKC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy53YXJuaW5nc0ZvdW5kLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB3YXJuIG9mIHRoaXMucGFyYW1ldGVycy53YXJuaW5nc0ZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2Fybih3YXJuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlYWRNYXN0ZXIoKTtcclxuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmF1dG90cmFuc2xhdGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9UcmFuc2xhdGVTZXJ2aWNlID0gbmV3IFhsaWZmTWVyZ2VBdXRvVHJhbnNsYXRlU2VydmljZSh0aGlzLnBhcmFtZXRlcnMuYXBpa2V5KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleGVjdXRpb25Gb3JBbGxMYW5ndWFnZXM6IE9ic2VydmFibGU8bnVtYmVyPltdID0gW107XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmxhbmd1YWdlcygpLmZvckVhY2goKGxhbmc6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBleGVjdXRpb25Gb3JBbGxMYW5ndWFnZXMucHVzaCh0aGlzLnByb2Nlc3NMYW5ndWFnZShsYW5nKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luKGV4ZWN1dGlvbkZvckFsbExhbmd1YWdlcykucGlwZShcclxuICAgICAgICAgICAgbWFwKChyZXRjb2RlczogbnVtYmVyW10pID0+IHRoaXMudG90YWxSZXRjb2RlKHJldGNvZGVzKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZSBhbiBhcnJheSBvZiByZXRjb2RlcyBmb3IgdGhlIGRpZmZlcmVudCBsYW5ndWFnZXMsIHJldHVybiB0aGUgdG90YWwgcmV0Y29kZS5cclxuICAgICAqIElmIGFsbCBhcmUgMCwgaXQgaXMgMCwgb3RoZXJ3aXNlIHRoZSBmaXJzdCBub24gemVyby5cclxuICAgICAqIEBwYXJhbSByZXRjb2RlcyByZXRjb2Rlc1xyXG4gICAgICogQHJldHVybiBudW1iZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0b3RhbFJldGNvZGUocmV0Y29kZXM6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldGNvZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXRjb2Rlc1tpXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldGNvZGVzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgZmlsZSBmb3IgZ2l2ZW4gbGFuZy5cclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlXHJcbiAgICAgKiBAcmV0dXJuIG5hbWUgb2YgZ2VuZXJhdGVkIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdlbmVyYXRlZEkxOG5GaWxlKGxhbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVycy5nZW5lcmF0ZWRJMThuRmlsZShsYW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIG5neC10cmFuc2xhdGlvbiBmaWxlIGZvciBnaXZlbiBsYW5nLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2VcclxuICAgICAqIEByZXR1cm4gbmFtZSBvZiB0cmFuc2xhdGUgZmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVkTmd4VHJhbnNsYXRlRmlsZShsYW5nOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnMuZ2VuZXJhdGVkTmd4VHJhbnNsYXRlRmlsZShsYW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdhcm5pbmdzIGZvdW5kIGR1cmluZyB0aGUgcnVuLlxyXG4gICAgICogQHJldHVybiB3YXJuaW5nc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd2FybmluZ3MoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnMud2FybmluZ3NGb3VuZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlYWRNYXN0ZXIoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5tYXN0ZXIgPSBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5mcm9tRmlsZShcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5pMThuRm9ybWF0KCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaTE4bkZpbGUoKSxcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5lbmNvZGluZygpKTtcclxuICAgICAgICAgICAgdGhpcy5tYXN0ZXIud2FybmluZ3MoKS5mb3JFYWNoKCh3YXJuaW5nOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKHdhcm5pbmcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLm1hc3Rlci5udW1iZXJPZlRyYW5zVW5pdHMoKTtcclxuICAgICAgICAgICAgY29uc3QgbWlzc2luZ0lkQ291bnQgPSB0aGlzLm1hc3Rlci5udW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5pbmZvKCdtYXN0ZXIgY29udGFpbnMgJXMgdHJhbnMtdW5pdHMnLCBjb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChtaXNzaW5nSWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdtYXN0ZXIgY29udGFpbnMgJXMgdHJhbnMtdW5pdHMsIGJ1dCB0aGVyZSBhcmUgJXMgd2l0aG91dCBpZCcsIGNvdW50LCBtaXNzaW5nSWRDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc291cmNlTGFuZzogc3RyaW5nID0gdGhpcy5tYXN0ZXIuc291cmNlTGFuZ3VhZ2UoKTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUxhbmcgJiYgc291cmNlTGFuZyAhPT0gdGhpcy5wYXJhbWV0ZXJzLmRlZmF1bHRMYW5ndWFnZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybihcclxuICAgICAgICAgICAgICAgICAgICAnbWFzdGVyIHNheXMgdG8gaGF2ZSBzb3VyY2UtbGFuZ3VhZ2U9XCIlc1wiLCBzaG91bGQgYmUgXCIlc1wiICh5b3VyIGRlZmF1bHRMYW5ndWFnZSknLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUxhbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFzdGVyLnNldFNvdXJjZUxhbmd1YWdlKHRoaXMucGFyYW1ldGVycy5kZWZhdWx0TGFuZ3VhZ2UoKSk7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5zYXZlKHRoaXMubWFzdGVyLCB0aGlzLnBhcmFtZXRlcnMuYmVhdXRpZnlPdXRwdXQoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybignY2hhbmdlZCBtYXN0ZXIgc291cmNlLWxhbmd1YWdlPVwiJXNcIiB0byBcIiVzXCInLCBzb3VyY2VMYW5nLCB0aGlzLnBhcmFtZXRlcnMuZGVmYXVsdExhbmd1YWdlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBYbGlmZk1lcmdlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5lcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YoLTEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdW5oYW5kbGVkXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmlsZW5hbWUgPSB0aGlzLnBhcmFtZXRlcnMuaTE4bkZpbGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lU3RyaW5nID0gKGN1cnJlbnRGaWxlbmFtZSkgPyBmb3JtYXQoJ2ZpbGUgXCIlc1wiLCAnLCBjdXJyZW50RmlsZW5hbWUpIDogJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuZXJyb3IoZmlsZW5hbWVTdHJpbmcgKyAnb29wcyAnICsgZXJyKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgdGhlIGdpdmVuIGxhbmd1YWdlLlxyXG4gICAgICogQXN5bmMgb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2VcclxuICAgICAqIEByZXR1cm4gb24gY29tcGxldGlvbiAwIGZvciBvaywgb3RoZXIgZm9yIGVycm9yXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcHJvY2Vzc0xhbmd1YWdlKGxhbmc6IHN0cmluZyk6IE9ic2VydmFibGU8bnVtYmVyPiB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmRlYnVnKCdwcm9jZXNzaW5nIGxhbmd1YWdlICVzJywgbGFuZyk7XHJcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VYbGlmZkZpbGUgPSB0aGlzLnBhcmFtZXRlcnMuZ2VuZXJhdGVkSTE4bkZpbGUobGFuZyk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZpbGVuYW1lID0gbGFuZ3VhZ2VYbGlmZkZpbGU7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogT2JzZXJ2YWJsZTx2b2lkPjtcclxuICAgICAgICBpZiAoIUZpbGVVdGlsLmV4aXN0cyhsYW5ndWFnZVhsaWZmRmlsZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jcmVhdGVVbnRyYW5zbGF0ZWRYbGlmZihsYW5nLCBsYW5ndWFnZVhsaWZmRmlsZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tZXJnZU1hc3RlclRvKGxhbmcsIGxhbmd1YWdlWGxpZmZGaWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgICAgICAucGlwZShtYXAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5zdXBwb3J0Tmd4VHJhbnNsYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5mcm9tRmlsZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25Gb3JtYXQodGhpcy5wYXJhbWV0ZXJzLmkxOG5Gb3JtYXQoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVhsaWZmRmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5lbmNvZGluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXIuZmlsZW5hbWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgTmd4VHJhbnNsYXRlRXh0cmFjdG9yLmV4dHJhY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZ2VuZXJhdGVkTmd4VHJhbnNsYXRlRmlsZShsYW5nKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSksIGNhdGNoRXJyb3IoKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFhsaWZmTWVyZ2VFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5lcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKC0xKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5oYW5kbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWVTdHJpbmcgPSAoY3VycmVudEZpbGVuYW1lKSA/IGZvcm1hdCgnZmlsZSBcIiVzXCIsICcsIGN1cnJlbnRGaWxlbmFtZSkgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuZXJyb3IoZmlsZW5hbWVTdHJpbmcgKyAnb29wcyAnICsgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNyZWF0ZSBhIG5ldyBmaWxlIGZvciB0aGUgbGFuZ3VhZ2UsIHdoaWNoIGNvbnRhaW5zIG5vIHRyYW5zbGF0aW9ucywgYnV0IGFsbCBrZXlzLlxyXG4gICAgICogaW4gcHJpbmNpcGxlLCB0aGlzIGlzIGp1c3QgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgd2l0aCB0YXJnZXQtbGFuZ3VhZ2Ugc2V0LlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2VcclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZVhsaWZmRmlsZVBhdGggbmFtZSBvZiBmaWxlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlVW50cmFuc2xhdGVkWGxpZmYobGFuZzogc3RyaW5nLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGg6IHN0cmluZyk6IE9ic2VydmFibGU8dm9pZD4ge1xyXG4gICAgICAgIC8vIGNvcHkgbWFzdGVyIC4uLlxyXG4gICAgICAgIC8vIGFuZCBzZXQgdGFyZ2V0LWxhbmd1YWdlXHJcbiAgICAgICAgLy8gYW5kIGNvcHkgc291cmNlIHRvIHRhcmdldCBpZiBuZWNlc3NhcnlcclxuICAgICAgICBjb25zdCBpc0RlZmF1bHRMYW5nOiBib29sZWFuID0gKGxhbmcgPT09IHRoaXMucGFyYW1ldGVycy5kZWZhdWx0TGFuZ3VhZ2UoKSk7XHJcbiAgICAgICAgdGhpcy5tYXN0ZXIuc2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCh0aGlzLnBhcmFtZXRlcnMudGFyZ2V0UHJhZWZpeCgpKTtcclxuICAgICAgICB0aGlzLm1hc3Rlci5zZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgodGhpcy5wYXJhbWV0ZXJzLnRhcmdldFN1ZmZpeCgpKTtcclxuICAgICAgICBjb25zdCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUgPVxyXG4gICAgICAgICAgICB0aGlzLm1hc3Rlci5jcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nKGxhbmcsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCwgaXNEZWZhdWx0TGFuZywgdGhpcy5wYXJhbWV0ZXJzLnVzZVNvdXJjZUFzVGFyZ2V0KCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9UcmFuc2xhdGUodGhpcy5tYXN0ZXIuc291cmNlTGFuZ3VhZ2UoKSwgbGFuZywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSkucGlwZShcclxuICAgICAgICAgICAgbWFwKChzdW1tYXJ5KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHdyaXRlIGl0IHRvIGZpbGVcclxuICAgICAgICAgICAgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIuc2F2ZShsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLCB0aGlzLnBhcmFtZXRlcnMuYmVhdXRpZnlPdXRwdXQoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5pbmZvKCdjcmVhdGVkIG5ldyBmaWxlIFwiJXNcIiBmb3IgdGFyZ2V0LWxhbmd1YWdlPVwiJXNcIicsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCwgbGFuZyk7XHJcbiAgICAgICAgICAgIGlmICghaXNEZWZhdWx0TGFuZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ3BsZWFzZSB0cmFuc2xhdGUgZmlsZSBcIiVzXCIgdG8gdGFyZ2V0LWxhbmd1YWdlPVwiJXNcIicsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCwgbGFuZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIHRoZSBpbnB1dCBmb3JtYXQgdG8gdGhlIGZvcm1hdCBvZiB0aGUgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBOb3JtYWxseSB0aGV5IGFyZSB0aGUgc2FtZSBidXQgZm9yIHhtYiB0aGUgdHJhbnNsYXRpb24gZm9ybWF0IGlzIHh0Yi5cclxuICAgICAqIEBwYXJhbSBpMThuRm9ybWF0IGZvcm1hdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYW5zbGF0aW9uRm9ybWF0KGkxOG5Gb3JtYXQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKGkxOG5Gb3JtYXQgPT09IEZPUk1BVF9YTUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZPUk1BVF9YVEI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGkxOG5Gb3JtYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2UgYWxsXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBsYW5ndWFnZVxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCBmaWxlbmFtZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG1lcmdlTWFzdGVyVG8obGFuZzogc3RyaW5nLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGg6IHN0cmluZyk6IE9ic2VydmFibGU8dm9pZD4ge1xyXG4gICAgICAgIC8vIHJlYWQgbGFuZyBzcGVjaWZpYyBmaWxlXHJcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlID1cclxuICAgICAgICAgICAgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIuZnJvbUZpbGUoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9uRm9ybWF0KHRoaXMucGFyYW1ldGVycy5pMThuRm9ybWF0KCkpLFxyXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmVuY29kaW5nKCkpO1xyXG4gICAgICAgIGNvbnN0IGlzRGVmYXVsdExhbmc6IGJvb2xlYW4gPSAobGFuZyA9PT0gdGhpcy5wYXJhbWV0ZXJzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICBsZXQgbmV3Q291bnQgPSAwO1xyXG4gICAgICAgIGxldCBjb3JyZWN0U291cmNlQ29udGVudENvdW50ID0gMDtcclxuICAgICAgICBsZXQgY29ycmVjdFNvdXJjZVJlZkNvdW50ID0gMDtcclxuICAgICAgICBsZXQgY29ycmVjdERlc2NyaXB0aW9uT3JNZWFuaW5nQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBpZENoYW5nZWRDb3VudCA9IDA7XHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5zZXROZXdUcmFuc1VuaXRUYXJnZXRQcmFlZml4KHRoaXMucGFyYW1ldGVycy50YXJnZXRQcmFlZml4KCkpO1xyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUuc2V0TmV3VHJhbnNVbml0VGFyZ2V0U3VmZml4KHRoaXMucGFyYW1ldGVycy50YXJnZXRTdWZmaXgoKSk7XHJcbiAgICAgICAgbGV0IGxhc3RQcm9jZXNzZWRVbml0OiBJVHJhbnNVbml0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1hc3Rlci5mb3JFYWNoVHJhbnNVbml0KChtYXN0ZXJUcmFuc1VuaXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNVbml0OiBJVHJhbnNVbml0ID0gbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS50cmFuc1VuaXRXaXRoSWQobWFzdGVyVHJhbnNVbml0LmlkKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdHJhbnNVbml0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvb3BzLCBubyB0cmFuc2xhdGlvbiwgbXVzdCBiZSBhIG5ldyBrZXksIHNvIGFkZCBpdFxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld1VuaXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmFsbG93SWRDaGFuZ2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICYmIChuZXdVbml0ID0gdGhpcy5wcm9jZXNzQ2hhbmdlZElkVW5pdChtYXN0ZXJUcmFuc1VuaXQsIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUsIGxhc3RQcm9jZXNzZWRVbml0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvY2Vzc2VkVW5pdCA9IG5ld1VuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRDaGFuZ2VkQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb2Nlc3NlZFVuaXQgPSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLmltcG9ydE5ld1RyYW5zVW5pdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyVHJhbnNVbml0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZmF1bHRMYW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMudXNlU291cmNlQXNUYXJnZXQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMucGFyYW1ldGVycy5wcmVzZXJ2ZU9yZGVyKCkpID8gbGFzdFByb2Nlc3NlZFVuaXQgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgY2hhbmdlZCBzb3VyY2UgY29udGVudCBhbmQgY2hhbmdlIGl0IGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgLy8gKGNhbiBvbmx5IGhhcHBlbiBpZiBJRCBpcyBleHBsaWNpdGVseSBzZXQsIG90aGVyd2lzZSBJRCB3b3VsZCBjaGFuZ2UgaWYgc291cmNlIGNvbnRlbnQgaXMgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc1VuaXQuc3VwcG9ydHNTZXRTb3VyY2VDb250ZW50KCkgJiYgbWFzdGVyVHJhbnNVbml0LnNvdXJjZUNvbnRlbnQoKSAhPT0gdHJhbnNVbml0LnNvdXJjZUNvbnRlbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5zZXRTb3VyY2VDb250ZW50KG1hc3RlclRyYW5zVW5pdC5zb3VyY2VDb250ZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZmF1bHRMYW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICM4MSBjaGFuZ2VkIHNvdXJjZSBtdXN0IGJlIGNvcGllZCB0byB0YXJnZXQgZm9yIGRlZmF1bHQgbGFuZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQudHJhbnNsYXRlKG1hc3RlclRyYW5zVW5pdC5zb3VyY2VDb250ZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfRklOQUwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc1VuaXQudGFyZ2V0U3RhdGUoKSA9PT0gU1RBVEVfRklOQUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvdXJjZSBpcyBjaGFuZ2VkLCBzbyB0cmFuc2xhdGlvbiBoYXMgdG8gYmUgY2hlY2tlZCBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LnNldFRhcmdldFN0YXRlKFNUQVRFX1RSQU5TTEFURUQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RTb3VyY2VDb250ZW50Q291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIG9yIGNoYW5nZWQgc291cmNlIHJlZiBhbmQgYWRkIGl0IGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zVW5pdC5zdXBwb3J0c1NldFNvdXJjZVJlZmVyZW5jZXMoKVxyXG4gICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmFyZVNvdXJjZVJlZmVyZW5jZXNFcXVhbChtYXN0ZXJUcmFuc1VuaXQuc291cmNlUmVmZXJlbmNlcygpLCB0cmFuc1VuaXQuc291cmNlUmVmZXJlbmNlcygpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5zZXRTb3VyY2VSZWZlcmVuY2VzKG1hc3RlclRyYW5zVW5pdC5zb3VyY2VSZWZlcmVuY2VzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RTb3VyY2VSZWZDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGNoYW5nZWQgZGVzY3JpcHRpb24gb3IgbWVhbmluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zVW5pdC5zdXBwb3J0c1NldERlc2NyaXB0aW9uQW5kTWVhbmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNVbml0LmRlc2NyaXB0aW9uKCkgIT09IG1hc3RlclRyYW5zVW5pdC5kZXNjcmlwdGlvbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5zZXREZXNjcmlwdGlvbihtYXN0ZXJUcmFuc1VuaXQuZGVzY3JpcHRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNVbml0Lm1lYW5pbmcoKSAhPT0gbWFzdGVyVHJhbnNVbml0Lm1lYW5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuc2V0TWVhbmluZyhtYXN0ZXJUcmFuc1VuaXQubWVhbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlY3REZXNjcmlwdGlvbk9yTWVhbmluZ0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdFByb2Nlc3NlZFVuaXQgPSB0cmFuc1VuaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobmV3Q291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdtZXJnZWQgJXMgdHJhbnMtdW5pdHMgZnJvbSBtYXN0ZXIgdG8gXCIlc1wiJywgbmV3Q291bnQsIGxhbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29ycmVjdFNvdXJjZUNvbnRlbnRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ3RyYW5zZmVycmVkICVzIGNoYW5nZWQgc291cmNlIGNvbnRlbnQgZnJvbSBtYXN0ZXIgdG8gXCIlc1wiJywgY29ycmVjdFNvdXJjZUNvbnRlbnRDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3JyZWN0U291cmNlUmVmQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCd0cmFuc2ZlcnJlZCAlcyBzb3VyY2UgcmVmZXJlbmNlcyBmcm9tIG1hc3RlciB0byBcIiVzXCInLCBjb3JyZWN0U291cmNlUmVmQ291bnQsIGxhbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaWRDaGFuZ2VkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdmb3VuZCAlcyBjaGFuZ2VkIGlkXFwncyBpbiBcIiVzXCInLCBpZENoYW5nZWRDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3JyZWN0RGVzY3JpcHRpb25Pck1lYW5pbmdDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oXHJcbiAgICAgICAgICAgICAgICAndHJhbnNmZXJyZWQgJXMgY2hhbmdlZCBkZXNjcmlwdGlvbnMvbWVhbmluZ3MgZnJvbSBtYXN0ZXIgdG8gXCIlc1wiJywgY29ycmVjdERlc2NyaXB0aW9uT3JNZWFuaW5nQ291bnQsIGxhbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBubyBsb25nZXIgdXNlZFxyXG4gICAgICAgIGxldCByZW1vdmVDb3VudCA9IDA7XHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5mb3JFYWNoVHJhbnNVbml0KCh0cmFuc1VuaXQ6IElUcmFuc1VuaXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RzSW5NYXN0ZXIgPSAhaXNOdWxsT3JVbmRlZmluZWQodGhpcy5tYXN0ZXIudHJhbnNVbml0V2l0aElkKHRyYW5zVW5pdC5pZCkpO1xyXG4gICAgICAgICAgICBpZiAoIWV4aXN0c0luTWFzdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnJlbW92ZVVudXNlZElkcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5yZW1vdmVUcmFuc1VuaXRXaXRoSWQodHJhbnNVbml0LmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocmVtb3ZlQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMucmVtb3ZlVW51c2VkSWRzKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdyZW1vdmVkICVzIHVudXNlZCB0cmFucy11bml0cyBpbiBcIiVzXCInLCByZW1vdmVDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2Fybigna2VlcGluZyAlcyB1bnVzZWQgdHJhbnMtdW5pdHMgaW4gXCIlc1wiLCBiZWNhdXNlIHJlbW92ZVVudXNlZCBpcyBkaXNhYmxlZCcsIHJlbW92ZUNvdW50LCBsYW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5ld0NvdW50ID09PSAwICYmIHJlbW92ZUNvdW50ID09PSAwICYmIGNvcnJlY3RTb3VyY2VDb250ZW50Q291bnQgPT09IDBcclxuICAgICAgICAgICAgJiYgY29ycmVjdFNvdXJjZVJlZkNvdW50ID09PSAwICYmIGNvcnJlY3REZXNjcmlwdGlvbk9yTWVhbmluZ0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5pbmZvKCdmaWxlIGZvciBcIiVzXCIgd2FzIHVwIHRvIGRhdGUnLCBsYW5nKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9mKG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dG9UcmFuc2xhdGUodGhpcy5tYXN0ZXIuc291cmNlTGFuZ3VhZ2UoKSwgbGFuZywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSlcclxuICAgICAgICAgICAgICAgIC5waXBlKG1hcCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGUgaXQgdG8gZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyLnNhdmUobGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSwgdGhpcy5wYXJhbWV0ZXJzLmJlYXV0aWZ5T3V0cHV0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5pbmZvKCd1cGRhdGVkIGZpbGUgXCIlc1wiIGZvciB0YXJnZXQtbGFuZ3VhZ2U9XCIlc1wiJywgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoLCBsYW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q291bnQgPiAwICYmICFpc0RlZmF1bHRMYW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdwbGVhc2UgdHJhbnNsYXRlIGZpbGUgXCIlc1wiIHRvIHRhcmdldC1sYW5ndWFnZT1cIiVzXCInLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGgsIGxhbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdGhlIGNhc2Ugb2YgY2hhbmdlZCBpZCBkdWUgdG8gc21hbGwgd2hpdGUgc3BhY2UgY2hhbmdlcy5cclxuICAgICAqIEBwYXJhbSBtYXN0ZXJUcmFuc1VuaXQgdW5pdCBpbiBtYXN0ZXIgZmlsZVxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUgdHJhbnNsYXRpb24gZmlsZVxyXG4gICAgICogQHBhcmFtIGxhc3RQcm9jZXNzZWRVbml0IFVuaXQgYmVmb3JlIHRoZSBvbmUgcHJvY2Vzc2VkIGhlcmUuIE5ldyB1bml0IHdpbGwgYmUgaW5zZXJ0ZWQgYWZ0ZXIgdGhpcyBvbmUuXHJcbiAgICAgKiBAcmV0dXJuIHByb2Nlc3NlZCB1bml0LCBpZiBkb25lLCBudWxsIGlmIG5vIGNoYW5nZWQgdW5pdCBmb3VuZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHByb2Nlc3NDaGFuZ2VkSWRVbml0KFxyXG4gICAgICAgIG1hc3RlclRyYW5zVW5pdDogSVRyYW5zVW5pdCxcclxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsXHJcbiAgICAgICAgbGFzdFByb2Nlc3NlZFVuaXQ6IElUcmFuc1VuaXQpOiBJVHJhbnNVbml0IHtcclxuXHJcbiAgICAgICAgY29uc3QgbWFzdGVyU291cmNlU3RyaW5nID0gbWFzdGVyVHJhbnNVbml0LnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkuYXNEaXNwbGF5U3RyaW5nKE5PUk1BTElaQVRJT05fRk9STUFUX0RFRkFVTFQpLnRyaW0oKTtcclxuICAgICAgICBsZXQgY2hhbmdlZFRyYW5zVW5pdDogSVRyYW5zVW5pdCA9IG51bGw7XHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5mb3JFYWNoVHJhbnNVbml0KChsYW5ndWFnZVRyYW5zVW5pdCkgPT4ge1xyXG4gICAgICAgICAgICAgaWYgKGxhbmd1YWdlVHJhbnNVbml0LnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkuYXNEaXNwbGF5U3RyaW5nKE5PUk1BTElaQVRJT05fRk9STUFUX0RFRkFVTFQpLnRyaW0oKSA9PT0gbWFzdGVyU291cmNlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgY2hhbmdlZFRyYW5zVW5pdCA9IGxhbmd1YWdlVHJhbnNVbml0O1xyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghY2hhbmdlZFRyYW5zVW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWVyZ2VkVHJhbnNVbml0ID0gbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5pbXBvcnROZXdUcmFuc1VuaXQoXHJcbiAgICAgICAgICAgIG1hc3RlclRyYW5zVW5pdCxcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICAodGhpcy5wYXJhbWV0ZXJzLnByZXNlcnZlT3JkZXIoKSkgPyBsYXN0UHJvY2Vzc2VkVW5pdCA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlZENvbnRlbnQgPSBjaGFuZ2VkVHJhbnNVbml0LnRhcmdldENvbnRlbnQoKTtcclxuICAgICAgICBpZiAodHJhbnNsYXRlZENvbnRlbnQpIHsgLy8gaXNzdWUgIzY4IHNldCB0cmFuc2xhdGVkIG9ubHksIGlmIGl0IGlzIHJlYWxseSB0cmFuc2xhdGVkXHJcbiAgICAgICAgICAgIG1lcmdlZFRyYW5zVW5pdC50cmFuc2xhdGUodHJhbnNsYXRlZENvbnRlbnQpO1xyXG4gICAgICAgICAgICBtZXJnZWRUcmFuc1VuaXQuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfVFJBTlNMQVRFRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXJnZWRUcmFuc1VuaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhcmVTb3VyY2VSZWZlcmVuY2VzRXF1YWwoXHJcbiAgICAgICAgcmVmMToge3NvdXJjZWZpbGU6IHN0cmluZzsgbGluZW51bWJlcjogbnVtYmVyOyB9W10sXHJcbiAgICAgICAgcmVmMjoge3NvdXJjZWZpbGU6IHN0cmluZzsgbGluZW51bWJlcjogbnVtYmVyOyB9W10pOiBib29sZWFuIHtcclxuXHJcbiAgICAgICAgaWYgKChpc051bGxPclVuZGVmaW5lZChyZWYxKSAmJiAhaXNOdWxsT3JVbmRlZmluZWQocmVmMikpIHx8IChpc051bGxPclVuZGVmaW5lZChyZWYyKSAmJiAhaXNOdWxsT3JVbmRlZmluZWQocmVmMSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHJlZjEpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHJlZjIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBib3QgcmVmcyBhcmUgc2V0IG5vdywgY29udmVydCB0byBzZXQgdG8gY29tcGFyZSB0aGVtXHJcbiAgICAgICAgY29uc3Qgc2V0MTogU2V0PHN0cmluZz4gPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICByZWYxLmZvckVhY2goKHJlZikgPT4ge3NldDEuYWRkKHJlZi5zb3VyY2VmaWxlICsgJzonICsgcmVmLmxpbmVudW1iZXIpOyB9KTtcclxuICAgICAgICBjb25zdCBzZXQyOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gICAgICAgIHJlZjIuZm9yRWFjaCgocmVmKSA9PiB7c2V0Mi5hZGQocmVmLnNvdXJjZWZpbGUgKyAnOicgKyByZWYubGluZW51bWJlcik7IH0pO1xyXG4gICAgICAgIGlmIChzZXQxLnNpemUgIT09IHNldDIuc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgc2V0Mi5mb3JFYWNoKChyZWYpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFzZXQxLmhhcyhyZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXV0byB0cmFuc2xhdGUgZmlsZSB2aWEgR29vZ2xlIFRyYW5zbGF0ZS5cclxuICAgICAqIFdpbGwgdHJhbnNsYXRlIGFsbCBuZXcgdW5pdHMgaW4gZmlsZS5cclxuICAgICAqIEBwYXJhbSBmcm9tIGZyb21cclxuICAgICAqIEBwYXJhbSB0byB0b1xyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZVxyXG4gICAgICogQHJldHVybiBhIHByb21pc2Ugd2l0aCB0aGUgZXhlY3V0aW9uIHJlc3VsdCBhcyBhIHN1bW1hcnkgcmVwb3J0LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGF1dG9UcmFuc2xhdGUoXHJcbiAgICAgICAgZnJvbTogc3RyaW5nLFxyXG4gICAgICAgIHRvOiBzdHJpbmcsXHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTogT2JzZXJ2YWJsZTxBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydD4ge1xyXG5cclxuICAgICAgICBsZXQgc2VydmljZUNhbGw6IE9ic2VydmFibGU8QXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQ+O1xyXG4gICAgICAgIGNvbnN0IGF1dG90cmFuc2xhdGVFbmFibGVkOiBib29sZWFuID0gdGhpcy5wYXJhbWV0ZXJzLmF1dG90cmFuc2xhdGVMYW5ndWFnZSh0byk7XHJcbiAgICAgICAgaWYgKGF1dG90cmFuc2xhdGVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHNlcnZpY2VDYWxsID0gdGhpcy5hdXRvVHJhbnNsYXRlU2VydmljZS5hdXRvVHJhbnNsYXRlKGZyb20sIHRvLCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXJ2aWNlQ2FsbCA9IG9mKG5ldyBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydChmcm9tLCB0bykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VydmljZUNhbGwucGlwZShtYXAoKHN1bW1hcnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGF1dG90cmFuc2xhdGVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VtbWFyeS5lcnJvcigpIHx8IHN1bW1hcnkuZmFpbGVkKCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmVycm9yKHN1bW1hcnkuY29udGVudCgpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oc3VtbWFyeS5jb250ZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdW1tYXJ5O1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbn1cclxuIl0sIm5hbWVzIjpbImZzLmV4aXN0c1N5bmMiLCJmcy5yZWFkRmlsZVN5bmMiLCJmcy53cml0ZUZpbGVTeW5jIiwiZnMub3BlblN5bmMiLCJmcy5yZWFkU3luYyIsImZzLndyaXRlU3luYyIsImZzLmNsb3NlU3luYyIsImZzLnJlYWRkaXJTeW5jIiwiZnMubHN0YXRTeW5jIiwiZnMudW5saW5rU3luYyIsImZzLnJtZGlyU3luYyIsImZzLnN0YXRTeW5jIiwiZnMuYWNjZXNzU3luYyIsImZzLmNvbnN0YW50cyIsInBhdGgucmVzb2x2ZSIsImVudGl0eURlY29kZXJMaWIuZGVjb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFTQSxNQUFhLGdCQUFnQjs7O1lBTjVCLFFBQVEsU0FBQztnQkFDTixPQUFPLEVBQUUsRUFDUjtnQkFDRCxZQUFZLEVBQUUsRUFBRTtnQkFDaEIsT0FBTyxFQUFFLEVBQUU7YUFDZDs7Ozs7Ozs7Ozs7Ozs7O0FDREQsU0FBZ0IsaUJBQWlCLENBQUMsS0FBVTtJQUN4QyxPQUFPLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQztDQUNoRDs7Ozs7O0FBS0QsU0FBZ0IsUUFBUSxDQUFDLEtBQVU7SUFDL0IsT0FBTyxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUM7Q0FDcEM7Ozs7OztBQW1CRCxTQUFnQixPQUFPLENBQUMsS0FBVTtJQUM5QixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDL0I7Ozs7OztBQ3JDRDs7Ozs7O0FBU0EsTUFBYSxjQUFlLFNBQVEsUUFBUTtJQUl4QztRQUNJLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7S0FDMUI7Ozs7Ozs7SUFFTSxNQUFNLENBQUMsS0FBVSxFQUFFLFFBQWdCLEVBQUUsUUFBa0I7O1lBQ3RELFdBQVc7UUFDZixJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNqQixXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQ3ZCO2FBQU0sSUFBSSxLQUFLLFlBQVksTUFBTSxFQUFFO1lBQ2hDLFdBQVcsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDbEM7YUFBTTtZQUNILFdBQVcsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN4RDtRQUNELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksR0FBRyxX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