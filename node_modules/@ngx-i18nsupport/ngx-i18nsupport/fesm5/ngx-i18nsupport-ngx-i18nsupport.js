import { NgModule } from '@angular/core';
import { __extends, __spread, __values } from 'tslib';
import { Writable } from 'stream';
import chalk from 'chalk';
import { format } from 'util';
import { readFileSync, statSync, accessSync, constants, existsSync, writeFileSync, openSync, readSync, writeSync, closeSync, readdirSync, lstatSync, unlinkSync, rmdirSync } from 'fs';
import { NORMALIZATION_FORMAT_NGXTRANSLATE, TranslationMessagesFileFactory, STATE_NEW, FORMAT_XMB, FORMAT_XTB, NORMALIZATION_FORMAT_DEFAULT, STATE_FINAL, STATE_TRANSLATED } from '@ngx-i18nsupport/ngx-i18nsupport-lib';
import { dirname, isAbsolute, join, resolve } from 'path';
import * as request from 'request';
import { Observable, of, forkJoin, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { decode } from 'he';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
// not used, only there to make ng-packagr happy
var XliffmergeModule = /** @class */ (function () {
    function XliffmergeModule() {
    }
    XliffmergeModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    declarations: [],
                    exports: []
                },] }
    ];
    return XliffmergeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Collection of utility functions that are deprecated in nodes util.
 */
/**
 * Replaces node isNullOrUndefined.
 * @param {?} value
 * @return {?}
 */
function isNullOrUndefined(value) {
    return value === undefined || value === null;
}
/**
 * Replaces node isString.
 * @param {?} value
 * @return {?}
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * Replaces node isArray.
 * @param {?} value
 * @return {?}
 */
function isArray(value) {
    return Array.isArray(value);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 20.02.2017.
 * A helper class for testing.
 * Can be used as a WritableStream and writes everything (synchronously) into a string,
 * that can easily be read by the tests.
 */
var  /**
 * Created by martin on 20.02.2017.
 * A helper class for testing.
 * Can be used as a WritableStream and writes everything (synchronously) into a string,
 * that can easily be read by the tests.
 */
WriterToString = /** @class */ (function (_super) {
    __extends(WriterToString, _super);
    function WriterToString() {
        var _this = _super.call(this) || this;
        _this.resultString = '';
        return _this;
    }
    /**
     * @param {?} chunk
     * @param {?} encoding
     * @param {?} callback
     * @return {?}
     */
    WriterToString.prototype._write = /**
     * @param {?} chunk
     * @param {?} encoding
     * @param {?} callback
     * @return {?}
     */
    function (chunk, encoding, callback) {
        /** @type {?} */
        var chunkString;
        if (isString(chunk)) {
            chunkString = chunk;
        }
        else if (chunk instanceof Buffer) {
            chunkString = chunk.toString();
        }
        else {
            chunkString = Buffer.alloc(chunk).toString(encoding);
        }
        this.resultString = this.resultString + chunkString;
        callback();
    };
    /**
     * Returns a string of everything, that was written to the stream so far.
     * @return written data
     */
    /**
     * Returns a string of everything, that was written to the stream so far.
     * @return {?} written data
     */
    WriterToString.prototype.writtenData = /**
     * Returns a string of everything, that was written to the stream so far.
     * @return {?} written data
     */
    function () {
        return this.resultString;
    };
    return WriterToString;
}(Writable));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @enum {number} */
var LogLevel = {
    'ERROR': 0,
    'WARN': 1,
    'INFO': 2,
    'DEBUG': 3,
};
LogLevel[LogLevel['ERROR']] = 'ERROR';
LogLevel[LogLevel['WARN']] = 'WARN';
LogLevel[LogLevel['INFO']] = 'INFO';
LogLevel[LogLevel['DEBUG']] = 'DEBUG';
var CommandOutput = /** @class */ (function () {
    function CommandOutput(stdout) {
        this._quiet = false;
        this._verbose = false;
        if (stdout) {
            this.outputStream = stdout;
        }
        else {
            this.outputStream = process.stdout;
        }
    }
    /**
     * @return {?}
     */
    CommandOutput.prototype.setVerbose = /**
     * @return {?}
     */
    function () {
        this._verbose = true;
    };
    /**
     * @return {?}
     */
    CommandOutput.prototype.setQuiet = /**
     * @return {?}
     */
    function () {
        this._quiet = true;
    };
    /**
     * Test, wether verbose is enabled.
     * @return wether verbose is enabled.
     */
    /**
     * Test, wether verbose is enabled.
     * @return {?} wether verbose is enabled.
     */
    CommandOutput.prototype.verbose = /**
     * Test, wether verbose is enabled.
     * @return {?} wether verbose is enabled.
     */
    function () {
        return this._verbose;
    };
    /**
     * Test, wether quiet is enabled.
     * @return wether quiet is enabled.
     */
    /**
     * Test, wether quiet is enabled.
     * @return {?} wether quiet is enabled.
     */
    CommandOutput.prototype.quiet = /**
     * Test, wether quiet is enabled.
     * @return {?} wether quiet is enabled.
     */
    function () {
        return this._quiet;
    };
    /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    CommandOutput.prototype.error = /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    function (msg) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        this.log(LogLevel.ERROR, msg, params);
    };
    /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    CommandOutput.prototype.warn = /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    function (msg) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        this.log(LogLevel.WARN, msg, params);
    };
    /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    CommandOutput.prototype.info = /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    function (msg) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        this.log(LogLevel.INFO, msg, params);
    };
    /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    CommandOutput.prototype.debug = /**
     * @param {?} msg
     * @param {...?} params
     * @return {?}
     */
    function (msg) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        this.log(LogLevel.DEBUG, msg, params);
    };
    /**
     * @param {?} level
     * @param {?} msg
     * @param {?} params
     * @return {?}
     */
    CommandOutput.prototype.log = /**
     * @param {?} level
     * @param {?} msg
     * @param {?} params
     * @return {?}
     */
    function (level, msg, params) {
        if (!this.isOutputEnabled(level)) {
            return;
        }
        /** @type {?} */
        var coloredMessage;
        switch (level) {
            case LogLevel.ERROR:
                coloredMessage = chalk.red('ERROR: ' + msg);
                break;
            case LogLevel.WARN:
                coloredMessage = chalk.magenta('WARNING: ' + msg);
                break;
            default:
                coloredMessage = chalk.gray('* ' + msg);
                break;
        }
        /** @type {?} */
        var outMsg = format.apply(void 0, __spread([coloredMessage], params));
        this.outputStream.write(outMsg + '\n');
    };
    /**
     * @param {?} level
     * @return {?}
     */
    CommandOutput.prototype.isOutputEnabled = /**
     * @param {?} level
     * @return {?}
     */
    function (level) {
        /** @type {?} */
        var quietEnabled;
        /** @type {?} */
        var verboseEnabled;
        if (this._quiet && this._verbose) {
            quietEnabled = false;
            verboseEnabled = false;
        }
        else {
            quietEnabled = this._quiet;
            verboseEnabled = this._verbose;
        }
        switch (level) {
            case LogLevel.ERROR:
                return true; // always output errors
            case LogLevel.WARN:
                return (!quietEnabled);
            case LogLevel.INFO:
                return (verboseEnabled && !quietEnabled);
            case LogLevel.DEBUG:
                return verboseEnabled;
            default:
                return true;
        }
    };
    return CommandOutput;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 17.02.2017.
 */
var XliffMergeError = /** @class */ (function (_super) {
    __extends(XliffMergeError, _super);
    function XliffMergeError(msg) {
        var _this = _super.call(this, msg) || this;
        // Set the prototype explicitly.
        Object.setPrototypeOf(_this, XliffMergeError.prototype);
        return _this;
    }
    return XliffMergeError;
}(Error));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 17.02.2017.
 * Some (a few) simple utils for file operations.
 * Just for convenience.
 */
var /**
 * Created by martin on 17.02.2017.
 * Some (a few) simple utils for file operations.
 * Just for convenience.
 */
FileUtil = /** @class */ (function () {
    function FileUtil() {
    }
    /**
     * Check for existence.
     * @param filename filename
     * @return wether file exists
     */
    /**
     * Check for existence.
     * @param {?} filename filename
     * @return {?} wether file exists
     */
    FileUtil.exists = /**
     * Check for existence.
     * @param {?} filename filename
     * @return {?} wether file exists
     */
    function (filename) {
        return existsSync(filename);
    };
    /**
     * Read a file.
     * @param filename filename
     * @param encoding encoding
     * @return content of file
     */
    /**
     * Read a file.
     * @param {?} filename filename
     * @param {?} encoding encoding
     * @return {?} content of file
     */
    FileUtil.read = /**
     * Read a file.
     * @param {?} filename filename
     * @param {?} encoding encoding
     * @return {?} content of file
     */
    function (filename, encoding) {
        return readFileSync(filename, encoding);
    };
    /**
     * Write a file with given content.
     * @param filename filename
     * @param newContent newContent
     * @param encoding encoding
     */
    /**
     * Write a file with given content.
     * @param {?} filename filename
     * @param {?} newContent newContent
     * @param {?} encoding encoding
     * @return {?}
     */
    FileUtil.replaceContent = /**
     * Write a file with given content.
     * @param {?} filename filename
     * @param {?} newContent newContent
     * @param {?} encoding encoding
     * @return {?}
     */
    function (filename, newContent, encoding) {
        writeFileSync(filename, newContent, { encoding: encoding });
    };
    /**
     * @param {?} srcFile
     * @param {?} destFile
     * @return {?}
     */
    FileUtil.copy = /**
     * @param {?} srcFile
     * @param {?} destFile
     * @return {?}
     */
    function (srcFile, destFile) {
        /** @type {?} */
        var BUF_LENGTH = 64 * 1024;
        /** @type {?} */
        var buff = Buffer.alloc(BUF_LENGTH);
        /** @type {?} */
        var fdr = openSync(srcFile, 'r');
        /** @type {?} */
        var fdw = openSync(destFile, 'w');
        /** @type {?} */
        var bytesRead = 1;
        /** @type {?} */
        var pos = 0;
        while (bytesRead > 0) {
            bytesRead = readSync(fdr, buff, 0, BUF_LENGTH, pos);
            writeSync(fdw, buff, 0, bytesRead);
            pos += bytesRead;
        }
        closeSync(fdr);
        closeSync(fdw);
    };
    /**
     * Delete the folder and all of its content (rm -rf).
     * @param path path
     */
    /**
     * Delete the folder and all of its content (rm -rf).
     * @param {?} path path
     * @return {?}
     */
    FileUtil.deleteFolderRecursive = /**
     * Delete the folder and all of its content (rm -rf).
     * @param {?} path path
     * @return {?}
     */
    function (path) {
        /** @type {?} */
        var files = [];
        if (existsSync(path)) {
            files = readdirSync(path);
            files.forEach(function (file) {
                /** @type {?} */
                var curPath = path + '/' + file;
                if (lstatSync(curPath).isDirectory()) { // recurse
                    FileUtil.deleteFolderRecursive(curPath);
                }
                else { // delete file
                    unlinkSync(curPath);
                }
            });
            rmdirSync(path);
        }
    };
    /**
     * Delete folders content recursively, but do not delete folder.
     * Folder is left empty at the end.
     * @param path path
     */
    /**
     * Delete folders content recursively, but do not delete folder.
     * Folder is left empty at the end.
     * @param {?} path path
     * @return {?}
     */
    FileUtil.deleteFolderContentRecursive = /**
     * Delete folders content recursively, but do not delete folder.
     * Folder is left empty at the end.
     * @param {?} path path
     * @return {?}
     */
    function (path) {
        /** @type {?} */
        var files = [];
        if (existsSync(path)) {
            files = readdirSync(path);
            files.forEach(function (file) {
                /** @type {?} */
                var curPath = path + '/' + file;
                if (lstatSync(curPath).isDirectory()) { // recurse
                    FileUtil.deleteFolderRecursive(curPath);
                }
                else { // delete file
                    unlinkSync(curPath);
                }
            });
        }
    };
    /**
     * Delete a file.
     * @param path path
     */
    /**
     * Delete a file.
     * @param {?} path path
     * @return {?}
     */
    FileUtil.deleteFile = /**
     * Delete a file.
     * @param {?} path path
     * @return {?}
     */
    function (path) {
        unlinkSync(path);
    };
    return FileUtil;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Helper class to parse ngx translate extraction pattern
 * and to decide wether a given message matches the pattern.
 */
var /**
 * Helper class to parse ngx translate extraction pattern
 * and to decide wether a given message matches the pattern.
 */
NgxTranslateExtractionPattern = /** @class */ (function () {
    /**
     * Construct the pattern from given description string
     * @param extractionPatternString extractionPatternString
     * @throws an error, if there is a syntax error
     */
    function NgxTranslateExtractionPattern(extractionPatternString) {
        this.extractionPatternString = extractionPatternString;
        /** @type {?} */
        var parts = extractionPatternString.split('|');
        this._matchExplicitId = false;
        this._descriptionPatterns = [];
        for (var i = 0; i < parts.length; i++) {
            /** @type {?} */
            var part = parts[i];
            if (part === '@@') {
                if (this._matchExplicitId) {
                    throw new Error('extraction pattern must not contain @@ twice');
                }
                this._matchExplicitId = true;
            }
            else {
                /** @type {?} */
                var errorString = this.checkValidDescriptionPattern(part);
                if (errorString) {
                    throw new Error(errorString);
                }
                this._descriptionPatterns.push(part);
            }
        }
    }
    /**
     * Check, wether an explicitly set id matches the pattern.
     * @param id id
     * @return wether an explicitly set id matches the pattern.
     */
    /**
     * Check, wether an explicitly set id matches the pattern.
     * @param {?} id id
     * @return {?} wether an explicitly set id matches the pattern.
     */
    NgxTranslateExtractionPattern.prototype.isExplicitIdMatched = /**
     * Check, wether an explicitly set id matches the pattern.
     * @param {?} id id
     * @return {?} wether an explicitly set id matches the pattern.
     */
    function (id) {
        return id && this._matchExplicitId;
    };
    /**
     * Check, wether a given description matches the pattern.
     * @param description description
     * @return wether a given description matches the pattern.
     */
    /**
     * Check, wether a given description matches the pattern.
     * @param {?} description description
     * @return {?} wether a given description matches the pattern.
     */
    NgxTranslateExtractionPattern.prototype.isDescriptionMatched = /**
     * Check, wether a given description matches the pattern.
     * @param {?} description description
     * @return {?} wether a given description matches the pattern.
     */
    function (description) {
        return this._descriptionPatterns.indexOf(description) >= 0;
    };
    /**
     * @param {?} descriptionPattern
     * @return {?}
     */
    NgxTranslateExtractionPattern.prototype.checkValidDescriptionPattern = /**
     * @param {?} descriptionPattern
     * @return {?}
     */
    function (descriptionPattern) {
        if (!descriptionPattern) {
            return 'empty value not allowed';
        }
        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {
            return null; // it is ok
        }
        else {
            return 'description pattern must be an identifier containing only letters, digits, _ or -';
        }
    };
    return NgxTranslateExtractionPattern;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var NgxTranslateExtractor = /** @class */ (function () {
    function NgxTranslateExtractor(messagesFile, extractionPatternString) {
        this.messagesFile = messagesFile;
        this.extractionPattern = new NgxTranslateExtractionPattern(extractionPatternString);
    }
    /**
     * Check, wether extractionPattern has valid syntax.
     * @param extractionPatternString extractionPatternString
     * @return null, if pattern is ok, string describing the error, if it is not ok.
     */
    /**
     * Check, wether extractionPattern has valid syntax.
     * @param {?} extractionPatternString extractionPatternString
     * @return {?} null, if pattern is ok, string describing the error, if it is not ok.
     */
    NgxTranslateExtractor.checkPattern = /**
     * Check, wether extractionPattern has valid syntax.
     * @param {?} extractionPatternString extractionPatternString
     * @return {?} null, if pattern is ok, string describing the error, if it is not ok.
     */
    function (extractionPatternString) {
        try {
            if (new NgxTranslateExtractionPattern(extractionPatternString)) {
                return null;
            }
        }
        catch (error) {
            return error.message;
        }
        return null;
    };
    /**
     * @param {?} messagesFile
     * @param {?} extractionPattern
     * @param {?} outputFile
     * @return {?}
     */
    NgxTranslateExtractor.extract = /**
     * @param {?} messagesFile
     * @param {?} extractionPattern
     * @param {?} outputFile
     * @return {?}
     */
    function (messagesFile, extractionPattern, outputFile) {
        new NgxTranslateExtractor(messagesFile, extractionPattern).extractTo(outputFile);
    };
    /**
     * Extact messages and write them to a file.
     * @param outputFile outputFile
     */
    /**
     * Extact messages and write them to a file.
     * @param {?} outputFile outputFile
     * @return {?}
     */
    NgxTranslateExtractor.prototype.extractTo = /**
     * Extact messages and write them to a file.
     * @param {?} outputFile outputFile
     * @return {?}
     */
    function (outputFile) {
        /** @type {?} */
        var translations = this.toNgxTranslations(this.extract());
        if (translations && Object.keys(translations).length > 0) {
            FileUtil.replaceContent(outputFile, JSON.stringify(translations, null, 4), 'UTF-8');
        }
        else {
            if (FileUtil.exists(outputFile)) {
                FileUtil.deleteFile(outputFile);
            }
        }
    };
    /**
     *  Extract messages and convert them to ngx translations.
     *  @return the translation objects.
     */
    /**
     *  Extract messages and convert them to ngx translations.
     * @return {?} the translation objects.
     */
    NgxTranslateExtractor.prototype.extract = /**
     *  Extract messages and convert them to ngx translations.
     * @return {?} the translation objects.
     */
    function () {
        var _this = this;
        /** @type {?} */
        var result = [];
        this.messagesFile.forEachTransUnit(function (tu) {
            /** @type {?} */
            var ngxId = _this.ngxTranslateIdFromTU(tu);
            if (ngxId) {
                /** @type {?} */
                var messagetext = tu.targetContentNormalized().asDisplayString(NORMALIZATION_FORMAT_NGXTRANSLATE);
                result.push({ id: ngxId, message: messagetext });
            }
        });
        return result;
    };
    /**
     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.
     * There are 2 possibilities:
     * 1. description is set to "ngx-translate" and meaning contains the id.
     * 2. id is explicitly set to a string.
     * @param tu tu
     * @return an ngx id or null, if this tu should not be extracted.
     */
    /**
     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.
     * There are 2 possibilities:
     * 1. description is set to "ngx-translate" and meaning contains the id.
     * 2. id is explicitly set to a string.
     * @param {?} tu tu
     * @return {?} an ngx id or null, if this tu should not be extracted.
     */
    NgxTranslateExtractor.prototype.ngxTranslateIdFromTU = /**
     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.
     * There are 2 possibilities:
     * 1. description is set to "ngx-translate" and meaning contains the id.
     * 2. id is explicitly set to a string.
     * @param {?} tu tu
     * @return {?} an ngx id or null, if this tu should not be extracted.
     */
    function (tu) {
        if (this.isExplicitlySetId(tu.id)) {
            if (this.extractionPattern.isExplicitIdMatched(tu.id)) {
                return tu.id;
            }
            else {
                return null;
            }
        }
        /** @type {?} */
        var description = tu.description();
        if (description && this.extractionPattern.isDescriptionMatched(description)) {
            return tu.meaning();
        }
    };
    /**
     * Test, wether ID was explicitly set (via i18n="@myid).
     * Just heuristic, an ID is explicitly, if it does not look like a generated one.
     * @param id id
     * @return wether ID was explicitly set (via i18n="@myid).
     */
    /**
     * Test, wether ID was explicitly set (via i18n="\@myid).
     * Just heuristic, an ID is explicitly, if it does not look like a generated one.
     * @param {?} id id
     * @return {?} wether ID was explicitly set (via i18n="\@myid).
     */
    NgxTranslateExtractor.prototype.isExplicitlySetId = /**
     * Test, wether ID was explicitly set (via i18n="\@myid).
     * Just heuristic, an ID is explicitly, if it does not look like a generated one.
     * @param {?} id id
     * @return {?} wether ID was explicitly set (via i18n="\@myid).
     */
    function (id) {
        if (isNullOrUndefined(id)) {
            return false;
        }
        // generated IDs are either decimal or sha1 hex
        /** @type {?} */
        var reForGeneratedId = /^[0-9a-f]{11,}$/;
        return !reForGeneratedId.test(id);
    };
    /**
     * Convert list of relevant TUs to ngx translations object.
     * @param msgList msgList
     */
    /**
     * Convert list of relevant TUs to ngx translations object.
     * @param {?} msgList msgList
     * @return {?}
     */
    NgxTranslateExtractor.prototype.toNgxTranslations = /**
     * Convert list of relevant TUs to ngx translations object.
     * @param {?} msgList msgList
     * @return {?}
     */
    function (msgList) {
        var _this = this;
        /** @type {?} */
        var translationObject = {};
        msgList.forEach(function (msg) {
            _this.putInTranslationObject(translationObject, msg);
        });
        return translationObject;
    };
    /**
     * Put a new messages into the translation data object.
     * If you add, e.g. "{id: 'myapp.example', message: 'test'}",
     * the translation object will then contain an object myapp that has property example:
     * {myapp: {
     *   example: 'test'
     *   }}
     * @param translationObject translationObject
     * @param msg msg
     */
    /**
     * Put a new messages into the translation data object.
     * If you add, e.g. "{id: 'myapp.example', message: 'test'}",
     * the translation object will then contain an object myapp that has property example:
     * {myapp: {
     *   example: 'test'
     *   }}
     * @param {?} translationObject translationObject
     * @param {?} msg msg
     * @return {?}
     */
    NgxTranslateExtractor.prototype.putInTranslationObject = /**
     * Put a new messages into the translation data object.
     * If you add, e.g. "{id: 'myapp.example', message: 'test'}",
     * the translation object will then contain an object myapp that has property example:
     * {myapp: {
     *   example: 'test'
     *   }}
     * @param {?} translationObject translationObject
     * @param {?} msg msg
     * @return {?}
     */
    function (translationObject, msg) {
        /** @type {?} */
        var firstPartOfId;
        /** @type {?} */
        var restOfId;
        /** @type {?} */
        var indexOfDot = msg.id.indexOf('.');
        if (indexOfDot === 0 || indexOfDot === (msg.id.length - 1)) {
            throw new Error('bad nxg-translate id "' + msg.id + '"');
        }
        if (indexOfDot < 0) {
            firstPartOfId = msg.id;
            restOfId = '';
        }
        else {
            firstPartOfId = msg.id.substring(0, indexOfDot);
            restOfId = msg.id.substring(indexOfDot + 1);
        }
        /** @type {?} */
        var object = translationObject[firstPartOfId];
        if (isNullOrUndefined(object)) {
            if (restOfId === '') {
                translationObject[firstPartOfId] = msg.message;
                return;
            }
            object = {};
            translationObject[firstPartOfId] = object;
        }
        else {
            if (restOfId === '') {
                throw new Error('duplicate id praefix "' + msg.id + '"');
            }
        }
        this.putInTranslationObject((/** @type {?} */ (object)), { id: restOfId, message: msg.message });
    };
    NgxTranslateExtractor.DefaultExtractionPattern = '@@|ngx-translate';
    return NgxTranslateExtractor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
var PROFILE_CANDIDATES = ['package.json', '.angular-cli.json'];
var XliffMergeParameters = /** @class */ (function () {
    function XliffMergeParameters() {
        this.errorsFound = [];
        this.warningsFound = [];
    }
    /**
     * Create Parameters.
     * @param options command options
     * @param profileContent given profile (if not, it is read from the profile path from options).
     */
    /**
     * Create Parameters.
     * @param {?} options command options
     * @param {?=} profileContent given profile (if not, it is read from the profile path from options).
     * @return {?}
     */
    XliffMergeParameters.createFromOptions = /**
     * Create Parameters.
     * @param {?} options command options
     * @param {?=} profileContent given profile (if not, it is read from the profile path from options).
     * @return {?}
     */
    function (options, profileContent) {
        /** @type {?} */
        var parameters = new XliffMergeParameters();
        parameters.configure(options, profileContent);
        return parameters;
    };
    /**
     * Read potential profile.
     * To be a candidate, file must exist and contain property "xliffmergeOptions".
     * @param profilePath path of profile
     * @return parsed content of file or null, if file does not exist or is not a profile candidate.
     */
    /**
     * Read potential profile.
     * To be a candidate, file must exist and contain property "xliffmergeOptions".
     * @param {?} profilePath path of profile
     * @return {?} parsed content of file or null, if file does not exist or is not a profile candidate.
     */
    XliffMergeParameters.readProfileCandidate = /**
     * Read potential profile.
     * To be a candidate, file must exist and contain property "xliffmergeOptions".
     * @param {?} profilePath path of profile
     * @return {?} parsed content of file or null, if file does not exist or is not a profile candidate.
     */
    function (profilePath) {
        /** @type {?} */
        var content;
        try {
            content = readFileSync(profilePath, 'UTF-8');
        }
        catch (err) {
            return null;
        }
        /** @type {?} */
        var parsedContent = JSON.parse(content);
        if (parsedContent && parsedContent.xliffmergeOptions) {
            return parsedContent;
        }
        else {
            return null;
        }
    };
    /**
     * Initialize me from the profile content.
     * (public only for test usage).
     * @param options options given at runtime via command line
     * @param profileContent if null, read it from profile.
     */
    /**
     * Initialize me from the profile content.
     * (public only for test usage).
     * @param {?} options options given at runtime via command line
     * @param {?=} profileContent if null, read it from profile.
     * @return {?}
     */
    XliffMergeParameters.prototype.configure = /**
     * Initialize me from the profile content.
     * (public only for test usage).
     * @param {?} options options given at runtime via command line
     * @param {?=} profileContent if null, read it from profile.
     * @return {?}
     */
    function (options, profileContent) {
        this.errorsFound = [];
        this.warningsFound = [];
        if (!profileContent) {
            profileContent = this.readProfile(options);
        }
        /** @type {?} */
        var validProfile = (!!profileContent);
        if (options.quiet) {
            this._quiet = options.quiet;
        }
        if (options.verbose) {
            this._verbose = options.verbose;
        }
        if (validProfile) {
            this.initializeFromConfig(profileContent);
            // if languages are given as parameters, they ovveride everything said in profile
            if (!!options.languages && options.languages.length > 0) {
                this._languages = options.languages;
                if (!this._defaultLanguage) {
                    this._defaultLanguage = this._languages[0];
                }
            }
            this.checkParameters();
        }
    };
    /**
     * Read profile.
     * @param options program options
     * @return the read profile (empty, if none, null if errors)
     */
    /**
     * Read profile.
     * @param {?} options program options
     * @return {?} the read profile (empty, if none, null if errors)
     */
    XliffMergeParameters.prototype.readProfile = /**
     * Read profile.
     * @param {?} options program options
     * @return {?} the read profile (empty, if none, null if errors)
     */
    function (options) {
        var e_1, _a;
        /** @type {?} */
        var profilePath = options.profilePath;
        if (!profilePath) {
            try {
                for (var PROFILE_CANDIDATES_1 = __values(PROFILE_CANDIDATES), PROFILE_CANDIDATES_1_1 = PROFILE_CANDIDATES_1.next(); !PROFILE_CANDIDATES_1_1.done; PROFILE_CANDIDATES_1_1 = PROFILE_CANDIDATES_1.next()) {
                    var configfilename = PROFILE_CANDIDATES_1_1.value;
                    /** @type {?} */
                    var profile = XliffMergeParameters.readProfileCandidate(configfilename);
                    if (profile) {
                        this.usedProfilePath = configfilename;
                        return profile;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (PROFILE_CANDIDATES_1_1 && !PROFILE_CANDIDATES_1_1.done && (_a = PROFILE_CANDIDATES_1.return)) _a.call(PROFILE_CANDIDATES_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return {};
        }
        /** @type {?} */
        var content;
        try {
            content = readFileSync(profilePath, 'UTF-8');
        }
        catch (err) {
            this.errorsFound.push(new XliffMergeError('could not read profile "' + profilePath + '"'));
            return null;
        }
        this.usedProfilePath = profilePath;
        /** @type {?} */
        var profileContent = JSON.parse(content);
        // replace all pathes in options by absolute paths
        /** @type {?} */
        var xliffmergeOptions = profileContent.xliffmergeOptions;
        xliffmergeOptions.srcDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.srcDir);
        xliffmergeOptions.genDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.genDir);
        xliffmergeOptions.apikeyfile = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.apikeyfile);
        return profileContent;
    };
    /**
     * @param {?} profilePath
     * @param {?} pathToAdjust
     * @return {?}
     */
    XliffMergeParameters.prototype.adjustPathToProfilePath = /**
     * @param {?} profilePath
     * @param {?} pathToAdjust
     * @return {?}
     */
    function (profilePath, pathToAdjust) {
        if (!pathToAdjust || isAbsolute(pathToAdjust)) {
            return pathToAdjust;
        }
        return join(dirname(profilePath), pathToAdjust).replace(/\\/g, '/');
    };
    /**
     * @param {?} profileContent
     * @return {?}
     */
    XliffMergeParameters.prototype.initializeFromConfig = /**
     * @param {?} profileContent
     * @return {?}
     */
    function (profileContent) {
        if (!profileContent) {
            return;
        }
        /** @type {?} */
        var profile = profileContent.xliffmergeOptions;
        if (profile) {
            if (!isNullOrUndefined(profile.quiet)) {
                this._quiet = profile.quiet;
            }
            if (!isNullOrUndefined(profile.verbose)) {
                this._verbose = profile.verbose;
            }
            if (!isNullOrUndefined(profile.allowIdChange)) {
                this._allowIdChange = profile.allowIdChange;
            }
            if (profile.defaultLanguage) {
                this._defaultLanguage = profile.defaultLanguage;
            }
            if (profile.languages) {
                this._languages = profile.languages;
            }
            if (profile.srcDir) {
                this._srcDir = profile.srcDir;
            }
            if (profile.angularCompilerOptions) {
                if (profile.angularCompilerOptions.genDir) {
                    this._genDir = profile.angularCompilerOptions.genDir;
                }
            }
            if (profile.genDir) {
                // this must be after angularCompilerOptions to be preferred
                this._genDir = profile.genDir;
            }
            if (profile.i18nBaseFile) {
                this._i18nBaseFile = profile.i18nBaseFile;
            }
            if (profile.i18nFile) {
                this._i18nFile = profile.i18nFile;
            }
            if (profile.i18nFormat) {
                this._i18nFormat = profile.i18nFormat;
            }
            if (profile.encoding) {
                this._encoding = profile.encoding;
            }
            if (!isNullOrUndefined(profile.removeUnusedIds)) {
                this._removeUnusedIds = profile.removeUnusedIds;
            }
            if (!isNullOrUndefined(profile.supportNgxTranslate)) {
                this._supportNgxTranslate = profile.supportNgxTranslate;
            }
            if (!isNullOrUndefined(profile.ngxTranslateExtractionPattern)) {
                this._ngxTranslateExtractionPattern = profile.ngxTranslateExtractionPattern;
            }
            if (!isNullOrUndefined(profile.useSourceAsTarget)) {
                this._useSourceAsTarget = profile.useSourceAsTarget;
            }
            if (!isNullOrUndefined(profile.targetPraefix)) {
                this._targetPraefix = profile.targetPraefix;
            }
            if (!isNullOrUndefined(profile.targetSuffix)) {
                this._targetSuffix = profile.targetSuffix;
            }
            if (!isNullOrUndefined(profile.autotranslate)) {
                this._autotranslate = profile.autotranslate;
            }
            if (!isNullOrUndefined(profile.beautifyOutput)) {
                this._beautifyOutput = profile.beautifyOutput;
            }
            if (!isNullOrUndefined(profile.preserveOrder)) {
                this._preserveOrder = profile.preserveOrder;
            }
            if (!isNullOrUndefined(profile.apikey)) {
                this._apikey = profile.apikey;
            }
            if (!isNullOrUndefined(profile.apikeyfile)) {
                this._apikeyfile = profile.apikeyfile;
            }
        }
        else {
            this.warningsFound.push('did not find "xliffmergeOptions" in profile, using defaults');
        }
    };
    /**
     * Check all Parameters, wether they are complete and consistent.
     * if something is wrong with the parameters, it is collected in errorsFound.
     */
    /**
     * Check all Parameters, wether they are complete and consistent.
     * if something is wrong with the parameters, it is collected in errorsFound.
     * @return {?}
     */
    XliffMergeParameters.prototype.checkParameters = /**
     * Check all Parameters, wether they are complete and consistent.
     * if something is wrong with the parameters, it is collected in errorsFound.
     * @return {?}
     */
    function () {
        var _this = this;
        this.checkLanguageSyntax(this.defaultLanguage());
        if (this.languages().length === 0) {
            this.errorsFound.push(new XliffMergeError('no languages specified'));
        }
        this.languages().forEach(function (lang) {
            _this.checkLanguageSyntax(lang);
        });
        /** @type {?} */
        var stats;
        /** @type {?} */
        var err;
        // srcDir should exists
        try {
            stats = statSync(this.srcDir());
        }
        catch (e) {
            err = e;
        }
        if (!!err || !stats.isDirectory()) {
            this.errorsFound.push(new XliffMergeError('srcDir "' + this.srcDir() + '" is not a directory'));
        }
        // genDir should exists
        try {
            stats = statSync(this.genDir());
        }
        catch (e) {
            err = e;
        }
        if (!!err || !stats.isDirectory()) {
            this.errorsFound.push(new XliffMergeError('genDir "' + this.genDir() + '" is not a directory'));
        }
        // master file MUST exist
        try {
            accessSync(this.i18nFile(), constants.R_OK);
        }
        catch (err) {
            this.errorsFound.push(new XliffMergeError('i18nFile "' + this.i18nFile() + '" is not readable'));
        }
        // i18nFormat must be xlf xlf2 or xmb
        if (!(this.i18nFormat() === 'xlf' || this.i18nFormat() === 'xlf2' || this.i18nFormat() === 'xmb')) {
            this.errorsFound.push(new XliffMergeError('i18nFormat "' + this.i18nFormat() + '" invalid, must be "xlf" or "xlf2" or "xmb"'));
        }
        // autotranslate requires api key
        if (this.autotranslate() && !this.apikey()) {
            this.errorsFound.push(new XliffMergeError('autotranslate requires an API key, please set one'));
        }
        // autotranslated languages must be in list of all languages
        this.autotranslatedLanguages().forEach(function (lang) {
            if (_this.languages().indexOf(lang) < 0) {
                _this.errorsFound.push(new XliffMergeError('autotranslate language "' + lang + '" is not in list of languages'));
            }
            if (lang === _this.defaultLanguage()) {
                _this.errorsFound.push(new XliffMergeError('autotranslate language "' + lang + '" cannot be translated, because it is the source language'));
            }
        });
        // ngx translate pattern check
        if (this.supportNgxTranslate()) {
            /** @type {?} */
            var checkResult = NgxTranslateExtractor.checkPattern(this.ngxTranslateExtractionPattern());
            if (!isNullOrUndefined(checkResult)) {
                this.errorsFound.push(new XliffMergeError('ngxTranslateExtractionPattern "' + this.ngxTranslateExtractionPattern() + '": ' + checkResult));
            }
        }
        // targetPraefix and targetSuffix check
        if (!this.useSourceAsTarget()) {
            if (this.targetPraefix().length > 0) {
                this.warningsFound.push('configured targetPraefix "' + this.targetPraefix() + '" will not be used because "useSourceAsTarget" is disabled"');
            }
            if (this.targetSuffix().length > 0) {
                this.warningsFound.push('configured targetSuffix "' + this.targetSuffix() + '" will not be used because "useSourceAsTarget" is disabled"');
            }
        }
    };
    /**
     * Check syntax of language.
     * Must be compatible with XML Schema type xsd:language.
     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*
     * @param lang language to check
     */
    /**
     * Check syntax of language.
     * Must be compatible with XML Schema type xsd:language.
     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*
     * @param {?} lang language to check
     * @return {?}
     */
    XliffMergeParameters.prototype.checkLanguageSyntax = /**
     * Check syntax of language.
     * Must be compatible with XML Schema type xsd:language.
     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*
     * @param {?} lang language to check
     * @return {?}
     */
    function (lang) {
        /** @type {?} */
        var pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;
        if (!pattern.test(lang)) {
            this.errorsFound.push(new XliffMergeError('language "' + lang + '" is not valid'));
        }
    };
    /**
     * @return {?}
     */
    XliffMergeParameters.prototype.allowIdChange = /**
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._allowIdChange)) ? false : this._allowIdChange;
    };
    /**
     * @return {?}
     */
    XliffMergeParameters.prototype.verbose = /**
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._verbose)) ? false : this._verbose;
    };
    /**
     * @return {?}
     */
    XliffMergeParameters.prototype.quiet = /**
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._quiet)) ? false : this._quiet;
    };
    /**
     * Debug output all parameters to commandOutput.
     */
    /**
     * Debug output all parameters to commandOutput.
     * @param {?} commandOutput
     * @return {?}
     */
    XliffMergeParameters.prototype.showAllParameters = /**
     * Debug output all parameters to commandOutput.
     * @param {?} commandOutput
     * @return {?}
     */
    function (commandOutput) {
        var e_2, _a;
        commandOutput.debug('xliffmerge Used Parameters:');
        commandOutput.debug('usedProfilePath:\t"%s"', this.usedProfilePath);
        commandOutput.debug('defaultLanguage:\t"%s"', this.defaultLanguage());
        commandOutput.debug('srcDir:\t"%s"', this.srcDir());
        commandOutput.debug('genDir:\t"%s"', this.genDir());
        commandOutput.debug('i18nBaseFile:\t"%s"', this.i18nBaseFile());
        commandOutput.debug('i18nFile:\t"%s"', this.i18nFile());
        commandOutput.debug('languages:\t%s', this.languages());
        try {
            for (var _b = __values(this.languages()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var language = _c.value;
                commandOutput.debug('outputFile[%s]:\t%s', language, this.generatedI18nFile(language));
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        commandOutput.debug('removeUnusedIds:\t%s', this.removeUnusedIds());
        commandOutput.debug('supportNgxTranslate:\t%s', this.supportNgxTranslate());
        if (this.supportNgxTranslate()) {
            commandOutput.debug('ngxTranslateExtractionPattern:\t%s', this.ngxTranslateExtractionPattern());
        }
        commandOutput.debug('useSourceAsTarget:\t%s', this.useSourceAsTarget());
        if (this.useSourceAsTarget()) {
            commandOutput.debug('targetPraefix:\t"%s"', this.targetPraefix());
            commandOutput.debug('targetSuffix:\t"%s"', this.targetSuffix());
        }
        commandOutput.debug('allowIdChange:\t%s', this.allowIdChange());
        commandOutput.debug('beautifyOutput:\t%s', this.beautifyOutput());
        commandOutput.debug('preserveOrder:\t%s', this.preserveOrder());
        commandOutput.debug('autotranslate:\t%s', this.autotranslate());
        if (this.autotranslate()) {
            commandOutput.debug('autotranslated languages:\t%s', this.autotranslatedLanguages());
            commandOutput.debug('apikey:\t%s', this.apikey() ? '****' : 'NOT SET');
            commandOutput.debug('apikeyfile:\t%s', this.apikeyfile());
        }
    };
    /**
     * Default-Language, default en.
     * @return default language
     */
    /**
     * Default-Language, default en.
     * @return {?} default language
     */
    XliffMergeParameters.prototype.defaultLanguage = /**
     * Default-Language, default en.
     * @return {?} default language
     */
    function () {
        return this._defaultLanguage ? this._defaultLanguage : 'en';
    };
    /**
     * Liste der zu bearbeitenden Sprachen.
     * @return languages
     */
    /**
     * Liste der zu bearbeitenden Sprachen.
     * @return {?} languages
     */
    XliffMergeParameters.prototype.languages = /**
     * Liste der zu bearbeitenden Sprachen.
     * @return {?} languages
     */
    function () {
        return this._languages ? this._languages : [];
    };
    /**
     * src directory, where the master xlif is located.
     * @return srcDir
     */
    /**
     * src directory, where the master xlif is located.
     * @return {?} srcDir
     */
    XliffMergeParameters.prototype.srcDir = /**
     * src directory, where the master xlif is located.
     * @return {?} srcDir
     */
    function () {
        return this._srcDir ? this._srcDir : '.';
    };
    /**
     * The base file name of the xlif file for input and output.
     * Default is messages
     * @return base file
     */
    /**
     * The base file name of the xlif file for input and output.
     * Default is messages
     * @return {?} base file
     */
    XliffMergeParameters.prototype.i18nBaseFile = /**
     * The base file name of the xlif file for input and output.
     * Default is messages
     * @return {?} base file
     */
    function () {
        return this._i18nBaseFile ? this._i18nBaseFile : 'messages';
    };
    /**
     * The master xlif file (the one generated by ng-xi18n).
     * Default is <srcDir>/<i18nBaseFile>.xlf.
     * @return master file
     */
    /**
     * The master xlif file (the one generated by ng-xi18n).
     * Default is <srcDir>/<i18nBaseFile>.xlf.
     * @return {?} master file
     */
    XliffMergeParameters.prototype.i18nFile = /**
     * The master xlif file (the one generated by ng-xi18n).
     * Default is <srcDir>/<i18nBaseFile>.xlf.
     * @return {?} master file
     */
    function () {
        return join(this.srcDir(), (this._i18nFile ? this._i18nFile : this.i18nBaseFile() + '.' + this.suffixForGeneratedI18nFile())).replace(/\\/g, '/');
    };
    /**
     * Format of the master xlif file.
     * Default is "xlf", possible are "xlf" or "xlf2" or "xmb".
     * @return format
     */
    /**
     * Format of the master xlif file.
     * Default is "xlf", possible are "xlf" or "xlf2" or "xmb".
     * @return {?} format
     */
    XliffMergeParameters.prototype.i18nFormat = /**
     * Format of the master xlif file.
     * Default is "xlf", possible are "xlf" or "xlf2" or "xmb".
     * @return {?} format
     */
    function () {
        return (this._i18nFormat ? this._i18nFormat : 'xlf');
    };
    /**
     * potentially to be generated I18n-File with the translations for one language.
     * @param lang language shortcut
     * @return Path of file
     */
    /**
     * potentially to be generated I18n-File with the translations for one language.
     * @param {?} lang language shortcut
     * @return {?} Path of file
     */
    XliffMergeParameters.prototype.generatedI18nFile = /**
     * potentially to be generated I18n-File with the translations for one language.
     * @param {?} lang language shortcut
     * @return {?} Path of file
     */
    function (lang) {
        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + this.suffixForGeneratedI18nFile()).replace(/\\/g, '/');
    };
    /**
     * @return {?}
     */
    XliffMergeParameters.prototype.suffixForGeneratedI18nFile = /**
     * @return {?}
     */
    function () {
        switch (this.i18nFormat()) {
            case 'xlf':
                return 'xlf';
            case 'xlf2':
                return 'xlf';
            case 'xmb':
                return 'xtb';
        }
    };
    /**
     * potentially to be generated translate-File for ngx-translate with the translations for one language.
     * @param lang language shortcut
     * @return Path of file
     */
    /**
     * potentially to be generated translate-File for ngx-translate with the translations for one language.
     * @param {?} lang language shortcut
     * @return {?} Path of file
     */
    XliffMergeParameters.prototype.generatedNgxTranslateFile = /**
     * potentially to be generated translate-File for ngx-translate with the translations for one language.
     * @param {?} lang language shortcut
     * @return {?} Path of file
     */
    function (lang) {
        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + 'json').replace(/\\/g, '/');
    };
    /**
     * The encoding used to write new XLIFF-files.
     * @return encoding
     */
    /**
     * The encoding used to write new XLIFF-files.
     * @return {?} encoding
     */
    XliffMergeParameters.prototype.encoding = /**
     * The encoding used to write new XLIFF-files.
     * @return {?} encoding
     */
    function () {
        return this._encoding ? this._encoding : 'UTF-8';
    };
    /**
     * Output-Directory, where the output is written to.
     * Default is <srcDir>.
    */
    /**
     * Output-Directory, where the output is written to.
     * Default is <srcDir>.
     * @return {?}
     */
    XliffMergeParameters.prototype.genDir = /**
     * Output-Directory, where the output is written to.
     * Default is <srcDir>.
     * @return {?}
     */
    function () {
        return this._genDir ? this._genDir : this.srcDir();
    };
    /**
     * @return {?}
     */
    XliffMergeParameters.prototype.removeUnusedIds = /**
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._removeUnusedIds)) ? true : this._removeUnusedIds;
    };
    /**
     * @return {?}
     */
    XliffMergeParameters.prototype.supportNgxTranslate = /**
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._supportNgxTranslate)) ? false : this._supportNgxTranslate;
    };
    /**
     * @return {?}
     */
    XliffMergeParameters.prototype.ngxTranslateExtractionPattern = /**
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._ngxTranslateExtractionPattern)) ?
            NgxTranslateExtractor.DefaultExtractionPattern : this._ngxTranslateExtractionPattern;
    };
    /**
     * Whether source must be used as target for new trans-units
     * Default is true
     */
    /**
     * Whether source must be used as target for new trans-units
     * Default is true
     * @return {?}
     */
    XliffMergeParameters.prototype.useSourceAsTarget = /**
     * Whether source must be used as target for new trans-units
     * Default is true
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._useSourceAsTarget)) ? true : this._useSourceAsTarget;
    };
    /**
     * Praefix used for target when copying new trans-units
     * Default is ""
     */
    /**
     * Praefix used for target when copying new trans-units
     * Default is ""
     * @return {?}
     */
    XliffMergeParameters.prototype.targetPraefix = /**
     * Praefix used for target when copying new trans-units
     * Default is ""
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._targetPraefix)) ? '' : this._targetPraefix;
    };
    /**
     * Suffix used for target when copying new trans-units
     * Default is ""
     */
    /**
     * Suffix used for target when copying new trans-units
     * Default is ""
     * @return {?}
     */
    XliffMergeParameters.prototype.targetSuffix = /**
     * Suffix used for target when copying new trans-units
     * Default is ""
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._targetSuffix)) ? '' : this._targetSuffix;
    };
    /**
     * If set, run xml result through beautifier (pretty-data).
     */
    /**
     * If set, run xml result through beautifier (pretty-data).
     * @return {?}
     */
    XliffMergeParameters.prototype.beautifyOutput = /**
     * If set, run xml result through beautifier (pretty-data).
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._beautifyOutput)) ? false : this._beautifyOutput;
    };
    /**
     * If set, order of new trans units will be as in master.
     * Otherwise they are added at the end.
     */
    /**
     * If set, order of new trans units will be as in master.
     * Otherwise they are added at the end.
     * @return {?}
     */
    XliffMergeParameters.prototype.preserveOrder = /**
     * If set, order of new trans units will be as in master.
     * Otherwise they are added at the end.
     * @return {?}
     */
    function () {
        return (isNullOrUndefined(this._preserveOrder)) ? true : this._preserveOrder;
    };
    /**
     * Whether to use autotranslate for new trans-units
     * Default is false
     */
    /**
     * Whether to use autotranslate for new trans-units
     * Default is false
     * @return {?}
     */
    XliffMergeParameters.prototype.autotranslate = /**
     * Whether to use autotranslate for new trans-units
     * Default is false
     * @return {?}
     */
    function () {
        if (isNullOrUndefined(this._autotranslate)) {
            return false;
        }
        if (isArray(this._autotranslate)) {
            return ((/** @type {?} */ (this._autotranslate))).length > 0;
        }
        return (/** @type {?} */ (this._autotranslate));
    };
    /**
     * Whether to use autotranslate for a given language.
     * @param lang language code.
     */
    /**
     * Whether to use autotranslate for a given language.
     * @param {?} lang language code.
     * @return {?}
     */
    XliffMergeParameters.prototype.autotranslateLanguage = /**
     * Whether to use autotranslate for a given language.
     * @param {?} lang language code.
     * @return {?}
     */
    function (lang) {
        return this.autotranslatedLanguages().indexOf(lang) >= 0;
    };
    /**
     * Return a list of languages to be autotranslated.
     */
    /**
     * Return a list of languages to be autotranslated.
     * @return {?}
     */
    XliffMergeParameters.prototype.autotranslatedLanguages = /**
     * Return a list of languages to be autotranslated.
     * @return {?}
     */
    function () {
        if (isNullOrUndefined(this._autotranslate) || this._autotranslate === false) {
            return [];
        }
        if (isArray(this._autotranslate)) {
            return ((/** @type {?} */ (this._autotranslate)));
        }
        return this.languages().slice(1); // first is source language
    };
    /**
     * API key to be used for Google Translate
     * @return api key
     */
    /**
     * API key to be used for Google Translate
     * @return {?} api key
     */
    XliffMergeParameters.prototype.apikey = /**
     * API key to be used for Google Translate
     * @return {?} api key
     */
    function () {
        if (!isNullOrUndefined(this._apikey)) {
            return this._apikey;
        }
        else {
            /** @type {?} */
            var apikeyPath = this.apikeyfile();
            if (this.apikeyfile()) {
                if (existsSync(apikeyPath)) {
                    return FileUtil.read(apikeyPath, 'utf-8');
                }
                else {
                    throw new Error(format('api key file not found: API_KEY_FILE=%s', apikeyPath));
                }
            }
            else {
                return null;
            }
        }
    };
    /**
     * file name for API key to be used for Google Translate.
     * Explicitly set or read from env var API_KEY_FILE.
     * @return file of api key
     */
    /**
     * file name for API key to be used for Google Translate.
     * Explicitly set or read from env var API_KEY_FILE.
     * @return {?} file of api key
     */
    XliffMergeParameters.prototype.apikeyfile = /**
     * file name for API key to be used for Google Translate.
     * Explicitly set or read from env var API_KEY_FILE.
     * @return {?} file of api key
     */
    function () {
        if (this._apikeyfile) {
            return this._apikeyfile;
        }
        else if (process.env.API_KEY_FILE) {
            return process.env.API_KEY_FILE;
        }
        else {
            return null;
        }
    };
    return XliffMergeParameters;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
var pkg = null;
try {
    pkg = require(resolve(__dirname, '..', 'package.json'));
}
catch (e) {
    try {
        pkg = require(resolve(__dirname, '..', '..', 'package.json'));
    }
    catch (e) {
        pkg = null;
    }
}
/** @type {?} */
var VERSION = (pkg ? pkg.version : 'unknown');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 10.03.2017.
 * Helper class to read XMl with a correct encoding.
 */
var XmlReader = /** @class */ (function () {
    function XmlReader() {
    }
    /**
     * Read an xml-File.
     * @param path Path to file
     * @param encoding optional encoding of the xml.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @return file content and encoding found in the file.
     */
    /**
     * Read an xml-File.
     * @param {?} path Path to file
     * @param {?=} encoding optional encoding of the xml.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @return {?} file content and encoding found in the file.
     */
    XmlReader.readXmlFileContent = /**
     * Read an xml-File.
     * @param {?} path Path to file
     * @param {?=} encoding optional encoding of the xml.
     * This is read from the file, but if you know it before, you can avoid reading the file twice.
     * @return {?} file content and encoding found in the file.
     */
    function (path, encoding) {
        if (!encoding) {
            encoding = XmlReader.DEFAULT_ENCODING;
        }
        /** @type {?} */
        var content = FileUtil.read(path, encoding);
        /** @type {?} */
        var foundEncoding = XmlReader.encodingFromXml(content);
        if (foundEncoding !== encoding) {
            // read again with the correct encoding
            content = FileUtil.read(path, foundEncoding);
        }
        return {
            content: content,
            encoding: foundEncoding
        };
    };
    /**
     * Read the encoding from the xml.
     * xml File starts with .. encoding=".."
     * @param xmlString xmlString
     * @return encoding
     */
    /**
     * Read the encoding from the xml.
     * xml File starts with .. encoding=".."
     * @param {?} xmlString xmlString
     * @return {?} encoding
     */
    XmlReader.encodingFromXml = /**
     * Read the encoding from the xml.
     * xml File starts with .. encoding=".."
     * @param {?} xmlString xmlString
     * @return {?} encoding
     */
    function (xmlString) {
        /** @type {?} */
        var index = xmlString.indexOf('encoding="');
        if (index < 0) {
            return this.DEFAULT_ENCODING; // default in xml if not explicitly set
        }
        /** @type {?} */
        var endIndex = xmlString.indexOf('"', index + 10);
        return xmlString.substring(index + 10, endIndex);
    };
    XmlReader.DEFAULT_ENCODING = 'UTF-8';
    return XmlReader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Helper class to read translation files depending on format.
 */
var /**
 * Helper class to read translation files depending on format.
 */
TranslationMessagesFileReader = /** @class */ (function () {
    function TranslationMessagesFileReader() {
    }
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param i18nFormat format
     * @param path path
     * @param encoding encoding
     * @param optionalMasterFilePath optionalMasterFilePath
     * @return XliffFile
     */
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} i18nFormat format
     * @param {?} path path
     * @param {?} encoding encoding
     * @param {?=} optionalMasterFilePath optionalMasterFilePath
     * @return {?} XliffFile
     */
    TranslationMessagesFileReader.fromFile = /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} i18nFormat format
     * @param {?} path path
     * @param {?} encoding encoding
     * @param {?=} optionalMasterFilePath optionalMasterFilePath
     * @return {?} XliffFile
     */
    function (i18nFormat, path, encoding, optionalMasterFilePath) {
        /** @type {?} */
        var xmlContent = XmlReader.readXmlFileContent(path, encoding);
        /** @type {?} */
        var optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);
        return TranslationMessagesFileFactory.fromFileContent(i18nFormat, xmlContent.content, path, xmlContent.encoding, optionalMaster);
    };
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param path path
     * @param encoding encoding
     * @param optionalMasterFilePath optionalMasterFilePath
     * @return XliffFile
     */
    /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} path path
     * @param {?} encoding encoding
     * @param {?=} optionalMasterFilePath optionalMasterFilePath
     * @return {?} XliffFile
     */
    TranslationMessagesFileReader.fromUnknownFormatFile = /**
     * Read file function, result depends on format, either XliffFile or XmbFile.
     * @param {?} path path
     * @param {?} encoding encoding
     * @param {?=} optionalMasterFilePath optionalMasterFilePath
     * @return {?} XliffFile
     */
    function (path, encoding, optionalMasterFilePath) {
        /** @type {?} */
        var xmlContent = XmlReader.readXmlFileContent(path, encoding);
        /** @type {?} */
        var optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);
        return TranslationMessagesFileFactory.fromUnknownFormatFileContent(xmlContent.content, path, xmlContent.encoding, optionalMaster);
    };
    /**
     * Read master xmb file
     * @param optionalMasterFilePath optionalMasterFilePath
     * @param encoding encoding
     * @return content and encoding of file
     */
    /**
     * Read master xmb file
     * @param {?} optionalMasterFilePath optionalMasterFilePath
     * @param {?} encoding encoding
     * @return {?} content and encoding of file
     */
    TranslationMessagesFileReader.masterFileContent = /**
     * Read master xmb file
     * @param {?} optionalMasterFilePath optionalMasterFilePath
     * @param {?} encoding encoding
     * @return {?} content and encoding of file
     */
    function (optionalMasterFilePath, encoding) {
        if (optionalMasterFilePath) {
            /** @type {?} */
            var masterXmlContent = XmlReader.readXmlFileContent(optionalMasterFilePath, encoding);
            return {
                xmlContent: masterXmlContent.content,
                path: optionalMasterFilePath,
                encoding: masterXmlContent.encoding
            };
        }
        else {
            return null;
        }
    };
    /**
     * Save edited file.
     * @param messagesFile messagesFile
     * @param beautifyOutput Flag whether to use pretty-data to format the output.
     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
     * See issue #64 for details.
     * Default is false.
     */
    /**
     * Save edited file.
     * @param {?} messagesFile messagesFile
     * @param {?=} beautifyOutput Flag whether to use pretty-data to format the output.
     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
     * See issue #64 for details.
     * Default is false.
     * @return {?}
     */
    TranslationMessagesFileReader.save = /**
     * Save edited file.
     * @param {?} messagesFile messagesFile
     * @param {?=} beautifyOutput Flag whether to use pretty-data to format the output.
     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.
     * See issue #64 for details.
     * Default is false.
     * @return {?}
     */
    function (messagesFile, beautifyOutput) {
        FileUtil.replaceContent(messagesFile.filename(), messagesFile.editedContent(beautifyOutput), messagesFile.encoding());
    };
    return TranslationMessagesFileReader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
var MAX_SEGMENTS = 128;
var AutoTranslateService = /** @class */ (function () {
    function AutoTranslateService(apiKey) {
        this._request = request;
        this._apiKey = apiKey;
        this._rootUrl = 'https://translation.googleapis.com/';
    }
    /**
     * Strip region code and convert to lower
     * @param lang lang
     * @return lang without region code and in lower case.
     */
    /**
     * Strip region code and convert to lower
     * @param {?} lang lang
     * @return {?} lang without region code and in lower case.
     */
    AutoTranslateService.stripRegioncode = /**
     * Strip region code and convert to lower
     * @param {?} lang lang
     * @return {?} lang without region code and in lower case.
     */
    function (lang) {
        /** @type {?} */
        var langLower = lang.toLowerCase();
        for (var i = 0; i < langLower.length; i++) {
            /** @type {?} */
            var c = langLower.charAt(i);
            if (c < 'a' || c > 'z') {
                return langLower.substring(0, i);
            }
        }
        return langLower;
    };
    /**
     * Change API key (just for tests).
     * @param apikey apikey
     */
    /**
     * Change API key (just for tests).
     * @param {?} apikey apikey
     * @return {?}
     */
    AutoTranslateService.prototype.setApiKey = /**
     * Change API key (just for tests).
     * @param {?} apikey apikey
     * @return {?}
     */
    function (apikey) {
        this._apiKey = apikey;
    };
    /**
     * Translate an array of messages at once.
     * @param messages the messages to be translated
     * @param from source language code
     * @param to target language code
     * @return Observable with translated messages or error
     */
    /**
     * Translate an array of messages at once.
     * @param {?} messages the messages to be translated
     * @param {?} from source language code
     * @param {?} to target language code
     * @return {?} Observable with translated messages or error
     */
    AutoTranslateService.prototype.translateMultipleStrings = /**
     * Translate an array of messages at once.
     * @param {?} messages the messages to be translated
     * @param {?} from source language code
     * @param {?} to target language code
     * @return {?} Observable with translated messages or error
     */
    function (messages, from, to) {
        var _this = this;
        // empty array needs no translation and always works ... (#78)
        if (messages.length === 0) {
            return of([]);
        }
        if (!this._apiKey) {
            return throwError('cannot autotranslate: no api key');
        }
        if (!from || !to) {
            return throwError('cannot autotranslate: source and target language must be set');
        }
        from = AutoTranslateService.stripRegioncode(from);
        to = AutoTranslateService.stripRegioncode(to);
        /** @type {?} */
        var allRequests = this.splitMessagesToGoogleLimit(messages).map(function (partialMessages) {
            return _this.limitedTranslateMultipleStrings(partialMessages, from, to);
        });
        return forkJoin(allRequests).pipe(map(function (allTranslations) {
            /** @type {?} */
            var all = [];
            for (var i = 0; i < allTranslations.length; i++) {
                all = all.concat(allTranslations[i]);
            }
            return all;
        }));
    };
    /**
     * @param {?} messages
     * @return {?}
     */
    AutoTranslateService.prototype.splitMessagesToGoogleLimit = /**
     * @param {?} messages
     * @return {?}
     */
    function (messages) {
        if (messages.length <= MAX_SEGMENTS) {
            return [messages];
        }
        /** @type {?} */
        var result = [];
        /** @type {?} */
        var currentPackage = [];
        /** @type {?} */
        var packageSize = 0;
        for (var i = 0; i < messages.length; i++) {
            currentPackage.push(messages[i]);
            packageSize++;
            if (packageSize >= MAX_SEGMENTS) {
                result.push(currentPackage);
                currentPackage = [];
                packageSize = 0;
            }
        }
        if (currentPackage.length > 0) {
            result.push(currentPackage);
        }
        return result;
    };
    /**
     * Return translation request, but messages must be limited to google limits.
     * Not more that 128 single messages.
     * @param messages messages
     * @param from from
     * @param to to
     * @return the translated strings
     */
    /**
     * Return translation request, but messages must be limited to google limits.
     * Not more that 128 single messages.
     * @param {?} messages messages
     * @param {?} from from
     * @param {?} to to
     * @return {?} the translated strings
     */
    AutoTranslateService.prototype.limitedTranslateMultipleStrings = /**
     * Return translation request, but messages must be limited to google limits.
     * Not more that 128 single messages.
     * @param {?} messages messages
     * @param {?} from from
     * @param {?} to to
     * @return {?} the translated strings
     */
    function (messages, from, to) {
        /** @type {?} */
        var realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;
        /** @type {?} */
        var translateRequest = {
            q: messages,
            target: to,
            source: from,
        };
        /** @type {?} */
        var options = {
            url: realUrl,
            body: translateRequest,
            json: true,
        };
        return this.post(realUrl, options).pipe(map(function (data) {
            /** @type {?} */
            var body = data.body;
            if (!body) {
                throw new Error('no result received');
            }
            if (body.error) {
                if (body.error.code === 400) {
                    if (body.error.message === 'Invalid Value') {
                        throw new Error(format('Translation from "%s" to "%s" not supported', from, to));
                    }
                    throw new Error(format('Invalid request: %s', body.error.message));
                }
                else {
                    throw new Error(format('Error %s: %s', body.error.code, body.error.message));
                }
            }
            /** @type {?} */
            var result = body.data;
            return result.translations.map(function (translation) {
                return translation.translatedText;
            });
        }));
    };
    /**
     * Function to do a POST HTTP request
     *
     * @param uri uri
     * @param options options
     *
     * @return response
     */
    /**
     * Function to do a POST HTTP request
     *
     * @param {?} uri uri
     * @param {?=} options options
     *
     * @return {?} response
     */
    AutoTranslateService.prototype.post = /**
     * Function to do a POST HTTP request
     *
     * @param {?} uri uri
     * @param {?=} options options
     *
     * @return {?} response
     */
    function (uri, options) {
        return (/** @type {?} */ (this._call.apply(this, [].concat('post', (/** @type {?} */ (uri)), (/** @type {?} */ (Object.assign({}, options || {})))))));
    };
    /**
     * Function to do a HTTP request for given method
     *
     * @param method method
     * @param uri uri
     * @param options options
     *
     * @return response
     *
     */
    /**
     * Function to do a HTTP request for given method
     *
     * @param {?} method method
     * @param {?} uri uri
     * @param {?=} options options
     *
     * @return {?} response
     *
     */
    AutoTranslateService.prototype._call = /**
     * Function to do a HTTP request for given method
     *
     * @param {?} method method
     * @param {?} uri uri
     * @param {?=} options options
     *
     * @return {?} response
     *
     */
    function (method, uri, options) {
        var _this = this;
        return (/** @type {?} */ (Observable.create(function (observer) {
            // build params array
            /** @type {?} */
            var params = [].concat((/** @type {?} */ (uri)), (/** @type {?} */ (Object.assign({}, options || {}))), function (error, response, body) {
                if (error) {
                    return observer.error(error);
                }
                observer.next((/** @type {?} */ (Object.assign({}, {
                    response: (/** @type {?} */ (response)),
                    body: (/** @type {?} */ (body))
                }))));
                observer.complete();
            });
            // _call request method
            try {
                _this._request[(/** @type {?} */ (method))].apply((/** @type {?} */ (_this._request)), params);
            }
            catch (error) {
                observer.error(error);
            }
        })));
    };
    return AutoTranslateService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 29.06.2017.
 */
var AutoTranslateResult = /** @class */ (function () {
    function AutoTranslateResult(_success, _details) {
        this._success = _success;
        this._details = _details;
    }
    /**
     * @return {?}
     */
    AutoTranslateResult.prototype.success = /**
     * @return {?}
     */
    function () {
        return this._success;
    };
    return AutoTranslateResult;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * A report about a run of Google Translate over all untranslated unit.
 * * Created by martin on 29.06.2017.
 */
var /**
 * A report about a run of Google Translate over all untranslated unit.
 * * Created by martin on 29.06.2017.
 */
AutoTranslateSummaryReport = /** @class */ (function () {
    function AutoTranslateSummaryReport(from, to) {
        this._from = from;
        this._to = to;
        this._total = 0;
        this._ignored = 0;
        this._success = 0;
        this._failed = 0;
    }
    /**
     * Set error if total call failed (e.g. "invalid api key" or "no connection" ...)
     * @param error error
     * @param total total
     */
    /**
     * Set error if total call failed (e.g. "invalid api key" or "no connection" ...)
     * @param {?} error error
     * @param {?} total total
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.setError = /**
     * Set error if total call failed (e.g. "invalid api key" or "no connection" ...)
     * @param {?} error error
     * @param {?} total total
     * @return {?}
     */
    function (error, total) {
        this._error = error;
        this._total = total;
        this._failed = total;
    };
    /**
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.error = /**
     * @return {?}
     */
    function () {
        return this._error;
    };
    /**
     * @param {?} ignored
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.setIgnored = /**
     * @param {?} ignored
     * @return {?}
     */
    function (ignored) {
        this._total += ignored;
        this._ignored = ignored;
    };
    /**
     * Add a single result to the summary.
     * @param tu tu
     * @param result result
     */
    /**
     * Add a single result to the summary.
     * @param {?} tu tu
     * @param {?} result result
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.addSingleResult = /**
     * Add a single result to the summary.
     * @param {?} tu tu
     * @param {?} result result
     * @return {?}
     */
    function (tu, result) {
        this._total++;
        if (result.success()) {
            this._success++;
        }
        else {
            this._failed++;
        }
    };
    /**
     * Merge another summary into this one.
     * @param anotherSummary anotherSummary
     */
    /**
     * Merge another summary into this one.
     * @param {?} anotherSummary anotherSummary
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.merge = /**
     * Merge another summary into this one.
     * @param {?} anotherSummary anotherSummary
     * @return {?}
     */
    function (anotherSummary) {
        if (!this._error) {
            this._error = anotherSummary._error;
        }
        this._total += anotherSummary.total();
        this._ignored += anotherSummary.ignored();
        this._success += anotherSummary.success();
        this._failed += anotherSummary.failed();
    };
    /**
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.total = /**
     * @return {?}
     */
    function () {
        return this._total;
    };
    /**
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.ignored = /**
     * @return {?}
     */
    function () {
        return this._ignored;
    };
    /**
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.success = /**
     * @return {?}
     */
    function () {
        return this._success;
    };
    /**
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.failed = /**
     * @return {?}
     */
    function () {
        return this._failed;
    };
    /**
     * Human readable version of report
     */
    /**
     * Human readable version of report
     * @return {?}
     */
    AutoTranslateSummaryReport.prototype.content = /**
     * Human readable version of report
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result;
        if (this._error) {
            result = format('Auto translation from "%s" to "%s" failed: "%s", failed units: %s', this._from, this._to, this._error, this._failed);
        }
        else {
            result = format('Auto translation from "%s" to "%s", total auto translated units: %s, ignored: %s, succesful: %s, failed: %s', this._from, this._to, this._total, this._ignored, this._success, this._failed);
        }
        return result;
    };
    return AutoTranslateSummaryReport;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 07.07.2017.
 * Service to autotranslate Transunits via Google Translate.
 */
var /**
 * Created by martin on 07.07.2017.
 * Service to autotranslate Transunits via Google Translate.
 */
XliffMergeAutoTranslateService = /** @class */ (function () {
    function XliffMergeAutoTranslateService(apikey) {
        this.autoTranslateService = new AutoTranslateService(apikey);
    }
    /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param from from
     * @param to to
     * @param languageSpecificMessagesFile languageSpecificMessagesFile
     * @return a promise with the execution result as a summary report.
     */
    /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param {?} from from
     * @param {?} to to
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} a promise with the execution result as a summary report.
     */
    XliffMergeAutoTranslateService.prototype.autoTranslate = /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param {?} from from
     * @param {?} to to
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} a promise with the execution result as a summary report.
     */
    function (from, to, languageSpecificMessagesFile) {
        return forkJoin(__spread([
            this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile)
        ], this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)))
            .pipe(map(function (summaries) {
            /** @type {?} */
            var summary = summaries[0];
            for (var i = 1; i < summaries.length; i++) {
                summary.merge(summaries[i]);
            }
            return summary;
        }));
    };
    /**
     * Collect all units that are untranslated.
     * @param languageSpecificMessagesFile languageSpecificMessagesFile
     * @return all untranslated units
     */
    /**
     * Collect all units that are untranslated.
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} all untranslated units
     */
    XliffMergeAutoTranslateService.prototype.allUntranslatedTUs = /**
     * Collect all units that are untranslated.
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} all untranslated units
     */
    function (languageSpecificMessagesFile) {
        // collect all units, that should be auto translated
        /** @type {?} */
        var allUntranslated = [];
        languageSpecificMessagesFile.forEachTransUnit(function (tu) {
            if (tu.targetState() === STATE_NEW) {
                allUntranslated.push(tu);
            }
        });
        return allUntranslated;
    };
    /**
     * @param {?} from
     * @param {?} to
     * @param {?} languageSpecificMessagesFile
     * @return {?}
     */
    XliffMergeAutoTranslateService.prototype.doAutoTranslateNonICUMessages = /**
     * @param {?} from
     * @param {?} to
     * @param {?} languageSpecificMessagesFile
     * @return {?}
     */
    function (from, to, languageSpecificMessagesFile) {
        var _this = this;
        /** @type {?} */
        var allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);
        /** @type {?} */
        var allTranslatable = allUntranslated.filter(function (tu) { return isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()); });
        /** @type {?} */
        var allMessages = allTranslatable.map(function (tu) {
            return tu.sourceContentNormalized().asDisplayString();
        });
        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)
            .pipe(
        // #94 google translate might return &#.. entity refs, that must be decoded
        map(function (translations) { return translations.map(function (encodedTranslation) { return decode(encodedTranslation); }); }), map(function (translations) {
            /** @type {?} */
            var summary = new AutoTranslateSummaryReport(from, to);
            summary.setIgnored(allUntranslated.length - allTranslatable.length);
            for (var i = 0; i < translations.length; i++) {
                /** @type {?} */
                var tu = allTranslatable[i];
                /** @type {?} */
                var translationText = translations[i];
                /** @type {?} */
                var result = _this.autoTranslateNonICUUnit(tu, translationText);
                summary.addSingleResult(tu, result);
            }
            return summary;
        }), catchError(function (err) {
            /** @type {?} */
            var failSummary = new AutoTranslateSummaryReport(from, to);
            failSummary.setError(err.message, allMessages.length);
            return of(failSummary);
        }));
    };
    /**
     * @param {?} from
     * @param {?} to
     * @param {?} languageSpecificMessagesFile
     * @return {?}
     */
    XliffMergeAutoTranslateService.prototype.doAutoTranslateICUMessages = /**
     * @param {?} from
     * @param {?} to
     * @param {?} languageSpecificMessagesFile
     * @return {?}
     */
    function (from, to, languageSpecificMessagesFile) {
        var _this = this;
        /** @type {?} */
        var allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);
        /** @type {?} */
        var allTranslatableICU = allUntranslated.filter(function (tu) { return !isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()); });
        return allTranslatableICU.map(function (tu) {
            return _this.doAutoTranslateICUMessage(from, to, tu);
        });
    };
    /**
     * Translate single ICU Messages.
     * @param from from
     * @param to to
     * @param tu transunit to translate (must contain ICU Message)
     * @return summary report
     */
    /**
     * Translate single ICU Messages.
     * @param {?} from from
     * @param {?} to to
     * @param {?} tu transunit to translate (must contain ICU Message)
     * @return {?} summary report
     */
    XliffMergeAutoTranslateService.prototype.doAutoTranslateICUMessage = /**
     * Translate single ICU Messages.
     * @param {?} from from
     * @param {?} to to
     * @param {?} tu transunit to translate (must contain ICU Message)
     * @return {?} summary report
     */
    function (from, to, tu) {
        var _this = this;
        /** @type {?} */
        var icuMessage = tu.sourceContentNormalized().getICUMessage();
        /** @type {?} */
        var categories = icuMessage.getCategories();
        // check for nested ICUs, we do not support that
        if (categories.find(function (category) { return !isNullOrUndefined(category.getMessageNormalized().getICUMessage()); })) {
            /** @type {?} */
            var summary = new AutoTranslateSummaryReport(from, to);
            summary.setIgnored(1);
            return of(summary);
        }
        /** @type {?} */
        var allMessages = categories.map(function (category) { return category.getMessageNormalized().asDisplayString(); });
        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)
            .pipe(
        // #94 google translate might return &#.. entity refs, that must be decoded
        map(function (translations) { return translations.map(function (encodedTranslation) { return decode(encodedTranslation); }); }), map(function (translations) {
            /** @type {?} */
            var summary = new AutoTranslateSummaryReport(from, to);
            /** @type {?} */
            var icuTranslation = {};
            for (var i = 0; i < translations.length; i++) {
                icuTranslation[categories[i].getCategory()] = translations[i];
            }
            /** @type {?} */
            var result = _this.autoTranslateICUUnit(tu, icuTranslation);
            summary.addSingleResult(tu, result);
            return summary;
        }), catchError(function (err) {
            /** @type {?} */
            var failSummary = new AutoTranslateSummaryReport(from, to);
            failSummary.setError(err.message, allMessages.length);
            return of(failSummary);
        }));
    };
    /**
     * @param {?} tu
     * @param {?} translatedMessage
     * @return {?}
     */
    XliffMergeAutoTranslateService.prototype.autoTranslateNonICUUnit = /**
     * @param {?} tu
     * @param {?} translatedMessage
     * @return {?}
     */
    function (tu, translatedMessage) {
        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));
    };
    /**
     * @param {?} tu
     * @param {?} translation
     * @return {?}
     */
    XliffMergeAutoTranslateService.prototype.autoTranslateICUUnit = /**
     * @param {?} tu
     * @param {?} translation
     * @return {?}
     */
    function (tu, translation) {
        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));
    };
    /**
     * @param {?} tu
     * @param {?} translatedMessage
     * @return {?}
     */
    XliffMergeAutoTranslateService.prototype.autoTranslateUnit = /**
     * @param {?} tu
     * @param {?} translatedMessage
     * @return {?}
     */
    function (tu, translatedMessage) {
        /** @type {?} */
        var errors = translatedMessage.validate();
        /** @type {?} */
        var warnings = translatedMessage.validateWarnings();
        if (!isNullOrUndefined(errors)) {
            return new AutoTranslateResult(false, 'errors detected, not translated');
        }
        else if (!isNullOrUndefined(warnings)) {
            return new AutoTranslateResult(false, 'warnings detected, not translated');
        }
        else {
            tu.translate(translatedMessage);
            return new AutoTranslateResult(true, null); // success
        }
    };
    return XliffMergeAutoTranslateService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Created by martin on 17.02.2017.
 * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.
 *
 */
var  /**
 * Created by martin on 17.02.2017.
 * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.
 *
 */
XliffMerge = /** @class */ (function () {
    function XliffMerge(commandOutput, options) {
        this.commandOutput = commandOutput;
        this.options = options;
        this.parameters = null;
    }
    /**
     * @param {?} argv
     * @return {?}
     */
    XliffMerge.main = /**
     * @param {?} argv
     * @return {?}
     */
    function (argv) {
        /** @type {?} */
        var options = XliffMerge.parseArgs(argv);
        if (options) {
            new XliffMerge(new CommandOutput(process.stdout), options).run(function (result) {
                process.exit(result);
            });
        }
    };
    /**
     * @param {?} argv
     * @return {?}
     */
    XliffMerge.parseArgs = /**
     * @param {?} argv
     * @return {?}
     */
    function (argv) {
        /** @type {?} */
        var options = {
            languages: []
        };
        for (var i = 1; i < argv.length; i++) {
            /** @type {?} */
            var arg = argv[i];
            if (arg === '--version' || arg === '-version') {
                console.log('xliffmerge ' + VERSION);
            }
            else if (arg === '--verbose' || arg === '-v') {
                options.verbose = true;
            }
            else if (arg === '--profile' || arg === '-p') {
                i++;
                if (i >= argv.length) {
                    console.log('missing config file');
                    XliffMerge.showUsage();
                    return null;
                }
                else {
                    options.profilePath = argv[i];
                }
            }
            else if (arg === '--quiet' || arg === '-q') {
                options.quiet = true;
            }
            else if (arg === '--help' || arg === '-help' || arg === '-h') {
                XliffMerge.showUsage();
            }
            else if (arg.length > 0 && arg.charAt(0) === '-') {
                console.log('unknown option');
                return null;
            }
            else {
                options.languages.push(arg);
            }
        }
        return options;
    };
    /**
     * @return {?}
     */
    XliffMerge.showUsage = /**
     * @return {?}
     */
    function () {
        console.log('usage: xliffmerge <option>* <language>*');
        console.log('Options');
        console.log('\t-p|--profile a json configuration file containing all relevant parameters.');
        console.log('\t\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');
        console.log('\t-v|--verbose show some output for debugging purposes');
        console.log('\t-q|--quiet only show errors, nothing else');
        console.log('\t-version|--version show version string');
        console.log('');
        console.log('\t<language> has to be a valid language short string, e,g. "en", "de", "de-ch"');
    };
    /**
     * For Tests, create instance with given profile
     * @param commandOutput commandOutput
     * @param options options
     * @param profileContent profileContent
     */
    /**
     * For Tests, create instance with given profile
     * @param {?} commandOutput commandOutput
     * @param {?} options options
     * @param {?=} profileContent profileContent
     * @return {?}
     */
    XliffMerge.createFromOptions = /**
     * For Tests, create instance with given profile
     * @param {?} commandOutput commandOutput
     * @param {?} options options
     * @param {?=} profileContent profileContent
     * @return {?}
     */
    function (commandOutput, options, profileContent) {
        /** @type {?} */
        var instance = new XliffMerge(commandOutput, options);
        instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);
        return instance;
    };
    /**
     * Run the command.
     * This runs async.
     * @param callbackFunction when command is executed, called with the return code (0 for ok), if given.
     * @param errorFunction callbackFunction for error handling
     */
    /**
     * Run the command.
     * This runs async.
     * @param {?=} callbackFunction when command is executed, called with the return code (0 for ok), if given.
     * @param {?=} errorFunction callbackFunction for error handling
     * @return {?}
     */
    XliffMerge.prototype.run = /**
     * Run the command.
     * This runs async.
     * @param {?=} callbackFunction when command is executed, called with the return code (0 for ok), if given.
     * @param {?=} errorFunction callbackFunction for error handling
     * @return {?}
     */
    function (callbackFunction, errorFunction) {
        this.runAsync()
            .subscribe(function (retcode) {
            if (!isNullOrUndefined(callbackFunction)) {
                callbackFunction(retcode);
            }
        }, function (error) {
            if (!isNullOrUndefined(errorFunction)) {
                errorFunction(error);
            }
        });
    };
    /**
     * Execute merge-Process.
     * @return Async operation, on completion returns retcode 0=ok, other = error.
     */
    /**
     * Execute merge-Process.
     * @return {?} Async operation, on completion returns retcode 0=ok, other = error.
     */
    XliffMerge.prototype.runAsync = /**
     * Execute merge-Process.
     * @return {?} Async operation, on completion returns retcode 0=ok, other = error.
     */
    function () {
        var _this = this;
        var e_1, _a, e_2, _b;
        if (this.options && this.options.quiet) {
            this.commandOutput.setQuiet();
        }
        if (this.options && this.options.verbose) {
            this.commandOutput.setVerbose();
        }
        if (!this.parameters) {
            this.parameters = XliffMergeParameters.createFromOptions(this.options);
        }
        this.commandOutput.info('xliffmerge version %s', VERSION);
        if (this.parameters.verbose()) {
            this.parameters.showAllParameters(this.commandOutput);
        }
        if (this.parameters.errorsFound.length > 0) {
            try {
                for (var _c = __values(this.parameters.errorsFound), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var err = _d.value;
                    this.commandOutput.error(err.message);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return of(-1);
        }
        if (this.parameters.warningsFound.length > 0) {
            try {
                for (var _e = __values(this.parameters.warningsFound), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var warn = _f.value;
                    this.commandOutput.warn(warn);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        this.readMaster();
        if (this.parameters.autotranslate()) {
            this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());
        }
        /** @type {?} */
        var executionForAllLanguages = [];
        this.parameters.languages().forEach(function (lang) {
            executionForAllLanguages.push(_this.processLanguage(lang));
        });
        return forkJoin(executionForAllLanguages).pipe(map(function (retcodes) { return _this.totalRetcode(retcodes); }));
    };
    /**
     * Give an array of retcodes for the different languages, return the total retcode.
     * If all are 0, it is 0, otherwise the first non zero.
     * @param retcodes retcodes
     * @return number
     */
    /**
     * Give an array of retcodes for the different languages, return the total retcode.
     * If all are 0, it is 0, otherwise the first non zero.
     * @param {?} retcodes retcodes
     * @return {?} number
     */
    XliffMerge.prototype.totalRetcode = /**
     * Give an array of retcodes for the different languages, return the total retcode.
     * If all are 0, it is 0, otherwise the first non zero.
     * @param {?} retcodes retcodes
     * @return {?} number
     */
    function (retcodes) {
        for (var i = 0; i < retcodes.length; i++) {
            if (retcodes[i] !== 0) {
                return retcodes[i];
            }
        }
        return 0;
    };
    /**
     * Return the name of the generated file for given lang.
     * @param lang language
     * @return name of generated file
     */
    /**
     * Return the name of the generated file for given lang.
     * @param {?} lang language
     * @return {?} name of generated file
     */
    XliffMerge.prototype.generatedI18nFile = /**
     * Return the name of the generated file for given lang.
     * @param {?} lang language
     * @return {?} name of generated file
     */
    function (lang) {
        return this.parameters.generatedI18nFile(lang);
    };
    /**
     * Return the name of the generated ngx-translation file for given lang.
     * @param lang language
     * @return name of translate file
     */
    /**
     * Return the name of the generated ngx-translation file for given lang.
     * @param {?} lang language
     * @return {?} name of translate file
     */
    XliffMerge.prototype.generatedNgxTranslateFile = /**
     * Return the name of the generated ngx-translation file for given lang.
     * @param {?} lang language
     * @return {?} name of translate file
     */
    function (lang) {
        return this.parameters.generatedNgxTranslateFile(lang);
    };
    /**
     * Warnings found during the run.
     * @return warnings
     */
    /**
     * Warnings found during the run.
     * @return {?} warnings
     */
    XliffMerge.prototype.warnings = /**
     * Warnings found during the run.
     * @return {?} warnings
     */
    function () {
        return this.parameters.warningsFound;
    };
    /**
     * @return {?}
     */
    XliffMerge.prototype.readMaster = /**
     * @return {?}
     */
    function () {
        var _this = this;
        try {
            this.master = TranslationMessagesFileReader.fromFile(this.parameters.i18nFormat(), this.parameters.i18nFile(), this.parameters.encoding());
            this.master.warnings().forEach(function (warning) {
                _this.commandOutput.warn(warning);
            });
            /** @type {?} */
            var count = this.master.numberOfTransUnits();
            /** @type {?} */
            var missingIdCount = this.master.numberOfTransUnitsWithMissingId();
            this.commandOutput.info('master contains %s trans-units', count);
            if (missingIdCount > 0) {
                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);
            }
            /** @type {?} */
            var sourceLang = this.master.sourceLanguage();
            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {
                this.commandOutput.warn('master says to have source-language="%s", should be "%s" (your defaultLanguage)', sourceLang, this.parameters.defaultLanguage());
                this.master.setSourceLanguage(this.parameters.defaultLanguage());
                TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());
                this.commandOutput.warn('changed master source-language="%s" to "%s"', sourceLang, this.parameters.defaultLanguage());
            }
        }
        catch (err) {
            if (err instanceof XliffMergeError) {
                this.commandOutput.error(err.message);
                return of(-1);
            }
            else {
                // unhandled
                /** @type {?} */
                var currentFilename = this.parameters.i18nFile();
                /** @type {?} */
                var filenameString = (currentFilename) ? format('file "%s", ', currentFilename) : '';
                this.commandOutput.error(filenameString + 'oops ' + err);
                throw err;
            }
        }
    };
    /**
     * Process the given language.
     * Async operation.
     * @param lang language
     * @return on completion 0 for ok, other for error
     */
    /**
     * Process the given language.
     * Async operation.
     * @param {?} lang language
     * @return {?} on completion 0 for ok, other for error
     */
    XliffMerge.prototype.processLanguage = /**
     * Process the given language.
     * Async operation.
     * @param {?} lang language
     * @return {?} on completion 0 for ok, other for error
     */
    function (lang) {
        var _this = this;
        this.commandOutput.debug('processing language %s', lang);
        /** @type {?} */
        var languageXliffFile = this.parameters.generatedI18nFile(lang);
        /** @type {?} */
        var currentFilename = languageXliffFile;
        /** @type {?} */
        var result;
        if (!FileUtil.exists(languageXliffFile)) {
            result = this.createUntranslatedXliff(lang, languageXliffFile);
        }
        else {
            result = this.mergeMasterTo(lang, languageXliffFile);
        }
        return result
            .pipe(map(function () {
            if (_this.parameters.supportNgxTranslate()) {
                /** @type {?} */
                var languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(_this.translationFormat(_this.parameters.i18nFormat()), languageXliffFile, _this.parameters.encoding(), _this.master.filename());
                NgxTranslateExtractor.extract(languageSpecificMessagesFile, _this.parameters.ngxTranslateExtractionPattern(), _this.parameters.generatedNgxTranslateFile(lang));
            }
            return 0;
        }), catchError(function (err) {
            if (err instanceof XliffMergeError) {
                _this.commandOutput.error(err.message);
                return of(-1);
            }
            else {
                // unhandled
                /** @type {?} */
                var filenameString = (currentFilename) ? format('file "%s", ', currentFilename) : '';
                _this.commandOutput.error(filenameString + 'oops ' + err);
                throw err;
            }
        }));
    };
    /**
     * create a new file for the language, which contains no translations, but all keys.
     * in principle, this is just a copy of the master with target-language set.
     * @param lang language
     * @param languageXliffFilePath name of file
     */
    /**
     * create a new file for the language, which contains no translations, but all keys.
     * in principle, this is just a copy of the master with target-language set.
     * @param {?} lang language
     * @param {?} languageXliffFilePath name of file
     * @return {?}
     */
    XliffMerge.prototype.createUntranslatedXliff = /**
     * create a new file for the language, which contains no translations, but all keys.
     * in principle, this is just a copy of the master with target-language set.
     * @param {?} lang language
     * @param {?} languageXliffFilePath name of file
     * @return {?}
     */
    function (lang, languageXliffFilePath) {
        var _this = this;
        // copy master ...
        // and set target-language
        // and copy source to target if necessary
        /** @type {?} */
        var isDefaultLang = (lang === this.parameters.defaultLanguage());
        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
        /** @type {?} */
        var languageSpecificMessagesFile = this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());
        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(map(function (summary) {
            // write it to file
            TranslationMessagesFileReader.save(languageSpecificMessagesFile, _this.parameters.beautifyOutput());
            _this.commandOutput.info('created new file "%s" for target-language="%s"', languageXliffFilePath, lang);
            if (!isDefaultLang) {
                _this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
            }
            return null;
        }));
    };
    /**
     * Map the input format to the format of the translation.
     * Normally they are the same but for xmb the translation format is xtb.
     * @param i18nFormat format
     */
    /**
     * Map the input format to the format of the translation.
     * Normally they are the same but for xmb the translation format is xtb.
     * @param {?} i18nFormat format
     * @return {?}
     */
    XliffMerge.prototype.translationFormat = /**
     * Map the input format to the format of the translation.
     * Normally they are the same but for xmb the translation format is xtb.
     * @param {?} i18nFormat format
     * @return {?}
     */
    function (i18nFormat) {
        if (i18nFormat === FORMAT_XMB) {
            return FORMAT_XTB;
        }
        else {
            return i18nFormat;
        }
    };
    /**
     * Merge all
     * @param lang language
     * @param languageXliffFilePath filename
     */
    /**
     * Merge all
     * @param {?} lang language
     * @param {?} languageXliffFilePath filename
     * @return {?}
     */
    XliffMerge.prototype.mergeMasterTo = /**
     * Merge all
     * @param {?} lang language
     * @param {?} languageXliffFilePath filename
     * @return {?}
     */
    function (lang, languageXliffFilePath) {
        var _this = this;
        // read lang specific file
        /** @type {?} */
        var languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFilePath, this.parameters.encoding());
        /** @type {?} */
        var isDefaultLang = (lang === this.parameters.defaultLanguage());
        /** @type {?} */
        var newCount = 0;
        /** @type {?} */
        var correctSourceContentCount = 0;
        /** @type {?} */
        var correctSourceRefCount = 0;
        /** @type {?} */
        var correctDescriptionOrMeaningCount = 0;
        /** @type {?} */
        var idChangedCount = 0;
        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
        /** @type {?} */
        var lastProcessedUnit = null;
        this.master.forEachTransUnit(function (masterTransUnit) {
            /** @type {?} */
            var transUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);
            if (!transUnit) {
                // oops, no translation, must be a new key, so add it
                /** @type {?} */
                var newUnit = void 0;
                if (_this.parameters.allowIdChange()
                    && (newUnit = _this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {
                    lastProcessedUnit = newUnit;
                    idChangedCount++;
                }
                else {
                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, isDefaultLang, _this.parameters.useSourceAsTarget(), (_this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);
                    newCount++;
                }
            }
            else {
                // check for changed source content and change it if needed
                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.
                if (transUnit.supportsSetSourceContent() && masterTransUnit.sourceContent() !== transUnit.sourceContent()) {
                    transUnit.setSourceContent(masterTransUnit.sourceContent());
                    if (isDefaultLang) {
                        // #81 changed source must be copied to target for default lang
                        transUnit.translate(masterTransUnit.sourceContent());
                        transUnit.setTargetState(STATE_FINAL);
                    }
                    else {
                        if (transUnit.targetState() === STATE_FINAL) {
                            // source is changed, so translation has to be checked again
                            transUnit.setTargetState(STATE_TRANSLATED);
                        }
                    }
                    correctSourceContentCount++;
                }
                // check for missing or changed source ref and add it if needed
                if (transUnit.supportsSetSourceReferences()
                    && !_this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {
                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());
                    correctSourceRefCount++;
                }
                // check for changed description or meaning
                if (transUnit.supportsSetDescriptionAndMeaning()) {
                    /** @type {?} */
                    var changed = false;
                    if (transUnit.description() !== masterTransUnit.description()) {
                        transUnit.setDescription(masterTransUnit.description());
                        changed = true;
                    }
                    if (transUnit.meaning() !== masterTransUnit.meaning()) {
                        transUnit.setMeaning(masterTransUnit.meaning());
                        changed = true;
                    }
                    if (changed) {
                        correctDescriptionOrMeaningCount++;
                    }
                }
                lastProcessedUnit = transUnit;
            }
        });
        if (newCount > 0) {
            this.commandOutput.warn('merged %s trans-units from master to "%s"', newCount, lang);
        }
        if (correctSourceContentCount > 0) {
            this.commandOutput.warn('transferred %s changed source content from master to "%s"', correctSourceContentCount, lang);
        }
        if (correctSourceRefCount > 0) {
            this.commandOutput.warn('transferred %s source references from master to "%s"', correctSourceRefCount, lang);
        }
        if (idChangedCount > 0) {
            this.commandOutput.warn('found %s changed id\'s in "%s"', idChangedCount, lang);
        }
        if (correctDescriptionOrMeaningCount > 0) {
            this.commandOutput.warn('transferred %s changed descriptions/meanings from master to "%s"', correctDescriptionOrMeaningCount, lang);
        }
        // remove all elements that are no longer used
        /** @type {?} */
        var removeCount = 0;
        languageSpecificMessagesFile.forEachTransUnit(function (transUnit) {
            /** @type {?} */
            var existsInMaster = !isNullOrUndefined(_this.master.transUnitWithId(transUnit.id));
            if (!existsInMaster) {
                if (_this.parameters.removeUnusedIds()) {
                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);
                }
                removeCount++;
            }
        });
        if (removeCount > 0) {
            if (this.parameters.removeUnusedIds()) {
                this.commandOutput.warn('removed %s unused trans-units in "%s"', removeCount, lang);
            }
            else {
                this.commandOutput.warn('keeping %s unused trans-units in "%s", because removeUnused is disabled', removeCount, lang);
            }
        }
        if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0
            && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {
            this.commandOutput.info('file for "%s" was up to date', lang);
            return of(null);
        }
        else {
            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)
                .pipe(map(function () {
                // write it to file
                TranslationMessagesFileReader.save(languageSpecificMessagesFile, _this.parameters.beautifyOutput());
                _this.commandOutput.info('updated file "%s" for target-language="%s"', languageXliffFilePath, lang);
                if (newCount > 0 && !isDefaultLang) {
                    _this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
                }
                return null;
            }));
        }
    };
    /**
     * Handle the case of changed id due to small white space changes.
     * @param masterTransUnit unit in master file
     * @param languageSpecificMessagesFile translation file
     * @param lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.
     * @return processed unit, if done, null if no changed unit found
     */
    /**
     * Handle the case of changed id due to small white space changes.
     * @param {?} masterTransUnit unit in master file
     * @param {?} languageSpecificMessagesFile translation file
     * @param {?} lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.
     * @return {?} processed unit, if done, null if no changed unit found
     */
    XliffMerge.prototype.processChangedIdUnit = /**
     * Handle the case of changed id due to small white space changes.
     * @param {?} masterTransUnit unit in master file
     * @param {?} languageSpecificMessagesFile translation file
     * @param {?} lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.
     * @return {?} processed unit, if done, null if no changed unit found
     */
    function (masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit) {
        /** @type {?} */
        var masterSourceString = masterTransUnit.sourceContentNormalized().asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();
        /** @type {?} */
        var changedTransUnit = null;
        languageSpecificMessagesFile.forEachTransUnit(function (languageTransUnit) {
            if (languageTransUnit.sourceContentNormalized().asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim() === masterSourceString) {
                changedTransUnit = languageTransUnit;
            }
        });
        if (!changedTransUnit) {
            return null;
        }
        /** @type {?} */
        var mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, false, false, (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);
        /** @type {?} */
        var translatedContent = changedTransUnit.targetContent();
        if (translatedContent) { // issue #68 set translated only, if it is really translated
            mergedTransUnit.translate(translatedContent);
            mergedTransUnit.setTargetState(STATE_TRANSLATED);
        }
        return mergedTransUnit;
    };
    /**
     * @param {?} ref1
     * @param {?} ref2
     * @return {?}
     */
    XliffMerge.prototype.areSourceReferencesEqual = /**
     * @param {?} ref1
     * @param {?} ref2
     * @return {?}
     */
    function (ref1, ref2) {
        if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {
            return false;
        }
        if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {
            return true;
        }
        // bot refs are set now, convert to set to compare them
        /** @type {?} */
        var set1 = new Set();
        ref1.forEach(function (ref) { set1.add(ref.sourcefile + ':' + ref.linenumber); });
        /** @type {?} */
        var set2 = new Set();
        ref2.forEach(function (ref) { set2.add(ref.sourcefile + ':' + ref.linenumber); });
        if (set1.size !== set2.size) {
            return false;
        }
        /** @type {?} */
        var match = true;
        set2.forEach(function (ref) {
            if (!set1.has(ref)) {
                match = false;
            }
        });
        return match;
    };
    /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param from from
     * @param to to
     * @param languageSpecificMessagesFile languageSpecificMessagesFile
     * @return a promise with the execution result as a summary report.
     */
    /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param {?} from from
     * @param {?} to to
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} a promise with the execution result as a summary report.
     */
    XliffMerge.prototype.autoTranslate = /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param {?} from from
     * @param {?} to to
     * @param {?} languageSpecificMessagesFile languageSpecificMessagesFile
     * @return {?} a promise with the execution result as a summary report.
     */
    function (from, to, languageSpecificMessagesFile) {
        var _this = this;
        /** @type {?} */
        var serviceCall;
        /** @type {?} */
        var autotranslateEnabled = this.parameters.autotranslateLanguage(to);
        if (autotranslateEnabled) {
            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);
        }
        else {
            serviceCall = of(new AutoTranslateSummaryReport(from, to));
        }
        return serviceCall.pipe(map(function (summary) {
            if (autotranslateEnabled) {
                if (summary.error() || summary.failed() > 0) {
                    _this.commandOutput.error(summary.content());
                }
                else {
                    _this.commandOutput.warn(summary.content());
                }
            }
            return summary;
        }));
    };
    return XliffMerge;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { WriterToString, CommandOutput, XliffMerge, XliffmergeModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWkxOG5zdXBwb3J0LW5neC1pMThuc3VwcG9ydC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvbGliL3hsaWZmbWVyZ2UubW9kdWxlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC9jb21tb24vdXRpbC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvY29tbW9uL3dyaXRlci10by1zdHJpbmcudHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0L2NvbW1vbi9jb21tYW5kLW91dHB1dC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS94bGlmZi1tZXJnZS1lcnJvci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvY29tbW9uL2ZpbGUtdXRpbC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS9uZ3gtdHJhbnNsYXRlLWV4dHJhY3Rpb24tcGF0dGVybi50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS9uZ3gtdHJhbnNsYXRlLWV4dHJhY3Rvci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS94bGlmZi1tZXJnZS1wYXJhbWV0ZXJzLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC94bGlmZm1lcmdlL3ZlcnNpb24udHMiLCJuZzovL0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0L3hsaWZmbWVyZ2UveG1sLXJlYWRlci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQveGxpZmZtZXJnZS90cmFuc2xhdGlvbi1tZXNzYWdlcy1maWxlLXJlYWRlci50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvYXV0b3RyYW5zbGF0ZS9hdXRvLXRyYW5zbGF0ZS1zZXJ2aWNlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC9hdXRvdHJhbnNsYXRlL2F1dG8tdHJhbnNsYXRlLXJlc3VsdC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvYXV0b3RyYW5zbGF0ZS9hdXRvLXRyYW5zbGF0ZS1zdW1tYXJ5LXJlcG9ydC50cyIsIm5nOi8vQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQvYXV0b3RyYW5zbGF0ZS94bGlmZi1tZXJnZS1hdXRvLXRyYW5zbGF0ZS1zZXJ2aWNlLnRzIiwibmc6Ly9Abmd4LWkxOG5zdXBwb3J0L25neC1pMThuc3VwcG9ydC94bGlmZm1lcmdlL3hsaWZmLW1lcmdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vLyBub3QgdXNlZCwgb25seSB0aGVyZSB0byBtYWtlIG5nLXBhY2thZ3IgaGFwcHlcclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgIF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtdLFxyXG4gICAgZXhwb3J0czogW11cclxufSlcclxuZXhwb3J0IGNsYXNzIFhsaWZmbWVyZ2VNb2R1bGUgeyB9XHJcbiIsIi8qKlxyXG4gKiBDb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgYXJlIGRlcHJlY2F0ZWQgaW4gbm9kZXMgdXRpbC5cclxuICovXHJcblxyXG4vKipcclxuICogUmVwbGFjZXMgbm9kZSBpc051bGxPclVuZGVmaW5lZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZTogYW55KSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIG5vZGUgaXNTdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IGFueSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXBsYWNlcyBub2RlIGlzQm9vbGVhbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWU6IGFueSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwbGFjZXMgbm9kZSBpc051bWJlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZTogYW55KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIG5vZGUgaXNBcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KHZhbHVlOiBhbnkpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcclxufVxyXG4iLCJpbXBvcnQge1dyaXRhYmxlfSBmcm9tICdzdHJlYW0nO1xyXG5pbXBvcnQge2lzU3RyaW5nfSBmcm9tICcuL3V0aWwnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMjAuMDIuMjAxNy5cclxuICogQSBoZWxwZXIgY2xhc3MgZm9yIHRlc3RpbmcuXHJcbiAqIENhbiBiZSB1c2VkIGFzIGEgV3JpdGFibGVTdHJlYW0gYW5kIHdyaXRlcyBldmVyeXRoaW5nIChzeW5jaHJvbm91c2x5KSBpbnRvIGEgc3RyaW5nLFxyXG4gKiB0aGF0IGNhbiBlYXNpbHkgYmUgcmVhZCBieSB0aGUgdGVzdHMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFdyaXRlclRvU3RyaW5nIGV4dGVuZHMgV3JpdGFibGUge1xyXG5cclxuICAgIHByaXZhdGUgcmVzdWx0U3RyaW5nOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnJlc3VsdFN0cmluZyA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfd3JpdGUoY2h1bms6IGFueSwgZW5jb2Rpbmc6IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGNodW5rU3RyaW5nO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaHVuaykpIHtcclxuICAgICAgICAgICAgY2h1bmtTdHJpbmcgPSBjaHVuaztcclxuICAgICAgICB9IGVsc2UgaWYgKGNodW5rIGluc3RhbmNlb2YgQnVmZmVyKSB7XHJcbiAgICAgICAgICAgIGNodW5rU3RyaW5nID0gY2h1bmsudG9TdHJpbmcoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaHVua1N0cmluZyA9IEJ1ZmZlci5hbGxvYyhjaHVuaykudG9TdHJpbmcoZW5jb2RpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3VsdFN0cmluZyA9IHRoaXMucmVzdWx0U3RyaW5nICsgY2h1bmtTdHJpbmc7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgb2YgZXZlcnl0aGluZywgdGhhdCB3YXMgd3JpdHRlbiB0byB0aGUgc3RyZWFtIHNvIGZhci5cclxuICAgICAqIEByZXR1cm4gd3JpdHRlbiBkYXRhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB3cml0dGVuRGF0YSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdFN0cmluZztcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTcuMDIuMjAxNy5cclxuICogVmVyeSBzaW1wbGUgY2xhc3MgdG8gY29udHJvbCB0aGUgb3V0cHV0IG9mIGEgY29tbWFuZC5cclxuICogT3V0cHV0IGNhbiBiZSBlcnJvcnMsIHdhcm5pbmdzLCBpbmZvcyBhbmQgZGVidWctT3V0cHV0cy5cclxuICogVGhlIG91dHB1dCBjYW4gYmUgY29udHJvbGxlZCB2aWEgMiBmbGFncywgcXVpZXQgYW5kIHZlcmJvc2UuXHJcbiAqIElmIHF1aXQgaXMgZW5hYmxlZCBvbmx5IGVycm9yIG1lc3NhZ2VzIGFyZSBzaG93bi5cclxuICogSWYgdmVyYm9zZSBpcyBlbmFibGVkLCBldmVyeXRoaW5nIGlzIHNob3duLlxyXG4gKiBJZiBib3RoIGFyZSBub3QgZW5hYmxlZCAodGhlIGRlZmF1bHQpIGVycm9ycywgd2FybmluZ3MgYW5kIGluZm9zIGFyZSBzaG93bi5cclxuICogSWYgbm90IGFyZSBlbmFibGVkIChzdHJhbmdlKSwgd2UgYXNzdW1lZCB0aGUgZGVmYXVsdC5cclxuICovXHJcblxyXG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xyXG5pbXBvcnQgV3JpdGFibGVTdHJlYW0gPSBOb2RlSlMuV3JpdGFibGVTdHJlYW07XHJcbmltcG9ydCB7Zm9ybWF0fSBmcm9tICd1dGlsJztcclxuXHJcbmVudW0gTG9nTGV2ZWwge1xyXG4gICAgJ0VSUk9SJyxcclxuICAgICdXQVJOJyxcclxuICAgICdJTkZPJyxcclxuICAgICdERUJVRydcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENvbW1hbmRPdXRwdXQge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdmVyYm9zZSBlbmFibGVzIG91dHB1dCBvZiBldmVyeXRoaW5nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgX3ZlcmJvc2U6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBxdWlldCBkaXNhYmxlcyBvdXRwdXQgb2YgZXZlcnl0aGluZyBidXQgZXJyb3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgX3F1aWV0OiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgb3V0cHV0U3RyZWFtOiBXcml0YWJsZVN0cmVhbTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzdGRvdXQ/OiBXcml0YWJsZVN0cmVhbSkge1xyXG4gICAgICAgIHRoaXMuX3F1aWV0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdmVyYm9zZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChzdGRvdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRTdHJlYW0gPSBzdGRvdXQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRTdHJlYW0gPSBwcm9jZXNzLnN0ZG91dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFZlcmJvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5fdmVyYm9zZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFF1aWV0KCkge1xyXG4gICAgICAgIHRoaXMuX3F1aWV0ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QsIHdldGhlciB2ZXJib3NlIGlzIGVuYWJsZWQuXHJcbiAgICAgKiBAcmV0dXJuIHdldGhlciB2ZXJib3NlIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB2ZXJib3NlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJib3NlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCwgd2V0aGVyIHF1aWV0IGlzIGVuYWJsZWQuXHJcbiAgICAgKiBAcmV0dXJuIHdldGhlciBxdWlldCBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcXVpZXQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1aWV0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBlcnJvcihtc2csIC4uLnBhcmFtczogYW55W10pIHtcclxuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbC5FUlJPUiwgbXNnLCBwYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB3YXJuKG1zZywgLi4ucGFyYW1zOiBhbnlbXSkge1xyXG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsLldBUk4sIG1zZywgcGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaW5mbyhtc2csIC4uLnBhcmFtczogYW55W10pIHtcclxuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbC5JTkZPLCBtc2csIHBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlYnVnKG1zZywgLi4ucGFyYW1zOiBhbnlbXSkge1xyXG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsLkRFQlVHLCBtc2csIHBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBsb2cobGV2ZWw6IExvZ0xldmVsLCBtc2csIHBhcmFtczogYW55W10pIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNPdXRwdXRFbmFibGVkKGxldmVsKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb2xvcmVkTWVzc2FnZTtcclxuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XHJcbiAgICAgICAgICAgIGNhc2UgTG9nTGV2ZWwuRVJST1I6XHJcbiAgICAgICAgICAgICAgICBjb2xvcmVkTWVzc2FnZSA9IGNoYWxrLnJlZCgnRVJST1I6ICcgKyBtc2cpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTG9nTGV2ZWwuV0FSTjpcclxuICAgICAgICAgICAgICAgIGNvbG9yZWRNZXNzYWdlID0gY2hhbGsubWFnZW50YSgnV0FSTklORzogJyArIG1zZyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbG9yZWRNZXNzYWdlID0gY2hhbGsuZ3JheSgnKiAnICsgbXNnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvdXRNc2cgPSBmb3JtYXQoY29sb3JlZE1lc3NhZ2UsIC4uLnBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdHJlYW0ud3JpdGUob3V0TXNnICsgJ1xcbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaXNPdXRwdXRFbmFibGVkKGxldmVsOiBMb2dMZXZlbCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBxdWlldEVuYWJsZWQsIHZlcmJvc2VFbmFibGVkOiBib29sZWFuO1xyXG4gICAgICAgIGlmICh0aGlzLl9xdWlldCAmJiB0aGlzLl92ZXJib3NlKSB7XHJcbiAgICAgICAgICAgIHF1aWV0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2ZXJib3NlRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHF1aWV0RW5hYmxlZCA9IHRoaXMuX3F1aWV0O1xyXG4gICAgICAgICAgICB2ZXJib3NlRW5hYmxlZCA9IHRoaXMuX3ZlcmJvc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcclxuICAgICAgICAgICAgY2FzZSBMb2dMZXZlbC5FUlJPUjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAvLyBhbHdheXMgb3V0cHV0IGVycm9yc1xyXG4gICAgICAgICAgICBjYXNlIExvZ0xldmVsLldBUk46XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCFxdWlldEVuYWJsZWQpO1xyXG4gICAgICAgICAgICBjYXNlIExvZ0xldmVsLklORk86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZlcmJvc2VFbmFibGVkICYmICFxdWlldEVuYWJsZWQpO1xyXG4gICAgICAgICAgICBjYXNlIExvZ0xldmVsLkRFQlVHOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcmJvc2VFbmFibGVkO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxNy4wMi4yMDE3LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZk1lcmdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IobXNnOiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihtc2cpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBleHBsaWNpdGx5LlxyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBYbGlmZk1lcmdlRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTcuMDIuMjAxNy5cclxuICogU29tZSAoYSBmZXcpIHNpbXBsZSB1dGlscyBmb3IgZmlsZSBvcGVyYXRpb25zLlxyXG4gKiBKdXN0IGZvciBjb252ZW5pZW5jZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgRmlsZVV0aWwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgZm9yIGV4aXN0ZW5jZS5cclxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBmaWxlbmFtZVxyXG4gICAgICogQHJldHVybiB3ZXRoZXIgZmlsZSBleGlzdHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBleGlzdHMoZmlsZW5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBmcy5leGlzdHNTeW5jKGZpbGVuYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYSBmaWxlLlxyXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIGZpbGVuYW1lXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgZW5jb2RpbmdcclxuICAgICAqIEByZXR1cm4gY29udGVudCBvZiBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZChmaWxlbmFtZTogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgZW5jb2RpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGUgYSBmaWxlIHdpdGggZ2l2ZW4gY29udGVudC5cclxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBmaWxlbmFtZVxyXG4gICAgICogQHBhcmFtIG5ld0NvbnRlbnQgbmV3Q29udGVudFxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIGVuY29kaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVwbGFjZUNvbnRlbnQoZmlsZW5hbWU6IHN0cmluZywgbmV3Q29udGVudDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlbmFtZSwgbmV3Q29udGVudCwge2VuY29kaW5nOiBlbmNvZGluZ30pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY29weShzcmNGaWxlOiBzdHJpbmcsIGRlc3RGaWxlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBCVUZfTEVOR1RIID0gNjQgKiAxMDI0O1xyXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBCdWZmZXIuYWxsb2MoQlVGX0xFTkdUSCk7XHJcbiAgICAgICAgY29uc3QgZmRyID0gZnMub3BlblN5bmMoc3JjRmlsZSwgJ3InKTtcclxuICAgICAgICBjb25zdCBmZHcgPSBmcy5vcGVuU3luYyhkZXN0RmlsZSwgJ3cnKTtcclxuICAgICAgICBsZXQgYnl0ZXNSZWFkID0gMTtcclxuICAgICAgICBsZXQgcG9zID0gMDtcclxuICAgICAgICB3aGlsZSAoYnl0ZXNSZWFkID4gMCkge1xyXG4gICAgICAgICAgICBieXRlc1JlYWQgPSBmcy5yZWFkU3luYyhmZHIsIGJ1ZmYsIDAsIEJVRl9MRU5HVEgsIHBvcyk7XHJcbiAgICAgICAgICAgIGZzLndyaXRlU3luYyhmZHcsIGJ1ZmYsIDAsIGJ5dGVzUmVhZCk7XHJcbiAgICAgICAgICAgIHBvcyArPSBieXRlc1JlYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZzLmNsb3NlU3luYyhmZHIpO1xyXG4gICAgICAgIGZzLmNsb3NlU3luYyhmZHcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIHRoZSBmb2xkZXIgYW5kIGFsbCBvZiBpdHMgY29udGVudCAocm0gLXJmKS5cclxuICAgICAqIEBwYXJhbSBwYXRoIHBhdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxldGVGb2xkZXJSZWN1cnNpdmUocGF0aDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGZpbGVzID0gW107XHJcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGF0aCkgKSB7XHJcbiAgICAgICAgICAgIGZpbGVzID0gZnMucmVhZGRpclN5bmMocGF0aCk7XHJcbiAgICAgICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUGF0aCA9IHBhdGggKyAnLycgKyBmaWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZzLmxzdGF0U3luYyhjdXJQYXRoKS5pc0RpcmVjdG9yeSgpKSB7IC8vIHJlY3Vyc2VcclxuICAgICAgICAgICAgICAgICAgICBGaWxlVXRpbC5kZWxldGVGb2xkZXJSZWN1cnNpdmUoY3VyUGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBkZWxldGUgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGZzLnVubGlua1N5bmMoY3VyUGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmcy5ybWRpclN5bmMocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIGZvbGRlcnMgY29udGVudCByZWN1cnNpdmVseSwgYnV0IGRvIG5vdCBkZWxldGUgZm9sZGVyLlxyXG4gICAgICogRm9sZGVyIGlzIGxlZnQgZW1wdHkgYXQgdGhlIGVuZC5cclxuICAgICAqIEBwYXJhbSBwYXRoIHBhdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxldGVGb2xkZXJDb250ZW50UmVjdXJzaXZlKHBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBmaWxlcyA9IFtdO1xyXG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHBhdGgpICkge1xyXG4gICAgICAgICAgICBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKHBhdGgpO1xyXG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clBhdGggPSBwYXRoICsgJy8nICsgZmlsZTtcclxuICAgICAgICAgICAgICAgIGlmIChmcy5sc3RhdFN5bmMoY3VyUGF0aCkuaXNEaXJlY3RvcnkoKSkgeyAvLyByZWN1cnNlXHJcbiAgICAgICAgICAgICAgICAgICAgRmlsZVV0aWwuZGVsZXRlRm9sZGVyUmVjdXJzaXZlKGN1clBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZGVsZXRlIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGN1clBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgYSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHBhdGggcGF0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGV0ZUZpbGUocGF0aDogc3RyaW5nKSB7XHJcbiAgICAgICAgZnMudW5saW5rU3luYyhwYXRoKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogSGVscGVyIGNsYXNzIHRvIHBhcnNlIG5neCB0cmFuc2xhdGUgZXh0cmFjdGlvbiBwYXR0ZXJuXHJcbiAqIGFuZCB0byBkZWNpZGUgd2V0aGVyIGEgZ2l2ZW4gbWVzc2FnZSBtYXRjaGVzIHRoZSBwYXR0ZXJuLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE5neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuIHtcclxuXHJcbiAgICBwcml2YXRlIF9tYXRjaEV4cGxpY2l0SWQ6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9kZXNjcmlwdGlvblBhdHRlcm5zOiBzdHJpbmdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdCB0aGUgcGF0dGVybiBmcm9tIGdpdmVuIGRlc2NyaXB0aW9uIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nXHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yLCBpZiB0aGVyZSBpcyBhIHN5bnRheCBlcnJvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nLnNwbGl0KCd8Jyk7XHJcbiAgICAgICAgdGhpcy5fbWF0Y2hFeHBsaWNpdElkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGVzY3JpcHRpb25QYXR0ZXJucyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJ0BAJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoRXhwbGljaXRJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0cmFjdGlvbiBwYXR0ZXJuIG11c3Qgbm90IGNvbnRhaW4gQEAgdHdpY2UnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoRXhwbGljaXRJZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclN0cmluZyA9IHRoaXMuY2hlY2tWYWxpZERlc2NyaXB0aW9uUGF0dGVybihwYXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvclN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvblBhdHRlcm5zLnB1c2gocGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjaywgd2V0aGVyIGFuIGV4cGxpY2l0bHkgc2V0IGlkIG1hdGNoZXMgdGhlIHBhdHRlcm4uXHJcbiAgICAgKiBAcGFyYW0gaWQgaWRcclxuICAgICAqIEByZXR1cm4gd2V0aGVyIGFuIGV4cGxpY2l0bHkgc2V0IGlkIG1hdGNoZXMgdGhlIHBhdHRlcm4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0V4cGxpY2l0SWRNYXRjaGVkKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gaWQgJiYgdGhpcy5fbWF0Y2hFeHBsaWNpdElkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2ssIHdldGhlciBhIGdpdmVuIGRlc2NyaXB0aW9uIG1hdGNoZXMgdGhlIHBhdHRlcm4uXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gZGVzY3JpcHRpb25cclxuICAgICAqIEByZXR1cm4gd2V0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gbWF0Y2hlcyB0aGUgcGF0dGVybi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzRGVzY3JpcHRpb25NYXRjaGVkKGRlc2NyaXB0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzY3JpcHRpb25QYXR0ZXJucy5pbmRleE9mKGRlc2NyaXB0aW9uKSA+PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2hlY2tWYWxpZERlc2NyaXB0aW9uUGF0dGVybihkZXNjcmlwdGlvblBhdHRlcm46IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKCFkZXNjcmlwdGlvblBhdHRlcm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuICdlbXB0eSB2YWx1ZSBub3QgYWxsb3dlZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgvXlthLXpBLVpfXVthLXpBLVpfLV0qJC8udGVzdChkZXNjcmlwdGlvblBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBpdCBpcyBva1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGVzY3JpcHRpb24gcGF0dGVybiBtdXN0IGJlIGFuIGlkZW50aWZpZXIgY29udGFpbmluZyBvbmx5IGxldHRlcnMsIGRpZ2l0cywgXyBvciAtJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsIElUcmFuc1VuaXQsIE5PUk1BTElaQVRJT05fRk9STUFUX05HWFRSQU5TTEFURX0gZnJvbSAnQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliJztcclxuaW1wb3J0IHtGaWxlVXRpbH0gZnJvbSAnLi4vY29tbW9uL2ZpbGUtdXRpbCc7XHJcbmltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJy4uL2NvbW1vbi91dGlsJztcclxuaW1wb3J0IHtOZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybn0gZnJvbSAnLi9uZ3gtdHJhbnNsYXRlLWV4dHJhY3Rpb24tcGF0dGVybic7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IHJvb2JtIG9uIDE1LjAzLjIwMTcuXHJcbiAqIEEgdG9vbCBmb3IgZXh0cmFjdGluZyBtZXNzYWdlcyBpbiBuZ3gtdHJhbnNsYXRlIGZvcm1hdC5cclxuICogR2VuZXJhdGVzIGEganNvbi1maWxlIHRvIGJlIHVzZWQgd2l0aCBuZ3gtdHJhbnNsYXRlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgaW50ZXJmYWNlIHVzZWQgZm9yIHRyYW5zbGF0aW9ucyBpbiBuZ3gtdHJhbnNsYXRlLlxyXG4gKiBBIGhhc2ggdGhhdCBjb250YWlucyBlaXRoZXIgdGhlIHRyYW5zbGF0aW9uIG9yIGFub3RoZXIgaGFzaC5cclxuICovXHJcbmludGVyZmFjZSBOZ3hUcmFuc2xhdGlvbnMge1xyXG4gICAgW2lkOiBzdHJpbmddOiBOZ3hUcmFuc2xhdGlvbnMgfCBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBpbnRlcm5hbCxcclxuICogYSBtZXNzYWdlIHdpdGggaWQgKGEgZG90LXNlcGFyYXRlZCBzdHJpbmcpLlxyXG4gKi9cclxuaW50ZXJmYWNlIE5neE1lc3NhZ2Uge1xyXG4gICAgaWQ6IHN0cmluZzsgLy8gZG90IHNlcGFyYXRlZCBuYW1lLCBlLmcuIFwibXlhcHAuc2VydmljZTEubWVzc2FnZTFcIlxyXG4gICAgbWVzc2FnZTogc3RyaW5nOyAvLyB0aGUgbWVzc2FnZSwgcGxhY2Vob2xkZXIgYXJlIGluIHt7bn19IHN5bnRheCwgZS5nLiBcImEgdGVzdCB3aXRoIHZhbHVlOiB7ezB9fVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTmd4VHJhbnNsYXRlRXh0cmFjdG9yIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIERlZmF1bHRFeHRyYWN0aW9uUGF0dGVybiA9ICdAQHxuZ3gtdHJhbnNsYXRlJztcclxuICAgIHByaXZhdGUgZXh0cmFjdGlvblBhdHRlcm46IE5neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2ssIHdldGhlciBleHRyYWN0aW9uUGF0dGVybiBoYXMgdmFsaWQgc3ludGF4LlxyXG4gICAgICogQHBhcmFtIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nIGV4dHJhY3Rpb25QYXR0ZXJuU3RyaW5nXHJcbiAgICAgKiBAcmV0dXJuIG51bGwsIGlmIHBhdHRlcm4gaXMgb2ssIHN0cmluZyBkZXNjcmliaW5nIHRoZSBlcnJvciwgaWYgaXQgaXMgbm90IG9rLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNoZWNrUGF0dGVybihleHRyYWN0aW9uUGF0dGVyblN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKG5ldyBOZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybihleHRyYWN0aW9uUGF0dGVyblN0cmluZykpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBleHRyYWN0KG1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLCBleHRyYWN0aW9uUGF0dGVybjogc3RyaW5nLCBvdXRwdXRGaWxlOiBzdHJpbmcpIHtcclxuICAgICAgICBuZXcgTmd4VHJhbnNsYXRlRXh0cmFjdG9yKG1lc3NhZ2VzRmlsZSwgZXh0cmFjdGlvblBhdHRlcm4pLmV4dHJhY3RUbyhvdXRwdXRGaWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlLCBleHRyYWN0aW9uUGF0dGVyblN0cmluZzogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5leHRyYWN0aW9uUGF0dGVybiA9IG5ldyBOZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybihleHRyYWN0aW9uUGF0dGVyblN0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRhY3QgbWVzc2FnZXMgYW5kIHdyaXRlIHRoZW0gdG8gYSBmaWxlLlxyXG4gICAgICogQHBhcmFtIG91dHB1dEZpbGUgb3V0cHV0RmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZXh0cmFjdFRvKG91dHB1dEZpbGU6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uczogTmd4VHJhbnNsYXRpb25zID0gdGhpcy50b05neFRyYW5zbGF0aW9ucyh0aGlzLmV4dHJhY3QoKSk7XHJcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9ucyAmJiBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbnMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgRmlsZVV0aWwucmVwbGFjZUNvbnRlbnQob3V0cHV0RmlsZSwgSlNPTi5zdHJpbmdpZnkodHJhbnNsYXRpb25zLCBudWxsLCA0KSwgJ1VURi04Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKEZpbGVVdGlsLmV4aXN0cyhvdXRwdXRGaWxlKSkge1xyXG4gICAgICAgICAgICAgICAgRmlsZVV0aWwuZGVsZXRlRmlsZShvdXRwdXRGaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICBFeHRyYWN0IG1lc3NhZ2VzIGFuZCBjb252ZXJ0IHRoZW0gdG8gbmd4IHRyYW5zbGF0aW9ucy5cclxuICAgICAqICBAcmV0dXJuIHRoZSB0cmFuc2xhdGlvbiBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGV4dHJhY3QoKTogTmd4TWVzc2FnZVtdIHtcclxuICAgICAgICBjb25zdCByZXN1bHQ6IE5neE1lc3NhZ2VbXSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZXNGaWxlLmZvckVhY2hUcmFuc1VuaXQoKHR1OiBJVHJhbnNVbml0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5neElkID0gdGhpcy5uZ3hUcmFuc2xhdGVJZEZyb21UVSh0dSk7XHJcbiAgICAgICAgICAgIGlmIChuZ3hJZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZXRleHQgPSB0dS50YXJnZXRDb250ZW50Tm9ybWFsaXplZCgpLmFzRGlzcGxheVN0cmluZyhOT1JNQUxJWkFUSU9OX0ZPUk1BVF9OR1hUUkFOU0xBVEUpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe2lkOiBuZ3hJZCwgbWVzc2FnZTogbWVzc2FnZXRleHR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjaywgd2V0aGVyIHRoaXMgdHUgc2hvdWxkIGJlIGV4dHJhY3RlZCBmb3Igbmd4LXRyYW5zbGF0ZSB1c2FnZSwgYW5kIHJldHVybiBpdHMgaWQgZm9yIG5neC10cmFuc2xhdGUuXHJcbiAgICAgKiBUaGVyZSBhcmUgMiBwb3NzaWJpbGl0aWVzOlxyXG4gICAgICogMS4gZGVzY3JpcHRpb24gaXMgc2V0IHRvIFwibmd4LXRyYW5zbGF0ZVwiIGFuZCBtZWFuaW5nIGNvbnRhaW5zIHRoZSBpZC5cclxuICAgICAqIDIuIGlkIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHR1IHR1XHJcbiAgICAgKiBAcmV0dXJuIGFuIG5neCBpZCBvciBudWxsLCBpZiB0aGlzIHR1IHNob3VsZCBub3QgYmUgZXh0cmFjdGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG5neFRyYW5zbGF0ZUlkRnJvbVRVKHR1OiBJVHJhbnNVbml0KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5pc0V4cGxpY2l0bHlTZXRJZCh0dS5pZCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXh0cmFjdGlvblBhdHRlcm4uaXNFeHBsaWNpdElkTWF0Y2hlZCh0dS5pZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0dS5pZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdHUuZGVzY3JpcHRpb24oKTtcclxuICAgICAgICBpZiAoZGVzY3JpcHRpb24gJiYgdGhpcy5leHRyYWN0aW9uUGF0dGVybi5pc0Rlc2NyaXB0aW9uTWF0Y2hlZChkZXNjcmlwdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR1Lm1lYW5pbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0LCB3ZXRoZXIgSUQgd2FzIGV4cGxpY2l0bHkgc2V0ICh2aWEgaTE4bj1cIkBteWlkKS5cclxuICAgICAqIEp1c3QgaGV1cmlzdGljLCBhbiBJRCBpcyBleHBsaWNpdGx5LCBpZiBpdCBkb2VzIG5vdCBsb29rIGxpa2UgYSBnZW5lcmF0ZWQgb25lLlxyXG4gICAgICogQHBhcmFtIGlkIGlkXHJcbiAgICAgKiBAcmV0dXJuIHdldGhlciBJRCB3YXMgZXhwbGljaXRseSBzZXQgKHZpYSBpMThuPVwiQG15aWQpLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzRXhwbGljaXRseVNldElkKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoaWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2VuZXJhdGVkIElEcyBhcmUgZWl0aGVyIGRlY2ltYWwgb3Igc2hhMSBoZXhcclxuICAgICAgICBjb25zdCByZUZvckdlbmVyYXRlZElkID0gL15bMC05YS1mXXsxMSx9JC87XHJcbiAgICAgICAgcmV0dXJuICFyZUZvckdlbmVyYXRlZElkLnRlc3QoaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBsaXN0IG9mIHJlbGV2YW50IFRVcyB0byBuZ3ggdHJhbnNsYXRpb25zIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBtc2dMaXN0IG1zZ0xpc3RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0b05neFRyYW5zbGF0aW9ucyhtc2dMaXN0OiBOZ3hNZXNzYWdlW10pOiBOZ3hUcmFuc2xhdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uT2JqZWN0OiBOZ3hUcmFuc2xhdGlvbnMgPSB7fTtcclxuICAgICAgICBtc2dMaXN0LmZvckVhY2goKG1zZzogTmd4TWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnB1dEluVHJhbnNsYXRpb25PYmplY3QodHJhbnNsYXRpb25PYmplY3QsIG1zZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uT2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHV0IGEgbmV3IG1lc3NhZ2VzIGludG8gdGhlIHRyYW5zbGF0aW9uIGRhdGEgb2JqZWN0LlxyXG4gICAgICogSWYgeW91IGFkZCwgZS5nLiBcIntpZDogJ215YXBwLmV4YW1wbGUnLCBtZXNzYWdlOiAndGVzdCd9XCIsXHJcbiAgICAgKiB0aGUgdHJhbnNsYXRpb24gb2JqZWN0IHdpbGwgdGhlbiBjb250YWluIGFuIG9iamVjdCBteWFwcCB0aGF0IGhhcyBwcm9wZXJ0eSBleGFtcGxlOlxyXG4gICAgICoge215YXBwOiB7XHJcbiAgICAgKiAgIGV4YW1wbGU6ICd0ZXN0J1xyXG4gICAgICogICB9fVxyXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uT2JqZWN0IHRyYW5zbGF0aW9uT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gbXNnIG1zZ1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHB1dEluVHJhbnNsYXRpb25PYmplY3QodHJhbnNsYXRpb25PYmplY3Q6IE5neFRyYW5zbGF0aW9ucywgbXNnOiBOZ3hNZXNzYWdlKSB7XHJcbiAgICAgICAgbGV0IGZpcnN0UGFydE9mSWQ6IHN0cmluZztcclxuICAgICAgICBsZXQgcmVzdE9mSWQ6IHN0cmluZztcclxuICAgICAgICBjb25zdCBpbmRleE9mRG90ID0gbXNnLmlkLmluZGV4T2YoJy4nKTtcclxuICAgICAgICBpZiAoaW5kZXhPZkRvdCA9PT0gMCB8fCBpbmRleE9mRG90ID09PSAobXNnLmlkLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIG54Zy10cmFuc2xhdGUgaWQgXCInICsgbXNnLmlkICsgJ1wiJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmRleE9mRG90IDwgMCkge1xyXG4gICAgICAgICAgICBmaXJzdFBhcnRPZklkID0gbXNnLmlkO1xyXG4gICAgICAgICAgICByZXN0T2ZJZCA9ICcnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZpcnN0UGFydE9mSWQgPSBtc2cuaWQuc3Vic3RyaW5nKDAsIGluZGV4T2ZEb3QpO1xyXG4gICAgICAgICAgICByZXN0T2ZJZCA9IG1zZy5pZC5zdWJzdHJpbmcoaW5kZXhPZkRvdCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgb2JqZWN0ID0gdHJhbnNsYXRpb25PYmplY3RbZmlyc3RQYXJ0T2ZJZF07XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG9iamVjdCkpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3RPZklkID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25PYmplY3RbZmlyc3RQYXJ0T2ZJZF0gPSBtc2cubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgdHJhbnNsYXRpb25PYmplY3RbZmlyc3RQYXJ0T2ZJZF0gPSBvYmplY3Q7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHJlc3RPZklkID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXBsaWNhdGUgaWQgcHJhZWZpeCBcIicgKyBtc2cuaWQgKyAnXCInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnB1dEluVHJhbnNsYXRpb25PYmplY3QoPE5neFRyYW5zbGF0aW9ucz4gb2JqZWN0LCB7aWQ6IHJlc3RPZklkLCBtZXNzYWdlOiBtc2cubWVzc2FnZX0pO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxNy4wMi4yMDE3LlxyXG4gKiBDb2xsZWN0aW9uIG9mIGFsbCBwYXJhbWV0ZXJzIHVzZWQgYnkgdGhlIHRvb2wuXHJcbiAqIFRoZSBwYXJhbWV0ZXJzIGFyZSByZWFkIGZvcm0gdGhlIHByb2ZpbGUgb3IgZGVmYXVsdHMgYXJlIHVzZWQuXHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQge1hsaWZmTWVyZ2VFcnJvcn0gZnJvbSAnLi94bGlmZi1tZXJnZS1lcnJvcic7XHJcbmltcG9ydCB7U3RhdHN9IGZyb20gJ2ZzJztcclxuaW1wb3J0IHtDb21tYW5kT3V0cHV0fSBmcm9tICcuLi9jb21tb24vY29tbWFuZC1vdXRwdXQnO1xyXG5pbXBvcnQge2Zvcm1hdH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7aXNBcnJheSwgaXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJy4uL2NvbW1vbi91dGlsJztcclxuaW1wb3J0IHtQcm9ncmFtT3B0aW9ucywgSUNvbmZpZ0ZpbGV9IGZyb20gJy4vaS14bGlmZi1tZXJnZS1vcHRpb25zJztcclxuaW1wb3J0IHtGaWxlVXRpbH0gZnJvbSAnLi4vY29tbW9uL2ZpbGUtdXRpbCc7XHJcbmltcG9ydCB7Tmd4VHJhbnNsYXRlRXh0cmFjdG9yfSBmcm9tICcuL25neC10cmFuc2xhdGUtZXh0cmFjdG9yJztcclxuaW1wb3J0IHtkaXJuYW1lLCBpc0Fic29sdXRlLCBqb2luLCBub3JtYWxpemV9IGZyb20gJ3BhdGgnO1xyXG5cclxuY29uc3QgUFJPRklMRV9DQU5ESURBVEVTID0gWydwYWNrYWdlLmpzb24nLCAnLmFuZ3VsYXItY2xpLmpzb24nXTtcclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZk1lcmdlUGFyYW1ldGVycyB7XHJcblxyXG4gICAgcHJpdmF0ZSB1c2VkUHJvZmlsZVBhdGg6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3F1aWV0OiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBfdmVyYm9zZTogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX2FsbG93SWRDaGFuZ2U6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9kZWZhdWx0TGFuZ3VhZ2U6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3NyY0Rpcjogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaTE4bkJhc2VGaWxlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9pMThuRmlsZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaTE4bkZvcm1hdDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfZW5jb2Rpbmc6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2dlbkRpcjogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfbGFuZ3VhZ2VzOiBzdHJpbmdbXTtcclxuICAgIHByaXZhdGUgX3JlbW92ZVVudXNlZElkczogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX3N1cHBvcnROZ3hUcmFuc2xhdGU6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybjogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfdXNlU291cmNlQXNUYXJnZXQ6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF90YXJnZXRQcmFlZml4OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF90YXJnZXRTdWZmaXg6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2JlYXV0aWZ5T3V0cHV0OiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBfcHJlc2VydmVPcmRlcjogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX2F1dG90cmFuc2xhdGU6IGJvb2xlYW58c3RyaW5nW107XHJcbiAgICBwcml2YXRlIF9hcGlrZXk6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2FwaWtleWZpbGU6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgZXJyb3JzRm91bmQ6IFhsaWZmTWVyZ2VFcnJvcltdO1xyXG4gICAgcHVibGljIHdhcm5pbmdzRm91bmQ6IHN0cmluZ1tdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIFBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb21tYW5kIG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSBwcm9maWxlQ29udGVudCBnaXZlbiBwcm9maWxlIChpZiBub3QsIGl0IGlzIHJlYWQgZnJvbSB0aGUgcHJvZmlsZSBwYXRoIGZyb20gb3B0aW9ucykuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRnJvbU9wdGlvbnMob3B0aW9uczogUHJvZ3JhbU9wdGlvbnMsIHByb2ZpbGVDb250ZW50PzogSUNvbmZpZ0ZpbGUpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFhsaWZmTWVyZ2VQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgcGFyYW1ldGVycy5jb25maWd1cmUob3B0aW9ucywgcHJvZmlsZUNvbnRlbnQpO1xyXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvcnNGb3VuZCA9IFtdO1xyXG4gICAgICAgIHRoaXMud2FybmluZ3NGb3VuZCA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBwb3RlbnRpYWwgcHJvZmlsZS5cclxuICAgICAqIFRvIGJlIGEgY2FuZGlkYXRlLCBmaWxlIG11c3QgZXhpc3QgYW5kIGNvbnRhaW4gcHJvcGVydHkgXCJ4bGlmZm1lcmdlT3B0aW9uc1wiLlxyXG4gICAgICogQHBhcmFtIHByb2ZpbGVQYXRoIHBhdGggb2YgcHJvZmlsZVxyXG4gICAgICogQHJldHVybiBwYXJzZWQgY29udGVudCBvZiBmaWxlIG9yIG51bGwsIGlmIGZpbGUgZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IGEgcHJvZmlsZSBjYW5kaWRhdGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRQcm9maWxlQ2FuZGlkYXRlKHByb2ZpbGVQYXRoOiBzdHJpbmcpOiBJQ29uZmlnRmlsZSB7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHByb2ZpbGVQYXRoLCAnVVRGLTgnKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZENvbnRlbnQ6IElDb25maWdGaWxlID0gSlNPTi5wYXJzZShjb250ZW50KTtcclxuICAgICAgICBpZiAocGFyc2VkQ29udGVudCAmJiBwYXJzZWRDb250ZW50LnhsaWZmbWVyZ2VPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRDb250ZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgbWUgZnJvbSB0aGUgcHJvZmlsZSBjb250ZW50LlxyXG4gICAgICogKHB1YmxpYyBvbmx5IGZvciB0ZXN0IHVzYWdlKS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgZ2l2ZW4gYXQgcnVudGltZSB2aWEgY29tbWFuZCBsaW5lXHJcbiAgICAgKiBAcGFyYW0gcHJvZmlsZUNvbnRlbnQgaWYgbnVsbCwgcmVhZCBpdCBmcm9tIHByb2ZpbGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY29uZmlndXJlKG9wdGlvbnM6IFByb2dyYW1PcHRpb25zLCBwcm9maWxlQ29udGVudD86IElDb25maWdGaWxlKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvcnNGb3VuZCA9IFtdO1xyXG4gICAgICAgIHRoaXMud2FybmluZ3NGb3VuZCA9IFtdO1xyXG4gICAgICAgIGlmICghcHJvZmlsZUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgcHJvZmlsZUNvbnRlbnQgPSB0aGlzLnJlYWRQcm9maWxlKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2YWxpZFByb2ZpbGU6IGJvb2xlYW4gPSAoISFwcm9maWxlQ29udGVudCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucXVpZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcXVpZXQgPSBvcHRpb25zLnF1aWV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy52ZXJib3NlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZlcmJvc2UgPSBvcHRpb25zLnZlcmJvc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWxpZFByb2ZpbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRnJvbUNvbmZpZyhwcm9maWxlQ29udGVudCk7XHJcbiAgICAgICAgICAgIC8vIGlmIGxhbmd1YWdlcyBhcmUgZ2l2ZW4gYXMgcGFyYW1ldGVycywgdGhleSBvdnZlcmlkZSBldmVyeXRoaW5nIHNhaWQgaW4gcHJvZmlsZVxyXG4gICAgICAgICAgICBpZiAoISFvcHRpb25zLmxhbmd1YWdlcyAmJiBvcHRpb25zLmxhbmd1YWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYW5ndWFnZXMgPSBvcHRpb25zLmxhbmd1YWdlcztcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGVmYXVsdExhbmd1YWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdExhbmd1YWdlID0gdGhpcy5fbGFuZ3VhZ2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBwcm9maWxlLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgcHJvZ3JhbSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHRoZSByZWFkIHByb2ZpbGUgKGVtcHR5LCBpZiBub25lLCBudWxsIGlmIGVycm9ycylcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWFkUHJvZmlsZShvcHRpb25zOiBQcm9ncmFtT3B0aW9ucyk6IElDb25maWdGaWxlIHtcclxuICAgICAgICBjb25zdCBwcm9maWxlUGF0aDogc3RyaW5nID0gb3B0aW9ucy5wcm9maWxlUGF0aDtcclxuICAgICAgICBpZiAoIXByb2ZpbGVQYXRoKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29uZmlnZmlsZW5hbWUgb2YgUFJPRklMRV9DQU5ESURBVEVTKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gWGxpZmZNZXJnZVBhcmFtZXRlcnMucmVhZFByb2ZpbGVDYW5kaWRhdGUoY29uZmlnZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2ZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZWRQcm9maWxlUGF0aCA9IGNvbmZpZ2ZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9maWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHByb2ZpbGVQYXRoLCAnVVRGLTgnKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKG5ldyBYbGlmZk1lcmdlRXJyb3IoJ2NvdWxkIG5vdCByZWFkIHByb2ZpbGUgXCInICsgcHJvZmlsZVBhdGggKyAnXCInKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVzZWRQcm9maWxlUGF0aCA9IHByb2ZpbGVQYXRoO1xyXG4gICAgICAgIGNvbnN0IHByb2ZpbGVDb250ZW50OiBJQ29uZmlnRmlsZSA9IEpTT04ucGFyc2UoY29udGVudCk7XHJcbiAgICAgICAgLy8gcmVwbGFjZSBhbGwgcGF0aGVzIGluIG9wdGlvbnMgYnkgYWJzb2x1dGUgcGF0aHNcclxuICAgICAgICBjb25zdCB4bGlmZm1lcmdlT3B0aW9ucyA9IHByb2ZpbGVDb250ZW50LnhsaWZmbWVyZ2VPcHRpb25zO1xyXG4gICAgICAgIHhsaWZmbWVyZ2VPcHRpb25zLnNyY0RpciA9IHRoaXMuYWRqdXN0UGF0aFRvUHJvZmlsZVBhdGgocHJvZmlsZVBhdGgsIHhsaWZmbWVyZ2VPcHRpb25zLnNyY0Rpcik7XHJcbiAgICAgICAgeGxpZmZtZXJnZU9wdGlvbnMuZ2VuRGlyID0gdGhpcy5hZGp1c3RQYXRoVG9Qcm9maWxlUGF0aChwcm9maWxlUGF0aCwgeGxpZmZtZXJnZU9wdGlvbnMuZ2VuRGlyKTtcclxuICAgICAgICB4bGlmZm1lcmdlT3B0aW9ucy5hcGlrZXlmaWxlID0gdGhpcy5hZGp1c3RQYXRoVG9Qcm9maWxlUGF0aChwcm9maWxlUGF0aCwgeGxpZmZtZXJnZU9wdGlvbnMuYXBpa2V5ZmlsZSk7XHJcbiAgICAgICAgcmV0dXJuIHByb2ZpbGVDb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYWRqdXN0UGF0aFRvUHJvZmlsZVBhdGgocHJvZmlsZVBhdGg6IHN0cmluZywgcGF0aFRvQWRqdXN0OiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGlmICghcGF0aFRvQWRqdXN0IHx8IGlzQWJzb2x1dGUocGF0aFRvQWRqdXN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aFRvQWRqdXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gam9pbihkaXJuYW1lKHByb2ZpbGVQYXRoKSwgcGF0aFRvQWRqdXN0KS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplRnJvbUNvbmZpZyhwcm9maWxlQ29udGVudDogSUNvbmZpZ0ZpbGUpIHtcclxuICAgICAgICBpZiAoIXByb2ZpbGVDb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IHByb2ZpbGVDb250ZW50LnhsaWZmbWVyZ2VPcHRpb25zO1xyXG4gICAgICAgIGlmIChwcm9maWxlKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5xdWlldCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1aWV0ID0gcHJvZmlsZS5xdWlldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUudmVyYm9zZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZlcmJvc2UgPSBwcm9maWxlLnZlcmJvc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLmFsbG93SWRDaGFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxvd0lkQ2hhbmdlID0gcHJvZmlsZS5hbGxvd0lkQ2hhbmdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmRlZmF1bHRMYW5ndWFnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdExhbmd1YWdlID0gcHJvZmlsZS5kZWZhdWx0TGFuZ3VhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2ZpbGUubGFuZ3VhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYW5ndWFnZXMgPSBwcm9maWxlLmxhbmd1YWdlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5zcmNEaXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NyY0RpciA9IHByb2ZpbGUuc3JjRGlyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmFuZ3VsYXJDb21waWxlck9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9maWxlLmFuZ3VsYXJDb21waWxlck9wdGlvbnMuZ2VuRGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VuRGlyID0gcHJvZmlsZS5hbmd1bGFyQ29tcGlsZXJPcHRpb25zLmdlbkRpcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5nZW5EaXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgbXVzdCBiZSBhZnRlciBhbmd1bGFyQ29tcGlsZXJPcHRpb25zIHRvIGJlIHByZWZlcnJlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VuRGlyID0gcHJvZmlsZS5nZW5EaXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2ZpbGUuaTE4bkJhc2VGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pMThuQmFzZUZpbGUgPSBwcm9maWxlLmkxOG5CYXNlRmlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5pMThuRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faTE4bkZpbGUgPSBwcm9maWxlLmkxOG5GaWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmkxOG5Gb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2kxOG5Gb3JtYXQgPSBwcm9maWxlLmkxOG5Gb3JtYXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2ZpbGUuZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kaW5nID0gcHJvZmlsZS5lbmNvZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUucmVtb3ZlVW51c2VkSWRzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVW51c2VkSWRzID0gcHJvZmlsZS5yZW1vdmVVbnVzZWRJZHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLnN1cHBvcnROZ3hUcmFuc2xhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0Tmd4VHJhbnNsYXRlID0gcHJvZmlsZS5zdXBwb3J0Tmd4VHJhbnNsYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuID0gcHJvZmlsZS5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUudXNlU291cmNlQXNUYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VTb3VyY2VBc1RhcmdldCA9IHByb2ZpbGUudXNlU291cmNlQXNUYXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLnRhcmdldFByYWVmaXgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRQcmFlZml4ID0gcHJvZmlsZS50YXJnZXRQcmFlZml4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS50YXJnZXRTdWZmaXgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRTdWZmaXggPSBwcm9maWxlLnRhcmdldFN1ZmZpeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUuYXV0b3RyYW5zbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG90cmFuc2xhdGUgPSBwcm9maWxlLmF1dG90cmFuc2xhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLmJlYXV0aWZ5T3V0cHV0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmVhdXRpZnlPdXRwdXQgPSBwcm9maWxlLmJlYXV0aWZ5T3V0cHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvZmlsZS5wcmVzZXJ2ZU9yZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlc2VydmVPcmRlciA9IHByb2ZpbGUucHJlc2VydmVPcmRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHByb2ZpbGUuYXBpa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpa2V5ID0gcHJvZmlsZS5hcGlrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9maWxlLmFwaWtleWZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGlrZXlmaWxlID0gcHJvZmlsZS5hcGlrZXlmaWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5nc0ZvdW5kLnB1c2goJ2RpZCBub3QgZmluZCBcInhsaWZmbWVyZ2VPcHRpb25zXCIgaW4gcHJvZmlsZSwgdXNpbmcgZGVmYXVsdHMnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBhbGwgUGFyYW1ldGVycywgd2V0aGVyIHRoZXkgYXJlIGNvbXBsZXRlIGFuZCBjb25zaXN0ZW50LlxyXG4gICAgICogaWYgc29tZXRoaW5nIGlzIHdyb25nIHdpdGggdGhlIHBhcmFtZXRlcnMsIGl0IGlzIGNvbGxlY3RlZCBpbiBlcnJvcnNGb3VuZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja1BhcmFtZXRlcnMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jaGVja0xhbmd1YWdlU3ludGF4KHRoaXMuZGVmYXVsdExhbmd1YWdlKCkpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhbmd1YWdlcygpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2gobmV3IFhsaWZmTWVyZ2VFcnJvcignbm8gbGFuZ3VhZ2VzIHNwZWNpZmllZCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZXMoKS5mb3JFYWNoKChsYW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tMYW5ndWFnZVN5bnRheChsYW5nKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgc3RhdHM6IFN0YXRzO1xyXG4gICAgICAgIGxldCBlcnI6IGFueTtcclxuICAgICAgICAvLyBzcmNEaXIgc2hvdWxkIGV4aXN0c1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN0YXRzID0gZnMuc3RhdFN5bmModGhpcy5zcmNEaXIoKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlcnIgPSBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISFlcnIgfHwgIXN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKG5ldyBYbGlmZk1lcmdlRXJyb3IoJ3NyY0RpciBcIicgKyB0aGlzLnNyY0RpcigpICsgJ1wiIGlzIG5vdCBhIGRpcmVjdG9yeScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2VuRGlyIHNob3VsZCBleGlzdHNcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzdGF0cyA9IGZzLnN0YXRTeW5jKHRoaXMuZ2VuRGlyKCkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXJyID0gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhZXJyIHx8ICFzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzRm91bmQucHVzaChuZXcgWGxpZmZNZXJnZUVycm9yKCdnZW5EaXIgXCInICsgdGhpcy5nZW5EaXIoKSArICdcIiBpcyBub3QgYSBkaXJlY3RvcnknKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1hc3RlciBmaWxlIE1VU1QgZXhpc3RcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmcy5hY2Nlc3NTeW5jKHRoaXMuaTE4bkZpbGUoKSwgZnMuY29uc3RhbnRzLlJfT0spO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2gobmV3IFhsaWZmTWVyZ2VFcnJvcignaTE4bkZpbGUgXCInICsgdGhpcy5pMThuRmlsZSgpICsgJ1wiIGlzIG5vdCByZWFkYWJsZScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaTE4bkZvcm1hdCBtdXN0IGJlIHhsZiB4bGYyIG9yIHhtYlxyXG4gICAgICAgIGlmICghKHRoaXMuaTE4bkZvcm1hdCgpID09PSAneGxmJyB8fCB0aGlzLmkxOG5Gb3JtYXQoKSA9PT0gJ3hsZjInIHx8IHRoaXMuaTE4bkZvcm1hdCgpID09PSAneG1iJykpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnNGb3VuZC5wdXNoKG5ldyBYbGlmZk1lcmdlRXJyb3IoJ2kxOG5Gb3JtYXQgXCInICsgdGhpcy5pMThuRm9ybWF0KCkgKyAnXCIgaW52YWxpZCwgbXVzdCBiZSBcInhsZlwiIG9yIFwieGxmMlwiIG9yIFwieG1iXCInKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGF1dG90cmFuc2xhdGUgcmVxdWlyZXMgYXBpIGtleVxyXG4gICAgICAgIGlmICh0aGlzLmF1dG90cmFuc2xhdGUoKSAmJiAhdGhpcy5hcGlrZXkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2gobmV3IFhsaWZmTWVyZ2VFcnJvcignYXV0b3RyYW5zbGF0ZSByZXF1aXJlcyBhbiBBUEkga2V5LCBwbGVhc2Ugc2V0IG9uZScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXV0b3RyYW5zbGF0ZWQgbGFuZ3VhZ2VzIG11c3QgYmUgaW4gbGlzdCBvZiBhbGwgbGFuZ3VhZ2VzXHJcbiAgICAgICAgdGhpcy5hdXRvdHJhbnNsYXRlZExhbmd1YWdlcygpLmZvckVhY2goKGxhbmcpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGFuZ3VhZ2VzKCkuaW5kZXhPZihsYW5nKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzRm91bmQucHVzaChuZXcgWGxpZmZNZXJnZUVycm9yKCdhdXRvdHJhbnNsYXRlIGxhbmd1YWdlIFwiJyArIGxhbmcgKyAnXCIgaXMgbm90IGluIGxpc3Qgb2YgbGFuZ3VhZ2VzJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYW5nID09PSB0aGlzLmRlZmF1bHRMYW5ndWFnZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFhsaWZmTWVyZ2VFcnJvcignYXV0b3RyYW5zbGF0ZSBsYW5ndWFnZSBcIicgKyBsYW5nICsgJ1wiIGNhbm5vdCBiZSB0cmFuc2xhdGVkLCBiZWNhdXNlIGl0IGlzIHRoZSBzb3VyY2UgbGFuZ3VhZ2UnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBuZ3ggdHJhbnNsYXRlIHBhdHRlcm4gY2hlY2tcclxuICAgICAgICBpZiAodGhpcy5zdXBwb3J0Tmd4VHJhbnNsYXRlKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBOZ3hUcmFuc2xhdGVFeHRyYWN0b3IuY2hlY2tQYXR0ZXJuKHRoaXMubmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4oKSk7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoY2hlY2tSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yc0ZvdW5kLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFhsaWZmTWVyZ2VFcnJvcignbmd4VHJhbnNsYXRlRXh0cmFjdGlvblBhdHRlcm4gXCInICsgdGhpcy5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybigpICsgJ1wiOiAnICsgY2hlY2tSZXN1bHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0YXJnZXRQcmFlZml4IGFuZCB0YXJnZXRTdWZmaXggY2hlY2tcclxuICAgICAgICBpZiAoIXRoaXMudXNlU291cmNlQXNUYXJnZXQoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXRQcmFlZml4KCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53YXJuaW5nc0ZvdW5kLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZ3VyZWQgdGFyZ2V0UHJhZWZpeCBcIicgKyB0aGlzLnRhcmdldFByYWVmaXgoKSArICdcIiB3aWxsIG5vdCBiZSB1c2VkIGJlY2F1c2UgXCJ1c2VTb3VyY2VBc1RhcmdldFwiIGlzIGRpc2FibGVkXCInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXRTdWZmaXgoKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdzRm91bmQucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAnY29uZmlndXJlZCB0YXJnZXRTdWZmaXggXCInICsgdGhpcy50YXJnZXRTdWZmaXgoKSArICdcIiB3aWxsIG5vdCBiZSB1c2VkIGJlY2F1c2UgXCJ1c2VTb3VyY2VBc1RhcmdldFwiIGlzIGRpc2FibGVkXCInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBzeW50YXggb2YgbGFuZ3VhZ2UuXHJcbiAgICAgKiBNdXN0IGJlIGNvbXBhdGlibGUgd2l0aCBYTUwgU2NoZW1hIHR5cGUgeHNkOmxhbmd1YWdlLlxyXG4gICAgICogUGF0dGVybjogW2EtekEtWl17MSw4fSgoLXxfKVthLXpBLVowLTldezEsOH0pKlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2UgdG8gY2hlY2tcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja0xhbmd1YWdlU3ludGF4KGxhbmc6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAvXlthLXpBLVpdezEsOH0oWy1fXVthLXpBLVowLTldezEsOH0pKiQvO1xyXG4gICAgICAgIGlmICghcGF0dGVybi50ZXN0KGxhbmcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzRm91bmQucHVzaChuZXcgWGxpZmZNZXJnZUVycm9yKCdsYW5ndWFnZSBcIicgKyBsYW5nICsgJ1wiIGlzIG5vdCB2YWxpZCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFsbG93SWRDaGFuZ2UoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9hbGxvd0lkQ2hhbmdlKSkgPyBmYWxzZSA6IHRoaXMuX2FsbG93SWRDaGFuZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZlcmJvc2UoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl92ZXJib3NlKSkgPyBmYWxzZSA6IHRoaXMuX3ZlcmJvc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHF1aWV0KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fcXVpZXQpKSA/IGZhbHNlIDogdGhpcy5fcXVpZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWJ1ZyBvdXRwdXQgYWxsIHBhcmFtZXRlcnMgdG8gY29tbWFuZE91dHB1dC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNob3dBbGxQYXJhbWV0ZXJzKGNvbW1hbmRPdXRwdXQ6IENvbW1hbmRPdXRwdXQpOiB2b2lkIHtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCd4bGlmZm1lcmdlIFVzZWQgUGFyYW1ldGVyczonKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCd1c2VkUHJvZmlsZVBhdGg6XFx0XCIlc1wiJywgdGhpcy51c2VkUHJvZmlsZVBhdGgpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ2RlZmF1bHRMYW5ndWFnZTpcXHRcIiVzXCInLCB0aGlzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdzcmNEaXI6XFx0XCIlc1wiJywgdGhpcy5zcmNEaXIoKSk7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnZ2VuRGlyOlxcdFwiJXNcIicsIHRoaXMuZ2VuRGlyKCkpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ2kxOG5CYXNlRmlsZTpcXHRcIiVzXCInLCB0aGlzLmkxOG5CYXNlRmlsZSgpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdpMThuRmlsZTpcXHRcIiVzXCInLCB0aGlzLmkxOG5GaWxlKCkpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ2xhbmd1YWdlczpcXHQlcycsIHRoaXMubGFuZ3VhZ2VzKCkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgbGFuZ3VhZ2Ugb2YgdGhpcy5sYW5ndWFnZXMoKSkge1xyXG4gICAgICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdvdXRwdXRGaWxlWyVzXTpcXHQlcycsIGxhbmd1YWdlLCB0aGlzLmdlbmVyYXRlZEkxOG5GaWxlKGxhbmd1YWdlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ3JlbW92ZVVudXNlZElkczpcXHQlcycsIHRoaXMucmVtb3ZlVW51c2VkSWRzKCkpO1xyXG4gICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ3N1cHBvcnROZ3hUcmFuc2xhdGU6XFx0JXMnLCB0aGlzLnN1cHBvcnROZ3hUcmFuc2xhdGUoKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydE5neFRyYW5zbGF0ZSgpKSB7XHJcbiAgICAgICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ25neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuOlxcdCVzJywgdGhpcy5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygndXNlU291cmNlQXNUYXJnZXQ6XFx0JXMnLCB0aGlzLnVzZVNvdXJjZUFzVGFyZ2V0KCkpO1xyXG4gICAgICAgIGlmICh0aGlzLnVzZVNvdXJjZUFzVGFyZ2V0KCkpIHtcclxuICAgICAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygndGFyZ2V0UHJhZWZpeDpcXHRcIiVzXCInLCB0aGlzLnRhcmdldFByYWVmaXgoKSk7XHJcbiAgICAgICAgICAgIGNvbW1hbmRPdXRwdXQuZGVidWcoJ3RhcmdldFN1ZmZpeDpcXHRcIiVzXCInLCB0aGlzLnRhcmdldFN1ZmZpeCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnYWxsb3dJZENoYW5nZTpcXHQlcycsIHRoaXMuYWxsb3dJZENoYW5nZSgpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdiZWF1dGlmeU91dHB1dDpcXHQlcycsIHRoaXMuYmVhdXRpZnlPdXRwdXQoKSk7XHJcbiAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygncHJlc2VydmVPcmRlcjpcXHQlcycsIHRoaXMucHJlc2VydmVPcmRlcigpKTtcclxuICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdhdXRvdHJhbnNsYXRlOlxcdCVzJywgdGhpcy5hdXRvdHJhbnNsYXRlKCkpO1xyXG4gICAgICAgIGlmICh0aGlzLmF1dG90cmFuc2xhdGUoKSkge1xyXG4gICAgICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdhdXRvdHJhbnNsYXRlZCBsYW5ndWFnZXM6XFx0JXMnLCB0aGlzLmF1dG90cmFuc2xhdGVkTGFuZ3VhZ2VzKCkpO1xyXG4gICAgICAgICAgICBjb21tYW5kT3V0cHV0LmRlYnVnKCdhcGlrZXk6XFx0JXMnLCB0aGlzLmFwaWtleSgpID8gJyoqKionIDogJ05PVCBTRVQnKTtcclxuICAgICAgICAgICAgY29tbWFuZE91dHB1dC5kZWJ1ZygnYXBpa2V5ZmlsZTpcXHQlcycsIHRoaXMuYXBpa2V5ZmlsZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0LUxhbmd1YWdlLCBkZWZhdWx0IGVuLlxyXG4gICAgICogQHJldHVybiBkZWZhdWx0IGxhbmd1YWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWZhdWx0TGFuZ3VhZ2UoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdExhbmd1YWdlID8gdGhpcy5fZGVmYXVsdExhbmd1YWdlIDogJ2VuJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3RlIGRlciB6dSBiZWFyYmVpdGVuZGVuIFNwcmFjaGVuLlxyXG4gICAgICogQHJldHVybiBsYW5ndWFnZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxhbmd1YWdlcygpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlcyA/IHRoaXMuX2xhbmd1YWdlcyA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc3JjIGRpcmVjdG9yeSwgd2hlcmUgdGhlIG1hc3RlciB4bGlmIGlzIGxvY2F0ZWQuXHJcbiAgICAgKiBAcmV0dXJuIHNyY0RpclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3JjRGlyKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NyY0RpciA/IHRoaXMuX3NyY0RpciA6ICcuJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGZpbGUgbmFtZSBvZiB0aGUgeGxpZiBmaWxlIGZvciBpbnB1dCBhbmQgb3V0cHV0LlxyXG4gICAgICogRGVmYXVsdCBpcyBtZXNzYWdlc1xyXG4gICAgICogQHJldHVybiBiYXNlIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGkxOG5CYXNlRmlsZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pMThuQmFzZUZpbGUgPyB0aGlzLl9pMThuQmFzZUZpbGUgOiAnbWVzc2FnZXMnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1hc3RlciB4bGlmIGZpbGUgKHRoZSBvbmUgZ2VuZXJhdGVkIGJ5IG5nLXhpMThuKS5cclxuICAgICAqIERlZmF1bHQgaXMgPHNyY0Rpcj4vPGkxOG5CYXNlRmlsZT4ueGxmLlxyXG4gICAgICogQHJldHVybiBtYXN0ZXIgZmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaTE4bkZpbGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gam9pbih0aGlzLnNyY0RpcigpLFxyXG4gICAgICAgICAgICAodGhpcy5faTE4bkZpbGUgPyB0aGlzLl9pMThuRmlsZSA6IHRoaXMuaTE4bkJhc2VGaWxlKCkgKyAnLicgKyB0aGlzLnN1ZmZpeEZvckdlbmVyYXRlZEkxOG5GaWxlKCkpXHJcbiAgICAgICAgKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXQgb2YgdGhlIG1hc3RlciB4bGlmIGZpbGUuXHJcbiAgICAgKiBEZWZhdWx0IGlzIFwieGxmXCIsIHBvc3NpYmxlIGFyZSBcInhsZlwiIG9yIFwieGxmMlwiIG9yIFwieG1iXCIuXHJcbiAgICAgKiBAcmV0dXJuIGZvcm1hdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaTE4bkZvcm1hdCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5faTE4bkZvcm1hdCA/IHRoaXMuX2kxOG5Gb3JtYXQgOiAneGxmJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBwb3RlbnRpYWxseSB0byBiZSBnZW5lcmF0ZWQgSTE4bi1GaWxlIHdpdGggdGhlIHRyYW5zbGF0aW9ucyBmb3Igb25lIGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2Ugc2hvcnRjdXRcclxuICAgICAqIEByZXR1cm4gUGF0aCBvZiBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZW5lcmF0ZWRJMThuRmlsZShsYW5nOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBqb2luKHRoaXMuZ2VuRGlyKCksIHRoaXMuaTE4bkJhc2VGaWxlKCkgKyAnLicgKyBsYW5nICsgJy4nICsgdGhpcy5zdWZmaXhGb3JHZW5lcmF0ZWRJMThuRmlsZSgpKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdWZmaXhGb3JHZW5lcmF0ZWRJMThuRmlsZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5pMThuRm9ybWF0KCkpIHtcclxuICAgICAgICAgICAgY2FzZSAneGxmJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAneGxmJztcclxuICAgICAgICAgICAgY2FzZSAneGxmMic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3hsZic7XHJcbiAgICAgICAgICAgIGNhc2UgJ3htYic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3h0Yic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcG90ZW50aWFsbHkgdG8gYmUgZ2VuZXJhdGVkIHRyYW5zbGF0ZS1GaWxlIGZvciBuZ3gtdHJhbnNsYXRlIHdpdGggdGhlIHRyYW5zbGF0aW9ucyBmb3Igb25lIGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2Ugc2hvcnRjdXRcclxuICAgICAqIEByZXR1cm4gUGF0aCBvZiBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZW5lcmF0ZWROZ3hUcmFuc2xhdGVGaWxlKGxhbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGpvaW4odGhpcy5nZW5EaXIoKSwgdGhpcy5pMThuQmFzZUZpbGUoKSArICcuJyArIGxhbmcgKyAnLicgKyAnanNvbicpLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlbmNvZGluZyB1c2VkIHRvIHdyaXRlIG5ldyBYTElGRi1maWxlcy5cclxuICAgICAqIEByZXR1cm4gZW5jb2RpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuY29kaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kaW5nID8gdGhpcy5fZW5jb2RpbmcgOiAnVVRGLTgnO1xyXG4gICAgfVxyXG5cclxuICAgICAvKipcclxuICAgICAgKiBPdXRwdXQtRGlyZWN0b3J5LCB3aGVyZSB0aGUgb3V0cHV0IGlzIHdyaXR0ZW4gdG8uXHJcbiAgICAgICogRGVmYXVsdCBpcyA8c3JjRGlyPi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdlbkRpcigpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5EaXIgPyB0aGlzLl9nZW5EaXIgOiB0aGlzLnNyY0RpcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZW1vdmVVbnVzZWRJZHMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9yZW1vdmVVbnVzZWRJZHMpKSA/IHRydWUgOiB0aGlzLl9yZW1vdmVVbnVzZWRJZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN1cHBvcnROZ3hUcmFuc2xhdGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9zdXBwb3J0Tmd4VHJhbnNsYXRlKSkgPyBmYWxzZSA6IHRoaXMuX3N1cHBvcnROZ3hUcmFuc2xhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG5neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybikpID9cclxuICAgICAgICAgICAgTmd4VHJhbnNsYXRlRXh0cmFjdG9yLkRlZmF1bHRFeHRyYWN0aW9uUGF0dGVybiA6IHRoaXMuX25neFRyYW5zbGF0ZUV4dHJhY3Rpb25QYXR0ZXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBzb3VyY2UgbXVzdCBiZSB1c2VkIGFzIHRhcmdldCBmb3IgbmV3IHRyYW5zLXVuaXRzXHJcbiAgICAgKiBEZWZhdWx0IGlzIHRydWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVzZVNvdXJjZUFzVGFyZ2V0KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fdXNlU291cmNlQXNUYXJnZXQpKSA/IHRydWUgOiB0aGlzLl91c2VTb3VyY2VBc1RhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByYWVmaXggdXNlZCBmb3IgdGFyZ2V0IHdoZW4gY29weWluZyBuZXcgdHJhbnMtdW5pdHNcclxuICAgICAqIERlZmF1bHQgaXMgXCJcIlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdGFyZ2V0UHJhZWZpeCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fdGFyZ2V0UHJhZWZpeCkpID8gJycgOiB0aGlzLl90YXJnZXRQcmFlZml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VmZml4IHVzZWQgZm9yIHRhcmdldCB3aGVuIGNvcHlpbmcgbmV3IHRyYW5zLXVuaXRzXHJcbiAgICAgKiBEZWZhdWx0IGlzIFwiXCJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldFN1ZmZpeCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fdGFyZ2V0U3VmZml4KSkgPyAnJyA6IHRoaXMuX3RhcmdldFN1ZmZpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCwgcnVuIHhtbCByZXN1bHQgdGhyb3VnaCBiZWF1dGlmaWVyIChwcmV0dHktZGF0YSkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBiZWF1dGlmeU91dHB1dCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuX2JlYXV0aWZ5T3V0cHV0KSkgPyBmYWxzZSA6IHRoaXMuX2JlYXV0aWZ5T3V0cHV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0LCBvcmRlciBvZiBuZXcgdHJhbnMgdW5pdHMgd2lsbCBiZSBhcyBpbiBtYXN0ZXIuXHJcbiAgICAgKiBPdGhlcndpc2UgdGhleSBhcmUgYWRkZWQgYXQgdGhlIGVuZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHByZXNlcnZlT3JkZXIoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9wcmVzZXJ2ZU9yZGVyKSkgPyB0cnVlIDogdGhpcy5fcHJlc2VydmVPcmRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gdXNlIGF1dG90cmFuc2xhdGUgZm9yIG5ldyB0cmFucy11bml0c1xyXG4gICAgICogRGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXV0b3RyYW5zbGF0ZSgpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodGhpcy5fYXV0b3RyYW5zbGF0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheSh0aGlzLl9hdXRvdHJhbnNsYXRlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKDxzdHJpbmdbXT50aGlzLl9hdXRvdHJhbnNsYXRlKS5sZW5ndGggPiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGJvb2xlYW4+IHRoaXMuX2F1dG90cmFuc2xhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHVzZSBhdXRvdHJhbnNsYXRlIGZvciBhIGdpdmVuIGxhbmd1YWdlLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2UgY29kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGF1dG90cmFuc2xhdGVMYW5ndWFnZShsYW5nOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRvdHJhbnNsYXRlZExhbmd1YWdlcygpLmluZGV4T2YobGFuZykgPj0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGxpc3Qgb2YgbGFuZ3VhZ2VzIHRvIGJlIGF1dG90cmFuc2xhdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXV0b3RyYW5zbGF0ZWRMYW5ndWFnZXMoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh0aGlzLl9hdXRvdHJhbnNsYXRlKSB8fCB0aGlzLl9hdXRvdHJhbnNsYXRlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KHRoaXMuX2F1dG90cmFuc2xhdGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoPHN0cmluZ1tdPnRoaXMuX2F1dG90cmFuc2xhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZXMoKS5zbGljZSgxKTsgLy8gZmlyc3QgaXMgc291cmNlIGxhbmd1YWdlXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBUEkga2V5IHRvIGJlIHVzZWQgZm9yIEdvb2dsZSBUcmFuc2xhdGVcclxuICAgICAqIEByZXR1cm4gYXBpIGtleVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXBpa2V5KCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0aGlzLl9hcGlrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcGlrZXk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgYXBpa2V5UGF0aCA9IHRoaXMuYXBpa2V5ZmlsZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hcGlrZXlmaWxlKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGFwaWtleVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpbGVVdGlsLnJlYWQoYXBpa2V5UGF0aCwgJ3V0Zi04Jyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ2FwaSBrZXkgZmlsZSBub3QgZm91bmQ6IEFQSV9LRVlfRklMRT0lcycsIGFwaWtleVBhdGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmlsZSBuYW1lIGZvciBBUEkga2V5IHRvIGJlIHVzZWQgZm9yIEdvb2dsZSBUcmFuc2xhdGUuXHJcbiAgICAgKiBFeHBsaWNpdGx5IHNldCBvciByZWFkIGZyb20gZW52IHZhciBBUElfS0VZX0ZJTEUuXHJcbiAgICAgKiBAcmV0dXJuIGZpbGUgb2YgYXBpIGtleVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXBpa2V5ZmlsZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLl9hcGlrZXlmaWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcGlrZXlmaWxlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuQVBJX0tFWV9GSUxFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5BUElfS0VZX0ZJTEU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAxOS4wMi4yMDE3LlxyXG4gKi9cclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuXHJcbmxldCBwa2cgPSBudWxsO1xyXG50cnkge1xyXG4gICAgcGtnID0gcmVxdWlyZShwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAncGFja2FnZS5qc29uJykpO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHBrZyA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJ3BhY2thZ2UuanNvbicpKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBwa2cgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IChwa2cgPyBwa2cudmVyc2lvbiA6ICd1bmtub3duJyk7XHJcbiIsImltcG9ydCB7RmlsZVV0aWx9IGZyb20gJy4uL2NvbW1vbi9maWxlLXV0aWwnO1xyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTAuMDMuMjAxNy5cclxuICogSGVscGVyIGNsYXNzIHRvIHJlYWQgWE1sIHdpdGggYSBjb3JyZWN0IGVuY29kaW5nLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbWxSZWFkZXIge1xyXG4gICAgc3RhdGljIERFRkFVTFRfRU5DT0RJTkcgPSAnVVRGLTgnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBhbiB4bWwtRmlsZS5cclxuICAgICAqIEBwYXJhbSBwYXRoIFBhdGggdG8gZmlsZVxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIG9wdGlvbmFsIGVuY29kaW5nIG9mIHRoZSB4bWwuXHJcbiAgICAgKiBUaGlzIGlzIHJlYWQgZnJvbSB0aGUgZmlsZSwgYnV0IGlmIHlvdSBrbm93IGl0IGJlZm9yZSwgeW91IGNhbiBhdm9pZCByZWFkaW5nIHRoZSBmaWxlIHR3aWNlLlxyXG4gICAgICogQHJldHVybiBmaWxlIGNvbnRlbnQgYW5kIGVuY29kaW5nIGZvdW5kIGluIHRoZSBmaWxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRYbWxGaWxlQ29udGVudChwYXRoOiBzdHJpbmcsIGVuY29kaW5nPzogc3RyaW5nKToge2NvbnRlbnQ6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZ30ge1xyXG4gICAgICAgIGlmICghZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSBYbWxSZWFkZXIuREVGQVVMVF9FTkNPRElORztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZyA9IEZpbGVVdGlsLnJlYWQocGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIGNvbnN0IGZvdW5kRW5jb2RpbmcgPSBYbWxSZWFkZXIuZW5jb2RpbmdGcm9tWG1sKGNvbnRlbnQpO1xyXG4gICAgICAgIGlmIChmb3VuZEVuY29kaW5nICE9PSBlbmNvZGluZykge1xyXG4gICAgICAgICAgICAvLyByZWFkIGFnYWluIHdpdGggdGhlIGNvcnJlY3QgZW5jb2RpbmdcclxuICAgICAgICAgICAgY29udGVudCA9IEZpbGVVdGlsLnJlYWQocGF0aCwgZm91bmRFbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgIGVuY29kaW5nOiBmb3VuZEVuY29kaW5nXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgdGhlIGVuY29kaW5nIGZyb20gdGhlIHhtbC5cclxuICAgICAqIHhtbCBGaWxlIHN0YXJ0cyB3aXRoIC4uIGVuY29kaW5nPVwiLi5cIlxyXG4gICAgICogQHBhcmFtIHhtbFN0cmluZyB4bWxTdHJpbmdcclxuICAgICAqIEByZXR1cm4gZW5jb2RpbmdcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZW5jb2RpbmdGcm9tWG1sKHhtbFN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHhtbFN0cmluZy5pbmRleE9mKCdlbmNvZGluZz1cIicpO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuREVGQVVMVF9FTkNPRElORzsgLy8gZGVmYXVsdCBpbiB4bWwgaWYgbm90IGV4cGxpY2l0bHkgc2V0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0geG1sU3RyaW5nLmluZGV4T2YoJ1wiJywgaW5kZXggKyAxMCk7IC8vIDEwID0gbGVuZ3RoIG9mICdlbmNvZGluZz1cIidcclxuICAgICAgICByZXR1cm4geG1sU3RyaW5nLnN1YnN0cmluZyhpbmRleCArIDEwLCBlbmRJbmRleCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAyMS4wMy4yMDE3LlxyXG4gKi9cclxuaW1wb3J0IHtUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZUZhY3RvcnksIElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZX0gZnJvbSAnQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliJztcclxuaW1wb3J0IHtGaWxlVXRpbH0gZnJvbSAnLi4vY29tbW9uL2ZpbGUtdXRpbCc7XHJcbmltcG9ydCB7WG1sUmVhZGVyfSBmcm9tICcuL3htbC1yZWFkZXInO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyB0byByZWFkIHRyYW5zbGF0aW9uIGZpbGVzIGRlcGVuZGluZyBvbiBmb3JtYXQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBmaWxlIGZ1bmN0aW9uLCByZXN1bHQgZGVwZW5kcyBvbiBmb3JtYXQsIGVpdGhlciBYbGlmZkZpbGUgb3IgWG1iRmlsZS5cclxuICAgICAqIEBwYXJhbSBpMThuRm9ybWF0IGZvcm1hdFxyXG4gICAgICogQHBhcmFtIHBhdGggcGF0aFxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIGVuY29kaW5nXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCBvcHRpb25hbE1hc3RlckZpbGVQYXRoXHJcbiAgICAgKiBAcmV0dXJuIFhsaWZmRmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZyb21GaWxlKGkxOG5Gb3JtYXQ6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbE1hc3RlckZpbGVQYXRoPzogc3RyaW5nKTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlIHtcclxuICAgICAgICBjb25zdCB4bWxDb250ZW50ID0gWG1sUmVhZGVyLnJlYWRYbWxGaWxlQ29udGVudChwYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxNYXN0ZXIgPSBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5tYXN0ZXJGaWxlQ29udGVudChvcHRpb25hbE1hc3RlckZpbGVQYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgcmV0dXJuIFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlRmFjdG9yeS5mcm9tRmlsZUNvbnRlbnQoaTE4bkZvcm1hdCwgeG1sQ29udGVudC5jb250ZW50LCBwYXRoLCB4bWxDb250ZW50LmVuY29kaW5nLCBvcHRpb25hbE1hc3Rlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGZpbGUgZnVuY3Rpb24sIHJlc3VsdCBkZXBlbmRzIG9uIGZvcm1hdCwgZWl0aGVyIFhsaWZmRmlsZSBvciBYbWJGaWxlLlxyXG4gICAgICogQHBhcmFtIHBhdGggcGF0aFxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIGVuY29kaW5nXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCBvcHRpb25hbE1hc3RlckZpbGVQYXRoXHJcbiAgICAgKiBAcmV0dXJuIFhsaWZmRmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZyb21Vbmtub3duRm9ybWF0RmlsZShwYXRoOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aD86IHN0cmluZyk6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSB7XHJcbiAgICAgICAgY29uc3QgeG1sQ29udGVudCA9IFhtbFJlYWRlci5yZWFkWG1sRmlsZUNvbnRlbnQocGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsTWFzdGVyID0gVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIubWFzdGVyRmlsZUNvbnRlbnQob3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIHJldHVybiBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZUZhY3RvcnkuZnJvbVVua25vd25Gb3JtYXRGaWxlQ29udGVudCh4bWxDb250ZW50LmNvbnRlbnQsIHBhdGgsIHhtbENvbnRlbnQuZW5jb2RpbmcsIG9wdGlvbmFsTWFzdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgbWFzdGVyIHhtYiBmaWxlXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCBvcHRpb25hbE1hc3RlckZpbGVQYXRoXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgZW5jb2RpbmdcclxuICAgICAqIEByZXR1cm4gY29udGVudCBhbmQgZW5jb2Rpbmcgb2YgZmlsZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBtYXN0ZXJGaWxlQ29udGVudChvcHRpb25hbE1hc3RlckZpbGVQYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpXHJcbiAgICAgICAgOiB7eG1sQ29udGVudDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmd9IHtcclxuICAgICAgICBpZiAob3B0aW9uYWxNYXN0ZXJGaWxlUGF0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXN0ZXJYbWxDb250ZW50ID0gWG1sUmVhZGVyLnJlYWRYbWxGaWxlQ29udGVudChvcHRpb25hbE1hc3RlckZpbGVQYXRoLCBlbmNvZGluZyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4bWxDb250ZW50OiBtYXN0ZXJYbWxDb250ZW50LmNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICBwYXRoOiBvcHRpb25hbE1hc3RlckZpbGVQYXRoLFxyXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IG1hc3RlclhtbENvbnRlbnQuZW5jb2RpbmdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIGVkaXRlZCBmaWxlLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzRmlsZSBtZXNzYWdlc0ZpbGVcclxuICAgICAqIEBwYXJhbSBiZWF1dGlmeU91dHB1dCBGbGFnIHdoZXRoZXIgdG8gdXNlIHByZXR0eS1kYXRhIHRvIGZvcm1hdCB0aGUgb3V0cHV0LlxyXG4gICAgICogWE1MU2VyaWFsaXplciBwcm9kdWNlcyBzb21lIGNvcnJlY3QgYnV0IHN0cmFuZ2VseSBmb3JtYXR0ZWQgb3V0cHV0LCB3aGljaCBwcmV0dHktZGF0YSBjYW4gY29ycmVjdC5cclxuICAgICAqIFNlZSBpc3N1ZSAjNjQgZm9yIGRldGFpbHMuXHJcbiAgICAgKiBEZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNhdmUobWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsIGJlYXV0aWZ5T3V0cHV0PzogYm9vbGVhbikge1xyXG4gICAgICAgIEZpbGVVdGlsLnJlcGxhY2VDb250ZW50KG1lc3NhZ2VzRmlsZS5maWxlbmFtZSgpLCBtZXNzYWdlc0ZpbGUuZWRpdGVkQ29udGVudChiZWF1dGlmeU91dHB1dCksIG1lc3NhZ2VzRmlsZS5lbmNvZGluZygpKTtcclxuICAgIH1cclxufVxyXG5cclxuIiwiaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3JlcXVlc3QnO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge29mLCBmb3JrSm9pbiwgdGhyb3dFcnJvcn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7bWFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSByb29ibSBvbiAwMy4wNy4yMDE3LlxyXG4gKiBMb3cgTGV2ZWwgU2VydmljZSB0byBjYWxsIEdvb2dsZSBUcmFuc2xhdGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFR5cGVzIGZvcm0gZ29vZ2xlIHRyYW5zbGF0ZSBhcGkuXHJcbiAqL1xyXG5cclxuaW50ZXJmYWNlIEdldFN1cHBvcnRlZExhbmd1YWdlc1JlcXVlc3Qge1xyXG4gICAgdGFyZ2V0OiBzdHJpbmc7IC8vIFRoZSBsYW5ndWFnZSB0byB1c2UgdG8gcmV0dXJuIGxvY2FsaXplZCwgaHVtYW4gcmVhZGFibGUgbmFtZXMgb2Ygc3VwcG9ydGVkXFxubGFuZ3VhZ2VzLlxyXG59XHJcblxyXG5pbnRlcmZhY2UgTGFuZ3VhZ2VzUmVzb3VyY2Uge1xyXG4gICAgbGFuZ3VhZ2U6IHN0cmluZzsgLy8gY29kZSBvZiB0aGUgbGFuZ3VhZ2VcclxuICAgIG5hbWU6IHN0cmluZzsgLy8gaHVtYW4gcmVhZGFibGUgbmFtZSAoaW4gdGFyZ2V0IGxhbmd1YWdlKVxyXG59XHJcblxyXG5pbnRlcmZhY2UgTGFuZ3VhZ2VzTGlzdFJlc3BvbnNlIHtcclxuICAgIGxhbmd1YWdlczogTGFuZ3VhZ2VzUmVzb3VyY2VbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFRyYW5zbGF0ZVRleHRSZXF1ZXN0IHtcclxuICAgIHE6IHN0cmluZ1tdOyAgLy8gVGhlIGlucHV0IHRleHRzIHRvIHRyYW5zbGF0ZVxyXG4gICAgdGFyZ2V0OiBzdHJpbmc7IC8vIFRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIHRyYW5zbGF0aW9uIG9mIHRoZSBpbnB1dCB0ZXh0XHJcbiAgICBzb3VyY2U6IHN0cmluZzsgLy8gVGhlIGxhbmd1YWdlIG9mIHRoZSBzb3VyY2UgdGV4dFxyXG4gICAgZm9ybWF0Pzogc3RyaW5nOyAvLyBcImh0bWxcIiAoZGVmYXVsdCkgb3IgXCJ0ZXh0XCJcclxuICAgIG1vZGVsPzogc3RyaW5nOyAvLyBzZWUgcHVibGljIGRvY3VtZW50YXRpb25cclxufVxyXG5cclxuaW50ZXJmYWNlIFRyYW5zbGF0aW9uc1Jlc291cmNlIHtcclxuICAgIGRldGVjdGVkU291cmNlTGFuZ3VhZ2U/OiBzdHJpbmc7XHJcbiAgICBtb2RlbD86IHN0cmluZztcclxuICAgIHRyYW5zbGF0ZWRUZXh0OiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUcmFuc2xhdGlvbnNMaXN0UmVzcG9uc2Uge1xyXG4gICAgdHJhbnNsYXRpb25zOiBUcmFuc2xhdGlvbnNSZXNvdXJjZVtdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgSW50ZXJuYWxSZXF1ZXN0UmVzcG9uc2Uge1xyXG4gICAgcmVzcG9uc2U6IHJlcXVlc3QuUmVxdWVzdFJlc3BvbnNlO1xyXG4gICAgYm9keTogYW55O1xyXG59XHJcblxyXG5jb25zdCBNQVhfU0VHTUVOVFMgPSAxMjg7XHJcblxyXG5leHBvcnQgY2xhc3MgQXV0b1RyYW5zbGF0ZVNlcnZpY2Uge1xyXG5cclxuICAgIHByaXZhdGUgX3JlcXVlc3Q6IHJlcXVlc3QuUmVxdWVzdEFQSTxyZXF1ZXN0LlJlcXVlc3QsIHJlcXVlc3QuQ29yZU9wdGlvbnMsIHJlcXVlc3QuUmVxdWlyZWRVcmlVcmw+O1xyXG4gICAgX3Jvb3RVcmw6IHN0cmluZztcclxuICAgIF9hcGlLZXk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmlwIHJlZ2lvbiBjb2RlIGFuZCBjb252ZXJ0IHRvIGxvd2VyXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBsYW5nXHJcbiAgICAgKiBAcmV0dXJuIGxhbmcgd2l0aG91dCByZWdpb24gY29kZSBhbmQgaW4gbG93ZXIgY2FzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdHJpcFJlZ2lvbmNvZGUobGFuZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBsYW5nTG93ZXIgPSBsYW5nLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYW5nTG93ZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYyA9IGxhbmdMb3dlci5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgIGlmIChjIDwgJ2EnIHx8IGMgPiAneicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nTG93ZXIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsYW5nTG93ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBpS2V5OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgICAgICB0aGlzLl9hcGlLZXkgPSBhcGlLZXk7XHJcbiAgICAgICAgdGhpcy5fcm9vdFVybCA9ICdodHRwczovL3RyYW5zbGF0aW9uLmdvb2dsZWFwaXMuY29tLyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgQVBJIGtleSAoanVzdCBmb3IgdGVzdHMpLlxyXG4gICAgICogQHBhcmFtIGFwaWtleSBhcGlrZXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEFwaUtleShhcGlrZXk6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2FwaUtleSA9IGFwaWtleTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZSBhbiBhcnJheSBvZiBtZXNzYWdlcyBhdCBvbmNlLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIHRoZSBtZXNzYWdlcyB0byBiZSB0cmFuc2xhdGVkXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBzb3VyY2UgbGFuZ3VhZ2UgY29kZVxyXG4gICAgICogQHBhcmFtIHRvIHRhcmdldCBsYW5ndWFnZSBjb2RlXHJcbiAgICAgKiBAcmV0dXJuIE9ic2VydmFibGUgd2l0aCB0cmFuc2xhdGVkIG1lc3NhZ2VzIG9yIGVycm9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVNdWx0aXBsZVN0cmluZ3MobWVzc2FnZXM6IHN0cmluZ1tdLCBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZ1tdPiB7XHJcbiAgICAgICAgLy8gZW1wdHkgYXJyYXkgbmVlZHMgbm8gdHJhbnNsYXRpb24gYW5kIGFsd2F5cyB3b3JrcyAuLi4gKCM3OClcclxuICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvZihbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fYXBpS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdjYW5ub3QgYXV0b3RyYW5zbGF0ZTogbm8gYXBpIGtleScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZyb20gfHwgIXRvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdjYW5ub3QgYXV0b3RyYW5zbGF0ZTogc291cmNlIGFuZCB0YXJnZXQgbGFuZ3VhZ2UgbXVzdCBiZSBzZXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJvbSA9IEF1dG9UcmFuc2xhdGVTZXJ2aWNlLnN0cmlwUmVnaW9uY29kZShmcm9tKTtcclxuICAgICAgICB0byA9IEF1dG9UcmFuc2xhdGVTZXJ2aWNlLnN0cmlwUmVnaW9uY29kZSh0byk7XHJcbiAgICAgICAgY29uc3QgYWxsUmVxdWVzdHM6IE9ic2VydmFibGU8c3RyaW5nW10+W10gPSB0aGlzLnNwbGl0TWVzc2FnZXNUb0dvb2dsZUxpbWl0KG1lc3NhZ2VzKS5tYXAoKHBhcnRpYWxNZXNzYWdlczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGltaXRlZFRyYW5zbGF0ZU11bHRpcGxlU3RyaW5ncyhwYXJ0aWFsTWVzc2FnZXMsIGZyb20sIHRvKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oYWxsUmVxdWVzdHMpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoYWxsVHJhbnNsYXRpb25zOiBzdHJpbmdbXVtdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWxsID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbFRyYW5zbGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbCA9IGFsbC5jb25jYXQoYWxsVHJhbnNsYXRpb25zW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhbGw7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3BsaXRNZXNzYWdlc1RvR29vZ2xlTGltaXQobWVzc2FnZXM6IHN0cmluZ1tdKTogc3RyaW5nW11bXSB7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA8PSBNQVhfU0VHTUVOVFMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFttZXNzYWdlc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50UGFja2FnZSA9IFtdO1xyXG4gICAgICAgIGxldCBwYWNrYWdlU2l6ZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjdXJyZW50UGFja2FnZS5wdXNoKG1lc3NhZ2VzW2ldKTtcclxuICAgICAgICAgICAgcGFja2FnZVNpemUrKztcclxuICAgICAgICAgICAgaWYgKHBhY2thZ2VTaXplID49IE1BWF9TRUdNRU5UUykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudFBhY2thZ2UpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhY2thZ2UgPSBbXTtcclxuICAgICAgICAgICAgICAgIHBhY2thZ2VTaXplID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VycmVudFBhY2thZ2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50UGFja2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdHJhbnNsYXRpb24gcmVxdWVzdCwgYnV0IG1lc3NhZ2VzIG11c3QgYmUgbGltaXRlZCB0byBnb29nbGUgbGltaXRzLlxyXG4gICAgICogTm90IG1vcmUgdGhhdCAxMjggc2luZ2xlIG1lc3NhZ2VzLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIG1lc3NhZ2VzXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gdG8gdG9cclxuICAgICAqIEByZXR1cm4gdGhlIHRyYW5zbGF0ZWQgc3RyaW5nc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxpbWl0ZWRUcmFuc2xhdGVNdWx0aXBsZVN0cmluZ3MobWVzc2FnZXM6IHN0cmluZ1tdLCBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZ1tdPiB7XHJcbiAgICAgICAgY29uc3QgcmVhbFVybCA9IHRoaXMuX3Jvb3RVcmwgKyAnbGFuZ3VhZ2UvdHJhbnNsYXRlL3YyJyArICc/a2V5PScgKyB0aGlzLl9hcGlLZXk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlUmVxdWVzdDogVHJhbnNsYXRlVGV4dFJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIHE6IG1lc3NhZ2VzLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRvLFxyXG4gICAgICAgICAgICBzb3VyY2U6IGZyb20sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICB1cmw6IHJlYWxVcmwsXHJcbiAgICAgICAgICAgIGJvZHk6IHRyYW5zbGF0ZVJlcXVlc3QsXHJcbiAgICAgICAgICAgIGpzb246IHRydWUsXHJcbi8vICAgICAgICAgICAgcHJveHk6ICdodHRwOi8vMTI3LjAuMC4xOjg4ODgnIFRvIHNldCBhIHByb3h5IHVzZSBlbnYgdmFyIEhUVFBTX1BST1hZXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHJlYWxVcmwsIG9wdGlvbnMpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBib2R5OiBhbnkgPSBkYXRhLmJvZHk7XHJcbiAgICAgICAgICAgIGlmICghYm9keSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyByZXN1bHQgcmVjZWl2ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm9keS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHkuZXJyb3IuY29kZSA9PT0gNDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkuZXJyb3IubWVzc2FnZSA9PT0gJ0ludmFsaWQgVmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ1RyYW5zbGF0aW9uIGZyb20gXCIlc1wiIHRvIFwiJXNcIiBub3Qgc3VwcG9ydGVkJywgZnJvbSwgdG8pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnSW52YWxpZCByZXF1ZXN0OiAlcycsIGJvZHkuZXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdFcnJvciAlczogJXMnLCBib2R5LmVycm9yLmNvZGUsIGJvZHkuZXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGJvZHkuZGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50cmFuc2xhdGlvbnMubWFwKCh0cmFuc2xhdGlvbjogVHJhbnNsYXRpb25zUmVzb3VyY2UpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbi50cmFuc2xhdGVkVGV4dDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gZG8gYSBQT1NUIEhUVFAgcmVxdWVzdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmkgdXJpXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiByZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBwb3N0KHVyaTogc3RyaW5nLCBvcHRpb25zPzogcmVxdWVzdC5Db3JlT3B0aW9ucyk6IE9ic2VydmFibGU8SW50ZXJuYWxSZXF1ZXN0UmVzcG9uc2U+IHtcclxuICAgICAgICByZXR1cm4gPE9ic2VydmFibGU8SW50ZXJuYWxSZXF1ZXN0UmVzcG9uc2U+PiB0aGlzLl9jYWxsLmFwcGx5KHRoaXMsIFtdLmNvbmNhdCgncG9zdCcsIDxzdHJpbmc+IHVyaSxcclxuICAgICAgICAgICAgPHJlcXVlc3QuQ29yZU9wdGlvbnM+IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgfHwge30pKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBkbyBhIEhUVFAgcmVxdWVzdCBmb3IgZ2l2ZW4gbWV0aG9kXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1ldGhvZCBtZXRob2RcclxuICAgICAqIEBwYXJhbSB1cmkgdXJpXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiByZXNwb25zZVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfY2FsbChtZXRob2Q6IHN0cmluZywgdXJpOiBzdHJpbmcsIG9wdGlvbnM/OiByZXF1ZXN0LkNvcmVPcHRpb25zKTogT2JzZXJ2YWJsZTxJbnRlcm5hbFJlcXVlc3RSZXNwb25zZT4ge1xyXG4gICAgICAgIHJldHVybiA8T2JzZXJ2YWJsZTxJbnRlcm5hbFJlcXVlc3RSZXNwb25zZT4+IE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICAvLyBidWlsZCBwYXJhbXMgYXJyYXlcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW10uY29uY2F0KDxzdHJpbmc+IHVyaSwgPHJlcXVlc3QuQ29yZU9wdGlvbnM+IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgfHwge30pLFxyXG4gICAgICAgICAgICAgICAgPFJlcXVlc3RDYWxsYmFjaz4oZXJyb3I6IGFueSwgcmVzcG9uc2U6IHJlcXVlc3QuUmVxdWVzdFJlc3BvbnNlLCBib2R5OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoPEludGVybmFsUmVxdWVzdFJlc3BvbnNlPiBPYmplY3QuYXNzaWduKHt9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiA8cmVxdWVzdC5SZXF1ZXN0UmVzcG9uc2U+IHJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiA8YW55PiBib2R5XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIF9jYWxsIHJlcXVlc3QgbWV0aG9kXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0WzxzdHJpbmc+IG1ldGhvZF0uYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgPHJlcXVlc3QuUmVxdWVzdEFQSTxyZXF1ZXN0LlJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5Db3JlT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LlJlcXVpcmVkVXJpVXJsPj4gdGhpcy5fcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDI5LjA2LjIwMTcuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEF1dG9UcmFuc2xhdGVSZXN1bHQge1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zdWNjZXNzOiBib29sZWFuLCBwcml2YXRlIF9kZXRhaWxzOiBzdHJpbmcpIHtcclxuXHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3VjY2VzcygpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9zdWNjZXNzO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge0F1dG9UcmFuc2xhdGVSZXN1bHR9IGZyb20gJy4vYXV0by10cmFuc2xhdGUtcmVzdWx0JztcclxuaW1wb3J0IHtmb3JtYXR9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQge0lUcmFuc1VuaXR9IGZyb20gJ0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYic7XHJcblxyXG4vKipcclxuICogQSByZXBvcnQgYWJvdXQgYSBydW4gb2YgR29vZ2xlIFRyYW5zbGF0ZSBvdmVyIGFsbCB1bnRyYW5zbGF0ZWQgdW5pdC5cclxuICogKiBDcmVhdGVkIGJ5IG1hcnRpbiBvbiAyOS4wNi4yMDE3LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydCB7XHJcblxyXG4gIHByaXZhdGUgX2Vycm9yOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfZnJvbTogc3RyaW5nO1xyXG4gIHByaXZhdGUgX3RvOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfdG90YWw6IG51bWJlcjtcclxuICBwcml2YXRlIF9pZ25vcmVkOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBfc3VjY2VzczogbnVtYmVyO1xyXG4gIHByaXZhdGUgX2ZhaWxlZDogbnVtYmVyO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xyXG4gICAgdGhpcy5fdG8gPSB0bztcclxuICAgIHRoaXMuX3RvdGFsID0gMDtcclxuICAgIHRoaXMuX2lnbm9yZWQgPSAwO1xyXG4gICAgdGhpcy5fc3VjY2VzcyA9IDA7XHJcbiAgICB0aGlzLl9mYWlsZWQgPSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGVycm9yIGlmIHRvdGFsIGNhbGwgZmFpbGVkIChlLmcuIFwiaW52YWxpZCBhcGkga2V5XCIgb3IgXCJubyBjb25uZWN0aW9uXCIgLi4uKVxyXG4gICAqIEBwYXJhbSBlcnJvciBlcnJvclxyXG4gICAqIEBwYXJhbSB0b3RhbCB0b3RhbFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRFcnJvcihlcnJvcjogc3RyaW5nLCB0b3RhbDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xyXG4gICAgdGhpcy5fdG90YWwgPSB0b3RhbDtcclxuICAgIHRoaXMuX2ZhaWxlZCA9IHRvdGFsO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGVycm9yKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fZXJyb3I7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0SWdub3JlZChpZ25vcmVkOiBudW1iZXIpIHtcclxuICAgIHRoaXMuX3RvdGFsICs9IGlnbm9yZWQ7XHJcbiAgICB0aGlzLl9pZ25vcmVkID0gaWdub3JlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHNpbmdsZSByZXN1bHQgdG8gdGhlIHN1bW1hcnkuXHJcbiAgICogQHBhcmFtIHR1IHR1XHJcbiAgICogQHBhcmFtIHJlc3VsdCByZXN1bHRcclxuICAgKi9cclxuICBwdWJsaWMgYWRkU2luZ2xlUmVzdWx0KHR1OiBJVHJhbnNVbml0LCByZXN1bHQ6IEF1dG9UcmFuc2xhdGVSZXN1bHQpIHtcclxuICAgIHRoaXMuX3RvdGFsKys7XHJcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MoKSkge1xyXG4gICAgICB0aGlzLl9zdWNjZXNzKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9mYWlsZWQrKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIGFub3RoZXIgc3VtbWFyeSBpbnRvIHRoaXMgb25lLlxyXG4gICAqIEBwYXJhbSBhbm90aGVyU3VtbWFyeSBhbm90aGVyU3VtbWFyeVxyXG4gICAqL1xyXG4gIHB1YmxpYyBtZXJnZShhbm90aGVyU3VtbWFyeTogQXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQpIHtcclxuICAgIGlmICghdGhpcy5fZXJyb3IpIHtcclxuICAgICAgdGhpcy5fZXJyb3IgPSBhbm90aGVyU3VtbWFyeS5fZXJyb3I7XHJcbiAgICB9XHJcbiAgICB0aGlzLl90b3RhbCArPSBhbm90aGVyU3VtbWFyeS50b3RhbCgpO1xyXG4gICAgdGhpcy5faWdub3JlZCArPSBhbm90aGVyU3VtbWFyeS5pZ25vcmVkKCk7XHJcbiAgICB0aGlzLl9zdWNjZXNzICs9IGFub3RoZXJTdW1tYXJ5LnN1Y2Nlc3MoKTtcclxuICAgIHRoaXMuX2ZhaWxlZCArPSBhbm90aGVyU3VtbWFyeS5mYWlsZWQoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyB0b3RhbCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGlnbm9yZWQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl9pZ25vcmVkO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN1Y2Nlc3MoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl9zdWNjZXNzO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGZhaWxlZCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZhaWxlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEh1bWFuIHJlYWRhYmxlIHZlcnNpb24gb2YgcmVwb3J0XHJcbiAgICovXHJcbiAgcHVibGljIGNvbnRlbnQoKTogc3RyaW5nIHtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBpZiAodGhpcy5fZXJyb3IpIHtcclxuICAgICAgcmVzdWx0ID0gZm9ybWF0KCdBdXRvIHRyYW5zbGF0aW9uIGZyb20gXCIlc1wiIHRvIFwiJXNcIiBmYWlsZWQ6IFwiJXNcIiwgZmFpbGVkIHVuaXRzOiAlcycsIHRoaXMuX2Zyb20sIHRoaXMuX3RvLCB0aGlzLl9lcnJvciwgdGhpcy5fZmFpbGVkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdCA9IGZvcm1hdCgnQXV0byB0cmFuc2xhdGlvbiBmcm9tIFwiJXNcIiB0byBcIiVzXCIsIHRvdGFsIGF1dG8gdHJhbnNsYXRlZCB1bml0czogJXMsIGlnbm9yZWQ6ICVzLCBzdWNjZXNmdWw6ICVzLCBmYWlsZWQ6ICVzJyxcclxuICAgICAgICAgIHRoaXMuX2Zyb20sIHRoaXMuX3RvLCB0aGlzLl90b3RhbCwgdGhpcy5faWdub3JlZCwgdGhpcy5fc3VjY2VzcywgdGhpcy5fZmFpbGVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJy4uL2NvbW1vbi91dGlsJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBmb3JrSm9pbiwgb2Z9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge21hcCwgY2F0Y2hFcnJvcn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgKiBhcyBlbnRpdHlEZWNvZGVyTGliIGZyb20gJ2hlJztcclxuaW1wb3J0IHtcclxuICAgIElJQ1VNZXNzYWdlLCBJSUNVTWVzc2FnZVRyYW5zbGF0aW9uLCBJTm9ybWFsaXplZE1lc3NhZ2UsIElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSwgSVRyYW5zVW5pdCxcclxuICAgIFNUQVRFX05FV1xyXG59IGZyb20gJ0BuZ3gtaTE4bnN1cHBvcnQvbmd4LWkxOG5zdXBwb3J0LWxpYic7XHJcbmltcG9ydCB7QXV0b1RyYW5zbGF0ZVNlcnZpY2V9IGZyb20gJy4vYXV0by10cmFuc2xhdGUtc2VydmljZSc7XHJcbmltcG9ydCB7QXV0b1RyYW5zbGF0ZVJlc3VsdH0gZnJvbSAnLi9hdXRvLXRyYW5zbGF0ZS1yZXN1bHQnO1xyXG5pbXBvcnQge0F1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0fSBmcm9tICcuL2F1dG8tdHJhbnNsYXRlLXN1bW1hcnktcmVwb3J0JztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFydGluIG9uIDA3LjA3LjIwMTcuXHJcbiAqIFNlcnZpY2UgdG8gYXV0b3RyYW5zbGF0ZSBUcmFuc3VuaXRzIHZpYSBHb29nbGUgVHJhbnNsYXRlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZk1lcmdlQXV0b1RyYW5zbGF0ZVNlcnZpY2Uge1xyXG5cclxuICAgIHByaXZhdGUgYXV0b1RyYW5zbGF0ZVNlcnZpY2U6IEF1dG9UcmFuc2xhdGVTZXJ2aWNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwaWtleTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5hdXRvVHJhbnNsYXRlU2VydmljZSA9IG5ldyBBdXRvVHJhbnNsYXRlU2VydmljZShhcGlrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXV0byB0cmFuc2xhdGUgZmlsZSB2aWEgR29vZ2xlIFRyYW5zbGF0ZS5cclxuICAgICAqIFdpbGwgdHJhbnNsYXRlIGFsbCBuZXcgdW5pdHMgaW4gZmlsZS5cclxuICAgICAqIEBwYXJhbSBmcm9tIGZyb21cclxuICAgICAqIEBwYXJhbSB0byB0b1xyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZVxyXG4gICAgICogQHJldHVybiBhIHByb21pc2Ugd2l0aCB0aGUgZXhlY3V0aW9uIHJlc3VsdCBhcyBhIHN1bW1hcnkgcmVwb3J0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXV0b1RyYW5zbGF0ZShmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSlcclxuICAgICAgICA6IE9ic2VydmFibGU8QXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQ+IHtcclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oW1xyXG4gICAgICAgICAgICB0aGlzLmRvQXV0b1RyYW5zbGF0ZU5vbklDVU1lc3NhZ2VzKGZyb20sIHRvLCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlKSxcclxuICAgICAgICAgICAgLi4udGhpcy5kb0F1dG9UcmFuc2xhdGVJQ1VNZXNzYWdlcyhmcm9tLCB0bywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSldKVxyXG4gICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgIG1hcCgoc3VtbWFyaWVzOiBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydFtdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtbWFyeSA9IHN1bW1hcmllc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN1bW1hcmllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5Lm1lcmdlKHN1bW1hcmllc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW1tYXJ5O1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgYWxsIHVuaXRzIHRoYXQgYXJlIHVudHJhbnNsYXRlZC5cclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGVcclxuICAgICAqIEByZXR1cm4gYWxsIHVudHJhbnNsYXRlZCB1bml0c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFsbFVudHJhbnNsYXRlZFRVcyhsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUpOiBJVHJhbnNVbml0W10ge1xyXG4gICAgICAgIC8vIGNvbGxlY3QgYWxsIHVuaXRzLCB0aGF0IHNob3VsZCBiZSBhdXRvIHRyYW5zbGF0ZWRcclxuICAgICAgICBjb25zdCBhbGxVbnRyYW5zbGF0ZWQ6IElUcmFuc1VuaXRbXSA9IFtdO1xyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUuZm9yRWFjaFRyYW5zVW5pdCgodHUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHR1LnRhcmdldFN0YXRlKCkgPT09IFNUQVRFX05FVykge1xyXG4gICAgICAgICAgICAgICAgYWxsVW50cmFuc2xhdGVkLnB1c2godHUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFsbFVudHJhbnNsYXRlZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGRvQXV0b1RyYW5zbGF0ZU5vbklDVU1lc3NhZ2VzKGZyb206IHN0cmluZywgdG86IHN0cmluZywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKVxyXG4gICAgICAgIDogT2JzZXJ2YWJsZTxBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydD4ge1xyXG4gICAgICAgIGNvbnN0IGFsbFVudHJhbnNsYXRlZDogSVRyYW5zVW5pdFtdID0gdGhpcy5hbGxVbnRyYW5zbGF0ZWRUVXMobGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSk7XHJcbiAgICAgICAgY29uc3QgYWxsVHJhbnNsYXRhYmxlID0gYWxsVW50cmFuc2xhdGVkLmZpbHRlcigodHUpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHR1LnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkuZ2V0SUNVTWVzc2FnZSgpKSk7XHJcbiAgICAgICAgY29uc3QgYWxsTWVzc2FnZXM6IHN0cmluZ1tdID0gYWxsVHJhbnNsYXRhYmxlLm1hcCgodHUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHR1LnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkuYXNEaXNwbGF5U3RyaW5nKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b1RyYW5zbGF0ZVNlcnZpY2UudHJhbnNsYXRlTXVsdGlwbGVTdHJpbmdzKGFsbE1lc3NhZ2VzLCBmcm9tLCB0bylcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAvLyAjOTQgZ29vZ2xlIHRyYW5zbGF0ZSBtaWdodCByZXR1cm4gJiMuLiBlbnRpdHkgcmVmcywgdGhhdCBtdXN0IGJlIGRlY29kZWRcclxuICAgICAgICAgICAgICAgIG1hcCgodHJhbnNsYXRpb25zOiBzdHJpbmdbXSkgPT4gdHJhbnNsYXRpb25zLm1hcChlbmNvZGVkVHJhbnNsYXRpb24gPT4gZW50aXR5RGVjb2RlckxpYi5kZWNvZGUoZW5jb2RlZFRyYW5zbGF0aW9uKSkpLFxyXG4gICAgICAgICAgICAgICAgbWFwKCh0cmFuc2xhdGlvbnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gbmV3IEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0KGZyb20sIHRvKTtcclxuICAgICAgICAgICAgICAgIHN1bW1hcnkuc2V0SWdub3JlZChhbGxVbnRyYW5zbGF0ZWQubGVuZ3RoIC0gYWxsVHJhbnNsYXRhYmxlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zbGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR1ID0gYWxsVHJhbnNsYXRhYmxlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uVGV4dCA9IHRyYW5zbGF0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmF1dG9UcmFuc2xhdGVOb25JQ1VVbml0KHR1LCB0cmFuc2xhdGlvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnkuYWRkU2luZ2xlUmVzdWx0KHR1LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bW1hcnk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhaWxTdW1tYXJ5ID0gbmV3IEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0KGZyb20sIHRvKTtcclxuICAgICAgICAgICAgICAgICAgICBmYWlsU3VtbWFyeS5zZXRFcnJvcihlcnIubWVzc2FnZSwgYWxsTWVzc2FnZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YoZmFpbFN1bW1hcnkpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkb0F1dG9UcmFuc2xhdGVJQ1VNZXNzYWdlcyhmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGU6IElUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSlcclxuICAgICAgICA6IE9ic2VydmFibGU8QXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQ+W10ge1xyXG4gICAgICAgIGNvbnN0IGFsbFVudHJhbnNsYXRlZDogSVRyYW5zVW5pdFtdID0gdGhpcy5hbGxVbnRyYW5zbGF0ZWRUVXMobGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSk7XHJcbiAgICAgICAgY29uc3QgYWxsVHJhbnNsYXRhYmxlSUNVID0gYWxsVW50cmFuc2xhdGVkLmZpbHRlcigodHUpID0+ICFpc051bGxPclVuZGVmaW5lZCh0dS5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLmdldElDVU1lc3NhZ2UoKSkpO1xyXG4gICAgICAgIHJldHVybiBhbGxUcmFuc2xhdGFibGVJQ1UubWFwKCh0dSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F1dG9UcmFuc2xhdGVJQ1VNZXNzYWdlKGZyb20sIHRvLCB0dSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGUgc2luZ2xlIElDVSBNZXNzYWdlcy5cclxuICAgICAqIEBwYXJhbSBmcm9tIGZyb21cclxuICAgICAqIEBwYXJhbSB0byB0b1xyXG4gICAgICogQHBhcmFtIHR1IHRyYW5zdW5pdCB0byB0cmFuc2xhdGUgKG11c3QgY29udGFpbiBJQ1UgTWVzc2FnZSlcclxuICAgICAqIEByZXR1cm4gc3VtbWFyeSByZXBvcnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkb0F1dG9UcmFuc2xhdGVJQ1VNZXNzYWdlKGZyb206IHN0cmluZywgdG86IHN0cmluZywgdHU6IElUcmFuc1VuaXQpOiBPYnNlcnZhYmxlPEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0PiB7XHJcbiAgICAgICAgY29uc3QgaWN1TWVzc2FnZTogSUlDVU1lc3NhZ2UgPSB0dS5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLmdldElDVU1lc3NhZ2UoKTtcclxuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gaWN1TWVzc2FnZS5nZXRDYXRlZ29yaWVzKCk7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIG5lc3RlZCBJQ1VzLCB3ZSBkbyBub3Qgc3VwcG9ydCB0aGF0XHJcbiAgICAgICAgaWYgKGNhdGVnb3JpZXMuZmluZCgoY2F0ZWdvcnkpID0+ICFpc051bGxPclVuZGVmaW5lZChjYXRlZ29yeS5nZXRNZXNzYWdlTm9ybWFsaXplZCgpLmdldElDVU1lc3NhZ2UoKSkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSBuZXcgQXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQoZnJvbSwgdG8pO1xyXG4gICAgICAgICAgICBzdW1tYXJ5LnNldElnbm9yZWQoMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvZihzdW1tYXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWxsTWVzc2FnZXM6IHN0cmluZ1tdID0gY2F0ZWdvcmllcy5tYXAoKGNhdGVnb3J5KSA9PiBjYXRlZ29yeS5nZXRNZXNzYWdlTm9ybWFsaXplZCgpLmFzRGlzcGxheVN0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRvVHJhbnNsYXRlU2VydmljZS50cmFuc2xhdGVNdWx0aXBsZVN0cmluZ3MoYWxsTWVzc2FnZXMsIGZyb20sIHRvKVxyXG4gICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgIC8vICM5NCBnb29nbGUgdHJhbnNsYXRlIG1pZ2h0IHJldHVybiAmIy4uIGVudGl0eSByZWZzLCB0aGF0IG11c3QgYmUgZGVjb2RlZFxyXG4gICAgICAgICAgICAgICAgbWFwKCh0cmFuc2xhdGlvbnM6IHN0cmluZ1tdKSA9PiB0cmFuc2xhdGlvbnMubWFwKGVuY29kZWRUcmFuc2xhdGlvbiA9PiBlbnRpdHlEZWNvZGVyTGliLmRlY29kZShlbmNvZGVkVHJhbnNsYXRpb24pKSksXHJcbiAgICAgICAgICAgICAgICBtYXAoKHRyYW5zbGF0aW9uczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gbmV3IEF1dG9UcmFuc2xhdGVTdW1tYXJ5UmVwb3J0KGZyb20sIHRvKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY3VUcmFuc2xhdGlvbjogSUlDVU1lc3NhZ2VUcmFuc2xhdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNsYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljdVRyYW5zbGF0aW9uW2NhdGVnb3JpZXNbaV0uZ2V0Q2F0ZWdvcnkoKV0gPSB0cmFuc2xhdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXV0b1RyYW5zbGF0ZUlDVVVuaXQodHUsIGljdVRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5LmFkZFNpbmdsZVJlc3VsdCh0dSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtbWFyeTtcclxuICAgICAgICAgICAgICAgIH0pLCBjYXRjaEVycm9yKChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWlsU3VtbWFyeSA9IG5ldyBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydChmcm9tLCB0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbFN1bW1hcnkuc2V0RXJyb3IoZXJyLm1lc3NhZ2UsIGFsbE1lc3NhZ2VzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKGZhaWxTdW1tYXJ5KTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXV0b1RyYW5zbGF0ZU5vbklDVVVuaXQodHU6IElUcmFuc1VuaXQsIHRyYW5zbGF0ZWRNZXNzYWdlOiBzdHJpbmcpOiBBdXRvVHJhbnNsYXRlUmVzdWx0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRvVHJhbnNsYXRlVW5pdCh0dSwgdHUuc291cmNlQ29udGVudE5vcm1hbGl6ZWQoKS50cmFuc2xhdGUodHJhbnNsYXRlZE1lc3NhZ2UpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGF1dG9UcmFuc2xhdGVJQ1VVbml0KHR1OiBJVHJhbnNVbml0LCB0cmFuc2xhdGlvbjogSUlDVU1lc3NhZ2VUcmFuc2xhdGlvbik6IEF1dG9UcmFuc2xhdGVSZXN1bHQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9UcmFuc2xhdGVVbml0KHR1LCB0dS5zb3VyY2VDb250ZW50Tm9ybWFsaXplZCgpLnRyYW5zbGF0ZUlDVU1lc3NhZ2UodHJhbnNsYXRpb24pKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGF1dG9UcmFuc2xhdGVVbml0KHR1OiBJVHJhbnNVbml0LCB0cmFuc2xhdGVkTWVzc2FnZTogSU5vcm1hbGl6ZWRNZXNzYWdlKTogQXV0b1RyYW5zbGF0ZVJlc3VsdCB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JzID0gdHJhbnNsYXRlZE1lc3NhZ2UudmFsaWRhdGUoKTtcclxuICAgICAgICBjb25zdCB3YXJuaW5ncyA9IHRyYW5zbGF0ZWRNZXNzYWdlLnZhbGlkYXRlV2FybmluZ3MoKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGVycm9ycykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdXRvVHJhbnNsYXRlUmVzdWx0KGZhbHNlLCAnZXJyb3JzIGRldGVjdGVkLCBub3QgdHJhbnNsYXRlZCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHdhcm5pbmdzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1dG9UcmFuc2xhdGVSZXN1bHQoZmFsc2UsICd3YXJuaW5ncyBkZXRlY3RlZCwgbm90IHRyYW5zbGF0ZWQnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0dS50cmFuc2xhdGUodHJhbnNsYXRlZE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1dG9UcmFuc2xhdGVSZXN1bHQodHJ1ZSwgbnVsbCk7IC8vIHN1Y2Nlc3NcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtDb21tYW5kT3V0cHV0fSBmcm9tICcuLi9jb21tb24vY29tbWFuZC1vdXRwdXQnO1xyXG5pbXBvcnQge1hsaWZmTWVyZ2VQYXJhbWV0ZXJzfSBmcm9tICcuL3hsaWZmLW1lcmdlLXBhcmFtZXRlcnMnO1xyXG5pbXBvcnQge1hsaWZmTWVyZ2VFcnJvcn0gZnJvbSAnLi94bGlmZi1tZXJnZS1lcnJvcic7XHJcbmltcG9ydCB7RmlsZVV0aWx9IGZyb20gJy4uL2NvbW1vbi9maWxlLXV0aWwnO1xyXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4vdmVyc2lvbic7XHJcbmltcG9ydCB7Zm9ybWF0fSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZH0gZnJvbSAnLi4vY29tbW9uL3V0aWwnO1xyXG5pbXBvcnQge0lUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZSwgSVRyYW5zVW5pdCxcclxuICAgIEZPUk1BVF9YTUIsIEZPUk1BVF9YVEIsXHJcbiAgICBOT1JNQUxJWkFUSU9OX0ZPUk1BVF9ERUZBVUxULCBTVEFURV9GSU5BTCwgU1RBVEVfVFJBTlNMQVRFRH0gZnJvbSAnQG5neC1pMThuc3VwcG9ydC9uZ3gtaTE4bnN1cHBvcnQtbGliJztcclxuaW1wb3J0IHtQcm9ncmFtT3B0aW9ucywgSUNvbmZpZ0ZpbGV9IGZyb20gJy4vaS14bGlmZi1tZXJnZS1vcHRpb25zJztcclxuaW1wb3J0IHtOZ3hUcmFuc2xhdGVFeHRyYWN0b3J9IGZyb20gJy4vbmd4LXRyYW5zbGF0ZS1leHRyYWN0b3InO1xyXG5pbXBvcnQge1RyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyfSBmcm9tICcuL3RyYW5zbGF0aW9uLW1lc3NhZ2VzLWZpbGUtcmVhZGVyJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBvZiwgZm9ya0pvaW59IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge21hcCwgY2F0Y2hFcnJvcn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQge1hsaWZmTWVyZ2VBdXRvVHJhbnNsYXRlU2VydmljZX0gZnJvbSAnLi4vYXV0b3RyYW5zbGF0ZS94bGlmZi1tZXJnZS1hdXRvLXRyYW5zbGF0ZS1zZXJ2aWNlJztcclxuaW1wb3J0IHtBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydH0gZnJvbSAnLi4vYXV0b3RyYW5zbGF0ZS9hdXRvLXRyYW5zbGF0ZS1zdW1tYXJ5LXJlcG9ydCc7XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSBtYXJ0aW4gb24gMTcuMDIuMjAxNy5cclxuICogWGxpZmZNZXJnZSAtIHJlYWQgeGxpZmYgb3IgeG1iIGZpbGUgYW5kIHB1dCB1bnRyYW5zbGF0ZWQgcGFydHMgaW4gbGFuZ3VhZ2Ugc3BlY2lmaWMgeGxpZmYgb3IgeG1iIGZpbGVzLlxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBYbGlmZk1lcmdlIHtcclxuXHJcbiAgICBwcml2YXRlIGNvbW1hbmRPdXRwdXQ6IENvbW1hbmRPdXRwdXQ7XHJcblxyXG4gICAgcHJpdmF0ZSBvcHRpb25zOiBQcm9ncmFtT3B0aW9ucztcclxuXHJcbiAgICBwcml2YXRlIHBhcmFtZXRlcnM6IFhsaWZmTWVyZ2VQYXJhbWV0ZXJzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlYWQgbWFzdGVyIHhsZiBmaWxlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG1hc3RlcjogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlOyAvLyBYbGlmZkZpbGUgb3IgWGxpZmYyRmlsZSBvciBYbWJGaWxlXHJcblxyXG4gICAgcHJpdmF0ZSBhdXRvVHJhbnNsYXRlU2VydmljZTogWGxpZmZNZXJnZUF1dG9UcmFuc2xhdGVTZXJ2aWNlO1xyXG5cclxuICAgIHN0YXRpYyBtYWluKGFyZ3Y6IHN0cmluZ1tdKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IFhsaWZmTWVyZ2UucGFyc2VBcmdzKGFyZ3YpO1xyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG5ldyBYbGlmZk1lcmdlKG5ldyBDb21tYW5kT3V0cHV0KHByb2Nlc3Muc3Rkb3V0KSwgb3B0aW9ucykucnVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZXhpdChyZXN1bHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHBhcnNlQXJncyhhcmd2OiBzdHJpbmdbXSk6IFByb2dyYW1PcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBQcm9ncmFtT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbGFuZ3VhZ2VzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3ZbaV07XHJcbiAgICAgICAgICAgIGlmIChhcmcgPT09ICctLXZlcnNpb24nIHx8IGFyZyA9PT0gJy12ZXJzaW9uJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3hsaWZmbWVyZ2UgJyArIFZFUlNJT04pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyA9PT0gJy0tdmVyYm9zZScgfHwgYXJnID09PSAnLXYnKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZlcmJvc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyA9PT0gJy0tcHJvZmlsZScgfHwgYXJnID09PSAnLXAnKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcmd2Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtaXNzaW5nIGNvbmZpZyBmaWxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgWGxpZmZNZXJnZS5zaG93VXNhZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9maWxlUGF0aCA9IGFyZ3ZbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnID09PSAnLS1xdWlldCcgfHwgYXJnID09PSAnLXEnKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnF1aWV0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09ICctLWhlbHAnIHx8IGFyZyA9PT0gJy1oZWxwJyB8fCBhcmcgPT09ICctaCcpIHtcclxuICAgICAgICAgICAgICAgIFhsaWZmTWVyZ2Uuc2hvd1VzYWdlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmxlbmd0aCA+IDAgJiYgYXJnLmNoYXJBdCgwKSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndW5rbm93biBvcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZXMucHVzaChhcmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBzaG93VXNhZ2UoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3VzYWdlOiB4bGlmZm1lcmdlIDxvcHRpb24+KiA8bGFuZ3VhZ2U+KicpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdPcHRpb25zJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdC1wfC0tcHJvZmlsZSBhIGpzb24gY29uZmlndXJhdGlvbiBmaWxlIGNvbnRhaW5pbmcgYWxsIHJlbGV2YW50IHBhcmFtZXRlcnMuJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdFxcdGZvciBkZXRhaWxzIHBsZWFzZSBjb25zdWx0IHRoZSBob21lIHBhZ2UgaHR0cHM6Ly9naXRodWIuY29tL21hcnRpbnJvb2Ivbmd4LWkxOG5zdXBwb3J0Jyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdC12fC0tdmVyYm9zZSBzaG93IHNvbWUgb3V0cHV0IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMnKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnXFx0LXF8LS1xdWlldCBvbmx5IHNob3cgZXJyb3JzLCBub3RoaW5nIGVsc2UnKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnXFx0LXZlcnNpb258LS12ZXJzaW9uIHNob3cgdmVyc2lvbiBzdHJpbmcnKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xcdDxsYW5ndWFnZT4gaGFzIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2Ugc2hvcnQgc3RyaW5nLCBlLGcuIFwiZW5cIiwgXCJkZVwiLCBcImRlLWNoXCInKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBUZXN0cywgY3JlYXRlIGluc3RhbmNlIHdpdGggZ2l2ZW4gcHJvZmlsZVxyXG4gICAgICogQHBhcmFtIGNvbW1hbmRPdXRwdXQgY29tbWFuZE91dHB1dFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHByb2ZpbGVDb250ZW50IHByb2ZpbGVDb250ZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRnJvbU9wdGlvbnMoY29tbWFuZE91dHB1dDogQ29tbWFuZE91dHB1dCwgb3B0aW9uczogUHJvZ3JhbU9wdGlvbnMsIHByb2ZpbGVDb250ZW50PzogSUNvbmZpZ0ZpbGUpIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBYbGlmZk1lcmdlKGNvbW1hbmRPdXRwdXQsIG9wdGlvbnMpO1xyXG4gICAgICAgIGluc3RhbmNlLnBhcmFtZXRlcnMgPSBYbGlmZk1lcmdlUGFyYW1ldGVycy5jcmVhdGVGcm9tT3B0aW9ucyhvcHRpb25zLCBwcm9maWxlQ29udGVudCk7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRPdXRwdXQ6IENvbW1hbmRPdXRwdXQsIG9wdGlvbnM6IFByb2dyYW1PcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0ID0gY29tbWFuZE91dHB1dDtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW4gdGhlIGNvbW1hbmQuXHJcbiAgICAgKiBUaGlzIHJ1bnMgYXN5bmMuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tGdW5jdGlvbiB3aGVuIGNvbW1hbmQgaXMgZXhlY3V0ZWQsIGNhbGxlZCB3aXRoIHRoZSByZXR1cm4gY29kZSAoMCBmb3Igb2spLCBpZiBnaXZlbi5cclxuICAgICAqIEBwYXJhbSBlcnJvckZ1bmN0aW9uIGNhbGxiYWNrRnVuY3Rpb24gZm9yIGVycm9yIGhhbmRsaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBydW4oY2FsbGJhY2tGdW5jdGlvbj86ICgocmV0Y29kZTogbnVtYmVyKSA9PiBhbnkpLCBlcnJvckZ1bmN0aW9uPzogKChlcnJvcjogYW55KSA9PiBhbnkpKSB7XHJcbiAgICAgICAgdGhpcy5ydW5Bc3luYygpXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJldGNvZGU6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChjYWxsYmFja0Z1bmN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrRnVuY3Rpb24ocmV0Y29kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChlcnJvckZ1bmN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRnVuY3Rpb24oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGUgbWVyZ2UtUHJvY2Vzcy5cclxuICAgICAqIEByZXR1cm4gQXN5bmMgb3BlcmF0aW9uLCBvbiBjb21wbGV0aW9uIHJldHVybnMgcmV0Y29kZSAwPW9rLCBvdGhlciA9IGVycm9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcnVuQXN5bmMoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5xdWlldCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuc2V0UXVpZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMudmVyYm9zZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuc2V0VmVyYm9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMucGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBYbGlmZk1lcmdlUGFyYW1ldGVycy5jcmVhdGVGcm9tT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuaW5mbygneGxpZmZtZXJnZSB2ZXJzaW9uICVzJywgVkVSU0lPTik7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy52ZXJib3NlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnNob3dBbGxQYXJhbWV0ZXJzKHRoaXMuY29tbWFuZE91dHB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuZXJyb3JzRm91bmQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVyciBvZiB0aGlzLnBhcmFtZXRlcnMuZXJyb3JzRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5lcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9mKC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy53YXJuaW5nc0ZvdW5kLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB3YXJuIG9mIHRoaXMucGFyYW1ldGVycy53YXJuaW5nc0ZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2Fybih3YXJuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlYWRNYXN0ZXIoKTtcclxuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmF1dG90cmFuc2xhdGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9UcmFuc2xhdGVTZXJ2aWNlID0gbmV3IFhsaWZmTWVyZ2VBdXRvVHJhbnNsYXRlU2VydmljZSh0aGlzLnBhcmFtZXRlcnMuYXBpa2V5KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleGVjdXRpb25Gb3JBbGxMYW5ndWFnZXM6IE9ic2VydmFibGU8bnVtYmVyPltdID0gW107XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmxhbmd1YWdlcygpLmZvckVhY2goKGxhbmc6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBleGVjdXRpb25Gb3JBbGxMYW5ndWFnZXMucHVzaCh0aGlzLnByb2Nlc3NMYW5ndWFnZShsYW5nKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luKGV4ZWN1dGlvbkZvckFsbExhbmd1YWdlcykucGlwZShcclxuICAgICAgICAgICAgbWFwKChyZXRjb2RlczogbnVtYmVyW10pID0+IHRoaXMudG90YWxSZXRjb2RlKHJldGNvZGVzKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZSBhbiBhcnJheSBvZiByZXRjb2RlcyBmb3IgdGhlIGRpZmZlcmVudCBsYW5ndWFnZXMsIHJldHVybiB0aGUgdG90YWwgcmV0Y29kZS5cclxuICAgICAqIElmIGFsbCBhcmUgMCwgaXQgaXMgMCwgb3RoZXJ3aXNlIHRoZSBmaXJzdCBub24gemVyby5cclxuICAgICAqIEBwYXJhbSByZXRjb2RlcyByZXRjb2Rlc1xyXG4gICAgICogQHJldHVybiBudW1iZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0b3RhbFJldGNvZGUocmV0Y29kZXM6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldGNvZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXRjb2Rlc1tpXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldGNvZGVzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgZmlsZSBmb3IgZ2l2ZW4gbGFuZy5cclxuICAgICAqIEBwYXJhbSBsYW5nIGxhbmd1YWdlXHJcbiAgICAgKiBAcmV0dXJuIG5hbWUgb2YgZ2VuZXJhdGVkIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdlbmVyYXRlZEkxOG5GaWxlKGxhbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVycy5nZW5lcmF0ZWRJMThuRmlsZShsYW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIG5neC10cmFuc2xhdGlvbiBmaWxlIGZvciBnaXZlbiBsYW5nLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2VcclxuICAgICAqIEByZXR1cm4gbmFtZSBvZiB0cmFuc2xhdGUgZmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVkTmd4VHJhbnNsYXRlRmlsZShsYW5nOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnMuZ2VuZXJhdGVkTmd4VHJhbnNsYXRlRmlsZShsYW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdhcm5pbmdzIGZvdW5kIGR1cmluZyB0aGUgcnVuLlxyXG4gICAgICogQHJldHVybiB3YXJuaW5nc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd2FybmluZ3MoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnMud2FybmluZ3NGb3VuZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlYWRNYXN0ZXIoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5tYXN0ZXIgPSBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5mcm9tRmlsZShcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5pMThuRm9ybWF0KCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaTE4bkZpbGUoKSxcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5lbmNvZGluZygpKTtcclxuICAgICAgICAgICAgdGhpcy5tYXN0ZXIud2FybmluZ3MoKS5mb3JFYWNoKCh3YXJuaW5nOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKHdhcm5pbmcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLm1hc3Rlci5udW1iZXJPZlRyYW5zVW5pdHMoKTtcclxuICAgICAgICAgICAgY29uc3QgbWlzc2luZ0lkQ291bnQgPSB0aGlzLm1hc3Rlci5udW1iZXJPZlRyYW5zVW5pdHNXaXRoTWlzc2luZ0lkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5pbmZvKCdtYXN0ZXIgY29udGFpbnMgJXMgdHJhbnMtdW5pdHMnLCBjb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChtaXNzaW5nSWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdtYXN0ZXIgY29udGFpbnMgJXMgdHJhbnMtdW5pdHMsIGJ1dCB0aGVyZSBhcmUgJXMgd2l0aG91dCBpZCcsIGNvdW50LCBtaXNzaW5nSWRDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc291cmNlTGFuZzogc3RyaW5nID0gdGhpcy5tYXN0ZXIuc291cmNlTGFuZ3VhZ2UoKTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUxhbmcgJiYgc291cmNlTGFuZyAhPT0gdGhpcy5wYXJhbWV0ZXJzLmRlZmF1bHRMYW5ndWFnZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybihcclxuICAgICAgICAgICAgICAgICAgICAnbWFzdGVyIHNheXMgdG8gaGF2ZSBzb3VyY2UtbGFuZ3VhZ2U9XCIlc1wiLCBzaG91bGQgYmUgXCIlc1wiICh5b3VyIGRlZmF1bHRMYW5ndWFnZSknLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUxhbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFzdGVyLnNldFNvdXJjZUxhbmd1YWdlKHRoaXMucGFyYW1ldGVycy5kZWZhdWx0TGFuZ3VhZ2UoKSk7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5zYXZlKHRoaXMubWFzdGVyLCB0aGlzLnBhcmFtZXRlcnMuYmVhdXRpZnlPdXRwdXQoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2FybignY2hhbmdlZCBtYXN0ZXIgc291cmNlLWxhbmd1YWdlPVwiJXNcIiB0byBcIiVzXCInLCBzb3VyY2VMYW5nLCB0aGlzLnBhcmFtZXRlcnMuZGVmYXVsdExhbmd1YWdlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBYbGlmZk1lcmdlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5lcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YoLTEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdW5oYW5kbGVkXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmlsZW5hbWUgPSB0aGlzLnBhcmFtZXRlcnMuaTE4bkZpbGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lU3RyaW5nID0gKGN1cnJlbnRGaWxlbmFtZSkgPyBmb3JtYXQoJ2ZpbGUgXCIlc1wiLCAnLCBjdXJyZW50RmlsZW5hbWUpIDogJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuZXJyb3IoZmlsZW5hbWVTdHJpbmcgKyAnb29wcyAnICsgZXJyKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgdGhlIGdpdmVuIGxhbmd1YWdlLlxyXG4gICAgICogQXN5bmMgb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2VcclxuICAgICAqIEByZXR1cm4gb24gY29tcGxldGlvbiAwIGZvciBvaywgb3RoZXIgZm9yIGVycm9yXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcHJvY2Vzc0xhbmd1YWdlKGxhbmc6IHN0cmluZyk6IE9ic2VydmFibGU8bnVtYmVyPiB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmRlYnVnKCdwcm9jZXNzaW5nIGxhbmd1YWdlICVzJywgbGFuZyk7XHJcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VYbGlmZkZpbGUgPSB0aGlzLnBhcmFtZXRlcnMuZ2VuZXJhdGVkSTE4bkZpbGUobGFuZyk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZpbGVuYW1lID0gbGFuZ3VhZ2VYbGlmZkZpbGU7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogT2JzZXJ2YWJsZTx2b2lkPjtcclxuICAgICAgICBpZiAoIUZpbGVVdGlsLmV4aXN0cyhsYW5ndWFnZVhsaWZmRmlsZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jcmVhdGVVbnRyYW5zbGF0ZWRYbGlmZihsYW5nLCBsYW5ndWFnZVhsaWZmRmlsZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tZXJnZU1hc3RlclRvKGxhbmcsIGxhbmd1YWdlWGxpZmZGaWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgICAgICAucGlwZShtYXAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5zdXBwb3J0Tmd4VHJhbnNsYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbk1lc3NhZ2VzRmlsZVJlYWRlci5mcm9tRmlsZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25Gb3JtYXQodGhpcy5wYXJhbWV0ZXJzLmkxOG5Gb3JtYXQoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVhsaWZmRmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5lbmNvZGluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXIuZmlsZW5hbWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgTmd4VHJhbnNsYXRlRXh0cmFjdG9yLmV4dHJhY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5uZ3hUcmFuc2xhdGVFeHRyYWN0aW9uUGF0dGVybigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZ2VuZXJhdGVkTmd4VHJhbnNsYXRlRmlsZShsYW5nKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSksIGNhdGNoRXJyb3IoKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFhsaWZmTWVyZ2VFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5lcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKC0xKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5oYW5kbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWVTdHJpbmcgPSAoY3VycmVudEZpbGVuYW1lKSA/IGZvcm1hdCgnZmlsZSBcIiVzXCIsICcsIGN1cnJlbnRGaWxlbmFtZSkgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQuZXJyb3IoZmlsZW5hbWVTdHJpbmcgKyAnb29wcyAnICsgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNyZWF0ZSBhIG5ldyBmaWxlIGZvciB0aGUgbGFuZ3VhZ2UsIHdoaWNoIGNvbnRhaW5zIG5vIHRyYW5zbGF0aW9ucywgYnV0IGFsbCBrZXlzLlxyXG4gICAgICogaW4gcHJpbmNpcGxlLCB0aGlzIGlzIGp1c3QgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgd2l0aCB0YXJnZXQtbGFuZ3VhZ2Ugc2V0LlxyXG4gICAgICogQHBhcmFtIGxhbmcgbGFuZ3VhZ2VcclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZVhsaWZmRmlsZVBhdGggbmFtZSBvZiBmaWxlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlVW50cmFuc2xhdGVkWGxpZmYobGFuZzogc3RyaW5nLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGg6IHN0cmluZyk6IE9ic2VydmFibGU8dm9pZD4ge1xyXG4gICAgICAgIC8vIGNvcHkgbWFzdGVyIC4uLlxyXG4gICAgICAgIC8vIGFuZCBzZXQgdGFyZ2V0LWxhbmd1YWdlXHJcbiAgICAgICAgLy8gYW5kIGNvcHkgc291cmNlIHRvIHRhcmdldCBpZiBuZWNlc3NhcnlcclxuICAgICAgICBjb25zdCBpc0RlZmF1bHRMYW5nOiBib29sZWFuID0gKGxhbmcgPT09IHRoaXMucGFyYW1ldGVycy5kZWZhdWx0TGFuZ3VhZ2UoKSk7XHJcbiAgICAgICAgdGhpcy5tYXN0ZXIuc2V0TmV3VHJhbnNVbml0VGFyZ2V0UHJhZWZpeCh0aGlzLnBhcmFtZXRlcnMudGFyZ2V0UHJhZWZpeCgpKTtcclxuICAgICAgICB0aGlzLm1hc3Rlci5zZXROZXdUcmFuc1VuaXRUYXJnZXRTdWZmaXgodGhpcy5wYXJhbWV0ZXJzLnRhcmdldFN1ZmZpeCgpKTtcclxuICAgICAgICBjb25zdCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUgPVxyXG4gICAgICAgICAgICB0aGlzLm1hc3Rlci5jcmVhdGVUcmFuc2xhdGlvbkZpbGVGb3JMYW5nKGxhbmcsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCwgaXNEZWZhdWx0TGFuZywgdGhpcy5wYXJhbWV0ZXJzLnVzZVNvdXJjZUFzVGFyZ2V0KCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9UcmFuc2xhdGUodGhpcy5tYXN0ZXIuc291cmNlTGFuZ3VhZ2UoKSwgbGFuZywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSkucGlwZShcclxuICAgICAgICAgICAgbWFwKChzdW1tYXJ5KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHdyaXRlIGl0IHRvIGZpbGVcclxuICAgICAgICAgICAgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIuc2F2ZShsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLCB0aGlzLnBhcmFtZXRlcnMuYmVhdXRpZnlPdXRwdXQoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5pbmZvKCdjcmVhdGVkIG5ldyBmaWxlIFwiJXNcIiBmb3IgdGFyZ2V0LWxhbmd1YWdlPVwiJXNcIicsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCwgbGFuZyk7XHJcbiAgICAgICAgICAgIGlmICghaXNEZWZhdWx0TGFuZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ3BsZWFzZSB0cmFuc2xhdGUgZmlsZSBcIiVzXCIgdG8gdGFyZ2V0LWxhbmd1YWdlPVwiJXNcIicsIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCwgbGFuZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIHRoZSBpbnB1dCBmb3JtYXQgdG8gdGhlIGZvcm1hdCBvZiB0aGUgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBOb3JtYWxseSB0aGV5IGFyZSB0aGUgc2FtZSBidXQgZm9yIHhtYiB0aGUgdHJhbnNsYXRpb24gZm9ybWF0IGlzIHh0Yi5cclxuICAgICAqIEBwYXJhbSBpMThuRm9ybWF0IGZvcm1hdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYW5zbGF0aW9uRm9ybWF0KGkxOG5Gb3JtYXQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKGkxOG5Gb3JtYXQgPT09IEZPUk1BVF9YTUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZPUk1BVF9YVEI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGkxOG5Gb3JtYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2UgYWxsXHJcbiAgICAgKiBAcGFyYW0gbGFuZyBsYW5ndWFnZVxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlWGxpZmZGaWxlUGF0aCBmaWxlbmFtZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG1lcmdlTWFzdGVyVG8obGFuZzogc3RyaW5nLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGg6IHN0cmluZyk6IE9ic2VydmFibGU8dm9pZD4ge1xyXG4gICAgICAgIC8vIHJlYWQgbGFuZyBzcGVjaWZpYyBmaWxlXHJcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlID1cclxuICAgICAgICAgICAgVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGVSZWFkZXIuZnJvbUZpbGUoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9uRm9ybWF0KHRoaXMucGFyYW1ldGVycy5pMThuRm9ybWF0KCkpLFxyXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmVuY29kaW5nKCkpO1xyXG4gICAgICAgIGNvbnN0IGlzRGVmYXVsdExhbmc6IGJvb2xlYW4gPSAobGFuZyA9PT0gdGhpcy5wYXJhbWV0ZXJzLmRlZmF1bHRMYW5ndWFnZSgpKTtcclxuICAgICAgICBsZXQgbmV3Q291bnQgPSAwO1xyXG4gICAgICAgIGxldCBjb3JyZWN0U291cmNlQ29udGVudENvdW50ID0gMDtcclxuICAgICAgICBsZXQgY29ycmVjdFNvdXJjZVJlZkNvdW50ID0gMDtcclxuICAgICAgICBsZXQgY29ycmVjdERlc2NyaXB0aW9uT3JNZWFuaW5nQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBpZENoYW5nZWRDb3VudCA9IDA7XHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5zZXROZXdUcmFuc1VuaXRUYXJnZXRQcmFlZml4KHRoaXMucGFyYW1ldGVycy50YXJnZXRQcmFlZml4KCkpO1xyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUuc2V0TmV3VHJhbnNVbml0VGFyZ2V0U3VmZml4KHRoaXMucGFyYW1ldGVycy50YXJnZXRTdWZmaXgoKSk7XHJcbiAgICAgICAgbGV0IGxhc3RQcm9jZXNzZWRVbml0OiBJVHJhbnNVbml0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1hc3Rlci5mb3JFYWNoVHJhbnNVbml0KChtYXN0ZXJUcmFuc1VuaXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNVbml0OiBJVHJhbnNVbml0ID0gbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS50cmFuc1VuaXRXaXRoSWQobWFzdGVyVHJhbnNVbml0LmlkKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdHJhbnNVbml0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvb3BzLCBubyB0cmFuc2xhdGlvbiwgbXVzdCBiZSBhIG5ldyBrZXksIHNvIGFkZCBpdFxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld1VuaXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmFsbG93SWRDaGFuZ2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICYmIChuZXdVbml0ID0gdGhpcy5wcm9jZXNzQ2hhbmdlZElkVW5pdChtYXN0ZXJUcmFuc1VuaXQsIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUsIGxhc3RQcm9jZXNzZWRVbml0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvY2Vzc2VkVW5pdCA9IG5ld1VuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRDaGFuZ2VkQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb2Nlc3NlZFVuaXQgPSBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlLmltcG9ydE5ld1RyYW5zVW5pdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyVHJhbnNVbml0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZmF1bHRMYW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMudXNlU291cmNlQXNUYXJnZXQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMucGFyYW1ldGVycy5wcmVzZXJ2ZU9yZGVyKCkpID8gbGFzdFByb2Nlc3NlZFVuaXQgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgY2hhbmdlZCBzb3VyY2UgY29udGVudCBhbmQgY2hhbmdlIGl0IGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgLy8gKGNhbiBvbmx5IGhhcHBlbiBpZiBJRCBpcyBleHBsaWNpdGVseSBzZXQsIG90aGVyd2lzZSBJRCB3b3VsZCBjaGFuZ2UgaWYgc291cmNlIGNvbnRlbnQgaXMgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc1VuaXQuc3VwcG9ydHNTZXRTb3VyY2VDb250ZW50KCkgJiYgbWFzdGVyVHJhbnNVbml0LnNvdXJjZUNvbnRlbnQoKSAhPT0gdHJhbnNVbml0LnNvdXJjZUNvbnRlbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5zZXRTb3VyY2VDb250ZW50KG1hc3RlclRyYW5zVW5pdC5zb3VyY2VDb250ZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZmF1bHRMYW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICM4MSBjaGFuZ2VkIHNvdXJjZSBtdXN0IGJlIGNvcGllZCB0byB0YXJnZXQgZm9yIGRlZmF1bHQgbGFuZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQudHJhbnNsYXRlKG1hc3RlclRyYW5zVW5pdC5zb3VyY2VDb250ZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfRklOQUwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc1VuaXQudGFyZ2V0U3RhdGUoKSA9PT0gU1RBVEVfRklOQUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvdXJjZSBpcyBjaGFuZ2VkLCBzbyB0cmFuc2xhdGlvbiBoYXMgdG8gYmUgY2hlY2tlZCBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LnNldFRhcmdldFN0YXRlKFNUQVRFX1RSQU5TTEFURUQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RTb3VyY2VDb250ZW50Q291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIG9yIGNoYW5nZWQgc291cmNlIHJlZiBhbmQgYWRkIGl0IGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zVW5pdC5zdXBwb3J0c1NldFNvdXJjZVJlZmVyZW5jZXMoKVxyXG4gICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmFyZVNvdXJjZVJlZmVyZW5jZXNFcXVhbChtYXN0ZXJUcmFuc1VuaXQuc291cmNlUmVmZXJlbmNlcygpLCB0cmFuc1VuaXQuc291cmNlUmVmZXJlbmNlcygpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5zZXRTb3VyY2VSZWZlcmVuY2VzKG1hc3RlclRyYW5zVW5pdC5zb3VyY2VSZWZlcmVuY2VzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RTb3VyY2VSZWZDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGNoYW5nZWQgZGVzY3JpcHRpb24gb3IgbWVhbmluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zVW5pdC5zdXBwb3J0c1NldERlc2NyaXB0aW9uQW5kTWVhbmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNVbml0LmRlc2NyaXB0aW9uKCkgIT09IG1hc3RlclRyYW5zVW5pdC5kZXNjcmlwdGlvbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5zZXREZXNjcmlwdGlvbihtYXN0ZXJUcmFuc1VuaXQuZGVzY3JpcHRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNVbml0Lm1lYW5pbmcoKSAhPT0gbWFzdGVyVHJhbnNVbml0Lm1lYW5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuc2V0TWVhbmluZyhtYXN0ZXJUcmFuc1VuaXQubWVhbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlY3REZXNjcmlwdGlvbk9yTWVhbmluZ0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdFByb2Nlc3NlZFVuaXQgPSB0cmFuc1VuaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobmV3Q291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdtZXJnZWQgJXMgdHJhbnMtdW5pdHMgZnJvbSBtYXN0ZXIgdG8gXCIlc1wiJywgbmV3Q291bnQsIGxhbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29ycmVjdFNvdXJjZUNvbnRlbnRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oJ3RyYW5zZmVycmVkICVzIGNoYW5nZWQgc291cmNlIGNvbnRlbnQgZnJvbSBtYXN0ZXIgdG8gXCIlc1wiJywgY29ycmVjdFNvdXJjZUNvbnRlbnRDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3JyZWN0U291cmNlUmVmQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCd0cmFuc2ZlcnJlZCAlcyBzb3VyY2UgcmVmZXJlbmNlcyBmcm9tIG1hc3RlciB0byBcIiVzXCInLCBjb3JyZWN0U291cmNlUmVmQ291bnQsIGxhbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaWRDaGFuZ2VkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdmb3VuZCAlcyBjaGFuZ2VkIGlkXFwncyBpbiBcIiVzXCInLCBpZENoYW5nZWRDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3JyZWN0RGVzY3JpcHRpb25Pck1lYW5pbmdDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oXHJcbiAgICAgICAgICAgICAgICAndHJhbnNmZXJyZWQgJXMgY2hhbmdlZCBkZXNjcmlwdGlvbnMvbWVhbmluZ3MgZnJvbSBtYXN0ZXIgdG8gXCIlc1wiJywgY29ycmVjdERlc2NyaXB0aW9uT3JNZWFuaW5nQ291bnQsIGxhbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBubyBsb25nZXIgdXNlZFxyXG4gICAgICAgIGxldCByZW1vdmVDb3VudCA9IDA7XHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5mb3JFYWNoVHJhbnNVbml0KCh0cmFuc1VuaXQ6IElUcmFuc1VuaXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RzSW5NYXN0ZXIgPSAhaXNOdWxsT3JVbmRlZmluZWQodGhpcy5tYXN0ZXIudHJhbnNVbml0V2l0aElkKHRyYW5zVW5pdC5pZCkpO1xyXG4gICAgICAgICAgICBpZiAoIWV4aXN0c0luTWFzdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnJlbW92ZVVudXNlZElkcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5yZW1vdmVUcmFuc1VuaXRXaXRoSWQodHJhbnNVbml0LmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocmVtb3ZlQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMucmVtb3ZlVW51c2VkSWRzKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdyZW1vdmVkICVzIHVudXNlZCB0cmFucy11bml0cyBpbiBcIiVzXCInLCByZW1vdmVDb3VudCwgbGFuZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRPdXRwdXQud2Fybigna2VlcGluZyAlcyB1bnVzZWQgdHJhbnMtdW5pdHMgaW4gXCIlc1wiLCBiZWNhdXNlIHJlbW92ZVVudXNlZCBpcyBkaXNhYmxlZCcsIHJlbW92ZUNvdW50LCBsYW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5ld0NvdW50ID09PSAwICYmIHJlbW92ZUNvdW50ID09PSAwICYmIGNvcnJlY3RTb3VyY2VDb250ZW50Q291bnQgPT09IDBcclxuICAgICAgICAgICAgJiYgY29ycmVjdFNvdXJjZVJlZkNvdW50ID09PSAwICYmIGNvcnJlY3REZXNjcmlwdGlvbk9yTWVhbmluZ0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5pbmZvKCdmaWxlIGZvciBcIiVzXCIgd2FzIHVwIHRvIGRhdGUnLCBsYW5nKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9mKG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dG9UcmFuc2xhdGUodGhpcy5tYXN0ZXIuc291cmNlTGFuZ3VhZ2UoKSwgbGFuZywgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSlcclxuICAgICAgICAgICAgICAgIC5waXBlKG1hcCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGUgaXQgdG8gZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlUmVhZGVyLnNhdmUobGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZSwgdGhpcy5wYXJhbWV0ZXJzLmJlYXV0aWZ5T3V0cHV0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC5pbmZvKCd1cGRhdGVkIGZpbGUgXCIlc1wiIGZvciB0YXJnZXQtbGFuZ3VhZ2U9XCIlc1wiJywgbGFuZ3VhZ2VYbGlmZkZpbGVQYXRoLCBsYW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q291bnQgPiAwICYmICFpc0RlZmF1bHRMYW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZE91dHB1dC53YXJuKCdwbGVhc2UgdHJhbnNsYXRlIGZpbGUgXCIlc1wiIHRvIHRhcmdldC1sYW5ndWFnZT1cIiVzXCInLCBsYW5ndWFnZVhsaWZmRmlsZVBhdGgsIGxhbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdGhlIGNhc2Ugb2YgY2hhbmdlZCBpZCBkdWUgdG8gc21hbGwgd2hpdGUgc3BhY2UgY2hhbmdlcy5cclxuICAgICAqIEBwYXJhbSBtYXN0ZXJUcmFuc1VuaXQgdW5pdCBpbiBtYXN0ZXIgZmlsZVxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUgdHJhbnNsYXRpb24gZmlsZVxyXG4gICAgICogQHBhcmFtIGxhc3RQcm9jZXNzZWRVbml0IFVuaXQgYmVmb3JlIHRoZSBvbmUgcHJvY2Vzc2VkIGhlcmUuIE5ldyB1bml0IHdpbGwgYmUgaW5zZXJ0ZWQgYWZ0ZXIgdGhpcyBvbmUuXHJcbiAgICAgKiBAcmV0dXJuIHByb2Nlc3NlZCB1bml0LCBpZiBkb25lLCBudWxsIGlmIG5vIGNoYW5nZWQgdW5pdCBmb3VuZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHByb2Nlc3NDaGFuZ2VkSWRVbml0KFxyXG4gICAgICAgIG1hc3RlclRyYW5zVW5pdDogSVRyYW5zVW5pdCxcclxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlOiBJVHJhbnNsYXRpb25NZXNzYWdlc0ZpbGUsXHJcbiAgICAgICAgbGFzdFByb2Nlc3NlZFVuaXQ6IElUcmFuc1VuaXQpOiBJVHJhbnNVbml0IHtcclxuXHJcbiAgICAgICAgY29uc3QgbWFzdGVyU291cmNlU3RyaW5nID0gbWFzdGVyVHJhbnNVbml0LnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkuYXNEaXNwbGF5U3RyaW5nKE5PUk1BTElaQVRJT05fRk9STUFUX0RFRkFVTFQpLnRyaW0oKTtcclxuICAgICAgICBsZXQgY2hhbmdlZFRyYW5zVW5pdDogSVRyYW5zVW5pdCA9IG51bGw7XHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5mb3JFYWNoVHJhbnNVbml0KChsYW5ndWFnZVRyYW5zVW5pdCkgPT4ge1xyXG4gICAgICAgICAgICAgaWYgKGxhbmd1YWdlVHJhbnNVbml0LnNvdXJjZUNvbnRlbnROb3JtYWxpemVkKCkuYXNEaXNwbGF5U3RyaW5nKE5PUk1BTElaQVRJT05fRk9STUFUX0RFRkFVTFQpLnRyaW0oKSA9PT0gbWFzdGVyU291cmNlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgY2hhbmdlZFRyYW5zVW5pdCA9IGxhbmd1YWdlVHJhbnNVbml0O1xyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghY2hhbmdlZFRyYW5zVW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWVyZ2VkVHJhbnNVbml0ID0gbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZS5pbXBvcnROZXdUcmFuc1VuaXQoXHJcbiAgICAgICAgICAgIG1hc3RlclRyYW5zVW5pdCxcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICAodGhpcy5wYXJhbWV0ZXJzLnByZXNlcnZlT3JkZXIoKSkgPyBsYXN0UHJvY2Vzc2VkVW5pdCA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlZENvbnRlbnQgPSBjaGFuZ2VkVHJhbnNVbml0LnRhcmdldENvbnRlbnQoKTtcclxuICAgICAgICBpZiAodHJhbnNsYXRlZENvbnRlbnQpIHsgLy8gaXNzdWUgIzY4IHNldCB0cmFuc2xhdGVkIG9ubHksIGlmIGl0IGlzIHJlYWxseSB0cmFuc2xhdGVkXHJcbiAgICAgICAgICAgIG1lcmdlZFRyYW5zVW5pdC50cmFuc2xhdGUodHJhbnNsYXRlZENvbnRlbnQpO1xyXG4gICAgICAgICAgICBtZXJnZWRUcmFuc1VuaXQuc2V0VGFyZ2V0U3RhdGUoU1RBVEVfVFJBTlNMQVRFRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXJnZWRUcmFuc1VuaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhcmVTb3VyY2VSZWZlcmVuY2VzRXF1YWwoXHJcbiAgICAgICAgcmVmMToge3NvdXJjZWZpbGU6IHN0cmluZzsgbGluZW51bWJlcjogbnVtYmVyOyB9W10sXHJcbiAgICAgICAgcmVmMjoge3NvdXJjZWZpbGU6IHN0cmluZzsgbGluZW51bWJlcjogbnVtYmVyOyB9W10pOiBib29sZWFuIHtcclxuXHJcbiAgICAgICAgaWYgKChpc051bGxPclVuZGVmaW5lZChyZWYxKSAmJiAhaXNOdWxsT3JVbmRlZmluZWQocmVmMikpIHx8IChpc051bGxPclVuZGVmaW5lZChyZWYyKSAmJiAhaXNOdWxsT3JVbmRlZmluZWQocmVmMSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHJlZjEpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHJlZjIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBib3QgcmVmcyBhcmUgc2V0IG5vdywgY29udmVydCB0byBzZXQgdG8gY29tcGFyZSB0aGVtXHJcbiAgICAgICAgY29uc3Qgc2V0MTogU2V0PHN0cmluZz4gPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICByZWYxLmZvckVhY2goKHJlZikgPT4ge3NldDEuYWRkKHJlZi5zb3VyY2VmaWxlICsgJzonICsgcmVmLmxpbmVudW1iZXIpOyB9KTtcclxuICAgICAgICBjb25zdCBzZXQyOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gICAgICAgIHJlZjIuZm9yRWFjaCgocmVmKSA9PiB7c2V0Mi5hZGQocmVmLnNvdXJjZWZpbGUgKyAnOicgKyByZWYubGluZW51bWJlcik7IH0pO1xyXG4gICAgICAgIGlmIChzZXQxLnNpemUgIT09IHNldDIuc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgc2V0Mi5mb3JFYWNoKChyZWYpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFzZXQxLmhhcyhyZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXV0byB0cmFuc2xhdGUgZmlsZSB2aWEgR29vZ2xlIFRyYW5zbGF0ZS5cclxuICAgICAqIFdpbGwgdHJhbnNsYXRlIGFsbCBuZXcgdW5pdHMgaW4gZmlsZS5cclxuICAgICAqIEBwYXJhbSBmcm9tIGZyb21cclxuICAgICAqIEBwYXJhbSB0byB0b1xyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlU3BlY2lmaWNNZXNzYWdlc0ZpbGUgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZVxyXG4gICAgICogQHJldHVybiBhIHByb21pc2Ugd2l0aCB0aGUgZXhlY3V0aW9uIHJlc3VsdCBhcyBhIHN1bW1hcnkgcmVwb3J0LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGF1dG9UcmFuc2xhdGUoXHJcbiAgICAgICAgZnJvbTogc3RyaW5nLFxyXG4gICAgICAgIHRvOiBzdHJpbmcsXHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01lc3NhZ2VzRmlsZTogSVRyYW5zbGF0aW9uTWVzc2FnZXNGaWxlKTogT2JzZXJ2YWJsZTxBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydD4ge1xyXG5cclxuICAgICAgICBsZXQgc2VydmljZUNhbGw6IE9ic2VydmFibGU8QXV0b1RyYW5zbGF0ZVN1bW1hcnlSZXBvcnQ+O1xyXG4gICAgICAgIGNvbnN0IGF1dG90cmFuc2xhdGVFbmFibGVkOiBib29sZWFuID0gdGhpcy5wYXJhbWV0ZXJzLmF1dG90cmFuc2xhdGVMYW5ndWFnZSh0byk7XHJcbiAgICAgICAgaWYgKGF1dG90cmFuc2xhdGVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHNlcnZpY2VDYWxsID0gdGhpcy5hdXRvVHJhbnNsYXRlU2VydmljZS5hdXRvVHJhbnNsYXRlKGZyb20sIHRvLCBsYW5ndWFnZVNwZWNpZmljTWVzc2FnZXNGaWxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXJ2aWNlQ2FsbCA9IG9mKG5ldyBBdXRvVHJhbnNsYXRlU3VtbWFyeVJlcG9ydChmcm9tLCB0bykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VydmljZUNhbGwucGlwZShtYXAoKHN1bW1hcnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGF1dG90cmFuc2xhdGVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VtbWFyeS5lcnJvcigpIHx8IHN1bW1hcnkuZmFpbGVkKCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0LmVycm9yKHN1bW1hcnkuY29udGVudCgpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kT3V0cHV0Lndhcm4oc3VtbWFyeS5jb250ZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdW1tYXJ5O1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbn1cclxuIl0sIm5hbWVzIjpbInRzbGliXzEuX19leHRlbmRzIiwiZnMuZXhpc3RzU3luYyIsImZzLnJlYWRGaWxlU3luYyIsImZzLndyaXRlRmlsZVN5bmMiLCJmcy5vcGVuU3luYyIsImZzLnJlYWRTeW5jIiwiZnMud3JpdGVTeW5jIiwiZnMuY2xvc2VTeW5jIiwiZnMucmVhZGRpclN5bmMiLCJmcy5sc3RhdFN5bmMiLCJmcy51bmxpbmtTeW5jIiwiZnMucm1kaXJTeW5jIiwidHNsaWJfMS5fX3ZhbHVlcyIsImZzLnN0YXRTeW5jIiwiZnMuYWNjZXNzU3luYyIsImZzLmNvbnN0YW50cyIsInBhdGgucmVzb2x2ZSIsImVudGl0eURlY29kZXJMaWIuZGVjb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBR0E7SUFBQTtLQU1pQzs7Z0JBTmhDLFFBQVEsU0FBQztvQkFDTixPQUFPLEVBQUUsRUFDUjtvQkFDRCxZQUFZLEVBQUUsRUFBRTtvQkFDaEIsT0FBTyxFQUFFLEVBQUU7aUJBQ2Q7O0lBQytCLHVCQUFDO0NBTmpDOzs7Ozs7Ozs7Ozs7OztBQ0lBLFNBQWdCLGlCQUFpQixDQUFDLEtBQVU7SUFDeEMsT0FBTyxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUM7Q0FDaEQ7Ozs7OztBQUtELFNBQWdCLFFBQVEsQ0FBQyxLQUFVO0lBQy9CLE9BQU8sT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDO0NBQ3BDOzs7Ozs7QUFtQkQsU0FBZ0IsT0FBTyxDQUFDLEtBQVU7SUFDOUIsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQy9COzs7Ozs7Ozs7Ozs7QUM1QkQ7Ozs7Ozs7SUFBb0NBLGtDQUFRO0lBSXhDO1FBQUEsWUFDSSxpQkFBTyxTQUVWO1FBREcsS0FBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7O0tBQzFCOzs7Ozs7O0lBRU0sK0JBQU07Ozs7OztJQUFiLFVBQWMsS0FBVSxFQUFFLFFBQWdCLEVBQUUsUUFBa0I7O1lBQ3RELFdBQVc7UUFDZixJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNqQixXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQ3ZCO2FBQU0sSUFBSSxLQUFLLFlBQVksTUFBTSxFQUFFO1lBQ2hDLFdBQVcsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDbEM7YUFBTTtZQUNILFdBQVcsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxR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R1csUUFBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQ3RDO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixHQUFHLEdBQUcsQ0FBQyxDQUFDO1NBQ1g7UUFDRCxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLEVBQUU7WUFDL0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxlQUFlLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7U0FDbkc7O1FBRUQsSUFBSTtZQUNBLEtBQUssR0FBR0EsUUFBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQ3RDO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixHQUFHLEdBQUcsQ0FBQyxDQUFDO1NBQ1g7UUFDRCxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLEVBQUU7WUFDL0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxlQUFlLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7U0FDbkc7O1FBRUQsSUFBSTtZQUNBQyxVQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFQyxTQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckQ7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNWLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksZUFBZSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxDQUFDO1NBQ3BHOztRQUVELElBQUksRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRSxLQUFLLEtB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